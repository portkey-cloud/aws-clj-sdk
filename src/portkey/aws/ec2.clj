(ns portkey.aws.ec2 (:require [portkey.aws]))

(def
 endpoints
 '{"us-gov-east-1"
   {:credential-scope {:service "ec2", :region "us-gov-east-1"},
    :ssl-common-name "ec2.us-gov-east-1.amazonaws.com",
    :endpoint "https://ec2.us-gov-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-1"
   {:credential-scope {:service "ec2", :region "ap-northeast-1"},
    :ssl-common-name "ec2.ap-northeast-1.amazonaws.com",
    :endpoint "https://ec2.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "ec2", :region "eu-west-1"},
    :ssl-common-name "ec2.eu-west-1.amazonaws.com",
    :endpoint "https://ec2.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "ec2", :region "us-east-2"},
    :ssl-common-name "ec2.us-east-2.amazonaws.com",
    :endpoint "https://ec2.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope {:service "ec2", :region "ap-southeast-2"},
    :ssl-common-name "ec2.ap-southeast-2.amazonaws.com",
    :endpoint "https://ec2.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "ec2", :region "cn-north-1"},
    :ssl-common-name "ec2.cn-north-1.amazonaws.com.cn",
    :endpoint "https://ec2.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "sa-east-1"
   {:credential-scope {:service "ec2", :region "sa-east-1"},
    :ssl-common-name "ec2.sa-east-1.amazonaws.com",
    :endpoint "https://ec2.sa-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope {:service "ec2", :region "ap-southeast-1"},
    :ssl-common-name "ec2.ap-southeast-1.amazonaws.com",
    :endpoint "https://ec2.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "cn-northwest-1"
   {:credential-scope {:service "ec2", :region "cn-northwest-1"},
    :ssl-common-name "ec2.cn-northwest-1.amazonaws.com.cn",
    :endpoint "https://ec2.cn-northwest-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope {:service "ec2", :region "ap-northeast-2"},
    :ssl-common-name "ec2.ap-northeast-2.amazonaws.com",
    :endpoint "https://ec2.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "ec2", :region "eu-west-3"},
    :ssl-common-name "ec2.eu-west-3.amazonaws.com",
    :endpoint "https://ec2.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "ec2", :region "ca-central-1"},
    :ssl-common-name "ec2.ca-central-1.amazonaws.com",
    :endpoint "https://ec2.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "ec2", :region "eu-central-1"},
    :ssl-common-name "ec2.eu-central-1.amazonaws.com",
    :endpoint "https://ec2.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "ec2", :region "eu-west-2"},
    :ssl-common-name "ec2.eu-west-2.amazonaws.com",
    :endpoint "https://ec2.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope {:service "ec2", :region "us-gov-west-1"},
    :ssl-common-name "ec2.us-gov-west-1.amazonaws.com",
    :endpoint "https://ec2.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "ec2", :region "us-west-2"},
    :ssl-common-name "ec2.us-west-2.amazonaws.com",
    :endpoint "https://ec2.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "ec2", :region "us-east-1"},
    :ssl-common-name "ec2.us-east-1.amazonaws.com",
    :endpoint "https://ec2.us-east-1.amazonaws.com",
    :signature-version :v4},
   "us-west-1"
   {:credential-scope {:service "ec2", :region "us-west-1"},
    :ssl-common-name "ec2.us-west-1.amazonaws.com",
    :endpoint "https://ec2.us-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "ec2", :region "ap-south-1"},
    :ssl-common-name "ec2.ap-south-1.amazonaws.com",
    :endpoint "https://ec2.ap-south-1.amazonaws.com",
    :signature-version :v4},
   "eu-north-1"
   {:credential-scope {:service "ec2", :region "eu-north-1"},
    :ssl-common-name "ec2.eu-north-1.amazonaws.com",
    :endpoint "https://ec2.eu-north-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-zone-name-string-list)

(clojure.core/declare ser-launch-template-instance-network-interface-specification-request-list)

(clojure.core/declare ser-launch-template-license-configuration-request)

(clojure.core/declare ser-launch-template-hibernation-options-request)

(clojure.core/declare ser-scheduled-instances-monitoring)

(clojure.core/declare ser-spot-allocation-strategy)

(clojure.core/declare ser-permission-group)

(clojure.core/declare ser-launch-template-cpu-options-request)

(clojure.core/declare ser-launch-template-placement-request)

(clojure.core/declare ser-launch-template-config-list)

(clojure.core/declare ser-double)

(clojure.core/declare ser-cpu-options-request)

(clojure.core/declare ser-private-ip-address-config-set)

(clojure.core/declare ser-ebs-instance-block-device-specification)

(clojure.core/declare ser-scheduled-instances-ipv-6-address)

(clojure.core/declare ser-default-route-table-association-value)

(clojure.core/declare ser-target-groups-config)

(clojure.core/declare ser-reset-fpga-image-attribute-name)

(clojure.core/declare ser-on-demand-allocation-strategy)

(clojure.core/declare ser-load-permission-modifications)

(clojure.core/declare ser-vpc-endpoint-type)

(clojure.core/declare ser-storage)

(clojure.core/declare ser-value-string-list)

(clojure.core/declare ser-peering-connection-options-request)

(clojure.core/declare ser-customer-gateway-id-string-list)

(clojure.core/declare ser-client-vpn-authentication-type)

(clojure.core/declare ser-public-ip-string-list)

(clojure.core/declare ser-filter)

(clojure.core/declare ser-instance-ipv-6-address-request)

(clojure.core/declare ser-export-task-id-string-list)

(clojure.core/declare ser-target-groups)

(clojure.core/declare ser-host-reservation-id-set)

(clojure.core/declare ser-zone-id-string-list)

(clojure.core/declare ser-ipv-6-range-list)

(clojure.core/declare ser-vpc-classic-link-id-list)

(clojure.core/declare ser-prefix-list-id)

(clojure.core/declare ser-spot-instance-request-id-list)

(clojure.core/declare ser-security-group-string-list)

(clojure.core/declare ser-vpn-connection-id-string-list)

(clojure.core/declare ser-architecture-values)

(clojure.core/declare ser-blob-attribute-value)

(clojure.core/declare ser-export-environment)

(clojure.core/declare ser-fleet-launch-template-config-request)

(clojure.core/declare ser-fleet-identifier)

(clojure.core/declare ser-scheduled-instances-private-ip-address-config)

(clojure.core/declare ser-product-code-string-list)

(clojure.core/declare ser-association-id-list)

(clojure.core/declare ser-spot-placement)

(clojure.core/declare ser-occurrence-day-request-set)

(clojure.core/declare ser-launch-template-specification)

(clojure.core/declare ser-spot-instance-type)

(clojure.core/declare ser-ebs-block-device)

(clojure.core/declare ser-new-dhcp-configuration)

(clojure.core/declare ser-cidr-authorization-context)

(clojure.core/declare ser-spot-fleet-tag-specification-list)

(clojure.core/declare ser-placement)

(clojure.core/declare ser-network-interface-id-list)

(clojure.core/declare ser-request-host-id-set)

(clojure.core/declare ser-reserved-instances-configuration)

(clojure.core/declare ser-interface-permission-type)

(clojure.core/declare ser-pool-max-results)

(clojure.core/declare ser-license-specification-list-request)

(clojure.core/declare ser-launch-template-instance-network-interface-specification-request)

(clojure.core/declare ser-fleet-launch-template-specification)

(clojure.core/declare ser-vpn-connection-options-specification)

(clojure.core/declare ser-tenancy)

(clojure.core/declare ser-reserved-instances-offering-id-string-list)

(clojure.core/declare ser-ipv-6-support-value)

(clojure.core/declare ser-scheduled-instances-security-group-id-set)

(clojure.core/declare ser-affinity)

(clojure.core/declare ser-spot-market-options)

(clojure.core/declare ser-group-name-string-list)

(clojure.core/declare ser-scheduled-instances-placement)

(clojure.core/declare ser-key-name-string-list)

(clojure.core/declare ser-scheduled-instances-block-device-mapping)

(clojure.core/declare ser-account-attribute-name)

(clojure.core/declare ser-fleet-launch-template-overrides-request)

(clojure.core/declare ser-vpc-tenancy)

(clojure.core/declare ser-instance-type)

(clojure.core/declare ser-transit-gateway-id-string-list)

(clojure.core/declare ser-instance-type-list)

(clojure.core/declare ser-instance-id-string-list)

(clojure.core/declare ser-image-attribute-name)

(clojure.core/declare ser-create-volume-permission)

(clojure.core/declare ser-describe-network-acls-max-results)

(clojure.core/declare ser-iam-instance-profile-specification)

(clojure.core/declare ser-hibernation-options-request)

(clojure.core/declare ser-placement-group-string-list)

(clojure.core/declare ser-volume-detail)

(clojure.core/declare ser-end-date-type)

(clojure.core/declare ser-launch-template-spot-market-options-request)

(clojure.core/declare ser-host-tenancy)

(clojure.core/declare ser-storage-location)

(clojure.core/declare ser-icmp-type-code)

(clojure.core/declare ser-fpga-image-attribute-name)

(clojure.core/declare ser-describe-internet-gateways-max-results)

(clojure.core/declare ser-elastic-gpu-specification)

(clojure.core/declare ser-instance-ipv-6-address-list)

(clojure.core/declare ser-volume-attribute-name)

(clojure.core/declare ser-capacity-reservation-instance-platform)

(clojure.core/declare ser-fleet-event-type)

(clojure.core/declare ser-scheduled-instance-id-request-set)

(clojure.core/declare ser-attribute-boolean-value)

(clojure.core/declare ser-vpc-id-string-list)

(clojure.core/declare ser-price-schedule-specification)

(clojure.core/declare ser-export-to-s-3-task-specification)

(clojure.core/declare ser-elastic-inference-accelerator)

(clojure.core/declare ser-rule-action)

(clojure.core/declare ser-elastic-inference-accelerators)

(clojure.core/declare ser-fleet-type)

(clojure.core/declare ser-request-launch-template-data)

(clojure.core/declare ser-group-identifier-list)

(clojure.core/declare ser-price-schedule-specification-list)

(clojure.core/declare ser-fleet-launch-template-config-list-request)

(clojure.core/declare ser-elastic-gpu-id-set)

(clojure.core/declare ser-traffic-type)

(clojure.core/declare ser-allocation-id-list)

(clojure.core/declare ser-create-volume-permission-list)

(clojure.core/declare ser-certificate-authentication-request)

(clojure.core/declare ser-image-disk-container-list)

(clojure.core/declare ser-event-type)

(clojure.core/declare ser-restorable-by-string-list)

(clojure.core/declare ser-next-token)

(clojure.core/declare ser-slot-start-time-range-request)

(clojure.core/declare ser-elastic-gpu-specifications)

(clojure.core/declare ser-excess-capacity-termination-policy)

(clojure.core/declare ser-modify-transit-gateway-vpc-attachment-request-options)

(clojure.core/declare ser-spot-fleet-monitoring)

(clojure.core/declare ser-instance-block-device-mapping-specification)

(clojure.core/declare ser-load-permission-list-request)

(clojure.core/declare ser-transit-gateway-request-options)

(clojure.core/declare ser-instance-credit-specification-request)

(clojure.core/declare ser-group-ids)

(clojure.core/declare ser-user-id-group-pair-list)

(clojure.core/declare ser-s-3-storage)

(clojure.core/declare ser-launch-permission-list)

(clojure.core/declare ser-reserved-instances-id-string-list)

(clojure.core/declare ser-directory-service-authentication-request)

(clojure.core/declare ser-instance-ipv-6-address)

(clojure.core/declare ser-group-identifier)

(clojure.core/declare ser-client-vpn-authentication-request)

(clojure.core/declare ser-instance-ipv-6-address-list-request)

(clojure.core/declare ser-spot-instance-interruption-behavior)

(clojure.core/declare ser-run-instances-monitoring-enabled)

(clojure.core/declare ser-capacity-reservation-id-set)

(clojure.core/declare ser-transit-gateway-attachment-id-string-list)

(clojure.core/declare ser-disk-image-list)

(clojure.core/declare ser-tag-list)

(clojure.core/declare ser-client-data)

(clojure.core/declare ser-image-disk-container)

(clojure.core/declare ser-spot-fleet-request-config-data)

(clojure.core/declare ser-launch-template-overrides)

(clojure.core/declare ser-launch-template-instance-market-options-request)

(clojure.core/declare ser-conversion-id-string-list)

(clojure.core/declare ser-connection-log-options)

(clojure.core/declare ser-allocation-strategy)

(clojure.core/declare ser-attribute-value)

(clojure.core/declare ser-private-ip-address-specification-list)

(clojure.core/declare ser-auto-placement)

(clojure.core/declare ser-launch-template-tag-specification-request-list)

(clojure.core/declare ser-prefix-list-id-list)

(clojure.core/declare ser-auto-accept-shared-attachments-value)

(clojure.core/declare ser-vpc-attribute-name)

(clojure.core/declare ser-instance-block-device-mapping-specification-list)

(clojure.core/declare ser-load-permission-request)

(clojure.core/declare ser-describe-instance-credit-specifications-max-results)

(clojure.core/declare ser-fpga-image-id-list)

(clojure.core/declare ser-placement-strategy)

(clojure.core/declare ser-user-group-string-list)

(clojure.core/declare ser-scheduled-instances-ebs)

(clojure.core/declare ser-target-configuration-request-set)

(clojure.core/declare ser-instance-interruption-behavior)

(clojure.core/declare ser-volume-id-string-list)

(clojure.core/declare ser-dhcp-options-id-string-list)

(clojure.core/declare ser-dns-servers-options-modify-structure)

(clojure.core/declare serscope)

(clojure.core/declare ser-reset-image-attribute-name)

(clojure.core/declare ser-instance-match-criteria)

(clojure.core/declare ser-scheduled-instances-launch-specification)

(clojure.core/declare ser-product-description-list)

(clojure.core/declare ser-fleet-id-set)

(clojure.core/declare ser-vpn-tunnel-options-specification)

(clojure.core/declare ser-group-id-string-list)

(clojure.core/declare ser-snapshot-disk-container)

(clojure.core/declare ser-instance-credit-specification-list-request)

(clojure.core/declare ser-log-destination-type)

(clojure.core/declare ser-launch-specs-list)

(clojure.core/declare ser-launch-template-ebs-block-device-request)

(clojure.core/declare ser-launch-template-elastic-inference-accelerator)

(clojure.core/declare ser-load-balancers-config)

(clojure.core/declare ser-integer)

(clojure.core/declare ser-string)

(clojure.core/declare ser-classic-load-balancer)

(clojure.core/declare ser-ip-permission)

(clojure.core/declare ser-ip-permission-list)

(clojure.core/declare ser-slot-date-time-range-request)

(clojure.core/declare ser-launch-template-license-specification-list-request)

(clojure.core/declare ser-ri-product-description)

(clojure.core/declare ser-transit-gateway-route-table-id-string-list)

(clojure.core/declare ser-describe-vpc-peering-connections-max-results)

(clojure.core/declare ser-default-route-table-propagation-value)

(clojure.core/declare ser-reserved-instance-id-set)

(clojure.core/declare ser-launch-template-config)

(clojure.core/declare ser-disk-image-format)

(clojure.core/declare ser-scheduled-instances-network-interface-set)

(clojure.core/declare ser-security-group-id-string-list)

(clojure.core/declare ser-domain-type)

(clojure.core/declare ser-launch-template-name)

(clojure.core/declare ser-flow-logs-resource-type)

(clojure.core/declare ser-fleet-launch-template-overrides-list-request)

(clojure.core/declare ser-resource-type)

(clojure.core/declare ser-ipv-6-address-list)

(clojure.core/declare ser-resource-list)

(clojure.core/declare ser-operation-type)

(clojure.core/declare ser-fleet-on-demand-allocation-strategy)

(clojure.core/declare ser-launch-template-elastic-inference-accelerator-list)

(clojure.core/declare ser-snapshot-attribute-name)

(clojure.core/declare ser-currency-code-values)

(clojure.core/declare ser-network-interface-attribute)

(clojure.core/declare ser-license-configuration-request)

(clojure.core/declare ser-report-instance-reason-codes)

(clojure.core/declare ser-billing-product-list)

(clojure.core/declare ser-bundle-id-string-list)

(clojure.core/declare ser-egress-only-internet-gateway-id-list)

(clojure.core/declare ser-volume-type)

(clojure.core/declare ser-account-attribute-name-string-list)

(clojure.core/declare ser-target-capacity-specification-request)

(clojure.core/declare ser-tunnel-options-list)

(clojure.core/declare ser-vpn-ecmp-support-value)

(clojure.core/declare ser-launch-permission-modifications)

(clojure.core/declare ser-classic-load-balancers-config)

(clojure.core/declare ser-dns-support-value)

(clojure.core/declare ser-tag-specification-list)

(clojure.core/declare ser-long)

(clojure.core/declare ser-capacity-reservation-target)

(clojure.core/declare ser-transit-gateway-max-results)

(clojure.core/declare ser-subnet-id-string-list)

(clojure.core/declare ser-reserved-instance-limit-price)

(clojure.core/declare ser-tag-specification)

(clojure.core/declare ser-region-name-string-list)

(clojure.core/declare ser-scheduled-instance-recurrence-request)

(clojure.core/declare ser-version-description)

(clojure.core/declare ser-user-bucket)

(clojure.core/declare ser-scheduled-instances-network-interface)

(clojure.core/declare ser-default-target-capacity-type)

(clojure.core/declare ser-target-configuration-request)

(clojure.core/declare ser-reserved-instances-configuration-list)

(clojure.core/declare ser-capacity-reservation-specification)

(clojure.core/declare ser-instance-network-interface-specification-list)

(clojure.core/declare ser-block-device-mapping)

(clojure.core/declare ser-max-results)

(clojure.core/declare ser-tag)

(clojure.core/declare ser-spot-fleet-tag-specification)

(clojure.core/declare ser-user-id-string-list)

(clojure.core/declare ser-executable-by-string-list)

(clojure.core/declare ser-launch-template-name-string-list)

(clojure.core/declare ser-instance-market-options-request)

(clojure.core/declare ser-platform-values)

(clojure.core/declare ser-disk-image)

(clojure.core/declare ser-port-range)

(clojure.core/declare ser-client-vpn-authentication-request-list)

(clojure.core/declare ser-spot-fleet-launch-specification)

(clojure.core/declare ser-ip-range)

(clojure.core/declare ser-version-string-list)

(clojure.core/declare ser-block-device-mapping-request-list)

(clojure.core/declare ser-container-format)

(clojure.core/declare ser-purchase-request-set)

(clojure.core/declare ser-new-dhcp-configuration-list)

(clojure.core/declare ser-market-type)

(clojure.core/declare ser-fleet-launch-template-specification-request)

(clojure.core/declare ser-block-device-mapping-list)

(clojure.core/declare ser-blob)

(clojure.core/declare ser-gateway-type)

(clojure.core/declare ser-scheduled-instances-iam-instance-profile)

(clojure.core/declare ser-report-status-type)

(clojure.core/declare ser-transport-protocol)

(clojure.core/declare ser-ip-range-list)

(clojure.core/declare ser-import-instance-launch-specification)

(clojure.core/declare ser-classic-load-balancers)

(clojure.core/declare ser-spot-options-request)

(clojure.core/declare ser-scheduled-instances-block-device-mapping-set)

(clojure.core/declare ser-purchase-request)

(clojure.core/declare ser-reserved-instances-modification-id-string-list)

(clojure.core/declare ser-target-group)

(clojure.core/declare ser-resource-id-list)

(clojure.core/declare ser-on-demand-options-request)

(clojure.core/declare ser-ipv-6-address)

(clojure.core/declare ser-network-interface-permission-id-list)

(clojure.core/declare ser-offering-class-type)

(clojure.core/declare ser-request-host-id-list)

(clojure.core/declare ser-launch-template-overrides-list)

(clojure.core/declare ser-image-id-string-list)

(clojure.core/declare ser-launch-template-iam-instance-profile-specification-request)

(clojure.core/declare ser-instance-attribute-name)

(clojure.core/declare ser-capacity-reservation-preference)

(clojure.core/declare ser-launch-template-block-device-mapping-request-list)

(clojure.core/declare ser-disk-image-detail)

(clojure.core/declare ser-user-data)

(clojure.core/declare ser-offering-type-values)

(clojure.core/declare ser-launch-template-tag-specification-request)

(clojure.core/declare ser-launch-template-block-device-mapping-request)

(clojure.core/declare ser-network-interface-attachment-changes)

(clojure.core/declare ser-private-ip-address-string-list)

(clojure.core/declare ser-credit-specification-request)

(clojure.core/declare ser-launch-template-capacity-reservation-specification-request)

(clojure.core/declare ser-scheduled-instances-ipv-6-address-list)

(clojure.core/declare ser-owner-string-list)

(clojure.core/declare ser-create-volume-permission-modifications)

(clojure.core/declare ser-fleet-excess-capacity-termination-policy)

(clojure.core/declare ser-reason-codes-list)

(clojure.core/declare ser-filter-list)

(clojure.core/declare ser-launch-permission)

(clojure.core/declare ser-ipv-6-range)

(clojure.core/declare ser-egress-only-internet-gateway-id)

(clojure.core/declare ser-vpn-gateway-id-string-list)

(clojure.core/declare ser-create-transit-gateway-vpc-attachment-request-options)

(clojure.core/declare ser-private-ip-address-specification)

(clojure.core/declare ser-request-spot-launch-specification)

(clojure.core/declare ser-elastic-gpu-specification-list)

(clojure.core/declare ser-user-id-group-pair)

(clojure.core/declare ser-launch-templates-monitoring-request)

(clojure.core/declare ser-capacity-reservation-tenancy)

(clojure.core/declare ser-import-task-id-list)

(clojure.core/declare ser-describe-vpcs-max-results)

(clojure.core/declare ser-date-time)

(clojure.core/declare ser-snapshot-id-string-list)

(clojure.core/declare ser-shutdown-behavior)

(clojure.core/declare ser-boolean)

(clojure.core/declare ser-instance-network-interface-specification)

(clojure.core/declare ser-client-vpn-security-group-id-set)

(clojure.core/defn- ser-zone-name-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ZoneName"}))) input), :shape "ZoneNameStringList", :type "list"})

(clojure.core/defn- ser-launch-template-instance-network-interface-specification-request-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-launch-template-instance-network-interface-specification-request coll) #:http.request.field{:shape "LaunchTemplateInstanceNetworkInterfaceSpecificationRequest", :location-name "InstanceNetworkInterfaceSpecification"}))) input), :shape "LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList", :type "list"})

(clojure.core/defn- ser-launch-template-license-configuration-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateLicenseConfigurationRequest", :type "structure"} (clojure.core/contains? input :license-configuration-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :license-configuration-arn)) #:http.request.field{:name "LicenseConfigurationArn", :shape "String"}))))

(clojure.core/defn- ser-launch-template-hibernation-options-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateHibernationOptionsRequest", :type "structure"} (clojure.core/contains? input :configured) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :configured)) #:http.request.field{:name "Configured", :shape "Boolean"}))))

(clojure.core/defn- ser-scheduled-instances-monitoring [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ScheduledInstancesMonitoring", :type "structure"} (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "Boolean"}))))

(clojure.core/defn- ser-spot-allocation-strategy [input] #:http.request.field{:value (clojure.core/get {"lowest-price" "lowest-price", :lowestprice "lowest-price", "diversified" "diversified", :diversified "diversified"} input), :shape "SpotAllocationStrategy"})

(clojure.core/defn- ser-permission-group [input] #:http.request.field{:value (clojure.core/get {"all" "all", :all "all"} input), :shape "PermissionGroup"})

(clojure.core/defn- ser-launch-template-cpu-options-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateCpuOptionsRequest", :type "structure"} (clojure.core/contains? input :core-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :core-count)) #:http.request.field{:name "CoreCount", :shape "Integer"})) (clojure.core/contains? input :threads-per-core) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :threads-per-core)) #:http.request.field{:name "ThreadsPerCore", :shape "Integer"}))))

(clojure.core/defn- ser-launch-template-placement-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplatePlacementRequest", :type "structure"} (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :affinity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :affinity)) #:http.request.field{:name "Affinity", :shape "String"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String"})) (clojure.core/contains? input :host-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :host-id)) #:http.request.field{:name "HostId", :shape "String"})) (clojure.core/contains? input :tenancy) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tenancy (input :tenancy)) #:http.request.field{:name "Tenancy", :shape "Tenancy"})) (clojure.core/contains? input :spread-domain) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :spread-domain)) #:http.request.field{:name "SpreadDomain", :shape "String"}))))

(clojure.core/defn- ser-launch-template-config-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-launch-template-config coll) #:http.request.field{:shape "LaunchTemplateConfig", :location-name "item"}))) input), :shape "LaunchTemplateConfigList", :type "list"})

(clojure.core/defn- ser-double [input] #:http.request.field{:value input, :shape "Double"})

(clojure.core/defn- ser-cpu-options-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CpuOptionsRequest", :type "structure"} (clojure.core/contains? input :core-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :core-count)) #:http.request.field{:name "CoreCount", :shape "Integer"})) (clojure.core/contains? input :threads-per-core) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :threads-per-core)) #:http.request.field{:name "ThreadsPerCore", :shape "Integer"}))))

(clojure.core/defn- ser-private-ip-address-config-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-scheduled-instances-private-ip-address-config coll) #:http.request.field{:shape "ScheduledInstancesPrivateIpAddressConfig", :location-name "PrivateIpAddressConfigSet"}))) input), :shape "PrivateIpAddressConfigSet", :type "list"})

(clojure.core/defn- ser-ebs-instance-block-device-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EbsInstanceBlockDeviceSpecification", :type "structure"} (clojure.core/contains? input :delete-on-termination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :delete-on-termination)) #:http.request.field{:name "DeleteOnTermination", :shape "Boolean", :location-name "deleteOnTermination"})) (clojure.core/contains? input :volume-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :volume-id)) #:http.request.field{:name "VolumeId", :shape "String", :location-name "volumeId"}))))

(clojure.core/defn- ser-scheduled-instances-ipv-6-address [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ScheduledInstancesIpv6Address", :type "structure"} (clojure.core/contains? input :ipv-6-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ipv-6-address (input :ipv-6-address)) #:http.request.field{:name "Ipv6Address", :shape "Ipv6Address"}))))

(clojure.core/defn- ser-default-route-table-association-value [input] #:http.request.field{:value (clojure.core/get {"enable" "enable", :enable "enable", "disable" "disable", :disable "disable"} input), :shape "DefaultRouteTableAssociationValue"})

(clojure.core/defn- ser-target-groups-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "TargetGroupsConfig", :type "structure"} (clojure.core/contains? input :target-groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-groups (input :target-groups)) #:http.request.field{:name "TargetGroups", :shape "TargetGroups", :location-name "targetGroups"}))))

(clojure.core/defn- ser-reset-fpga-image-attribute-name [input] #:http.request.field{:value (clojure.core/get {"loadPermission" "loadPermission", :load-permission "loadPermission"} input), :shape "ResetFpgaImageAttributeName"})

(clojure.core/defn- ser-on-demand-allocation-strategy [input] #:http.request.field{:value (clojure.core/get {"lowestPrice" "lowestPrice", :lowest-price "lowestPrice", "prioritized" "prioritized", :prioritized "prioritized"} input), :shape "OnDemandAllocationStrategy"})

(clojure.core/defn- ser-load-permission-modifications [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LoadPermissionModifications", :type "structure"} (clojure.core/contains? input :add) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-load-permission-list-request (input :add)) #:http.request.field{:name "Add", :shape "LoadPermissionListRequest"})) (clojure.core/contains? input :remove) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-load-permission-list-request (input :remove)) #:http.request.field{:name "Remove", :shape "LoadPermissionListRequest"}))))

(clojure.core/defn- ser-vpc-endpoint-type [input] #:http.request.field{:value (clojure.core/get {"Interface" "Interface", :interface "Interface", "Gateway" "Gateway", :gateway "Gateway"} input), :shape "VpcEndpointType"})

(clojure.core/defn- ser-storage [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Storage", :type "structure"} (clojure.core/contains? input :s-3) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-storage (input :s-3)) #:http.request.field{:name "S3", :shape "S3Storage"}))))

(clojure.core/defn- ser-value-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "ValueStringList", :type "list"})

(clojure.core/defn- ser-peering-connection-options-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PeeringConnectionOptionsRequest", :type "structure"} (clojure.core/contains? input :allow-dns-resolution-from-remote-vpc) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :allow-dns-resolution-from-remote-vpc)) #:http.request.field{:name "AllowDnsResolutionFromRemoteVpc", :shape "Boolean"})) (clojure.core/contains? input :allow-egress-from-local-classic-link-to-remote-vpc) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :allow-egress-from-local-classic-link-to-remote-vpc)) #:http.request.field{:name "AllowEgressFromLocalClassicLinkToRemoteVpc", :shape "Boolean"})) (clojure.core/contains? input :allow-egress-from-local-vpc-to-remote-classic-link) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :allow-egress-from-local-vpc-to-remote-classic-link)) #:http.request.field{:name "AllowEgressFromLocalVpcToRemoteClassicLink", :shape "Boolean"}))))

(clojure.core/defn- ser-customer-gateway-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "CustomerGatewayId"}))) input), :shape "CustomerGatewayIdStringList", :type "list"})

(clojure.core/defn- ser-client-vpn-authentication-type [input] #:http.request.field{:value (clojure.core/get {"certificate-authentication" "certificate-authentication", :certificateauthentication "certificate-authentication", "directory-service-authentication" "directory-service-authentication", :directoryserviceauthentication "directory-service-authentication"} input), :shape "ClientVpnAuthenticationType"})

(clojure.core/defn- ser-public-ip-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "PublicIp"}))) input), :shape "PublicIpStringList", :type "list"})

(clojure.core/defn- ser-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Filter", :type "structure"} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :values)) #:http.request.field{:name "Values", :shape "ValueStringList", :location-name "Value"}))))

(clojure.core/defn- ser-instance-ipv-6-address-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "InstanceIpv6AddressRequest", :type "structure"} (clojure.core/contains? input :ipv-6-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ipv-6-address)) #:http.request.field{:name "Ipv6Address", :shape "String"}))))

(clojure.core/defn- ser-export-task-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ExportTaskId"}))) input), :shape "ExportTaskIdStringList", :type "list"})

(clojure.core/defn- ser-target-groups [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-group coll) #:http.request.field{:shape "TargetGroup", :location-name "item"}))) input), :shape "TargetGroups", :type "list", :max 5, :min 1})

(clojure.core/defn- ser-host-reservation-id-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "HostReservationIdSet", :type "list"})

(clojure.core/defn- ser-zone-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ZoneId"}))) input), :shape "ZoneIdStringList", :type "list"})

(clojure.core/defn- ser-ipv-6-range-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-ipv-6-range coll) #:http.request.field{:shape "Ipv6Range", :location-name "item"}))) input), :shape "Ipv6RangeList", :type "list"})

(clojure.core/defn- ser-vpc-classic-link-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "VpcId"}))) input), :shape "VpcClassicLinkIdList", :type "list"})

(clojure.core/defn- ser-prefix-list-id [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PrefixListId", :type "structure"} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"})) (clojure.core/contains? input :prefix-list-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :prefix-list-id)) #:http.request.field{:name "PrefixListId", :shape "String", :location-name "prefixListId"}))))

(clojure.core/defn- ser-spot-instance-request-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SpotInstanceRequestId"}))) input), :shape "SpotInstanceRequestIdList", :type "list"})

(clojure.core/defn- ser-security-group-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SecurityGroup"}))) input), :shape "SecurityGroupStringList", :type "list"})

(clojure.core/defn- ser-vpn-connection-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "VpnConnectionId"}))) input), :shape "VpnConnectionIdStringList", :type "list"})

(clojure.core/defn- ser-architecture-values [input] #:http.request.field{:value (clojure.core/get {"i386" "i386", :i-386 "i386", "x86_64" "x86_64", :x-86-64 "x86_64", "arm64" "arm64", :arm-64 "arm64"} input), :shape "ArchitectureValues"})

(clojure.core/defn- ser-blob-attribute-value [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "BlobAttributeValue", :type "structure"} (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-blob (input :value)) #:http.request.field{:name "Value", :shape "Blob", :location-name "value"}))))

(clojure.core/defn- ser-export-environment [input] #:http.request.field{:value (clojure.core/get {"citrix" "citrix", :citrix "citrix", "vmware" "vmware", :vmware "vmware", "microsoft" "microsoft", :microsoft "microsoft"} input), :shape "ExportEnvironment"})

(clojure.core/defn- ser-fleet-launch-template-config-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "FleetLaunchTemplateConfigRequest", :type "structure"} (clojure.core/contains? input :launch-template-specification) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fleet-launch-template-specification-request (input :launch-template-specification)) #:http.request.field{:name "LaunchTemplateSpecification", :shape "FleetLaunchTemplateSpecificationRequest"})) (clojure.core/contains? input :overrides) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fleet-launch-template-overrides-list-request (input :overrides)) #:http.request.field{:name "Overrides", :shape "FleetLaunchTemplateOverridesListRequest"}))))

(clojure.core/defn- ser-fleet-identifier [input] #:http.request.field{:value input, :shape "FleetIdentifier"})

(clojure.core/defn- ser-scheduled-instances-private-ip-address-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ScheduledInstancesPrivateIpAddressConfig", :type "structure"} (clojure.core/contains? input :primary) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :primary)) #:http.request.field{:name "Primary", :shape "Boolean"})) (clojure.core/contains? input :private-ip-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-ip-address)) #:http.request.field{:name "PrivateIpAddress", :shape "String"}))))

(clojure.core/defn- ser-product-code-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ProductCode"}))) input), :shape "ProductCodeStringList", :type "list"})

(clojure.core/defn- ser-association-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "AssociationId"}))) input), :shape "AssociationIdList", :type "list"})

(clojure.core/defn- ser-spot-placement [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SpotPlacement", :type "structure"} (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String", :location-name "availabilityZone"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String", :location-name "groupName"})) (clojure.core/contains? input :tenancy) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tenancy (input :tenancy)) #:http.request.field{:name "Tenancy", :shape "Tenancy", :location-name "tenancy"}))))

(clojure.core/defn- ser-occurrence-day-request-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-integer coll) #:http.request.field{:shape "Integer", :location-name "OccurenceDay"}))) input), :shape "OccurrenceDayRequestSet", :type "list"})

(clojure.core/defn- ser-launch-template-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateSpecification", :type "structure"} (clojure.core/contains? input :launch-template-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :launch-template-id)) #:http.request.field{:name "LaunchTemplateId", :shape "String"})) (clojure.core/contains? input :launch-template-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :launch-template-name)) #:http.request.field{:name "LaunchTemplateName", :shape "String"})) (clojure.core/contains? input :version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :version)) #:http.request.field{:name "Version", :shape "String"}))))

(clojure.core/defn- ser-spot-instance-type [input] #:http.request.field{:value (clojure.core/get {"one-time" "one-time", :onetime "one-time", "persistent" "persistent", :persistent "persistent"} input), :shape "SpotInstanceType"})

(clojure.core/defn- ser-ebs-block-device [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EbsBlockDevice", :type "structure"} (clojure.core/contains? input :delete-on-termination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :delete-on-termination)) #:http.request.field{:name "DeleteOnTermination", :shape "Boolean", :location-name "deleteOnTermination"})) (clojure.core/contains? input :iops) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :iops)) #:http.request.field{:name "Iops", :shape "Integer", :location-name "iops"})) (clojure.core/contains? input :snapshot-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "String", :location-name "snapshotId"})) (clojure.core/contains? input :volume-size) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :volume-size)) #:http.request.field{:name "VolumeSize", :shape "Integer", :location-name "volumeSize"})) (clojure.core/contains? input :volume-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-volume-type (input :volume-type)) #:http.request.field{:name "VolumeType", :shape "VolumeType", :location-name "volumeType"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "Boolean", :location-name "encrypted"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"}))))

(clojure.core/defn- ser-new-dhcp-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "NewDhcpConfiguration", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key)) #:http.request.field{:name "Key", :shape "String", :location-name "key"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :values)) #:http.request.field{:name "Values", :shape "ValueStringList", :location-name "Value"}))))

(clojure.core/defn- ser-cidr-authorization-context [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:message input)) #:http.request.field{:name "Message", :shape "String"}) (clojure.core/into (ser-string (:signature input)) #:http.request.field{:name "Signature", :shape "String"})], :shape "CidrAuthorizationContext", :type "structure"}))

(clojure.core/defn- ser-spot-fleet-tag-specification-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-spot-fleet-tag-specification coll) #:http.request.field{:shape "SpotFleetTagSpecification", :location-name "item"}))) input), :shape "SpotFleetTagSpecificationList", :type "list"})

(clojure.core/defn- ser-placement [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Placement", :type "structure"} (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String", :location-name "availabilityZone"})) (clojure.core/contains? input :affinity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :affinity)) #:http.request.field{:name "Affinity", :shape "String", :location-name "affinity"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String", :location-name "groupName"})) (clojure.core/contains? input :partition-number) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :partition-number)) #:http.request.field{:name "PartitionNumber", :shape "Integer", :location-name "partitionNumber"})) (clojure.core/contains? input :host-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :host-id)) #:http.request.field{:name "HostId", :shape "String", :location-name "hostId"})) (clojure.core/contains? input :tenancy) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tenancy (input :tenancy)) #:http.request.field{:name "Tenancy", :shape "Tenancy", :location-name "tenancy"})) (clojure.core/contains? input :spread-domain) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :spread-domain)) #:http.request.field{:name "SpreadDomain", :shape "String", :location-name "spreadDomain"}))))

(clojure.core/defn- ser-network-interface-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "NetworkInterfaceIdList", :type "list"})

(clojure.core/defn- ser-request-host-id-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "RequestHostIdSet", :type "list"})

(clojure.core/defn- ser-reserved-instances-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ReservedInstancesConfiguration", :type "structure"} (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String", :location-name "availabilityZone"})) (clojure.core/contains? input :instance-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :instance-count)) #:http.request.field{:name "InstanceCount", :shape "Integer", :location-name "instanceCount"})) (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-type (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "InstanceType", :location-name "instanceType"})) (clojure.core/contains? input :platform) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :platform)) #:http.request.field{:name "Platform", :shape "String", :location-name "platform"})) (clojure.core/contains? input :scope) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serscope (input :scope)) #:http.request.field{:name "Scope", :shape "scope", :location-name "scope"}))))

(clojure.core/defn- ser-interface-permission-type [input] #:http.request.field{:value (clojure.core/get {"INSTANCE-ATTACH" "INSTANCE-ATTACH", :instanceattach "INSTANCE-ATTACH", "EIP-ASSOCIATE" "EIP-ASSOCIATE", :eipassociate "EIP-ASSOCIATE"} input), :shape "InterfacePermissionType"})

(clojure.core/defn- ser-pool-max-results [input] #:http.request.field{:value input, :shape "PoolMaxResults"})

(clojure.core/defn- ser-license-specification-list-request [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-license-configuration-request coll) #:http.request.field{:shape "LicenseConfigurationRequest", :location-name "item"}))) input), :shape "LicenseSpecificationListRequest", :type "list"})

(clojure.core/defn- ser-launch-template-instance-network-interface-specification-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateInstanceNetworkInterfaceSpecificationRequest", :type "structure"} (clojure.core/contains? input :associate-public-ip-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :associate-public-ip-address)) #:http.request.field{:name "AssociatePublicIpAddress", :shape "Boolean"})) (clojure.core/contains? input :ipv-6-addresses) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-ipv-6-address-list-request (input :ipv-6-addresses)) #:http.request.field{:name "Ipv6Addresses", :shape "InstanceIpv6AddressListRequest"})) (clojure.core/contains? input :subnet-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String"})) (clojure.core/contains? input :network-interface-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String"})) (clojure.core/contains? input :device-index) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :device-index)) #:http.request.field{:name "DeviceIndex", :shape "Integer"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-id-string-list (input :groups)) #:http.request.field{:name "Groups", :shape "SecurityGroupIdStringList", :location-name "SecurityGroupId"})) (clojure.core/contains? input :delete-on-termination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :delete-on-termination)) #:http.request.field{:name "DeleteOnTermination", :shape "Boolean"})) (clojure.core/contains? input :private-ip-addresses) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-private-ip-address-specification-list (input :private-ip-addresses)) #:http.request.field{:name "PrivateIpAddresses", :shape "PrivateIpAddressSpecificationList"})) (clojure.core/contains? input :secondary-private-ip-address-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :secondary-private-ip-address-count)) #:http.request.field{:name "SecondaryPrivateIpAddressCount", :shape "Integer"})) (clojure.core/contains? input :private-ip-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-ip-address)) #:http.request.field{:name "PrivateIpAddress", :shape "String"})) (clojure.core/contains? input :ipv-6-address-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :ipv-6-address-count)) #:http.request.field{:name "Ipv6AddressCount", :shape "Integer"}))))

(clojure.core/defn- ser-fleet-launch-template-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "FleetLaunchTemplateSpecification", :type "structure"} (clojure.core/contains? input :launch-template-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :launch-template-id)) #:http.request.field{:name "LaunchTemplateId", :shape "String", :location-name "launchTemplateId"})) (clojure.core/contains? input :launch-template-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-name (input :launch-template-name)) #:http.request.field{:name "LaunchTemplateName", :shape "LaunchTemplateName", :location-name "launchTemplateName"})) (clojure.core/contains? input :version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :version)) #:http.request.field{:name "Version", :shape "String", :location-name "version"}))))

(clojure.core/defn- ser-vpn-connection-options-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "VpnConnectionOptionsSpecification", :type "structure"} (clojure.core/contains? input :static-routes-only) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :static-routes-only)) #:http.request.field{:name "StaticRoutesOnly", :shape "Boolean", :location-name "staticRoutesOnly"})) (clojure.core/contains? input :tunnel-options) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tunnel-options-list (input :tunnel-options)) #:http.request.field{:name "TunnelOptions", :shape "TunnelOptionsList"}))))

(clojure.core/defn- ser-tenancy [input] #:http.request.field{:value (clojure.core/get {"default" "default", :default "default", "dedicated" "dedicated", :dedicated "dedicated", "host" "host", :host "host"} input), :shape "Tenancy"})

(clojure.core/defn- ser-reserved-instances-offering-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "ReservedInstancesOfferingIdStringList", :type "list"})

(clojure.core/defn- ser-ipv-6-support-value [input] #:http.request.field{:value (clojure.core/get {"enable" "enable", :enable "enable", "disable" "disable", :disable "disable"} input), :shape "Ipv6SupportValue"})

(clojure.core/defn- ser-scheduled-instances-security-group-id-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SecurityGroupId"}))) input), :shape "ScheduledInstancesSecurityGroupIdSet", :type "list"})

(clojure.core/defn- ser-affinity [input] #:http.request.field{:value (clojure.core/get {"default" "default", :default "default", "host" "host", :host "host"} input), :shape "Affinity"})

(clojure.core/defn- ser-spot-market-options [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SpotMarketOptions", :type "structure"} (clojure.core/contains? input :max-price) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :max-price)) #:http.request.field{:name "MaxPrice", :shape "String"})) (clojure.core/contains? input :spot-instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-instance-type (input :spot-instance-type)) #:http.request.field{:name "SpotInstanceType", :shape "SpotInstanceType"})) (clojure.core/contains? input :block-duration-minutes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :block-duration-minutes)) #:http.request.field{:name "BlockDurationMinutes", :shape "Integer"})) (clojure.core/contains? input :valid-until) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :valid-until)) #:http.request.field{:name "ValidUntil", :shape "DateTime"})) (clojure.core/contains? input :instance-interruption-behavior) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-interruption-behavior (input :instance-interruption-behavior)) #:http.request.field{:name "InstanceInterruptionBehavior", :shape "InstanceInterruptionBehavior"}))))

(clojure.core/defn- ser-group-name-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "GroupName"}))) input), :shape "GroupNameStringList", :type "list"})

(clojure.core/defn- ser-scheduled-instances-placement [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ScheduledInstancesPlacement", :type "structure"} (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String"}))))

(clojure.core/defn- ser-key-name-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "KeyName"}))) input), :shape "KeyNameStringList", :type "list"})

(clojure.core/defn- ser-scheduled-instances-block-device-mapping [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ScheduledInstancesBlockDeviceMapping", :type "structure"} (clojure.core/contains? input :device-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :device-name)) #:http.request.field{:name "DeviceName", :shape "String"})) (clojure.core/contains? input :ebs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-scheduled-instances-ebs (input :ebs)) #:http.request.field{:name "Ebs", :shape "ScheduledInstancesEbs"})) (clojure.core/contains? input :no-device) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :no-device)) #:http.request.field{:name "NoDevice", :shape "String"})) (clojure.core/contains? input :virtual-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :virtual-name)) #:http.request.field{:name "VirtualName", :shape "String"}))))

(clojure.core/defn- ser-account-attribute-name [input] #:http.request.field{:value (clojure.core/get {"supported-platforms" "supported-platforms", :supportedplatforms "supported-platforms", "default-vpc" "default-vpc", :defaultvpc "default-vpc"} input), :shape "AccountAttributeName"})

(clojure.core/defn- ser-fleet-launch-template-overrides-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "FleetLaunchTemplateOverridesRequest", :type "structure"} (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-type (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "InstanceType"})) (clojure.core/contains? input :max-price) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :max-price)) #:http.request.field{:name "MaxPrice", :shape "String"})) (clojure.core/contains? input :subnet-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :weighted-capacity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :weighted-capacity)) #:http.request.field{:name "WeightedCapacity", :shape "Double"})) (clojure.core/contains? input :priority) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :priority)) #:http.request.field{:name "Priority", :shape "Double"})) (clojure.core/contains? input :placement) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-placement (input :placement)) #:http.request.field{:name "Placement", :shape "Placement"}))))

(clojure.core/defn- ser-vpc-tenancy [input] #:http.request.field{:value (clojure.core/get {"default" "default", :default "default"} input), :shape "VpcTenancy"})

(clojure.core/defn- ser-instance-type [input] #:http.request.field{:value (clojure.core/get {:r-3large "r3.large", :i-3large "i3.large", :c-4xlarge "c4.xlarge", "m1.large" "m1.large", :m-524xlarge "m5.24xlarge", "t3.small" "t3.small", :a-1medium "a1.medium", :c-3xlarge "c3.xlarge", "cc1.4xlarge" "cc1.4xlarge", :cg-14xlarge "cg1.4xlarge", "z1d.large" "z1d.large", :i-28xlarge "i2.8xlarge", :r-48xlarge "r4.8xlarge", :t-2small "t2.small", "x1e.32xlarge" "x1e.32xlarge", "r5d.xlarge" "r5d.xlarge", "r5a.large" "r5a.large", :c-518xlarge "c5.18xlarge", "r5a.xlarge" "r5a.xlarge", :c-1xlarge "c1.xlarge", :r-5d-12xlarge "r5d.12xlarge", "m5d.24xlarge" "m5d.24xlarge", "c1.medium" "c1.medium", "r4.2xlarge" "r4.2xlarge", :c-48xlarge "c4.8xlarge", :x-1exlarge "x1e.xlarge", "r3.8xlarge" "r3.8xlarge", "r5.4xlarge" "r5.4xlarge", "d2.xlarge" "d2.xlarge", "m3.2xlarge" "m3.2xlarge", :c-5n-18xlarge "c5n.18xlarge", "i2.8xlarge" "i2.8xlarge", "h1.16xlarge" "h1.16xlarge", "m5.xlarge" "m5.xlarge", "r5a.2xlarge" "r5a.2xlarge", "t3.2xlarge" "t3.2xlarge", "g2.2xlarge" "g2.2xlarge", :m-5xlarge "m5.xlarge", :m-52xlarge "m5.2xlarge", "g3.8xlarge" "g3.8xlarge", :z-1d-12xlarge "z1d.12xlarge", :c-5d-4xlarge "c5d.4xlarge", "t3.xlarge" "t3.xlarge", :z-1d-2xlarge "z1d.2xlarge", "c3.8xlarge" "c3.8xlarge", :i-38xlarge "i3.8xlarge", :m-5a-2xlarge "m5a.2xlarge", "t2.large" "t2.large", :r-5dmetal "r5d.metal", "x1e.4xlarge" "x1e.4xlarge", "t3.nano" "t3.nano", :u-9tb-1metal "u-9tb1.metal", :m-512xlarge "m5.12xlarge", :m-42xlarge "m4.2xlarge", "p2.16xlarge" "p2.16xlarge", "m1.xlarge" "m1.xlarge", "m5a.24xlarge" "m5a.24xlarge", :g-34xlarge "g3.4xlarge", "d2.8xlarge" "d2.8xlarge", "r5d.large" "r5d.large", "m4.4xlarge" "m4.4xlarge", :r-5dxlarge "r5d.xlarge", :m-5large "m5.large", "t2.2xlarge" "t2.2xlarge", "r4.16xlarge" "r4.16xlarge", :t-2large "t2.large", "u-12tb1.metal" "u-12tb1.metal", :c-34xlarge "c3.4xlarge", "r5d.4xlarge" "r5d.4xlarge", :x-116xlarge "x1.16xlarge", :r-512xlarge "r5.12xlarge", "g3.16xlarge" "g3.16xlarge", "z1d.2xlarge" "z1d.2xlarge", "t3.large" "t3.large", "h1.2xlarge" "h1.2xlarge", :c-5large "c5.large", "g3.4xlarge" "g3.4xlarge", "cr1.8xlarge" "cr1.8xlarge", "t1.micro" "t1.micro", :x-1e-16xlarge "x1e.16xlarge", "a1.2xlarge" "a1.2xlarge", "c5d.large" "c5d.large", :d-28xlarge "d2.8xlarge", :x-1e-4xlarge "x1e.4xlarge", :g-3sxlarge "g3s.xlarge", "r5a.24xlarge" "r5a.24xlarge", :m-5alarge "m5a.large", :r-524xlarge "r5.24xlarge", "z1d.xlarge" "z1d.xlarge", :r-5a-4xlarge "r5a.4xlarge", :r-5d-24xlarge "r5d.24xlarge", :r-34xlarge "r3.4xlarge", "c5.4xlarge" "c5.4xlarge", "p3dn.24xlarge" "p3dn.24xlarge", :z-1d-6xlarge "z1d.6xlarge", :m-32xlarge "m3.2xlarge", "c3.2xlarge" "c3.2xlarge", "g2.8xlarge" "g2.8xlarge", "z1d.3xlarge" "z1d.3xlarge", "c5d.18xlarge" "c5d.18xlarge", :m-54xlarge "m5.4xlarge", :r-5d-4xlarge "r5d.4xlarge", :t-2xlarge "t2.xlarge", "c4.8xlarge" "c4.8xlarge", "c5.18xlarge" "c5.18xlarge", :r-4large "r4.large", "x1e.2xlarge" "x1e.2xlarge", "r5.metal" "r5.metal", "z1d.6xlarge" "z1d.6xlarge", :g-22xlarge "g2.2xlarge", :h-18xlarge "h1.8xlarge", :c-3large "c3.large", "m2.xlarge" "m2.xlarge", "m1.small" "m1.small", "i2.4xlarge" "i2.4xlarge", "c3.4xlarge" "c3.4xlarge", "i3.16xlarge" "i3.16xlarge", :i-3metal "i3.metal", :t-2micro "t2.micro", :m-5d-4xlarge "m5d.4xlarge", :c-38xlarge "c3.8xlarge", "t2.micro" "t2.micro", :c-5n-9xlarge "c5n.9xlarge", :r-416xlarge "r4.16xlarge", "z1d.metal" "z1d.metal", :g-316xlarge "g3.16xlarge", :p-316xlarge "p3.16xlarge", "g3s.xlarge" "g3s.xlarge", "d2.2xlarge" "d2.2xlarge", :r-5axlarge "r5a.xlarge", "x1.32xlarge" "x1.32xlarge", :r-38xlarge "r3.8xlarge", "m4.2xlarge" "m4.2xlarge", "r5d.24xlarge" "r5d.24xlarge", :r-32xlarge "r3.2xlarge", :c-52xlarge "c5.2xlarge", "u-6tb1.metal" "u-6tb1.metal", "i3.4xlarge" "i3.4xlarge", :r-5xlarge "r5.xlarge", :t-3xlarge "t3.xlarge", :p-32xlarge "p3.2xlarge", "m4.10xlarge" "m4.10xlarge", "i3.metal" "i3.metal", "m1.medium" "m1.medium", "c5n.xlarge" "c5n.xlarge", :cc-14xlarge "cc1.4xlarge", "c4.4xlarge" "c4.4xlarge", :c-5n-2xlarge "c5n.2xlarge", "hi1.4xlarge" "hi1.4xlarge", :d-2xlarge "d2.xlarge", :c-5nlarge "c5n.large", :i-2xlarge "i2.xlarge", "r3.xlarge" "r3.xlarge", "c5n.large" "c5n.large", :t-3large "t3.large", :m-5dmetal "m5d.metal", "x1e.16xlarge" "x1e.16xlarge", :i-32xlarge "i3.2xlarge", :c-44xlarge "c4.4xlarge", :a-12xlarge "a1.2xlarge", :m-22xlarge "m2.2xlarge", "m5.large" "m5.large", :t-2medium "t2.medium", "r5.xlarge" "r5.xlarge", :r-5a-12xlarge "r5a.12xlarge", :r-3xlarge "r3.xlarge", "c4.2xlarge" "c4.2xlarge", :m-416xlarge "m4.16xlarge", "i3.8xlarge" "i3.8xlarge", "p3.2xlarge" "p3.2xlarge", :m-5dlarge "m5d.large", "m5.4xlarge" "m5.4xlarge", "t3.medium" "t3.medium", :c-5n-4xlarge "c5n.4xlarge", "u-9tb1.metal" "u-9tb1.metal", :r-42xlarge "r4.2xlarge", :c-59xlarge "c5.9xlarge", :i-22xlarge "i2.2xlarge", "t2.small" "t2.small", :m-1small "m1.small", :c-5d-9xlarge "c5d.9xlarge", "c5n.4xlarge" "c5n.4xlarge", "r4.xlarge" "r4.xlarge", :t-22xlarge "t2.2xlarge", :u-12tb-1metal "u-12tb1.metal", "m5a.2xlarge" "m5a.2xlarge", "m5.2xlarge" "m5.2xlarge", :m-3large "m3.large", "z1d.12xlarge" "z1d.12xlarge", "t3.micro" "t3.micro", :a-14xlarge "a1.4xlarge", "c5.large" "c5.large", "c5.2xlarge" "c5.2xlarge", :m-5a-4xlarge "m5a.4xlarge", :f-14xlarge "f1.4xlarge", "f1.2xlarge" "f1.2xlarge", "m5d.4xlarge" "m5d.4xlarge", "c5d.xlarge" "c5d.xlarge", :r-52xlarge "r5.2xlarge", "m3.xlarge" "m3.xlarge", :g-38xlarge "g3.8xlarge", :m-5d-12xlarge "m5d.12xlarge", "c5d.9xlarge" "c5d.9xlarge", "r3.2xlarge" "r3.2xlarge", "m5d.metal" "m5d.metal", :c-32xlarge "c3.2xlarge", :p-38xlarge "p3.8xlarge", "cg1.4xlarge" "cg1.4xlarge", :c-42xlarge "c4.2xlarge", :c-5d-2xlarge "c5d.2xlarge", :z-1dlarge "z1d.large", "r3.4xlarge" "r3.4xlarge", :r-44xlarge "r4.4xlarge", :m-5axlarge "m5a.xlarge", :p-2xlarge "p2.xlarge", :hs-18xlarge "hs1.8xlarge", :t-2nano "t2.nano", :m-44xlarge "m4.4xlarge", :p-3dn-24xlarge "p3dn.24xlarge", :i-34xlarge "i3.4xlarge", :m-24xlarge "m2.4xlarge", "t2.xlarge" "t2.xlarge", "c4.xlarge" "c4.xlarge", "m2.2xlarge" "m2.2xlarge", :m-5a-24xlarge "m5a.24xlarge", "f1.4xlarge" "f1.4xlarge", :c-54xlarge "c5.4xlarge", "r5.large" "r5.large", :t-3small "t3.small", "p2.8xlarge" "p2.8xlarge", :h-12xlarge "h1.2xlarge", "r5d.12xlarge" "r5d.12xlarge", "m5.metal" "m5.metal", "x1.16xlarge" "x1.16xlarge", "m4.large" "m4.large", "c5n.2xlarge" "c5n.2xlarge", :m-410xlarge "m4.10xlarge", :t-3nano "t3.nano", "m4.16xlarge" "m4.16xlarge", "r3.large" "r3.large", "d2.4xlarge" "d2.4xlarge", "h1.8xlarge" "h1.8xlarge", "i3.2xlarge" "i3.2xlarge", :h-116xlarge "h1.16xlarge", "c4.large" "c4.large", "h1.4xlarge" "h1.4xlarge", :r-5dlarge "r5d.large", "m5d.12xlarge" "m5d.12xlarge", :d-24xlarge "d2.4xlarge", :m-3medium "m3.medium", :g-28xlarge "g2.8xlarge", :m-1xlarge "m1.xlarge", "m4.xlarge" "m4.xlarge", "m5a.large" "m5a.large", "f1.16xlarge" "f1.16xlarge", "r5.12xlarge" "r5.12xlarge", "m5a.4xlarge" "m5a.4xlarge", "i2.2xlarge" "i2.2xlarge", "p3.16xlarge" "p3.16xlarge", :z-1d-3xlarge "z1d.3xlarge", :a-1xlarge "a1.xlarge", "i3.xlarge" "i3.xlarge", :c-4large "c4.large", :cc-28xlarge "cc2.8xlarge", "c5n.9xlarge" "c5n.9xlarge", :t-32xlarge "t3.2xlarge", :r-4xlarge "r4.xlarge", :i-24xlarge "i2.4xlarge", :r-5large "r5.large", :m-4xlarge "m4.xlarge", :m-3xlarge "m3.xlarge", :z-1dmetal "z1d.metal", "t2.nano" "t2.nano", "m2.4xlarge" "m2.4xlarge", :f-12xlarge "f1.2xlarge", "r5a.4xlarge" "r5a.4xlarge", :r-5alarge "r5a.large", :r-5metal "r5.metal", "r5d.metal" "r5d.metal", :r-5a-2xlarge "r5a.2xlarge", "r4.large" "r4.large", "m5a.xlarge" "m5a.xlarge", "c3.xlarge" "c3.xlarge", :m-4large "m4.large", "p2.xlarge" "p2.xlarge", "c5d.4xlarge" "c5d.4xlarge", :m-5metal "m5.metal", :m-1medium "m1.medium", :m-1large "m1.large", :x-1e-32xlarge "x1e.32xlarge", :i-3xlarge "i3.xlarge", "i3.large" "i3.large", "a1.4xlarge" "a1.4xlarge", "r4.8xlarge" "r4.8xlarge", "a1.xlarge" "a1.xlarge", "t2.medium" "t2.medium", :m-5a-12xlarge "m5a.12xlarge", :c-5nxlarge "c5n.xlarge", "p3.8xlarge" "p3.8xlarge", "m5a.12xlarge" "m5a.12xlarge", "c3.large" "c3.large", :c-1medium "c1.medium", "m3.medium" "m3.medium", "a1.medium" "a1.medium", :x-1e-2xlarge "x1e.2xlarge", "m5d.2xlarge" "m5d.2xlarge", :u-6tb-1metal "u-6tb1.metal", "r5d.2xlarge" "r5d.2xlarge", :f-116xlarge "f1.16xlarge", :c-5dxlarge "c5d.xlarge", :cr-18xlarge "cr1.8xlarge", "i2.xlarge" "i2.xlarge", "m5.24xlarge" "m5.24xlarge", "c5n.18xlarge" "c5n.18xlarge", "r5a.12xlarge" "r5a.12xlarge", "c5.9xlarge" "c5.9xlarge", "m5d.large" "m5d.large", :z-1dxlarge "z1d.xlarge", "m5.12xlarge" "m5.12xlarge", :h-14xlarge "h1.4xlarge", "cc2.8xlarge" "cc2.8xlarge", "hs1.8xlarge" "hs1.8xlarge", :r-5d-2xlarge "r5d.2xlarge", :c-5d-18xlarge "c5d.18xlarge", :t-3medium "t3.medium", :x-132xlarge "x1.32xlarge", "m3.large" "m3.large", :m-5d-2xlarge "m5d.2xlarge", :p-216xlarge "p2.16xlarge", "x1e.xlarge" "x1e.xlarge", "c1.xlarge" "c1.xlarge", "c5d.2xlarge" "c5d.2xlarge", :c-5xlarge "c5.xlarge", "x1e.8xlarge" "x1e.8xlarge", :t-1micro "t1.micro", :d-22xlarge "d2.2xlarge", :t-3micro "t3.micro", :a-1large "a1.large", "r5.2xlarge" "r5.2xlarge", :m-2xlarge "m2.xlarge", :x-1e-8xlarge "x1e.8xlarge", "m5d.xlarge" "m5d.xlarge", :p-28xlarge "p2.8xlarge", :r-54xlarge "r5.4xlarge", :c-5dlarge "c5d.large", "a1.large" "a1.large", :r-5a-24xlarge "r5a.24xlarge", "c5.xlarge" "c5.xlarge", :i-316xlarge "i3.16xlarge", :m-5d-24xlarge "m5d.24xlarge", "r4.4xlarge" "r4.4xlarge", "r5.24xlarge" "r5.24xlarge", :m-5dxlarge "m5d.xlarge", :hi-14xlarge "hi1.4xlarge"} input), :shape "InstanceType"})

(clojure.core/defn- ser-transit-gateway-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "TransitGatewayIdStringList", :type "list"})

(clojure.core/defn- ser-instance-type-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-type coll) #:http.request.field{:shape "InstanceType"}))) input), :shape "InstanceTypeList", :type "list"})

(clojure.core/defn- ser-instance-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "InstanceId"}))) input), :shape "InstanceIdStringList", :type "list"})

(clojure.core/defn- ser-image-attribute-name [input] #:http.request.field{:value (clojure.core/get {:description "description", "kernel" "kernel", "productCodes" "productCodes", "blockDeviceMapping" "blockDeviceMapping", :ramdisk "ramdisk", :product-codes "productCodes", "launchPermission" "launchPermission", :block-device-mapping "blockDeviceMapping", "ramdisk" "ramdisk", :sriov-net-support "sriovNetSupport", :kernel "kernel", :launch-permission "launchPermission", "description" "description", "sriovNetSupport" "sriovNetSupport"} input), :shape "ImageAttributeName"})

(clojure.core/defn- ser-create-volume-permission [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CreateVolumePermission", :type "structure"} (clojure.core/contains? input :group) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-permission-group (input :group)) #:http.request.field{:name "Group", :shape "PermissionGroup", :location-name "group"})) (clojure.core/contains? input :user-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :user-id)) #:http.request.field{:name "UserId", :shape "String", :location-name "userId"}))))

(clojure.core/defn- ser-describe-network-acls-max-results [input] #:http.request.field{:value input, :shape "DescribeNetworkAclsMaxResults"})

(clojure.core/defn- ser-iam-instance-profile-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "IamInstanceProfileSpecification", :type "structure"} (clojure.core/contains? input :arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :arn)) #:http.request.field{:name "Arn", :shape "String", :location-name "arn"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String", :location-name "name"}))))

(clojure.core/defn- ser-hibernation-options-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "HibernationOptionsRequest", :type "structure"} (clojure.core/contains? input :configured) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :configured)) #:http.request.field{:name "Configured", :shape "Boolean"}))))

(clojure.core/defn- ser-placement-group-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "PlacementGroupStringList", :type "list"})

(clojure.core/defn- ser-volume-detail [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-long (:size input)) #:http.request.field{:name "Size", :shape "Long", :location-name "size"})], :shape "VolumeDetail", :type "structure"}))

(clojure.core/defn- ser-end-date-type [input] #:http.request.field{:value (clojure.core/get {"unlimited" "unlimited", :unlimited "unlimited", "limited" "limited", :limited "limited"} input), :shape "EndDateType"})

(clojure.core/defn- ser-launch-template-spot-market-options-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateSpotMarketOptionsRequest", :type "structure"} (clojure.core/contains? input :max-price) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :max-price)) #:http.request.field{:name "MaxPrice", :shape "String"})) (clojure.core/contains? input :spot-instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-instance-type (input :spot-instance-type)) #:http.request.field{:name "SpotInstanceType", :shape "SpotInstanceType"})) (clojure.core/contains? input :block-duration-minutes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :block-duration-minutes)) #:http.request.field{:name "BlockDurationMinutes", :shape "Integer"})) (clojure.core/contains? input :valid-until) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :valid-until)) #:http.request.field{:name "ValidUntil", :shape "DateTime"})) (clojure.core/contains? input :instance-interruption-behavior) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-interruption-behavior (input :instance-interruption-behavior)) #:http.request.field{:name "InstanceInterruptionBehavior", :shape "InstanceInterruptionBehavior"}))))

(clojure.core/defn- ser-host-tenancy [input] #:http.request.field{:value (clojure.core/get {"dedicated" "dedicated", :dedicated "dedicated", "host" "host", :host "host"} input), :shape "HostTenancy"})

(clojure.core/defn- ser-storage-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "StorageLocation", :type "structure"} (clojure.core/contains? input :bucket) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :bucket)) #:http.request.field{:name "Bucket", :shape "String"})) (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key)) #:http.request.field{:name "Key", :shape "String"}))))

(clojure.core/defn- ser-icmp-type-code [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "IcmpTypeCode", :type "structure"} (clojure.core/contains? input :code) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :code)) #:http.request.field{:name "Code", :shape "Integer", :location-name "code"})) (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :type)) #:http.request.field{:name "Type", :shape "Integer", :location-name "type"}))))

(clojure.core/defn- ser-fpga-image-attribute-name [input] #:http.request.field{:value (clojure.core/get {"description" "description", :description "description", "name" "name", :name "name", "loadPermission" "loadPermission", :load-permission "loadPermission", "productCodes" "productCodes", :product-codes "productCodes"} input), :shape "FpgaImageAttributeName"})

(clojure.core/defn- ser-describe-internet-gateways-max-results [input] #:http.request.field{:value input, :shape "DescribeInternetGatewaysMaxResults"})

(clojure.core/defn- ser-elastic-gpu-specification [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:type input)) #:http.request.field{:name "Type", :shape "String"})], :shape "ElasticGpuSpecification", :type "structure"}))

(clojure.core/defn- ser-instance-ipv-6-address-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-ipv-6-address coll) #:http.request.field{:shape "InstanceIpv6Address", :location-name "item"}))) input), :shape "InstanceIpv6AddressList", :type "list"})

(clojure.core/defn- ser-volume-attribute-name [input] #:http.request.field{:value (clojure.core/get {"autoEnableIO" "autoEnableIO", :auto-enable-io "autoEnableIO", "productCodes" "productCodes", :product-codes "productCodes"} input), :shape "VolumeAttributeName"})

(clojure.core/defn- ser-capacity-reservation-instance-platform [input] #:http.request.field{:value (clojure.core/get {"Red Hat Enterprise Linux" "Red Hat Enterprise Linux", "Windows with SQL Server Standard" "Windows with SQL Server Standard", :red-hat-enterprise-linux "Red Hat Enterprise Linux", :windows "Windows", "Windows with SQL Server Enterprise" "Windows with SQL Server Enterprise", :linux-unix "Linux/UNIX", "Windows with SQL Server Web" "Windows with SQL Server Web", "SUSE Linux" "SUSE Linux", :linuxwith-sql-server-web "Linux with SQL Server Web", "Linux with SQL Server Standard" "Linux with SQL Server Standard", :windowswith-sql-server-enterprise "Windows with SQL Server Enterprise", "Windows" "Windows", :windowswith-sql-server-standard "Windows with SQL Server Standard", :windowswith-sql-server-web "Windows with SQL Server Web", "Linux/UNIX" "Linux/UNIX", :suse-linux "SUSE Linux", "Windows with SQL Server" "Windows with SQL Server", :linuxwith-sql-server-standard "Linux with SQL Server Standard", "Linux with SQL Server Enterprise" "Linux with SQL Server Enterprise", :linuxwith-sql-server-enterprise "Linux with SQL Server Enterprise", :windowswith-sql-server "Windows with SQL Server", "Linux with SQL Server Web" "Linux with SQL Server Web"} input), :shape "CapacityReservationInstancePlatform"})

(clojure.core/defn- ser-fleet-event-type [input] #:http.request.field{:value (clojure.core/get {"instance-change" "instance-change", :instancechange "instance-change", "fleet-change" "fleet-change", :fleetchange "fleet-change", "service-error" "service-error", :serviceerror "service-error"} input), :shape "FleetEventType"})

(clojure.core/defn- ser-scheduled-instance-id-request-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ScheduledInstanceId"}))) input), :shape "ScheduledInstanceIdRequestSet", :type "list"})

(clojure.core/defn- ser-attribute-boolean-value [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AttributeBooleanValue", :type "structure"} (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :value)) #:http.request.field{:name "Value", :shape "Boolean", :location-name "value"}))))

(clojure.core/defn- ser-vpc-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "VpcId"}))) input), :shape "VpcIdStringList", :type "list"})

(clojure.core/defn- ser-price-schedule-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PriceScheduleSpecification", :type "structure"} (clojure.core/contains? input :currency-code) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-currency-code-values (input :currency-code)) #:http.request.field{:name "CurrencyCode", :shape "CurrencyCodeValues", :location-name "currencyCode"})) (clojure.core/contains? input :price) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :price)) #:http.request.field{:name "Price", :shape "Double", :location-name "price"})) (clojure.core/contains? input :term) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-long (input :term)) #:http.request.field{:name "Term", :shape "Long", :location-name "term"}))))

(clojure.core/defn- ser-export-to-s-3-task-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ExportToS3TaskSpecification", :type "structure"} (clojure.core/contains? input :container-format) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-container-format (input :container-format)) #:http.request.field{:name "ContainerFormat", :shape "ContainerFormat", :location-name "containerFormat"})) (clojure.core/contains? input :disk-image-format) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-disk-image-format (input :disk-image-format)) #:http.request.field{:name "DiskImageFormat", :shape "DiskImageFormat", :location-name "diskImageFormat"})) (clojure.core/contains? input :s-3-bucket) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :s-3-bucket)) #:http.request.field{:name "S3Bucket", :shape "String", :location-name "s3Bucket"})) (clojure.core/contains? input :s-3-prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :s-3-prefix)) #:http.request.field{:name "S3Prefix", :shape "String", :location-name "s3Prefix"}))))

(clojure.core/defn- ser-elastic-inference-accelerator [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:type input)) #:http.request.field{:name "Type", :shape "String"})], :shape "ElasticInferenceAccelerator", :type "structure"}))

(clojure.core/defn- ser-rule-action [input] #:http.request.field{:value (clojure.core/get {"allow" "allow", :allow "allow", "deny" "deny", :deny "deny"} input), :shape "RuleAction"})

(clojure.core/defn- ser-elastic-inference-accelerators [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-elastic-inference-accelerator coll) #:http.request.field{:shape "ElasticInferenceAccelerator", :location-name "item"}))) input), :shape "ElasticInferenceAccelerators", :type "list"})

(clojure.core/defn- ser-fleet-type [input] #:http.request.field{:value (clojure.core/get {"request" "request", :request "request", "maintain" "maintain", :maintain "maintain", "instant" "instant", :instant "instant"} input), :shape "FleetType"})

(clojure.core/defn- ser-request-launch-template-data [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "RequestLaunchTemplateData", :type "structure"} (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-tag-specification-request-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "LaunchTemplateTagSpecificationRequestList", :location-name "TagSpecification"})) (clojure.core/contains? input :kernel-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kernel-id)) #:http.request.field{:name "KernelId", :shape "String"})) (clojure.core/contains? input :credit-specification) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-credit-specification-request (input :credit-specification)) #:http.request.field{:name "CreditSpecification", :shape "CreditSpecificationRequest"})) (clojure.core/contains? input :security-group-ids) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-id-string-list (input :security-group-ids)) #:http.request.field{:name "SecurityGroupIds", :shape "SecurityGroupIdStringList", :location-name "SecurityGroupId"})) (clojure.core/contains? input :image-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-id)) #:http.request.field{:name "ImageId", :shape "String"})) (clojure.core/contains? input :placement) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-placement-request (input :placement)) #:http.request.field{:name "Placement", :shape "LaunchTemplatePlacementRequest"})) (clojure.core/contains? input :security-groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-string-list (input :security-groups)) #:http.request.field{:name "SecurityGroups", :shape "SecurityGroupStringList", :location-name "SecurityGroup"})) (clojure.core/contains? input :ebs-optimized) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :ebs-optimized)) #:http.request.field{:name "EbsOptimized", :shape "Boolean"})) (clojure.core/contains? input :instance-market-options) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-instance-market-options-request (input :instance-market-options)) #:http.request.field{:name "InstanceMarketOptions", :shape "LaunchTemplateInstanceMarketOptionsRequest"})) (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-type (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "InstanceType"})) (clojure.core/contains? input :elastic-inference-accelerators) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-elastic-inference-accelerator-list (input :elastic-inference-accelerators)) #:http.request.field{:name "ElasticInferenceAccelerators", :shape "LaunchTemplateElasticInferenceAcceleratorList", :location-name "ElasticInferenceAccelerator"})) (clojure.core/contains? input :key-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key-name)) #:http.request.field{:name "KeyName", :shape "String"})) (clojure.core/contains? input :elastic-gpu-specifications) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-elastic-gpu-specification-list (input :elastic-gpu-specifications)) #:http.request.field{:name "ElasticGpuSpecifications", :shape "ElasticGpuSpecificationList", :location-name "ElasticGpuSpecification"})) (clojure.core/contains? input :license-specifications) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-license-specification-list-request (input :license-specifications)) #:http.request.field{:name "LicenseSpecifications", :shape "LaunchTemplateLicenseSpecificationListRequest", :location-name "LicenseSpecification"})) (clojure.core/contains? input :ram-disk-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ram-disk-id)) #:http.request.field{:name "RamDiskId", :shape "String"})) (clojure.core/contains? input :disable-api-termination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :disable-api-termination)) #:http.request.field{:name "DisableApiTermination", :shape "Boolean"})) (clojure.core/contains? input :hibernation-options) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-hibernation-options-request (input :hibernation-options)) #:http.request.field{:name "HibernationOptions", :shape "LaunchTemplateHibernationOptionsRequest"})) (clojure.core/contains? input :monitoring) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-templates-monitoring-request (input :monitoring)) #:http.request.field{:name "Monitoring", :shape "LaunchTemplatesMonitoringRequest"})) (clojure.core/contains? input :block-device-mappings) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-block-device-mapping-request-list (input :block-device-mappings)) #:http.request.field{:name "BlockDeviceMappings", :shape "LaunchTemplateBlockDeviceMappingRequestList", :location-name "BlockDeviceMapping"})) (clojure.core/contains? input :capacity-reservation-specification) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-capacity-reservation-specification-request (input :capacity-reservation-specification)) #:http.request.field{:name "CapacityReservationSpecification", :shape "LaunchTemplateCapacityReservationSpecificationRequest"})) (clojure.core/contains? input :cpu-options) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-cpu-options-request (input :cpu-options)) #:http.request.field{:name "CpuOptions", :shape "LaunchTemplateCpuOptionsRequest"})) (clojure.core/contains? input :user-data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :user-data)) #:http.request.field{:name "UserData", :shape "String"})) (clojure.core/contains? input :instance-initiated-shutdown-behavior) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-shutdown-behavior (input :instance-initiated-shutdown-behavior)) #:http.request.field{:name "InstanceInitiatedShutdownBehavior", :shape "ShutdownBehavior"})) (clojure.core/contains? input :iam-instance-profile) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-iam-instance-profile-specification-request (input :iam-instance-profile)) #:http.request.field{:name "IamInstanceProfile", :shape "LaunchTemplateIamInstanceProfileSpecificationRequest"})) (clojure.core/contains? input :network-interfaces) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-instance-network-interface-specification-request-list (input :network-interfaces)) #:http.request.field{:name "NetworkInterfaces", :shape "LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList", :location-name "NetworkInterface"}))))

(clojure.core/defn- ser-group-identifier-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-group-identifier coll) #:http.request.field{:shape "GroupIdentifier", :location-name "item"}))) input), :shape "GroupIdentifierList", :type "list"})

(clojure.core/defn- ser-price-schedule-specification-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-price-schedule-specification coll) #:http.request.field{:shape "PriceScheduleSpecification", :location-name "item"}))) input), :shape "PriceScheduleSpecificationList", :type "list"})

(clojure.core/defn- ser-fleet-launch-template-config-list-request [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-fleet-launch-template-config-request coll) #:http.request.field{:shape "FleetLaunchTemplateConfigRequest", :location-name "item"}))) input), :shape "FleetLaunchTemplateConfigListRequest", :type "list", :max 50})

(clojure.core/defn- ser-elastic-gpu-id-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "ElasticGpuIdSet", :type "list"})

(clojure.core/defn- ser-traffic-type [input] #:http.request.field{:value (clojure.core/get {"ACCEPT" "ACCEPT", :accept "ACCEPT", "REJECT" "REJECT", :reject "REJECT", "ALL" "ALL", :all "ALL"} input), :shape "TrafficType"})

(clojure.core/defn- ser-allocation-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "AllocationId"}))) input), :shape "AllocationIdList", :type "list"})

(clojure.core/defn- ser-create-volume-permission-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-create-volume-permission coll) #:http.request.field{:shape "CreateVolumePermission", :location-name "item"}))) input), :shape "CreateVolumePermissionList", :type "list"})

(clojure.core/defn- ser-certificate-authentication-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CertificateAuthenticationRequest", :type "structure"} (clojure.core/contains? input :client-root-certificate-chain-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-root-certificate-chain-arn)) #:http.request.field{:name "ClientRootCertificateChainArn", :shape "String"}))))

(clojure.core/defn- ser-image-disk-container-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-image-disk-container coll) #:http.request.field{:shape "ImageDiskContainer", :location-name "item"}))) input), :shape "ImageDiskContainerList", :type "list"})

(clojure.core/defn- ser-event-type [input] #:http.request.field{:value (clojure.core/get {"instanceChange" "instanceChange", :instance-change "instanceChange", "fleetRequestChange" "fleetRequestChange", :fleet-request-change "fleetRequestChange", "error" "error", :error "error"} input), :shape "EventType"})

(clojure.core/defn- ser-restorable-by-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "RestorableByStringList", :type "list"})

(clojure.core/defn- ser-next-token [input] #:http.request.field{:value input, :shape "NextToken"})

(clojure.core/defn- ser-slot-start-time-range-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SlotStartTimeRangeRequest", :type "structure"} (clojure.core/contains? input :earliest-time) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :earliest-time)) #:http.request.field{:name "EarliestTime", :shape "DateTime"})) (clojure.core/contains? input :latest-time) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :latest-time)) #:http.request.field{:name "LatestTime", :shape "DateTime"}))))

(clojure.core/defn- ser-elastic-gpu-specifications [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-elastic-gpu-specification coll) #:http.request.field{:shape "ElasticGpuSpecification", :location-name "item"}))) input), :shape "ElasticGpuSpecifications", :type "list"})

(clojure.core/defn- ser-excess-capacity-termination-policy [input] #:http.request.field{:value (clojure.core/get {"noTermination" "noTermination", :no-termination "noTermination", "default" "default", :default "default"} input), :shape "ExcessCapacityTerminationPolicy"})

(clojure.core/defn- ser-modify-transit-gateway-vpc-attachment-request-options [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ModifyTransitGatewayVpcAttachmentRequestOptions", :type "structure"} (clojure.core/contains? input :dns-support) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dns-support-value (input :dns-support)) #:http.request.field{:name "DnsSupport", :shape "DnsSupportValue"})) (clojure.core/contains? input :ipv-6-support) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ipv-6-support-value (input :ipv-6-support)) #:http.request.field{:name "Ipv6Support", :shape "Ipv6SupportValue"}))))

(clojure.core/defn- ser-spot-fleet-monitoring [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SpotFleetMonitoring", :type "structure"} (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "Boolean", :location-name "enabled"}))))

(clojure.core/defn- ser-instance-block-device-mapping-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "InstanceBlockDeviceMappingSpecification", :type "structure"} (clojure.core/contains? input :device-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :device-name)) #:http.request.field{:name "DeviceName", :shape "String", :location-name "deviceName"})) (clojure.core/contains? input :ebs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ebs-instance-block-device-specification (input :ebs)) #:http.request.field{:name "Ebs", :shape "EbsInstanceBlockDeviceSpecification", :location-name "ebs"})) (clojure.core/contains? input :no-device) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :no-device)) #:http.request.field{:name "NoDevice", :shape "String", :location-name "noDevice"})) (clojure.core/contains? input :virtual-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :virtual-name)) #:http.request.field{:name "VirtualName", :shape "String", :location-name "virtualName"}))))

(clojure.core/defn- ser-load-permission-list-request [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-load-permission-request coll) #:http.request.field{:shape "LoadPermissionRequest", :location-name "item"}))) input), :shape "LoadPermissionListRequest", :type "list"})

(clojure.core/defn- ser-transit-gateway-request-options [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "TransitGatewayRequestOptions", :type "structure"} (clojure.core/contains? input :amazon-side-asn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-long (input :amazon-side-asn)) #:http.request.field{:name "AmazonSideAsn", :shape "Long"})) (clojure.core/contains? input :auto-accept-shared-attachments) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-auto-accept-shared-attachments-value (input :auto-accept-shared-attachments)) #:http.request.field{:name "AutoAcceptSharedAttachments", :shape "AutoAcceptSharedAttachmentsValue"})) (clojure.core/contains? input :default-route-table-association) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-default-route-table-association-value (input :default-route-table-association)) #:http.request.field{:name "DefaultRouteTableAssociation", :shape "DefaultRouteTableAssociationValue"})) (clojure.core/contains? input :default-route-table-propagation) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-default-route-table-propagation-value (input :default-route-table-propagation)) #:http.request.field{:name "DefaultRouteTablePropagation", :shape "DefaultRouteTablePropagationValue"})) (clojure.core/contains? input :vpn-ecmp-support) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpn-ecmp-support-value (input :vpn-ecmp-support)) #:http.request.field{:name "VpnEcmpSupport", :shape "VpnEcmpSupportValue"})) (clojure.core/contains? input :dns-support) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dns-support-value (input :dns-support)) #:http.request.field{:name "DnsSupport", :shape "DnsSupportValue"}))))

(clojure.core/defn- ser-instance-credit-specification-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "InstanceCreditSpecificationRequest", :type "structure"} (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"})) (clojure.core/contains? input :cpu-credits) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cpu-credits)) #:http.request.field{:name "CpuCredits", :shape "String"}))))

(clojure.core/defn- ser-group-ids [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "GroupIds", :type "list"})

(clojure.core/defn- ser-user-id-group-pair-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-user-id-group-pair coll) #:http.request.field{:shape "UserIdGroupPair", :location-name "item"}))) input), :shape "UserIdGroupPairList", :type "list"})

(clojure.core/defn- ser-s-3-storage [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "S3Storage", :type "structure"} (clojure.core/contains? input :aws-access-key-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :aws-access-key-id)) #:http.request.field{:name "AWSAccessKeyId", :shape "String"})) (clojure.core/contains? input :bucket) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :bucket)) #:http.request.field{:name "Bucket", :shape "String", :location-name "bucket"})) (clojure.core/contains? input :prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :prefix)) #:http.request.field{:name "Prefix", :shape "String", :location-name "prefix"})) (clojure.core/contains? input :upload-policy) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-blob (input :upload-policy)) #:http.request.field{:name "UploadPolicy", :shape "Blob", :location-name "uploadPolicy"})) (clojure.core/contains? input :upload-policy-signature) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :upload-policy-signature)) #:http.request.field{:name "UploadPolicySignature", :shape "String", :location-name "uploadPolicySignature"}))))

(clojure.core/defn- ser-launch-permission-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-launch-permission coll) #:http.request.field{:shape "LaunchPermission", :location-name "item"}))) input), :shape "LaunchPermissionList", :type "list"})

(clojure.core/defn- ser-reserved-instances-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ReservedInstancesId"}))) input), :shape "ReservedInstancesIdStringList", :type "list"})

(clojure.core/defn- ser-directory-service-authentication-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DirectoryServiceAuthenticationRequest", :type "structure"} (clojure.core/contains? input :directory-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :directory-id)) #:http.request.field{:name "DirectoryId", :shape "String"}))))

(clojure.core/defn- ser-instance-ipv-6-address [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "InstanceIpv6Address", :type "structure"} (clojure.core/contains? input :ipv-6-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ipv-6-address)) #:http.request.field{:name "Ipv6Address", :shape "String", :location-name "ipv6Address"}))))

(clojure.core/defn- ser-group-identifier [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "GroupIdentifier", :type "structure"} (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String", :location-name "groupName"})) (clojure.core/contains? input :group-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-id)) #:http.request.field{:name "GroupId", :shape "String", :location-name "groupId"}))))

(clojure.core/defn- ser-client-vpn-authentication-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ClientVpnAuthenticationRequest", :type "structure"} (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-vpn-authentication-type (input :type)) #:http.request.field{:name "Type", :shape "ClientVpnAuthenticationType"})) (clojure.core/contains? input :active-directory) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-directory-service-authentication-request (input :active-directory)) #:http.request.field{:name "ActiveDirectory", :shape "DirectoryServiceAuthenticationRequest"})) (clojure.core/contains? input :mutual-authentication) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-authentication-request (input :mutual-authentication)) #:http.request.field{:name "MutualAuthentication", :shape "CertificateAuthenticationRequest"}))))

(clojure.core/defn- ser-instance-ipv-6-address-list-request [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-ipv-6-address-request coll) #:http.request.field{:shape "InstanceIpv6AddressRequest", :location-name "InstanceIpv6Address"}))) input), :shape "InstanceIpv6AddressListRequest", :type "list"})

(clojure.core/defn- ser-spot-instance-interruption-behavior [input] #:http.request.field{:value (clojure.core/get {"hibernate" "hibernate", :hibernate "hibernate", "stop" "stop", :stop "stop", "terminate" "terminate", :terminate "terminate"} input), :shape "SpotInstanceInterruptionBehavior"})

(clojure.core/defn- ser-run-instances-monitoring-enabled [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-boolean (:enabled input)) #:http.request.field{:name "Enabled", :shape "Boolean", :location-name "enabled"})], :shape "RunInstancesMonitoringEnabled", :type "structure"}))

(clojure.core/defn- ser-capacity-reservation-id-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "CapacityReservationIdSet", :type "list"})

(clojure.core/defn- ser-transit-gateway-attachment-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "TransitGatewayAttachmentIdStringList", :type "list"})

(clojure.core/defn- ser-disk-image-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-disk-image coll) #:http.request.field{:shape "DiskImage"}))) input), :shape "DiskImageList", :type "list"})

(clojure.core/defn- ser-tag-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag coll) #:http.request.field{:shape "Tag", :location-name "item"}))) input), :shape "TagList", :type "list"})

(clojure.core/defn- ser-client-data [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ClientData", :type "structure"} (clojure.core/contains? input :comment) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :comment)) #:http.request.field{:name "Comment", :shape "String"})) (clojure.core/contains? input :upload-end) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :upload-end)) #:http.request.field{:name "UploadEnd", :shape "DateTime"})) (clojure.core/contains? input :upload-size) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :upload-size)) #:http.request.field{:name "UploadSize", :shape "Double"})) (clojure.core/contains? input :upload-start) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :upload-start)) #:http.request.field{:name "UploadStart", :shape "DateTime"}))))

(clojure.core/defn- ser-image-disk-container [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ImageDiskContainer", :type "structure"} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :device-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :device-name)) #:http.request.field{:name "DeviceName", :shape "String"})) (clojure.core/contains? input :format) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :format)) #:http.request.field{:name "Format", :shape "String"})) (clojure.core/contains? input :snapshot-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "String"})) (clojure.core/contains? input :url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :url)) #:http.request.field{:name "Url", :shape "String"})) (clojure.core/contains? input :user-bucket) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-bucket (input :user-bucket)) #:http.request.field{:name "UserBucket", :shape "UserBucket"}))))

(clojure.core/defn- ser-spot-fleet-request-config-data [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:iam-fleet-role input)) #:http.request.field{:name "IamFleetRole", :shape "String", :location-name "iamFleetRole"}) (clojure.core/into (ser-integer (:target-capacity input)) #:http.request.field{:name "TargetCapacity", :shape "Integer", :location-name "targetCapacity"})], :shape "SpotFleetRequestConfigData", :type "structure"} (clojure.core/contains? input :on-demand-allocation-strategy) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-on-demand-allocation-strategy (input :on-demand-allocation-strategy)) #:http.request.field{:name "OnDemandAllocationStrategy", :shape "OnDemandAllocationStrategy", :location-name "onDemandAllocationStrategy"})) (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fleet-type (input :type)) #:http.request.field{:name "Type", :shape "FleetType", :location-name "type"})) (clojure.core/contains? input :valid-from) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :valid-from)) #:http.request.field{:name "ValidFrom", :shape "DateTime", :location-name "validFrom"})) (clojure.core/contains? input :instance-pools-to-use-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :instance-pools-to-use-count)) #:http.request.field{:name "InstancePoolsToUseCount", :shape "Integer", :location-name "instancePoolsToUseCount"})) (clojure.core/contains? input :excess-capacity-termination-policy) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-excess-capacity-termination-policy (input :excess-capacity-termination-policy)) #:http.request.field{:name "ExcessCapacityTerminationPolicy", :shape "ExcessCapacityTerminationPolicy", :location-name "excessCapacityTerminationPolicy"})) (clojure.core/contains? input :spot-price) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :spot-price)) #:http.request.field{:name "SpotPrice", :shape "String", :location-name "spotPrice"})) (clojure.core/contains? input :allocation-strategy) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-allocation-strategy (input :allocation-strategy)) #:http.request.field{:name "AllocationStrategy", :shape "AllocationStrategy", :location-name "allocationStrategy"})) (clojure.core/contains? input :instance-interruption-behavior) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-interruption-behavior (input :instance-interruption-behavior)) #:http.request.field{:name "InstanceInterruptionBehavior", :shape "InstanceInterruptionBehavior", :location-name "instanceInterruptionBehavior"})) (clojure.core/contains? input :launch-template-configs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-config-list (input :launch-template-configs)) #:http.request.field{:name "LaunchTemplateConfigs", :shape "LaunchTemplateConfigList", :location-name "launchTemplateConfigs"})) (clojure.core/contains? input :load-balancers-config) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-load-balancers-config (input :load-balancers-config)) #:http.request.field{:name "LoadBalancersConfig", :shape "LoadBalancersConfig", :location-name "loadBalancersConfig"})) (clojure.core/contains? input :fulfilled-capacity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :fulfilled-capacity)) #:http.request.field{:name "FulfilledCapacity", :shape "Double", :location-name "fulfilledCapacity"})) (clojure.core/contains? input :terminate-instances-with-expiration) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :terminate-instances-with-expiration)) #:http.request.field{:name "TerminateInstancesWithExpiration", :shape "Boolean", :location-name "terminateInstancesWithExpiration"})) (clojure.core/contains? input :on-demand-fulfilled-capacity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :on-demand-fulfilled-capacity)) #:http.request.field{:name "OnDemandFulfilledCapacity", :shape "Double", :location-name "onDemandFulfilledCapacity"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String", :location-name "clientToken"})) (clojure.core/contains? input :launch-specifications) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-specs-list (input :launch-specifications)) #:http.request.field{:name "LaunchSpecifications", :shape "LaunchSpecsList", :location-name "launchSpecifications"})) (clojure.core/contains? input :replace-unhealthy-instances) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :replace-unhealthy-instances)) #:http.request.field{:name "ReplaceUnhealthyInstances", :shape "Boolean", :location-name "replaceUnhealthyInstances"})) (clojure.core/contains? input :on-demand-target-capacity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :on-demand-target-capacity)) #:http.request.field{:name "OnDemandTargetCapacity", :shape "Integer", :location-name "onDemandTargetCapacity"})) (clojure.core/contains? input :valid-until) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :valid-until)) #:http.request.field{:name "ValidUntil", :shape "DateTime", :location-name "validUntil"}))))

(clojure.core/defn- ser-launch-template-overrides [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateOverrides", :type "structure"} (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-type (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "InstanceType", :location-name "instanceType"})) (clojure.core/contains? input :spot-price) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :spot-price)) #:http.request.field{:name "SpotPrice", :shape "String", :location-name "spotPrice"})) (clojure.core/contains? input :subnet-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String", :location-name "subnetId"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String", :location-name "availabilityZone"})) (clojure.core/contains? input :weighted-capacity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :weighted-capacity)) #:http.request.field{:name "WeightedCapacity", :shape "Double", :location-name "weightedCapacity"})) (clojure.core/contains? input :priority) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :priority)) #:http.request.field{:name "Priority", :shape "Double", :location-name "priority"}))))

(clojure.core/defn- ser-launch-template-instance-market-options-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateInstanceMarketOptionsRequest", :type "structure"} (clojure.core/contains? input :market-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-market-type (input :market-type)) #:http.request.field{:name "MarketType", :shape "MarketType"})) (clojure.core/contains? input :spot-options) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-spot-market-options-request (input :spot-options)) #:http.request.field{:name "SpotOptions", :shape "LaunchTemplateSpotMarketOptionsRequest"}))))

(clojure.core/defn- ser-conversion-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "ConversionIdStringList", :type "list"})

(clojure.core/defn- ser-connection-log-options [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ConnectionLogOptions", :type "structure"} (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "Boolean"})) (clojure.core/contains? input :cloudwatch-log-group) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cloudwatch-log-group)) #:http.request.field{:name "CloudwatchLogGroup", :shape "String"})) (clojure.core/contains? input :cloudwatch-log-stream) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cloudwatch-log-stream)) #:http.request.field{:name "CloudwatchLogStream", :shape "String"}))))

(clojure.core/defn- ser-allocation-strategy [input] #:http.request.field{:value (clojure.core/get {"lowestPrice" "lowestPrice", :lowest-price "lowestPrice", "diversified" "diversified", :diversified "diversified"} input), :shape "AllocationStrategy"})

(clojure.core/defn- ser-attribute-value [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AttributeValue", :type "structure"} (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "Value", :shape "String", :location-name "value"}))))

(clojure.core/defn- ser-private-ip-address-specification-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-private-ip-address-specification coll) #:http.request.field{:shape "PrivateIpAddressSpecification", :location-name "item"}))) input), :shape "PrivateIpAddressSpecificationList", :type "list"})

(clojure.core/defn- ser-auto-placement [input] #:http.request.field{:value (clojure.core/get {"on" "on", :on "on", "off" "off", :off "off"} input), :shape "AutoPlacement"})

(clojure.core/defn- ser-launch-template-tag-specification-request-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-launch-template-tag-specification-request coll) #:http.request.field{:shape "LaunchTemplateTagSpecificationRequest", :location-name "LaunchTemplateTagSpecificationRequest"}))) input), :shape "LaunchTemplateTagSpecificationRequestList", :type "list"})

(clojure.core/defn- ser-prefix-list-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-prefix-list-id coll) #:http.request.field{:shape "PrefixListId", :location-name "item"}))) input), :shape "PrefixListIdList", :type "list"})

(clojure.core/defn- ser-auto-accept-shared-attachments-value [input] #:http.request.field{:value (clojure.core/get {"enable" "enable", :enable "enable", "disable" "disable", :disable "disable"} input), :shape "AutoAcceptSharedAttachmentsValue"})

(clojure.core/defn- ser-vpc-attribute-name [input] #:http.request.field{:value (clojure.core/get {"enableDnsSupport" "enableDnsSupport", :enable-dns-support "enableDnsSupport", "enableDnsHostnames" "enableDnsHostnames", :enable-dns-hostnames "enableDnsHostnames"} input), :shape "VpcAttributeName"})

(clojure.core/defn- ser-instance-block-device-mapping-specification-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-block-device-mapping-specification coll) #:http.request.field{:shape "InstanceBlockDeviceMappingSpecification", :location-name "item"}))) input), :shape "InstanceBlockDeviceMappingSpecificationList", :type "list"})

(clojure.core/defn- ser-load-permission-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LoadPermissionRequest", :type "structure"} (clojure.core/contains? input :group) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-permission-group (input :group)) #:http.request.field{:name "Group", :shape "PermissionGroup"})) (clojure.core/contains? input :user-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :user-id)) #:http.request.field{:name "UserId", :shape "String"}))))

(clojure.core/defn- ser-describe-instance-credit-specifications-max-results [input] #:http.request.field{:value input, :shape "DescribeInstanceCreditSpecificationsMaxResults"})

(clojure.core/defn- ser-fpga-image-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "FpgaImageIdList", :type "list"})

(clojure.core/defn- ser-placement-strategy [input] #:http.request.field{:value (clojure.core/get {"cluster" "cluster", :cluster "cluster", "spread" "spread", :spread "spread", "partition" "partition", :partition "partition"} input), :shape "PlacementStrategy"})

(clojure.core/defn- ser-user-group-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "UserGroup"}))) input), :shape "UserGroupStringList", :type "list"})

(clojure.core/defn- ser-scheduled-instances-ebs [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ScheduledInstancesEbs", :type "structure"} (clojure.core/contains? input :delete-on-termination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :delete-on-termination)) #:http.request.field{:name "DeleteOnTermination", :shape "Boolean"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "Boolean"})) (clojure.core/contains? input :iops) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :iops)) #:http.request.field{:name "Iops", :shape "Integer"})) (clojure.core/contains? input :snapshot-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "String"})) (clojure.core/contains? input :volume-size) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :volume-size)) #:http.request.field{:name "VolumeSize", :shape "Integer"})) (clojure.core/contains? input :volume-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :volume-type)) #:http.request.field{:name "VolumeType", :shape "String"}))))

(clojure.core/defn- ser-target-configuration-request-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-configuration-request coll) #:http.request.field{:shape "TargetConfigurationRequest", :location-name "TargetConfigurationRequest"}))) input), :shape "TargetConfigurationRequestSet", :type "list"})

(clojure.core/defn- ser-instance-interruption-behavior [input] #:http.request.field{:value (clojure.core/get {"hibernate" "hibernate", :hibernate "hibernate", "stop" "stop", :stop "stop", "terminate" "terminate", :terminate "terminate"} input), :shape "InstanceInterruptionBehavior"})

(clojure.core/defn- ser-volume-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "VolumeId"}))) input), :shape "VolumeIdStringList", :type "list"})

(clojure.core/defn- ser-dhcp-options-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "DhcpOptionsId"}))) input), :shape "DhcpOptionsIdStringList", :type "list"})

(clojure.core/defn- ser-dns-servers-options-modify-structure [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DnsServersOptionsModifyStructure", :type "structure"} (clojure.core/contains? input :custom-dns-servers) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :custom-dns-servers)) #:http.request.field{:name "CustomDnsServers", :shape "ValueStringList"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "Boolean"}))))

(clojure.core/defn- serscope [input] #:http.request.field{:value (clojure.core/get {"Availability Zone" "Availability Zone", :availability-zone "Availability Zone", "Region" "Region", :region "Region"} input), :shape "scope"})

(clojure.core/defn- ser-reset-image-attribute-name [input] #:http.request.field{:value (clojure.core/get {"launchPermission" "launchPermission", :launch-permission "launchPermission"} input), :shape "ResetImageAttributeName"})

(clojure.core/defn- ser-instance-match-criteria [input] #:http.request.field{:value (clojure.core/get {"open" "open", :open "open", "targeted" "targeted", :targeted "targeted"} input), :shape "InstanceMatchCriteria"})

(clojure.core/defn- ser-scheduled-instances-launch-specification [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:image-id input)) #:http.request.field{:name "ImageId", :shape "String"})], :shape "ScheduledInstancesLaunchSpecification", :type "structure"} (clojure.core/contains? input :kernel-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kernel-id)) #:http.request.field{:name "KernelId", :shape "String"})) (clojure.core/contains? input :security-group-ids) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-scheduled-instances-security-group-id-set (input :security-group-ids)) #:http.request.field{:name "SecurityGroupIds", :shape "ScheduledInstancesSecurityGroupIdSet", :location-name "SecurityGroupId"})) (clojure.core/contains? input :placement) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-scheduled-instances-placement (input :placement)) #:http.request.field{:name "Placement", :shape "ScheduledInstancesPlacement"})) (clojure.core/contains? input :subnet-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String"})) (clojure.core/contains? input :ebs-optimized) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :ebs-optimized)) #:http.request.field{:name "EbsOptimized", :shape "Boolean"})) (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "String"})) (clojure.core/contains? input :key-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key-name)) #:http.request.field{:name "KeyName", :shape "String"})) (clojure.core/contains? input :monitoring) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-scheduled-instances-monitoring (input :monitoring)) #:http.request.field{:name "Monitoring", :shape "ScheduledInstancesMonitoring"})) (clojure.core/contains? input :block-device-mappings) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-scheduled-instances-block-device-mapping-set (input :block-device-mappings)) #:http.request.field{:name "BlockDeviceMappings", :shape "ScheduledInstancesBlockDeviceMappingSet", :location-name "BlockDeviceMapping"})) (clojure.core/contains? input :ramdisk-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ramdisk-id)) #:http.request.field{:name "RamdiskId", :shape "String"})) (clojure.core/contains? input :user-data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :user-data)) #:http.request.field{:name "UserData", :shape "String"})) (clojure.core/contains? input :iam-instance-profile) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-scheduled-instances-iam-instance-profile (input :iam-instance-profile)) #:http.request.field{:name "IamInstanceProfile", :shape "ScheduledInstancesIamInstanceProfile"})) (clojure.core/contains? input :network-interfaces) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-scheduled-instances-network-interface-set (input :network-interfaces)) #:http.request.field{:name "NetworkInterfaces", :shape "ScheduledInstancesNetworkInterfaceSet", :location-name "NetworkInterface"}))))

(clojure.core/defn- ser-product-description-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "ProductDescriptionList", :type "list"})

(clojure.core/defn- ser-fleet-id-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-fleet-identifier coll) #:http.request.field{:shape "FleetIdentifier"}))) input), :shape "FleetIdSet", :type "list"})

(clojure.core/defn- ser-vpn-tunnel-options-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "VpnTunnelOptionsSpecification", :type "structure"} (clojure.core/contains? input :tunnel-inside-cidr) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :tunnel-inside-cidr)) #:http.request.field{:name "TunnelInsideCidr", :shape "String"})) (clojure.core/contains? input :pre-shared-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :pre-shared-key)) #:http.request.field{:name "PreSharedKey", :shape "String"}))))

(clojure.core/defn- ser-group-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "groupId"}))) input), :shape "GroupIdStringList", :type "list"})

(clojure.core/defn- ser-snapshot-disk-container [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SnapshotDiskContainer", :type "structure"} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :format) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :format)) #:http.request.field{:name "Format", :shape "String"})) (clojure.core/contains? input :url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :url)) #:http.request.field{:name "Url", :shape "String"})) (clojure.core/contains? input :user-bucket) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-bucket (input :user-bucket)) #:http.request.field{:name "UserBucket", :shape "UserBucket"}))))

(clojure.core/defn- ser-instance-credit-specification-list-request [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-credit-specification-request coll) #:http.request.field{:shape "InstanceCreditSpecificationRequest", :location-name "item"}))) input), :shape "InstanceCreditSpecificationListRequest", :type "list"})

(clojure.core/defn- ser-log-destination-type [input] #:http.request.field{:value (clojure.core/get {"cloud-watch-logs" "cloud-watch-logs", :cloudwatchlogs "cloud-watch-logs", "s3" "s3", :s-3 "s3"} input), :shape "LogDestinationType"})

(clojure.core/defn- ser-launch-specs-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-spot-fleet-launch-specification coll) #:http.request.field{:shape "SpotFleetLaunchSpecification", :location-name "item"}))) input), :shape "LaunchSpecsList", :type "list"})

(clojure.core/defn- ser-launch-template-ebs-block-device-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateEbsBlockDeviceRequest", :type "structure"} (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "Boolean"})) (clojure.core/contains? input :delete-on-termination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :delete-on-termination)) #:http.request.field{:name "DeleteOnTermination", :shape "Boolean"})) (clojure.core/contains? input :iops) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :iops)) #:http.request.field{:name "Iops", :shape "Integer"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :snapshot-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "String"})) (clojure.core/contains? input :volume-size) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :volume-size)) #:http.request.field{:name "VolumeSize", :shape "Integer"})) (clojure.core/contains? input :volume-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-volume-type (input :volume-type)) #:http.request.field{:name "VolumeType", :shape "VolumeType"}))))

(clojure.core/defn- ser-launch-template-elastic-inference-accelerator [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:type input)) #:http.request.field{:name "Type", :shape "String"})], :shape "LaunchTemplateElasticInferenceAccelerator", :type "structure"}))

(clojure.core/defn- ser-load-balancers-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LoadBalancersConfig", :type "structure"} (clojure.core/contains? input :classic-load-balancers-config) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-classic-load-balancers-config (input :classic-load-balancers-config)) #:http.request.field{:name "ClassicLoadBalancersConfig", :shape "ClassicLoadBalancersConfig", :location-name "classicLoadBalancersConfig"})) (clojure.core/contains? input :target-groups-config) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-groups-config (input :target-groups-config)) #:http.request.field{:name "TargetGroupsConfig", :shape "TargetGroupsConfig", :location-name "targetGroupsConfig"}))))

(clojure.core/defn- ser-integer [input] #:http.request.field{:value input, :shape "Integer"})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-classic-load-balancer [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ClassicLoadBalancer", :type "structure"} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String", :location-name "name"}))))

(clojure.core/defn- ser-ip-permission [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "IpPermission", :type "structure"} (clojure.core/contains? input :from-port) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :from-port)) #:http.request.field{:name "FromPort", :shape "Integer", :location-name "fromPort"})) (clojure.core/contains? input :ip-protocol) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ip-protocol)) #:http.request.field{:name "IpProtocol", :shape "String", :location-name "ipProtocol"})) (clojure.core/contains? input :ip-ranges) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ip-range-list (input :ip-ranges)) #:http.request.field{:name "IpRanges", :shape "IpRangeList", :location-name "ipRanges"})) (clojure.core/contains? input :ipv-6-ranges) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ipv-6-range-list (input :ipv-6-ranges)) #:http.request.field{:name "Ipv6Ranges", :shape "Ipv6RangeList", :location-name "ipv6Ranges"})) (clojure.core/contains? input :prefix-list-ids) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-prefix-list-id-list (input :prefix-list-ids)) #:http.request.field{:name "PrefixListIds", :shape "PrefixListIdList", :location-name "prefixListIds"})) (clojure.core/contains? input :to-port) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :to-port)) #:http.request.field{:name "ToPort", :shape "Integer", :location-name "toPort"})) (clojure.core/contains? input :user-id-group-pairs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-id-group-pair-list (input :user-id-group-pairs)) #:http.request.field{:name "UserIdGroupPairs", :shape "UserIdGroupPairList", :location-name "groups"}))))

(clojure.core/defn- ser-ip-permission-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-ip-permission coll) #:http.request.field{:shape "IpPermission", :location-name "item"}))) input), :shape "IpPermissionList", :type "list"})

(clojure.core/defn- ser-slot-date-time-range-request [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-date-time (:earliest-time input)) #:http.request.field{:name "EarliestTime", :shape "DateTime"}) (clojure.core/into (ser-date-time (:latest-time input)) #:http.request.field{:name "LatestTime", :shape "DateTime"})], :shape "SlotDateTimeRangeRequest", :type "structure"}))

(clojure.core/defn- ser-launch-template-license-specification-list-request [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-launch-template-license-configuration-request coll) #:http.request.field{:shape "LaunchTemplateLicenseConfigurationRequest", :location-name "item"}))) input), :shape "LaunchTemplateLicenseSpecificationListRequest", :type "list"})

(clojure.core/defn- ser-ri-product-description [input] #:http.request.field{:value (clojure.core/get {"Linux/UNIX" "Linux/UNIX", :linux-unix "Linux/UNIX", "Linux/UNIX (Amazon VPC)" "Linux/UNIX (Amazon VPC)", :linux-unix-amazon-vpc "Linux/UNIX (Amazon VPC)", "Windows" "Windows", :windows "Windows", "Windows (Amazon VPC)" "Windows (Amazon VPC)", :windows-amazon-vpc "Windows (Amazon VPC)"} input), :shape "RIProductDescription"})

(clojure.core/defn- ser-transit-gateway-route-table-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "TransitGatewayRouteTableIdStringList", :type "list"})

(clojure.core/defn- ser-describe-vpc-peering-connections-max-results [input] #:http.request.field{:value input, :shape "DescribeVpcPeeringConnectionsMaxResults"})

(clojure.core/defn- ser-default-route-table-propagation-value [input] #:http.request.field{:value (clojure.core/get {"enable" "enable", :enable "enable", "disable" "disable", :disable "disable"} input), :shape "DefaultRouteTablePropagationValue"})

(clojure.core/defn- ser-reserved-instance-id-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ReservedInstanceId"}))) input), :shape "ReservedInstanceIdSet", :type "list"})

(clojure.core/defn- ser-launch-template-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateConfig", :type "structure"} (clojure.core/contains? input :launch-template-specification) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fleet-launch-template-specification (input :launch-template-specification)) #:http.request.field{:name "LaunchTemplateSpecification", :shape "FleetLaunchTemplateSpecification", :location-name "launchTemplateSpecification"})) (clojure.core/contains? input :overrides) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-overrides-list (input :overrides)) #:http.request.field{:name "Overrides", :shape "LaunchTemplateOverridesList", :location-name "overrides"}))))

(clojure.core/defn- ser-disk-image-format [input] #:http.request.field{:value (clojure.core/get {"VMDK" "VMDK", :vmdk "VMDK", "RAW" "RAW", :raw "RAW", "VHD" "VHD", :vhd "VHD"} input), :shape "DiskImageFormat"})

(clojure.core/defn- ser-scheduled-instances-network-interface-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-scheduled-instances-network-interface coll) #:http.request.field{:shape "ScheduledInstancesNetworkInterface", :location-name "NetworkInterface"}))) input), :shape "ScheduledInstancesNetworkInterfaceSet", :type "list"})

(clojure.core/defn- ser-security-group-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SecurityGroupId"}))) input), :shape "SecurityGroupIdStringList", :type "list"})

(clojure.core/defn- ser-domain-type [input] #:http.request.field{:value (clojure.core/get {"vpc" "vpc", :vpc "vpc", "standard" "standard", :standard "standard"} input), :shape "DomainType"})

(clojure.core/defn- ser-launch-template-name [input] #:http.request.field{:value input, :shape "LaunchTemplateName"})

(clojure.core/defn- ser-flow-logs-resource-type [input] #:http.request.field{:value (clojure.core/get {"VPC" "VPC", :vpc "VPC", "Subnet" "Subnet", :subnet "Subnet", "NetworkInterface" "NetworkInterface", :network-interface "NetworkInterface"} input), :shape "FlowLogsResourceType"})

(clojure.core/defn- ser-fleet-launch-template-overrides-list-request [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-fleet-launch-template-overrides-request coll) #:http.request.field{:shape "FleetLaunchTemplateOverridesRequest", :location-name "item"}))) input), :shape "FleetLaunchTemplateOverridesListRequest", :type "list", :max 50})

(clojure.core/defn- ser-resource-type [input] #:http.request.field{:value (clojure.core/get {:networkacl "network-acl", :vpcpeeringconnection "vpc-peering-connection", :dedicatedhost "dedicated-host", :natgateway "natgateway", "vpn-gateway" "vpn-gateway", "subnet" "subnet", :transitgatewayattachment "transit-gateway-attachment", "transit-gateway" "transit-gateway", :dhcpoptions "dhcp-options", "vpc" "vpc", "elastic-ip" "elastic-ip", "dedicated-host" "dedicated-host", "spot-instances-request" "spot-instances-request", :instance "instance", :elasticip "elastic-ip", :launchtemplate "launch-template", "route-table" "route-table", "image" "image", "natgateway" "natgateway", :securitygroup "security-group", :vpngateway "vpn-gateway", "transit-gateway-route-table" "transit-gateway-route-table", :routetable "route-table", "snapshot" "snapshot", "vpn-connection" "vpn-connection", :reservedinstances "reserved-instances", :fpgaimage "fpga-image", :volume "volume", "internet-gateway" "internet-gateway", :vpnconnection "vpn-connection", :snapshot "snapshot", "reserved-instances" "reserved-instances", :fleet "fleet", "instance" "instance", :vpc "vpc", "fleet" "fleet", :spotinstancesrequest "spot-instances-request", "network-interface" "network-interface", "security-group" "security-group", :clientvpnendpoint "client-vpn-endpoint", "volume" "volume", "dhcp-options" "dhcp-options", :image "image", :networkinterface "network-interface", "vpc-peering-connection" "vpc-peering-connection", "customer-gateway" "customer-gateway", "fpga-image" "fpga-image", :transitgateway "transit-gateway", :transitgatewayroutetable "transit-gateway-route-table", :customergateway "customer-gateway", :subnet "subnet", "network-acl" "network-acl", "client-vpn-endpoint" "client-vpn-endpoint", :internetgateway "internet-gateway", "launch-template" "launch-template", "transit-gateway-attachment" "transit-gateway-attachment"} input), :shape "ResourceType"})

(clojure.core/defn- ser-ipv-6-address-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "Ipv6AddressList", :type "list"})

(clojure.core/defn- ser-resource-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "ResourceList", :type "list"})

(clojure.core/defn- ser-operation-type [input] #:http.request.field{:value (clojure.core/get {"add" "add", :add "add", "remove" "remove", :remove "remove"} input), :shape "OperationType"})

(clojure.core/defn- ser-fleet-on-demand-allocation-strategy [input] #:http.request.field{:value (clojure.core/get {"lowest-price" "lowest-price", :lowestprice "lowest-price", "prioritized" "prioritized", :prioritized "prioritized"} input), :shape "FleetOnDemandAllocationStrategy"})

(clojure.core/defn- ser-launch-template-elastic-inference-accelerator-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-launch-template-elastic-inference-accelerator coll) #:http.request.field{:shape "LaunchTemplateElasticInferenceAccelerator", :location-name "item"}))) input), :shape "LaunchTemplateElasticInferenceAcceleratorList", :type "list"})

(clojure.core/defn- ser-snapshot-attribute-name [input] #:http.request.field{:value (clojure.core/get {"productCodes" "productCodes", :product-codes "productCodes", "createVolumePermission" "createVolumePermission", :create-volume-permission "createVolumePermission"} input), :shape "SnapshotAttributeName"})

(clojure.core/defn- ser-currency-code-values [input] #:http.request.field{:value (clojure.core/get {"USD" "USD", :usd "USD"} input), :shape "CurrencyCodeValues"})

(clojure.core/defn- ser-network-interface-attribute [input] #:http.request.field{:value (clojure.core/get {"description" "description", :description "description", "groupSet" "groupSet", :group-set "groupSet", "sourceDestCheck" "sourceDestCheck", :source-dest-check "sourceDestCheck", "attachment" "attachment", :attachment "attachment"} input), :shape "NetworkInterfaceAttribute"})

(clojure.core/defn- ser-license-configuration-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LicenseConfigurationRequest", :type "structure"} (clojure.core/contains? input :license-configuration-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :license-configuration-arn)) #:http.request.field{:name "LicenseConfigurationArn", :shape "String"}))))

(clojure.core/defn- ser-report-instance-reason-codes [input] #:http.request.field{:value (clojure.core/get {"password-not-available" "password-not-available", "performance-instance-store" "performance-instance-store", :other "other", :performancenetwork "performance-network", :performanceebsvolume "performance-ebs-volume", "not-accepting-credentials" "not-accepting-credentials", "unresponsive" "unresponsive", :performanceother "performance-other", :passwordnotavailable "password-not-available", "other" "other", "performance-ebs-volume" "performance-ebs-volume", :notacceptingcredentials "not-accepting-credentials", "instance-stuck-in-state" "instance-stuck-in-state", :performanceinstancestore "performance-instance-store", "performance-network" "performance-network", :instancestuckinstate "instance-stuck-in-state", :unresponsive "unresponsive", "performance-other" "performance-other"} input), :shape "ReportInstanceReasonCodes"})

(clojure.core/defn- ser-billing-product-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "BillingProductList", :type "list"})

(clojure.core/defn- ser-bundle-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "BundleId"}))) input), :shape "BundleIdStringList", :type "list"})

(clojure.core/defn- ser-egress-only-internet-gateway-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-egress-only-internet-gateway-id coll) #:http.request.field{:shape "EgressOnlyInternetGatewayId", :location-name "item"}))) input), :shape "EgressOnlyInternetGatewayIdList", :type "list"})

(clojure.core/defn- ser-volume-type [input] #:http.request.field{:value (clojure.core/get {"standard" "standard", "sc1" "sc1", "io1" "io1", :sc-1 "sc1", :st-1 "st1", "gp2" "gp2", "st1" "st1", :io-1 "io1", :standard "standard", :gp-2 "gp2"} input), :shape "VolumeType"})

(clojure.core/defn- ser-account-attribute-name-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-account-attribute-name coll) #:http.request.field{:shape "AccountAttributeName", :location-name "attributeName"}))) input), :shape "AccountAttributeNameStringList", :type "list"})

(clojure.core/defn- ser-target-capacity-specification-request [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-integer (:total-target-capacity input)) #:http.request.field{:name "TotalTargetCapacity", :shape "Integer"})], :shape "TargetCapacitySpecificationRequest", :type "structure"} (clojure.core/contains? input :on-demand-target-capacity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :on-demand-target-capacity)) #:http.request.field{:name "OnDemandTargetCapacity", :shape "Integer"})) (clojure.core/contains? input :spot-target-capacity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :spot-target-capacity)) #:http.request.field{:name "SpotTargetCapacity", :shape "Integer"})) (clojure.core/contains? input :default-target-capacity-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-default-target-capacity-type (input :default-target-capacity-type)) #:http.request.field{:name "DefaultTargetCapacityType", :shape "DefaultTargetCapacityType"}))))

(clojure.core/defn- ser-tunnel-options-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-vpn-tunnel-options-specification coll) #:http.request.field{:shape "VpnTunnelOptionsSpecification", :location-name "item"}))) input), :shape "TunnelOptionsList", :type "list"})

(clojure.core/defn- ser-vpn-ecmp-support-value [input] #:http.request.field{:value (clojure.core/get {"enable" "enable", :enable "enable", "disable" "disable", :disable "disable"} input), :shape "VpnEcmpSupportValue"})

(clojure.core/defn- ser-launch-permission-modifications [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchPermissionModifications", :type "structure"} (clojure.core/contains? input :add) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-permission-list (input :add)) #:http.request.field{:name "Add", :shape "LaunchPermissionList"})) (clojure.core/contains? input :remove) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-permission-list (input :remove)) #:http.request.field{:name "Remove", :shape "LaunchPermissionList"}))))

(clojure.core/defn- ser-classic-load-balancers-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ClassicLoadBalancersConfig", :type "structure"} (clojure.core/contains? input :classic-load-balancers) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-classic-load-balancers (input :classic-load-balancers)) #:http.request.field{:name "ClassicLoadBalancers", :shape "ClassicLoadBalancers", :location-name "classicLoadBalancers"}))))

(clojure.core/defn- ser-dns-support-value [input] #:http.request.field{:value (clojure.core/get {"enable" "enable", :enable "enable", "disable" "disable", :disable "disable"} input), :shape "DnsSupportValue"})

(clojure.core/defn- ser-tag-specification-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag-specification coll) #:http.request.field{:shape "TagSpecification", :location-name "item"}))) input), :shape "TagSpecificationList", :type "list"})

(clojure.core/defn- ser-long [input] #:http.request.field{:value input, :shape "Long"})

(clojure.core/defn- ser-capacity-reservation-target [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CapacityReservationTarget", :type "structure"} (clojure.core/contains? input :capacity-reservation-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :capacity-reservation-id)) #:http.request.field{:name "CapacityReservationId", :shape "String"}))))

(clojure.core/defn- ser-transit-gateway-max-results [input] #:http.request.field{:value input, :shape "TransitGatewayMaxResults"})

(clojure.core/defn- ser-subnet-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SubnetId"}))) input), :shape "SubnetIdStringList", :type "list"})

(clojure.core/defn- ser-reserved-instance-limit-price [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ReservedInstanceLimitPrice", :type "structure"} (clojure.core/contains? input :amount) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :amount)) #:http.request.field{:name "Amount", :shape "Double", :location-name "amount"})) (clojure.core/contains? input :currency-code) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-currency-code-values (input :currency-code)) #:http.request.field{:name "CurrencyCode", :shape "CurrencyCodeValues", :location-name "currencyCode"}))))

(clojure.core/defn- ser-tag-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "TagSpecification", :type "structure"} (clojure.core/contains? input :resource-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ResourceType", :location-name "resourceType"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList", :location-name "Tag"}))))

(clojure.core/defn- ser-region-name-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "RegionName"}))) input), :shape "RegionNameStringList", :type "list"})

(clojure.core/defn- ser-scheduled-instance-recurrence-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ScheduledInstanceRecurrenceRequest", :type "structure"} (clojure.core/contains? input :frequency) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :frequency)) #:http.request.field{:name "Frequency", :shape "String"})) (clojure.core/contains? input :interval) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :interval)) #:http.request.field{:name "Interval", :shape "Integer"})) (clojure.core/contains? input :occurrence-days) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-occurrence-day-request-set (input :occurrence-days)) #:http.request.field{:name "OccurrenceDays", :shape "OccurrenceDayRequestSet", :location-name "OccurrenceDay"})) (clojure.core/contains? input :occurrence-relative-to-end) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :occurrence-relative-to-end)) #:http.request.field{:name "OccurrenceRelativeToEnd", :shape "Boolean"})) (clojure.core/contains? input :occurrence-unit) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :occurrence-unit)) #:http.request.field{:name "OccurrenceUnit", :shape "String"}))))

(clojure.core/defn- ser-version-description [input] #:http.request.field{:value input, :shape "VersionDescription"})

(clojure.core/defn- ser-user-bucket [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "UserBucket", :type "structure"} (clojure.core/contains? input :s-3-bucket) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :s-3-bucket)) #:http.request.field{:name "S3Bucket", :shape "String"})) (clojure.core/contains? input :s-3-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :s-3-key)) #:http.request.field{:name "S3Key", :shape "String"}))))

(clojure.core/defn- ser-scheduled-instances-network-interface [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ScheduledInstancesNetworkInterface", :type "structure"} (clojure.core/contains? input :associate-public-ip-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :associate-public-ip-address)) #:http.request.field{:name "AssociatePublicIpAddress", :shape "Boolean"})) (clojure.core/contains? input :private-ip-address-configs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-private-ip-address-config-set (input :private-ip-address-configs)) #:http.request.field{:name "PrivateIpAddressConfigs", :shape "PrivateIpAddressConfigSet", :location-name "PrivateIpAddressConfig"})) (clojure.core/contains? input :ipv-6-addresses) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-scheduled-instances-ipv-6-address-list (input :ipv-6-addresses)) #:http.request.field{:name "Ipv6Addresses", :shape "ScheduledInstancesIpv6AddressList", :location-name "Ipv6Address"})) (clojure.core/contains? input :subnet-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String"})) (clojure.core/contains? input :network-interface-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String"})) (clojure.core/contains? input :device-index) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :device-index)) #:http.request.field{:name "DeviceIndex", :shape "Integer"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-scheduled-instances-security-group-id-set (input :groups)) #:http.request.field{:name "Groups", :shape "ScheduledInstancesSecurityGroupIdSet", :location-name "Group"})) (clojure.core/contains? input :delete-on-termination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :delete-on-termination)) #:http.request.field{:name "DeleteOnTermination", :shape "Boolean"})) (clojure.core/contains? input :secondary-private-ip-address-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :secondary-private-ip-address-count)) #:http.request.field{:name "SecondaryPrivateIpAddressCount", :shape "Integer"})) (clojure.core/contains? input :private-ip-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-ip-address)) #:http.request.field{:name "PrivateIpAddress", :shape "String"})) (clojure.core/contains? input :ipv-6-address-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :ipv-6-address-count)) #:http.request.field{:name "Ipv6AddressCount", :shape "Integer"}))))

(clojure.core/defn- ser-default-target-capacity-type [input] #:http.request.field{:value (clojure.core/get {"spot" "spot", :spot "spot", "on-demand" "on-demand", :ondemand "on-demand"} input), :shape "DefaultTargetCapacityType"})

(clojure.core/defn- ser-target-configuration-request [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:offering-id input)) #:http.request.field{:name "OfferingId", :shape "String"})], :shape "TargetConfigurationRequest", :type "structure"} (clojure.core/contains? input :instance-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :instance-count)) #:http.request.field{:name "InstanceCount", :shape "Integer"}))))

(clojure.core/defn- ser-reserved-instances-configuration-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-reserved-instances-configuration coll) #:http.request.field{:shape "ReservedInstancesConfiguration", :location-name "item"}))) input), :shape "ReservedInstancesConfigurationList", :type "list"})

(clojure.core/defn- ser-capacity-reservation-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CapacityReservationSpecification", :type "structure"} (clojure.core/contains? input :capacity-reservation-preference) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-capacity-reservation-preference (input :capacity-reservation-preference)) #:http.request.field{:name "CapacityReservationPreference", :shape "CapacityReservationPreference"})) (clojure.core/contains? input :capacity-reservation-target) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-capacity-reservation-target (input :capacity-reservation-target)) #:http.request.field{:name "CapacityReservationTarget", :shape "CapacityReservationTarget"}))))

(clojure.core/defn- ser-instance-network-interface-specification-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-network-interface-specification coll) #:http.request.field{:shape "InstanceNetworkInterfaceSpecification", :location-name "item"}))) input), :shape "InstanceNetworkInterfaceSpecificationList", :type "list"})

(clojure.core/defn- ser-block-device-mapping [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "BlockDeviceMapping", :type "structure"} (clojure.core/contains? input :device-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :device-name)) #:http.request.field{:name "DeviceName", :shape "String", :location-name "deviceName"})) (clojure.core/contains? input :virtual-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :virtual-name)) #:http.request.field{:name "VirtualName", :shape "String", :location-name "virtualName"})) (clojure.core/contains? input :ebs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ebs-block-device (input :ebs)) #:http.request.field{:name "Ebs", :shape "EbsBlockDevice", :location-name "ebs"})) (clojure.core/contains? input :no-device) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :no-device)) #:http.request.field{:name "NoDevice", :shape "String", :location-name "noDevice"}))))

(clojure.core/defn- ser-max-results [input] #:http.request.field{:value input, :shape "MaxResults"})

(clojure.core/defn- ser-tag [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Tag", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key)) #:http.request.field{:name "Key", :shape "String", :location-name "key"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "Value", :shape "String", :location-name "value"}))))

(clojure.core/defn- ser-spot-fleet-tag-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SpotFleetTagSpecification", :type "structure"} (clojure.core/contains? input :resource-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ResourceType", :location-name "resourceType"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList", :location-name "tag"}))))

(clojure.core/defn- ser-user-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "UserId"}))) input), :shape "UserIdStringList", :type "list"})

(clojure.core/defn- ser-executable-by-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ExecutableBy"}))) input), :shape "ExecutableByStringList", :type "list"})

(clojure.core/defn- ser-launch-template-name-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-launch-template-name coll) #:http.request.field{:shape "LaunchTemplateName", :location-name "item"}))) input), :shape "LaunchTemplateNameStringList", :type "list"})

(clojure.core/defn- ser-instance-market-options-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "InstanceMarketOptionsRequest", :type "structure"} (clojure.core/contains? input :market-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-market-type (input :market-type)) #:http.request.field{:name "MarketType", :shape "MarketType"})) (clojure.core/contains? input :spot-options) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-market-options (input :spot-options)) #:http.request.field{:name "SpotOptions", :shape "SpotMarketOptions"}))))

(clojure.core/defn- ser-platform-values [input] #:http.request.field{:value (clojure.core/get {"Windows" "Windows", :windows "Windows"} input), :shape "PlatformValues"})

(clojure.core/defn- ser-disk-image [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DiskImage", :type "structure"} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :image) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-disk-image-detail (input :image)) #:http.request.field{:name "Image", :shape "DiskImageDetail"})) (clojure.core/contains? input :volume) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-volume-detail (input :volume)) #:http.request.field{:name "Volume", :shape "VolumeDetail"}))))

(clojure.core/defn- ser-port-range [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PortRange", :type "structure"} (clojure.core/contains? input :from) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :from)) #:http.request.field{:name "From", :shape "Integer", :location-name "from"})) (clojure.core/contains? input :to) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :to)) #:http.request.field{:name "To", :shape "Integer", :location-name "to"}))))

(clojure.core/defn- ser-client-vpn-authentication-request-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-client-vpn-authentication-request coll) #:http.request.field{:shape "ClientVpnAuthenticationRequest"}))) input), :shape "ClientVpnAuthenticationRequestList", :type "list"})

(clojure.core/defn- ser-spot-fleet-launch-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SpotFleetLaunchSpecification", :type "structure"} (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-fleet-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "SpotFleetTagSpecificationList", :location-name "tagSpecificationSet"})) (clojure.core/contains? input :kernel-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kernel-id)) #:http.request.field{:name "KernelId", :shape "String", :location-name "kernelId"})) (clojure.core/contains? input :image-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-id)) #:http.request.field{:name "ImageId", :shape "String", :location-name "imageId"})) (clojure.core/contains? input :placement) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-placement (input :placement)) #:http.request.field{:name "Placement", :shape "SpotPlacement", :location-name "placement"})) (clojure.core/contains? input :addressing-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :addressing-type)) #:http.request.field{:name "AddressingType", :shape "String", :location-name "addressingType"})) (clojure.core/contains? input :subnet-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String", :location-name "subnetId"})) (clojure.core/contains? input :security-groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-group-identifier-list (input :security-groups)) #:http.request.field{:name "SecurityGroups", :shape "GroupIdentifierList", :location-name "groupSet"})) (clojure.core/contains? input :ebs-optimized) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :ebs-optimized)) #:http.request.field{:name "EbsOptimized", :shape "Boolean", :location-name "ebsOptimized"})) (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-type (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "InstanceType", :location-name "instanceType"})) (clojure.core/contains? input :key-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key-name)) #:http.request.field{:name "KeyName", :shape "String", :location-name "keyName"})) (clojure.core/contains? input :spot-price) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :spot-price)) #:http.request.field{:name "SpotPrice", :shape "String", :location-name "spotPrice"})) (clojure.core/contains? input :monitoring) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-fleet-monitoring (input :monitoring)) #:http.request.field{:name "Monitoring", :shape "SpotFleetMonitoring", :location-name "monitoring"})) (clojure.core/contains? input :weighted-capacity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :weighted-capacity)) #:http.request.field{:name "WeightedCapacity", :shape "Double", :location-name "weightedCapacity"})) (clojure.core/contains? input :block-device-mappings) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-block-device-mapping-list (input :block-device-mappings)) #:http.request.field{:name "BlockDeviceMappings", :shape "BlockDeviceMappingList", :location-name "blockDeviceMapping"})) (clojure.core/contains? input :ramdisk-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ramdisk-id)) #:http.request.field{:name "RamdiskId", :shape "String", :location-name "ramdiskId"})) (clojure.core/contains? input :user-data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :user-data)) #:http.request.field{:name "UserData", :shape "String", :location-name "userData"})) (clojure.core/contains? input :iam-instance-profile) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-instance-profile-specification (input :iam-instance-profile)) #:http.request.field{:name "IamInstanceProfile", :shape "IamInstanceProfileSpecification", :location-name "iamInstanceProfile"})) (clojure.core/contains? input :network-interfaces) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-network-interface-specification-list (input :network-interfaces)) #:http.request.field{:name "NetworkInterfaces", :shape "InstanceNetworkInterfaceSpecificationList", :location-name "networkInterfaceSet"}))))

(clojure.core/defn- ser-ip-range [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "IpRange", :type "structure"} (clojure.core/contains? input :cidr-ip) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidr-ip)) #:http.request.field{:name "CidrIp", :shape "String", :location-name "cidrIp"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"}))))

(clojure.core/defn- ser-version-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "VersionStringList", :type "list"})

(clojure.core/defn- ser-block-device-mapping-request-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-block-device-mapping coll) #:http.request.field{:shape "BlockDeviceMapping", :location-name "BlockDeviceMapping"}))) input), :shape "BlockDeviceMappingRequestList", :type "list"})

(clojure.core/defn- ser-container-format [input] #:http.request.field{:value (clojure.core/get {"ova" "ova", :ova "ova"} input), :shape "ContainerFormat"})

(clojure.core/defn- ser-purchase-request-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-purchase-request coll) #:http.request.field{:shape "PurchaseRequest", :location-name "PurchaseRequest"}))) input), :shape "PurchaseRequestSet", :type "list", :min 1})

(clojure.core/defn- ser-new-dhcp-configuration-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-new-dhcp-configuration coll) #:http.request.field{:shape "NewDhcpConfiguration", :location-name "item"}))) input), :shape "NewDhcpConfigurationList", :type "list"})

(clojure.core/defn- ser-market-type [input] #:http.request.field{:value (clojure.core/get {"spot" "spot", :spot "spot"} input), :shape "MarketType"})

(clojure.core/defn- ser-fleet-launch-template-specification-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "FleetLaunchTemplateSpecificationRequest", :type "structure"} (clojure.core/contains? input :launch-template-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :launch-template-id)) #:http.request.field{:name "LaunchTemplateId", :shape "String"})) (clojure.core/contains? input :launch-template-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-name (input :launch-template-name)) #:http.request.field{:name "LaunchTemplateName", :shape "LaunchTemplateName"})) (clojure.core/contains? input :version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :version)) #:http.request.field{:name "Version", :shape "String"}))))

(clojure.core/defn- ser-block-device-mapping-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-block-device-mapping coll) #:http.request.field{:shape "BlockDeviceMapping", :location-name "item"}))) input), :shape "BlockDeviceMappingList", :type "list"})

(clojure.core/defn- ser-blob [input] #:http.request.field{:value (portkey.aws/base64-encode input), :shape "Blob"})

(clojure.core/defn- ser-gateway-type [input] #:http.request.field{:value (clojure.core/get {"ipsec.1" "ipsec.1", :ipsec-1 "ipsec.1"} input), :shape "GatewayType"})

(clojure.core/defn- ser-scheduled-instances-iam-instance-profile [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ScheduledInstancesIamInstanceProfile", :type "structure"} (clojure.core/contains? input :arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :arn)) #:http.request.field{:name "Arn", :shape "String"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String"}))))

(clojure.core/defn- ser-report-status-type [input] #:http.request.field{:value (clojure.core/get {"ok" "ok", :ok "ok", "impaired" "impaired", :impaired "impaired"} input), :shape "ReportStatusType"})

(clojure.core/defn- ser-transport-protocol [input] #:http.request.field{:value (clojure.core/get {"tcp" "tcp", :tcp "tcp", "udp" "udp", :udp "udp"} input), :shape "TransportProtocol"})

(clojure.core/defn- ser-ip-range-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-ip-range coll) #:http.request.field{:shape "IpRange", :location-name "item"}))) input), :shape "IpRangeList", :type "list"})

(clojure.core/defn- ser-import-instance-launch-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ImportInstanceLaunchSpecification", :type "structure"} (clojure.core/contains? input :placement) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-placement (input :placement)) #:http.request.field{:name "Placement", :shape "Placement", :location-name "placement"})) (clojure.core/contains? input :subnet-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String", :location-name "subnetId"})) (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-type (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "InstanceType", :location-name "instanceType"})) (clojure.core/contains? input :group-ids) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-id-string-list (input :group-ids)) #:http.request.field{:name "GroupIds", :shape "SecurityGroupIdStringList", :location-name "GroupId"})) (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "String", :location-name "additionalInfo"})) (clojure.core/contains? input :monitoring) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :monitoring)) #:http.request.field{:name "Monitoring", :shape "Boolean", :location-name "monitoring"})) (clojure.core/contains? input :architecture) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-architecture-values (input :architecture)) #:http.request.field{:name "Architecture", :shape "ArchitectureValues", :location-name "architecture"})) (clojure.core/contains? input :user-data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-data (input :user-data)) #:http.request.field{:name "UserData", :shape "UserData", :location-name "userData"})) (clojure.core/contains? input :instance-initiated-shutdown-behavior) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-shutdown-behavior (input :instance-initiated-shutdown-behavior)) #:http.request.field{:name "InstanceInitiatedShutdownBehavior", :shape "ShutdownBehavior", :location-name "instanceInitiatedShutdownBehavior"})) (clojure.core/contains? input :group-names) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-string-list (input :group-names)) #:http.request.field{:name "GroupNames", :shape "SecurityGroupStringList", :location-name "GroupName"})) (clojure.core/contains? input :private-ip-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-ip-address)) #:http.request.field{:name "PrivateIpAddress", :shape "String", :location-name "privateIpAddress"}))))

(clojure.core/defn- ser-classic-load-balancers [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-classic-load-balancer coll) #:http.request.field{:shape "ClassicLoadBalancer", :location-name "item"}))) input), :shape "ClassicLoadBalancers", :type "list", :max 5, :min 1})

(clojure.core/defn- ser-spot-options-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SpotOptionsRequest", :type "structure"} (clojure.core/contains? input :allocation-strategy) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-allocation-strategy (input :allocation-strategy)) #:http.request.field{:name "AllocationStrategy", :shape "SpotAllocationStrategy"})) (clojure.core/contains? input :instance-interruption-behavior) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-instance-interruption-behavior (input :instance-interruption-behavior)) #:http.request.field{:name "InstanceInterruptionBehavior", :shape "SpotInstanceInterruptionBehavior"})) (clojure.core/contains? input :instance-pools-to-use-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :instance-pools-to-use-count)) #:http.request.field{:name "InstancePoolsToUseCount", :shape "Integer"})) (clojure.core/contains? input :single-instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :single-instance-type)) #:http.request.field{:name "SingleInstanceType", :shape "Boolean"})) (clojure.core/contains? input :single-availability-zone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :single-availability-zone)) #:http.request.field{:name "SingleAvailabilityZone", :shape "Boolean"})) (clojure.core/contains? input :min-target-capacity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :min-target-capacity)) #:http.request.field{:name "MinTargetCapacity", :shape "Integer"}))))

(clojure.core/defn- ser-scheduled-instances-block-device-mapping-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-scheduled-instances-block-device-mapping coll) #:http.request.field{:shape "ScheduledInstancesBlockDeviceMapping", :location-name "BlockDeviceMapping"}))) input), :shape "ScheduledInstancesBlockDeviceMappingSet", :type "list"})

(clojure.core/defn- ser-purchase-request [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-integer (:instance-count input)) #:http.request.field{:name "InstanceCount", :shape "Integer"}) (clojure.core/into (ser-string (:purchase-token input)) #:http.request.field{:name "PurchaseToken", :shape "String"})], :shape "PurchaseRequest", :type "structure"}))

(clojure.core/defn- ser-reserved-instances-modification-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ReservedInstancesModificationId"}))) input), :shape "ReservedInstancesModificationIdStringList", :type "list"})

(clojure.core/defn- ser-target-group [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "TargetGroup", :type "structure"} (clojure.core/contains? input :arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :arn)) #:http.request.field{:name "Arn", :shape "String", :location-name "arn"}))))

(clojure.core/defn- ser-resource-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "ResourceIdList", :type "list"})

(clojure.core/defn- ser-on-demand-options-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "OnDemandOptionsRequest", :type "structure"} (clojure.core/contains? input :allocation-strategy) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fleet-on-demand-allocation-strategy (input :allocation-strategy)) #:http.request.field{:name "AllocationStrategy", :shape "FleetOnDemandAllocationStrategy"})) (clojure.core/contains? input :single-instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :single-instance-type)) #:http.request.field{:name "SingleInstanceType", :shape "Boolean"})) (clojure.core/contains? input :single-availability-zone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :single-availability-zone)) #:http.request.field{:name "SingleAvailabilityZone", :shape "Boolean"})) (clojure.core/contains? input :min-target-capacity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :min-target-capacity)) #:http.request.field{:name "MinTargetCapacity", :shape "Integer"}))))

(clojure.core/defn- ser-ipv-6-address [input] #:http.request.field{:value input, :shape "Ipv6Address"})

(clojure.core/defn- ser-network-interface-permission-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "NetworkInterfacePermissionIdList", :type "list"})

(clojure.core/defn- ser-offering-class-type [input] #:http.request.field{:value (clojure.core/get {"standard" "standard", :standard "standard", "convertible" "convertible", :convertible "convertible"} input), :shape "OfferingClassType"})

(clojure.core/defn- ser-request-host-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "RequestHostIdList", :type "list"})

(clojure.core/defn- ser-launch-template-overrides-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-launch-template-overrides coll) #:http.request.field{:shape "LaunchTemplateOverrides", :location-name "item"}))) input), :shape "LaunchTemplateOverridesList", :type "list"})

(clojure.core/defn- ser-image-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ImageId"}))) input), :shape "ImageIdStringList", :type "list"})

(clojure.core/defn- ser-launch-template-iam-instance-profile-specification-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateIamInstanceProfileSpecificationRequest", :type "structure"} (clojure.core/contains? input :arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :arn)) #:http.request.field{:name "Arn", :shape "String"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String"}))))

(clojure.core/defn- ser-instance-attribute-name [input] #:http.request.field{:value (clojure.core/get {:instance-initiated-shutdown-behavior "instanceInitiatedShutdownBehavior", "kernel" "kernel", "groupSet" "groupSet", "productCodes" "productCodes", :group-set "groupSet", :ena-support "enaSupport", "blockDeviceMapping" "blockDeviceMapping", :source-dest-check "sourceDestCheck", :disable-api-termination "disableApiTermination", :ramdisk "ramdisk", :root-device-name "rootDeviceName", :product-codes "productCodes", "disableApiTermination" "disableApiTermination", :instance-type "instanceType", :ebs-optimized "ebsOptimized", "sourceDestCheck" "sourceDestCheck", :user-data "userData", "userData" "userData", "ebsOptimized" "ebsOptimized", :block-device-mapping "blockDeviceMapping", "ramdisk" "ramdisk", :sriov-net-support "sriovNetSupport", "instanceType" "instanceType", :kernel "kernel", "enaSupport" "enaSupport", "rootDeviceName" "rootDeviceName", "instanceInitiatedShutdownBehavior" "instanceInitiatedShutdownBehavior", "sriovNetSupport" "sriovNetSupport"} input), :shape "InstanceAttributeName"})

(clojure.core/defn- ser-capacity-reservation-preference [input] #:http.request.field{:value (clojure.core/get {"open" "open", :open "open", "none" "none", :none "none"} input), :shape "CapacityReservationPreference"})

(clojure.core/defn- ser-launch-template-block-device-mapping-request-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-launch-template-block-device-mapping-request coll) #:http.request.field{:shape "LaunchTemplateBlockDeviceMappingRequest", :location-name "BlockDeviceMapping"}))) input), :shape "LaunchTemplateBlockDeviceMappingRequestList", :type "list"})

(clojure.core/defn- ser-disk-image-detail [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-long (:bytes input)) #:http.request.field{:name "Bytes", :shape "Long", :location-name "bytes"}) (clojure.core/into (ser-disk-image-format (:format input)) #:http.request.field{:name "Format", :shape "DiskImageFormat", :location-name "format"}) (clojure.core/into (ser-string (:import-manifest-url input)) #:http.request.field{:name "ImportManifestUrl", :shape "String", :location-name "importManifestUrl"})], :shape "DiskImageDetail", :type "structure"}))

(clojure.core/defn- ser-user-data [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "UserData", :type "structure"} (clojure.core/contains? input :data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :data)) #:http.request.field{:name "Data", :shape "String", :location-name "data"}))))

(clojure.core/defn- ser-offering-type-values [input] #:http.request.field{:value (clojure.core/get {"All Upfront" "All Upfront", :heavy-utilization "Heavy Utilization", :no-upfront "No Upfront", :medium-utilization "Medium Utilization", :all-upfront "All Upfront", :light-utilization "Light Utilization", :partial-upfront "Partial Upfront", "No Upfront" "No Upfront", "Heavy Utilization" "Heavy Utilization", "Light Utilization" "Light Utilization", "Partial Upfront" "Partial Upfront", "Medium Utilization" "Medium Utilization"} input), :shape "OfferingTypeValues"})

(clojure.core/defn- ser-launch-template-tag-specification-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateTagSpecificationRequest", :type "structure"} (clojure.core/contains? input :resource-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ResourceType"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList", :location-name "Tag"}))))

(clojure.core/defn- ser-launch-template-block-device-mapping-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateBlockDeviceMappingRequest", :type "structure"} (clojure.core/contains? input :device-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :device-name)) #:http.request.field{:name "DeviceName", :shape "String"})) (clojure.core/contains? input :virtual-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :virtual-name)) #:http.request.field{:name "VirtualName", :shape "String"})) (clojure.core/contains? input :ebs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-ebs-block-device-request (input :ebs)) #:http.request.field{:name "Ebs", :shape "LaunchTemplateEbsBlockDeviceRequest"})) (clojure.core/contains? input :no-device) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :no-device)) #:http.request.field{:name "NoDevice", :shape "String"}))))

(clojure.core/defn- ser-network-interface-attachment-changes [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "NetworkInterfaceAttachmentChanges", :type "structure"} (clojure.core/contains? input :attachment-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :attachment-id)) #:http.request.field{:name "AttachmentId", :shape "String", :location-name "attachmentId"})) (clojure.core/contains? input :delete-on-termination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :delete-on-termination)) #:http.request.field{:name "DeleteOnTermination", :shape "Boolean", :location-name "deleteOnTermination"}))))

(clojure.core/defn- ser-private-ip-address-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "PrivateIpAddress"}))) input), :shape "PrivateIpAddressStringList", :type "list"})

(clojure.core/defn- ser-credit-specification-request [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:cpu-credits input)) #:http.request.field{:name "CpuCredits", :shape "String"})], :shape "CreditSpecificationRequest", :type "structure"}))

(clojure.core/defn- ser-launch-template-capacity-reservation-specification-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplateCapacityReservationSpecificationRequest", :type "structure"} (clojure.core/contains? input :capacity-reservation-preference) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-capacity-reservation-preference (input :capacity-reservation-preference)) #:http.request.field{:name "CapacityReservationPreference", :shape "CapacityReservationPreference"})) (clojure.core/contains? input :capacity-reservation-target) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-capacity-reservation-target (input :capacity-reservation-target)) #:http.request.field{:name "CapacityReservationTarget", :shape "CapacityReservationTarget"}))))

(clojure.core/defn- ser-scheduled-instances-ipv-6-address-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-scheduled-instances-ipv-6-address coll) #:http.request.field{:shape "ScheduledInstancesIpv6Address", :location-name "Ipv6Address"}))) input), :shape "ScheduledInstancesIpv6AddressList", :type "list"})

(clojure.core/defn- ser-owner-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "Owner"}))) input), :shape "OwnerStringList", :type "list"})

(clojure.core/defn- ser-create-volume-permission-modifications [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CreateVolumePermissionModifications", :type "structure"} (clojure.core/contains? input :add) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-create-volume-permission-list (input :add)) #:http.request.field{:name "Add", :shape "CreateVolumePermissionList"})) (clojure.core/contains? input :remove) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-create-volume-permission-list (input :remove)) #:http.request.field{:name "Remove", :shape "CreateVolumePermissionList"}))))

(clojure.core/defn- ser-fleet-excess-capacity-termination-policy [input] #:http.request.field{:value (clojure.core/get {"no-termination" "no-termination", :notermination "no-termination", "termination" "termination", :termination "termination"} input), :shape "FleetExcessCapacityTerminationPolicy"})

(clojure.core/defn- ser-reason-codes-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-report-instance-reason-codes coll) #:http.request.field{:shape "ReportInstanceReasonCodes", :location-name "item"}))) input), :shape "ReasonCodesList", :type "list"})

(clojure.core/defn- ser-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-filter coll) #:http.request.field{:shape "Filter", :location-name "Filter"}))) input), :shape "FilterList", :type "list"})

(clojure.core/defn- ser-launch-permission [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchPermission", :type "structure"} (clojure.core/contains? input :group) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-permission-group (input :group)) #:http.request.field{:name "Group", :shape "PermissionGroup", :location-name "group"})) (clojure.core/contains? input :user-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :user-id)) #:http.request.field{:name "UserId", :shape "String", :location-name "userId"}))))

(clojure.core/defn- ser-ipv-6-range [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Ipv6Range", :type "structure"} (clojure.core/contains? input :cidr-ipv-6) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidr-ipv-6)) #:http.request.field{:name "CidrIpv6", :shape "String", :location-name "cidrIpv6"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"}))))

(clojure.core/defn- ser-egress-only-internet-gateway-id [input] #:http.request.field{:value input, :shape "EgressOnlyInternetGatewayId"})

(clojure.core/defn- ser-vpn-gateway-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "VpnGatewayId"}))) input), :shape "VpnGatewayIdStringList", :type "list"})

(clojure.core/defn- ser-create-transit-gateway-vpc-attachment-request-options [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CreateTransitGatewayVpcAttachmentRequestOptions", :type "structure"} (clojure.core/contains? input :dns-support) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dns-support-value (input :dns-support)) #:http.request.field{:name "DnsSupport", :shape "DnsSupportValue"})) (clojure.core/contains? input :ipv-6-support) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ipv-6-support-value (input :ipv-6-support)) #:http.request.field{:name "Ipv6Support", :shape "Ipv6SupportValue"}))))

(clojure.core/defn- ser-private-ip-address-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PrivateIpAddressSpecification", :type "structure"} (clojure.core/contains? input :primary) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :primary)) #:http.request.field{:name "Primary", :shape "Boolean", :location-name "primary"})) (clojure.core/contains? input :private-ip-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-ip-address)) #:http.request.field{:name "PrivateIpAddress", :shape "String", :location-name "privateIpAddress"}))))

(clojure.core/defn- ser-request-spot-launch-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "RequestSpotLaunchSpecification", :type "structure"} (clojure.core/contains? input :kernel-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kernel-id)) #:http.request.field{:name "KernelId", :shape "String", :location-name "kernelId"})) (clojure.core/contains? input :security-group-ids) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :security-group-ids)) #:http.request.field{:name "SecurityGroupIds", :shape "ValueStringList", :location-name "SecurityGroupId"})) (clojure.core/contains? input :image-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-id)) #:http.request.field{:name "ImageId", :shape "String", :location-name "imageId"})) (clojure.core/contains? input :placement) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-placement (input :placement)) #:http.request.field{:name "Placement", :shape "SpotPlacement", :location-name "placement"})) (clojure.core/contains? input :addressing-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :addressing-type)) #:http.request.field{:name "AddressingType", :shape "String", :location-name "addressingType"})) (clojure.core/contains? input :subnet-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String", :location-name "subnetId"})) (clojure.core/contains? input :security-groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :security-groups)) #:http.request.field{:name "SecurityGroups", :shape "ValueStringList", :location-name "SecurityGroup"})) (clojure.core/contains? input :ebs-optimized) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :ebs-optimized)) #:http.request.field{:name "EbsOptimized", :shape "Boolean", :location-name "ebsOptimized"})) (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-type (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "InstanceType", :location-name "instanceType"})) (clojure.core/contains? input :key-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key-name)) #:http.request.field{:name "KeyName", :shape "String", :location-name "keyName"})) (clojure.core/contains? input :monitoring) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-run-instances-monitoring-enabled (input :monitoring)) #:http.request.field{:name "Monitoring", :shape "RunInstancesMonitoringEnabled", :location-name "monitoring"})) (clojure.core/contains? input :block-device-mappings) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-block-device-mapping-list (input :block-device-mappings)) #:http.request.field{:name "BlockDeviceMappings", :shape "BlockDeviceMappingList", :location-name "blockDeviceMapping"})) (clojure.core/contains? input :ramdisk-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ramdisk-id)) #:http.request.field{:name "RamdiskId", :shape "String", :location-name "ramdiskId"})) (clojure.core/contains? input :user-data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :user-data)) #:http.request.field{:name "UserData", :shape "String", :location-name "userData"})) (clojure.core/contains? input :iam-instance-profile) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-instance-profile-specification (input :iam-instance-profile)) #:http.request.field{:name "IamInstanceProfile", :shape "IamInstanceProfileSpecification", :location-name "iamInstanceProfile"})) (clojure.core/contains? input :network-interfaces) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-network-interface-specification-list (input :network-interfaces)) #:http.request.field{:name "NetworkInterfaces", :shape "InstanceNetworkInterfaceSpecificationList", :location-name "NetworkInterface"}))))

(clojure.core/defn- ser-elastic-gpu-specification-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-elastic-gpu-specification coll) #:http.request.field{:shape "ElasticGpuSpecification", :location-name "ElasticGpuSpecification"}))) input), :shape "ElasticGpuSpecificationList", :type "list"})

(clojure.core/defn- ser-user-id-group-pair [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "UserIdGroupPair", :type "structure"} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"})) (clojure.core/contains? input :group-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-id)) #:http.request.field{:name "GroupId", :shape "String", :location-name "groupId"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String", :location-name "groupName"})) (clojure.core/contains? input :peering-status) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :peering-status)) #:http.request.field{:name "PeeringStatus", :shape "String", :location-name "peeringStatus"})) (clojure.core/contains? input :user-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :user-id)) #:http.request.field{:name "UserId", :shape "String", :location-name "userId"})) (clojure.core/contains? input :vpc-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})) (clojure.core/contains? input :vpc-peering-connection-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpc-peering-connection-id)) #:http.request.field{:name "VpcPeeringConnectionId", :shape "String", :location-name "vpcPeeringConnectionId"}))))

(clojure.core/defn- ser-launch-templates-monitoring-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "LaunchTemplatesMonitoringRequest", :type "structure"} (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "Boolean"}))))

(clojure.core/defn- ser-capacity-reservation-tenancy [input] #:http.request.field{:value (clojure.core/get {"default" "default", :default "default", "dedicated" "dedicated", :dedicated "dedicated"} input), :shape "CapacityReservationTenancy"})

(clojure.core/defn- ser-import-task-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ImportTaskId"}))) input), :shape "ImportTaskIdList", :type "list"})

(clojure.core/defn- ser-describe-vpcs-max-results [input] #:http.request.field{:value input, :shape "DescribeVpcsMaxResults"})

(clojure.core/defn- ser-date-time [input] #:http.request.field{:value input, :shape "DateTime"})

(clojure.core/defn- ser-snapshot-id-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SnapshotId"}))) input), :shape "SnapshotIdStringList", :type "list"})

(clojure.core/defn- ser-shutdown-behavior [input] #:http.request.field{:value (clojure.core/get {"stop" "stop", :stop "stop", "terminate" "terminate", :terminate "terminate"} input), :shape "ShutdownBehavior"})

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "Boolean"})

(clojure.core/defn- ser-instance-network-interface-specification [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "InstanceNetworkInterfaceSpecification", :type "structure"} (clojure.core/contains? input :associate-public-ip-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :associate-public-ip-address)) #:http.request.field{:name "AssociatePublicIpAddress", :shape "Boolean", :location-name "associatePublicIpAddress"})) (clojure.core/contains? input :ipv-6-addresses) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-ipv-6-address-list (input :ipv-6-addresses)) #:http.request.field{:name "Ipv6Addresses", :shape "InstanceIpv6AddressList", :location-name "ipv6AddressesSet", :query-name "Ipv6Addresses"})) (clojure.core/contains? input :subnet-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String", :location-name "subnetId"})) (clojure.core/contains? input :network-interface-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})) (clojure.core/contains? input :device-index) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :device-index)) #:http.request.field{:name "DeviceIndex", :shape "Integer", :location-name "deviceIndex"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"})) (clojure.core/contains? input :groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-id-string-list (input :groups)) #:http.request.field{:name "Groups", :shape "SecurityGroupIdStringList", :location-name "SecurityGroupId"})) (clojure.core/contains? input :delete-on-termination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :delete-on-termination)) #:http.request.field{:name "DeleteOnTermination", :shape "Boolean", :location-name "deleteOnTermination"})) (clojure.core/contains? input :private-ip-addresses) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-private-ip-address-specification-list (input :private-ip-addresses)) #:http.request.field{:name "PrivateIpAddresses", :shape "PrivateIpAddressSpecificationList", :location-name "privateIpAddressesSet", :query-name "PrivateIpAddresses"})) (clojure.core/contains? input :secondary-private-ip-address-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :secondary-private-ip-address-count)) #:http.request.field{:name "SecondaryPrivateIpAddressCount", :shape "Integer", :location-name "secondaryPrivateIpAddressCount"})) (clojure.core/contains? input :private-ip-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-ip-address)) #:http.request.field{:name "PrivateIpAddress", :shape "String", :location-name "privateIpAddress"})) (clojure.core/contains? input :ipv-6-address-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :ipv-6-address-count)) #:http.request.field{:name "Ipv6AddressCount", :shape "Integer", :location-name "ipv6AddressCount"}))))

(clojure.core/defn- ser-client-vpn-security-group-id-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "item"}))) input), :shape "ClientVpnSecurityGroupIdSet", :type "list"})

(clojure.core/defn- req-describe-snapshots-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :owner-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-owner-string-list (input :owner-ids)) #:http.request.field{:name "OwnerIds", :shape "OwnerStringList", :location-name "Owner"})) (clojure.core/contains? input :restorable-by-user-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-restorable-by-string-list (input :restorable-by-user-ids)) #:http.request.field{:name "RestorableByUserIds", :shape "RestorableByStringList", :location-name "RestorableBy"})) (clojure.core/contains? input :snapshot-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-snapshot-id-string-list (input :snapshot-ids)) #:http.request.field{:name "SnapshotIds", :shape "SnapshotIdStringList", :location-name "SnapshotId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-spot-fleet-requests-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"})) (clojure.core/contains? input :spot-fleet-request-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :spot-fleet-request-ids)) #:http.request.field{:name "SpotFleetRequestIds", :shape "ValueStringList", :location-name "spotFleetRequestId"}))))

(clojure.core/defn- req-get-transit-gateway-attachment-propagations-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "TransitGatewayMaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-import-image-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :platform) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :platform)) #:http.request.field{:name "Platform", :shape "String"})) (clojure.core/contains? input :role-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :role-name)) #:http.request.field{:name "RoleName", :shape "String"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "Boolean"})) (clojure.core/contains? input :client-data) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-data (input :client-data)) #:http.request.field{:name "ClientData", :shape "ClientData"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :disk-containers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-image-disk-container-list (input :disk-containers)) #:http.request.field{:name "DiskContainers", :shape "ImageDiskContainerList", :location-name "DiskContainer"})) (clojure.core/contains? input :hypervisor) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hypervisor)) #:http.request.field{:name "Hypervisor", :shape "String"})) (clojure.core/contains? input :architecture) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :architecture)) #:http.request.field{:name "Architecture", :shape "String"})) (clojure.core/contains? input :license-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :license-type)) #:http.request.field{:name "LicenseType", :shape "String"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"}))))

(clojure.core/defn- req-describe-vpc-endpoint-service-configurations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :service-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :service-ids)) #:http.request.field{:name "ServiceIds", :shape "ValueStringList", :location-name "ServiceId"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-create-transit-gateway-route-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :destination-cidr-block)) #:http.request.field{:name "DestinationCidrBlock", :shape "String"}) (clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"})]} (clojure.core/contains? input :transit-gateway-attachment-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})) (clojure.core/contains? input :blackhole) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :blackhole)) #:http.request.field{:name "Blackhole", :shape "Boolean"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-confirm-product-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"}) (clojure.core/into (ser-string (input :product-code)) #:http.request.field{:name "ProductCode", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-vpn-gateways-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :vpn-gateway-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpn-gateway-id-string-list (input :vpn-gateway-ids)) #:http.request.field{:name "VpnGatewayIds", :shape "VpnGatewayIdStringList", :location-name "VpnGatewayId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-vpn-connection-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpn-connection-id)) #:http.request.field{:name "VpnConnectionId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-request-spot-fleet-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-spot-fleet-request-config-data (input :spot-fleet-request-config)) #:http.request.field{:name "SpotFleetRequestConfig", :shape "SpotFleetRequestConfigData", :location-name "spotFleetRequestConfig"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-fleet-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-fleet-identifier (input :fleet-id)) #:http.request.field{:name "FleetId", :shape "FleetIdentifier"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"}))))

(clojure.core/defn- req-describe-scheduled-instances-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :scheduled-instance-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-scheduled-instance-id-request-set (input :scheduled-instance-ids)) #:http.request.field{:name "ScheduledInstanceIds", :shape "ScheduledInstanceIdRequestSet", :location-name "ScheduledInstanceId"})) (clojure.core/contains? input :slot-start-time-range) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-slot-start-time-range-request (input :slot-start-time-range)) #:http.request.field{:name "SlotStartTimeRange", :shape "SlotStartTimeRangeRequest"}))))

(clojure.core/defn- req-delete-flow-logs-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-value-string-list (input :flow-log-ids)) #:http.request.field{:name "FlowLogIds", :shape "ValueStringList", :location-name "FlowLogId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-addresses-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :public-ips) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-public-ip-string-list (input :public-ips)) #:http.request.field{:name "PublicIps", :shape "PublicIpStringList", :location-name "PublicIp"})) (clojure.core/contains? input :allocation-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-allocation-id-list (input :allocation-ids)) #:http.request.field{:name "AllocationIds", :shape "AllocationIdList", :location-name "AllocationId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-network-acls-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :network-acl-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :network-acl-ids)) #:http.request.field{:name "NetworkAclIds", :shape "ValueStringList", :location-name "NetworkAclId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-describe-network-acls-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "DescribeNetworkAclsMaxResults"}))))

(clojure.core/defn- req-modify-id-format-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :resource)) #:http.request.field{:name "Resource", :shape "String"}) (clojure.core/into (ser-boolean (input :use-long-ids)) #:http.request.field{:name "UseLongIds", :shape "Boolean"})]}))

(clojure.core/defn- req-reset-network-interface-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :source-dest-check) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-dest-check)) #:http.request.field{:name "SourceDestCheck", :shape "String", :location-name "sourceDestCheck"}))))

(clojure.core/defn- req-reject-transit-gateway-vpc-attachment-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-internet-gateways-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :internet-gateway-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :internet-gateway-ids)) #:http.request.field{:name "InternetGatewayIds", :shape "ValueStringList", :location-name "internetGatewayId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-describe-internet-gateways-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "DescribeInternetGatewaysMaxResults"}))))

(clojure.core/defn- req-disassociate-iam-instance-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :association-id)) #:http.request.field{:name "AssociationId", :shape "String"})]}))

(clojure.core/defn- req-modify-vpc-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})]} (clojure.core/contains? input :enable-dns-hostnames) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-boolean-value (input :enable-dns-hostnames)) #:http.request.field{:name "EnableDnsHostnames", :shape "AttributeBooleanValue"})) (clojure.core/contains? input :enable-dns-support) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-boolean-value (input :enable-dns-support)) #:http.request.field{:name "EnableDnsSupport", :shape "AttributeBooleanValue"}))))

(clojure.core/defn- req-delete-customer-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :customer-gateway-id)) #:http.request.field{:name "CustomerGatewayId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-reserved-instances-listing-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String", :location-name "clientToken"}) (clojure.core/into (ser-integer (input :instance-count)) #:http.request.field{:name "InstanceCount", :shape "Integer", :location-name "instanceCount"}) (clojure.core/into (ser-price-schedule-specification-list (input :price-schedules)) #:http.request.field{:name "PriceSchedules", :shape "PriceScheduleSpecificationList", :location-name "priceSchedules"}) (clojure.core/into (ser-string (input :reserved-instances-id)) #:http.request.field{:name "ReservedInstancesId", :shape "String", :location-name "reservedInstancesId"})]}))

(clojure.core/defn- req-replace-route-table-association-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :association-id)) #:http.request.field{:name "AssociationId", :shape "String", :location-name "associationId"}) (clojure.core/into (ser-string (input :route-table-id)) #:http.request.field{:name "RouteTableId", :shape "String", :location-name "routeTableId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :volume-id)) #:http.request.field{:name "VolumeId", :shape "String"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "TagSpecificationList", :location-name "TagSpecification"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-allocate-hosts-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String", :location-name "availabilityZone"}) (clojure.core/into (ser-string (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "String", :location-name "instanceType"}) (clojure.core/into (ser-integer (input :quantity)) #:http.request.field{:name "Quantity", :shape "Integer", :location-name "quantity"})]} (clojure.core/contains? input :auto-placement) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-auto-placement (input :auto-placement)) #:http.request.field{:name "AutoPlacement", :shape "AutoPlacement", :location-name "autoPlacement"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String", :location-name "clientToken"})) (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "TagSpecificationList", :location-name "TagSpecification"}))))

(clojure.core/defn- req-create-image-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"}) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String", :location-name "name"})]} (clojure.core/contains? input :block-device-mappings) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-block-device-mapping-request-list (input :block-device-mappings)) #:http.request.field{:name "BlockDeviceMappings", :shape "BlockDeviceMappingRequestList", :location-name "blockDeviceMapping"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :no-reboot) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :no-reboot)) #:http.request.field{:name "NoReboot", :shape "Boolean", :location-name "noReboot"}))))

(clojure.core/defn- req-create-vpn-connection-route-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :destination-cidr-block)) #:http.request.field{:name "DestinationCidrBlock", :shape "String"}) (clojure.core/into (ser-string (input :vpn-connection-id)) #:http.request.field{:name "VpnConnectionId", :shape "String"})]}))

(clojure.core/defn- req-create-egress-only-internet-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"})]} (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-register-image-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String", :location-name "name"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :kernel-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kernel-id)) #:http.request.field{:name "KernelId", :shape "String", :location-name "kernelId"})) (clojure.core/contains? input :sriov-net-support) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sriov-net-support)) #:http.request.field{:name "SriovNetSupport", :shape "String", :location-name "sriovNetSupport"})) (clojure.core/contains? input :billing-products) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-product-list (input :billing-products)) #:http.request.field{:name "BillingProducts", :shape "BillingProductList", :location-name "BillingProduct"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"})) (clojure.core/contains? input :block-device-mappings) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-block-device-mapping-request-list (input :block-device-mappings)) #:http.request.field{:name "BlockDeviceMappings", :shape "BlockDeviceMappingRequestList", :location-name "BlockDeviceMapping"})) (clojure.core/contains? input :architecture) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-architecture-values (input :architecture)) #:http.request.field{:name "Architecture", :shape "ArchitectureValues", :location-name "architecture"})) (clojure.core/contains? input :virtualization-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :virtualization-type)) #:http.request.field{:name "VirtualizationType", :shape "String", :location-name "virtualizationType"})) (clojure.core/contains? input :image-location) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-location)) #:http.request.field{:name "ImageLocation", :shape "String"})) (clojure.core/contains? input :root-device-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :root-device-name)) #:http.request.field{:name "RootDeviceName", :shape "String", :location-name "rootDeviceName"})) (clojure.core/contains? input :ramdisk-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ramdisk-id)) #:http.request.field{:name "RamdiskId", :shape "String", :location-name "ramdiskId"})) (clojure.core/contains? input :ena-support) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :ena-support)) #:http.request.field{:name "EnaSupport", :shape "Boolean", :location-name "enaSupport"}))))

(clojure.core/defn- req-modify-hosts-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-auto-placement (input :auto-placement)) #:http.request.field{:name "AutoPlacement", :shape "AutoPlacement", :location-name "autoPlacement"}) (clojure.core/into (ser-request-host-id-list (input :host-ids)) #:http.request.field{:name "HostIds", :shape "RequestHostIdList", :location-name "hostId"})]}))

(clojure.core/defn- req-delete-volume-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :volume-id)) #:http.request.field{:name "VolumeId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-network-acl-entry-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-boolean (input :egress)) #:http.request.field{:name "Egress", :shape "Boolean", :location-name "egress"}) (clojure.core/into (ser-string (input :network-acl-id)) #:http.request.field{:name "NetworkAclId", :shape "String", :location-name "networkAclId"}) (clojure.core/into (ser-integer (input :rule-number)) #:http.request.field{:name "RuleNumber", :shape "Integer", :location-name "ruleNumber"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-conversion-tasks-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :conversion-task-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-conversion-id-string-list (input :conversion-task-ids)) #:http.request.field{:name "ConversionTaskIds", :shape "ConversionIdStringList", :location-name "conversionTaskId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-copy-image-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String"}) (clojure.core/into (ser-string (input :source-image-id)) #:http.request.field{:name "SourceImageId", :shape "String"}) (clojure.core/into (ser-string (input :source-region)) #:http.request.field{:name "SourceRegion", :shape "String"})]} (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "Boolean", :location-name "encrypted"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String", :location-name "kmsKeyId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-cancel-conversion-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :conversion-task-id)) #:http.request.field{:name "ConversionTaskId", :shape "String", :location-name "conversionTaskId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :reason-message) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reason-message)) #:http.request.field{:name "ReasonMessage", :shape "String", :location-name "reasonMessage"}))))

(clojure.core/defn- req-describe-network-interface-permissions-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :network-interface-permission-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-network-interface-permission-id-list (input :network-interface-permission-ids)) #:http.request.field{:name "NetworkInterfacePermissionIds", :shape "NetworkInterfacePermissionIdList", :location-name "NetworkInterfacePermissionId"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"}))))

(clojure.core/defn- req-modify-spot-fleet-request-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :spot-fleet-request-id)) #:http.request.field{:name "SpotFleetRequestId", :shape "String", :location-name "spotFleetRequestId"})]} (clojure.core/contains? input :excess-capacity-termination-policy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-excess-capacity-termination-policy (input :excess-capacity-termination-policy)) #:http.request.field{:name "ExcessCapacityTerminationPolicy", :shape "ExcessCapacityTerminationPolicy", :location-name "excessCapacityTerminationPolicy"})) (clojure.core/contains? input :target-capacity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :target-capacity)) #:http.request.field{:name "TargetCapacity", :shape "Integer", :location-name "targetCapacity"}))))

(clojure.core/defn- req-describe-flow-logs-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :filter) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filter)) #:http.request.field{:name "Filter", :shape "FilterList"})) (clojure.core/contains? input :flow-log-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :flow-log-ids)) #:http.request.field{:name "FlowLogIds", :shape "ValueStringList", :location-name "FlowLogId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-describe-elastic-gpus-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :elastic-gpu-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-elastic-gpu-id-set (input :elastic-gpu-ids)) #:http.request.field{:name "ElasticGpuIds", :shape "ElasticGpuIdSet", :location-name "ElasticGpuId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-delete-security-group-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-id)) #:http.request.field{:name "GroupId", :shape "String"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-transit-gateway-route-table-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-spot-price-history-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :instance-types) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-type-list (input :instance-types)) #:http.request.field{:name "InstanceTypes", :shape "InstanceTypeList", :location-name "InstanceType"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :end-time)) #:http.request.field{:name "EndTime", :shape "DateTime", :location-name "endTime"})) (clojure.core/contains? input :product-descriptions) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-product-description-list (input :product-descriptions)) #:http.request.field{:name "ProductDescriptions", :shape "ProductDescriptionList", :location-name "ProductDescription"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :start-time)) #:http.request.field{:name "StartTime", :shape "DateTime", :location-name "startTime"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String", :location-name "availabilityZone"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"}))))

(clojure.core/defn- req-bundle-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"}) (clojure.core/into (ser-storage (input :storage)) #:http.request.field{:name "Storage", :shape "Storage"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-vpc-peering-connection-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-peering-connection-id)) #:http.request.field{:name "VpcPeeringConnectionId", :shape "String", :location-name "vpcPeeringConnectionId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-route-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :route-table-id)) #:http.request.field{:name "RouteTableId", :shape "String", :location-name "routeTableId"})]} (clojure.core/contains? input :transit-gateway-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :transit-gateway-id)) #:http.request.field{:name "TransitGatewayId", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"})) (clojure.core/contains? input :nat-gateway-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :nat-gateway-id)) #:http.request.field{:name "NatGatewayId", :shape "String", :location-name "natGatewayId"})) (clojure.core/contains? input :network-interface-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})) (clojure.core/contains? input :destination-ipv-6-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :destination-ipv-6-cidr-block)) #:http.request.field{:name "DestinationIpv6CidrBlock", :shape "String", :location-name "destinationIpv6CidrBlock"})) (clojure.core/contains? input :destination-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :destination-cidr-block)) #:http.request.field{:name "DestinationCidrBlock", :shape "String", :location-name "destinationCidrBlock"})) (clojure.core/contains? input :vpc-peering-connection-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpc-peering-connection-id)) #:http.request.field{:name "VpcPeeringConnectionId", :shape "String", :location-name "vpcPeeringConnectionId"})) (clojure.core/contains? input :gateway-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :gateway-id)) #:http.request.field{:name "GatewayId", :shape "String", :location-name "gatewayId"})) (clojure.core/contains? input :egress-only-internet-gateway-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :egress-only-internet-gateway-id)) #:http.request.field{:name "EgressOnlyInternetGatewayId", :shape "String", :location-name "egressOnlyInternetGatewayId"}))))

(clojure.core/defn- req-delete-vpc-endpoint-connection-notifications-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-value-string-list (input :connection-notification-ids)) #:http.request.field{:name "ConnectionNotificationIds", :shape "ValueStringList", :location-name "ConnectionNotificationId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-byoip-cidrs-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-start-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id-string-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdStringList", :location-name "InstanceId"})]} (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "String", :location-name "additionalInfo"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-network-interface-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-vpc-endpoint-connection-notification-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :connection-notification-arn)) #:http.request.field{:name "ConnectionNotificationArn", :shape "String"}) (clojure.core/into (ser-value-string-list (input :connection-events)) #:http.request.field{:name "ConnectionEvents", :shape "ValueStringList"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :service-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :service-id)) #:http.request.field{:name "ServiceId", :shape "String"})) (clojure.core/contains? input :vpc-endpoint-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpc-endpoint-id)) #:http.request.field{:name "VpcEndpointId", :shape "String"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"}))))

(clojure.core/defn- req-describe-volume-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-volume-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "VolumeAttributeName"}) (clojure.core/into (ser-string (input :volume-id)) #:http.request.field{:name "VolumeId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-export-client-vpn-client-configuration-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-delete-launch-template-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :launch-template-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :launch-template-id)) #:http.request.field{:name "LaunchTemplateId", :shape "String"})) (clojure.core/contains? input :launch-template-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-name (input :launch-template-name)) #:http.request.field{:name "LaunchTemplateName", :shape "LaunchTemplateName"}))))

(clojure.core/defn- req-unmonitor-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id-string-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdStringList", :location-name "InstanceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-authorize-client-vpn-ingress-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"}) (clojure.core/into (ser-string (input :target-network-cidr)) #:http.request.field{:name "TargetNetworkCidr", :shape "String"})]} (clojure.core/contains? input :access-group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :access-group-id)) #:http.request.field{:name "AccessGroupId", :shape "String"})) (clojure.core/contains? input :authorize-all-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :authorize-all-groups)) #:http.request.field{:name "AuthorizeAllGroups", :shape "Boolean"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-spot-fleet-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :spot-fleet-request-id)) #:http.request.field{:name "SpotFleetRequestId", :shape "String", :location-name "spotFleetRequestId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"}))))

(clojure.core/defn- req-import-snapshot-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :client-data) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-data (input :client-data)) #:http.request.field{:name "ClientData", :shape "ClientData"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :disk-container) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-snapshot-disk-container (input :disk-container)) #:http.request.field{:name "DiskContainer", :shape "SnapshotDiskContainer"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "Boolean"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :role-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :role-name)) #:http.request.field{:name "RoleName", :shape "String"}))))

(clojure.core/defn- req-describe-vpc-endpoint-service-permissions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :service-id)) #:http.request.field{:name "ServiceId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-describe-instance-status-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :instance-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id-string-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdStringList", :location-name "InstanceId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :include-all-instances) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :include-all-instances)) #:http.request.field{:name "IncludeAllInstances", :shape "Boolean", :location-name "includeAllInstances"}))))

(clojure.core/defn- req-disable-vpc-classic-link-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-import-image-tasks-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList"})) (clojure.core/contains? input :import-task-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-import-task-id-list (input :import-task-ids)) #:http.request.field{:name "ImportTaskIds", :shape "ImportTaskIdList", :location-name "ImportTaskId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-copy-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :source-region)) #:http.request.field{:name "SourceRegion", :shape "String"}) (clojure.core/into (ser-string (input :source-snapshot-id)) #:http.request.field{:name "SourceSnapshotId", :shape "String"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :destination-region) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :destination-region)) #:http.request.field{:name "DestinationRegion", :shape "String", :location-name "destinationRegion"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "Boolean", :location-name "encrypted"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String", :location-name "kmsKeyId"})) (clojure.core/contains? input :presigned-url) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :presigned-url)) #:http.request.field{:name "PresignedUrl", :shape "String", :location-name "presignedUrl"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-instance-credit-specifications-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :instance-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id-string-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdStringList", :location-name "InstanceId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-describe-instance-credit-specifications-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "DescribeInstanceCreditSpecificationsMaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-delete-internet-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :internet-gateway-id)) #:http.request.field{:name "InternetGatewayId", :shape "String", :location-name "internetGatewayId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-attach-volume-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :device)) #:http.request.field{:name "Device", :shape "String"}) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"}) (clojure.core/into (ser-string (input :volume-id)) #:http.request.field{:name "VolumeId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-modify-identity-id-format-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :principal-arn)) #:http.request.field{:name "PrincipalArn", :shape "String", :location-name "principalArn"}) (clojure.core/into (ser-string (input :resource)) #:http.request.field{:name "Resource", :shape "String", :location-name "resource"}) (clojure.core/into (ser-boolean (input :use-long-ids)) #:http.request.field{:name "UseLongIds", :shape "Boolean", :location-name "useLongIds"})]}))

(clojure.core/defn- req-cancel-export-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :export-task-id)) #:http.request.field{:name "ExportTaskId", :shape "String", :location-name "exportTaskId"})]}))

(clojure.core/defn- req-advertise-byoip-cidr-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cidr)) #:http.request.field{:name "Cidr", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-create-security-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "GroupDescription"}) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String"})]} (clojure.core/contains? input :vpc-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-client-vpn-endpoint-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-cidr-block)) #:http.request.field{:name "ClientCidrBlock", :shape "String"}) (clojure.core/into (ser-string (input :server-certificate-arn)) #:http.request.field{:name "ServerCertificateArn", :shape "String"}) (clojure.core/into (ser-client-vpn-authentication-request-list (input :authentication-options)) #:http.request.field{:name "AuthenticationOptions", :shape "ClientVpnAuthenticationRequestList", :location-name "Authentication"}) (clojure.core/into (ser-connection-log-options (input :connection-log-options)) #:http.request.field{:name "ConnectionLogOptions", :shape "ConnectionLogOptions"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "TagSpecificationList", :location-name "TagSpecification"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :transport-protocol) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transport-protocol (input :transport-protocol)) #:http.request.field{:name "TransportProtocol", :shape "TransportProtocol"})) (clojure.core/contains? input :dns-servers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :dns-servers)) #:http.request.field{:name "DnsServers", :shape "ValueStringList"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String", :idempotency-token true}))))

(clojure.core/defn- req-describe-transit-gateways-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :transit-gateway-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-id-string-list (input :transit-gateway-ids)) #:http.request.field{:name "TransitGatewayIds", :shape "TransitGatewayIdStringList"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "TransitGatewayMaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-modify-instance-event-start-time-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"}) (clojure.core/into (ser-string (input :instance-event-id)) #:http.request.field{:name "InstanceEventId", :shape "String"}) (clojure.core/into (ser-date-time (input :not-before)) #:http.request.field{:name "NotBefore", :shape "DateTime"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-revoke-security-group-ingress-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :source-security-group-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-security-group-owner-id)) #:http.request.field{:name "SourceSecurityGroupOwnerId", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :to-port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :to-port)) #:http.request.field{:name "ToPort", :shape "Integer"})) (clojure.core/contains? input :source-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-security-group-name)) #:http.request.field{:name "SourceSecurityGroupName", :shape "String"})) (clojure.core/contains? input :ip-protocol) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ip-protocol)) #:http.request.field{:name "IpProtocol", :shape "String"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String"})) (clojure.core/contains? input :group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-id)) #:http.request.field{:name "GroupId", :shape "String"})) (clojure.core/contains? input :from-port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :from-port)) #:http.request.field{:name "FromPort", :shape "Integer"})) (clojure.core/contains? input :ip-permissions) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ip-permission-list (input :ip-permissions)) #:http.request.field{:name "IpPermissions", :shape "IpPermissionList"})) (clojure.core/contains? input :cidr-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidr-ip)) #:http.request.field{:name "CidrIp", :shape "String"}))))

(clojure.core/defn- req-delete-vpn-connection-route-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :destination-cidr-block)) #:http.request.field{:name "DestinationCidrBlock", :shape "String"}) (clojure.core/into (ser-string (input :vpn-connection-id)) #:http.request.field{:name "VpnConnectionId", :shape "String"})]}))

(clojure.core/defn- req-delete-fpga-image-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :fpga-image-id)) #:http.request.field{:name "FpgaImageId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-create-key-pair-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :key-name)) #:http.request.field{:name "KeyName", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-vpn-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-gateway-type (input :type)) #:http.request.field{:name "Type", :shape "GatewayType"})]} (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :amazon-side-asn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-long (input :amazon-side-asn)) #:http.request.field{:name "AmazonSideAsn", :shape "Long"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-replace-iam-instance-profile-association-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-iam-instance-profile-specification (input :iam-instance-profile)) #:http.request.field{:name "IamInstanceProfile", :shape "IamInstanceProfileSpecification"}) (clojure.core/into (ser-string (input :association-id)) #:http.request.field{:name "AssociationId", :shape "String"})]}))

(clojure.core/defn- req-create-fpga-image-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-storage-location (input :input-storage-location)) #:http.request.field{:name "InputStorageLocation", :shape "StorageLocation"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :logs-storage-location) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-storage-location (input :logs-storage-location)) #:http.request.field{:name "LogsStorageLocation", :shape "StorageLocation"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"}))))

(clojure.core/defn- req-enable-vgw-route-propagation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :gateway-id)) #:http.request.field{:name "GatewayId", :shape "String"}) (clojure.core/into (ser-string (input :route-table-id)) #:http.request.field{:name "RouteTableId", :shape "String"})]}))

(clojure.core/defn- req-disassociate-transit-gateway-route-table-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"}) (clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-regions-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :region-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-region-name-string-list (input :region-names)) #:http.request.field{:name "RegionNames", :shape "RegionNameStringList", :location-name "RegionName"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-vpn-connections-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :vpn-connection-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpn-connection-id-string-list (input :vpn-connection-ids)) #:http.request.field{:name "VpnConnectionIds", :shape "VpnConnectionIdStringList", :location-name "VpnConnectionId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-replace-route-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :route-table-id)) #:http.request.field{:name "RouteTableId", :shape "String", :location-name "routeTableId"})]} (clojure.core/contains? input :transit-gateway-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :transit-gateway-id)) #:http.request.field{:name "TransitGatewayId", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"})) (clojure.core/contains? input :nat-gateway-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :nat-gateway-id)) #:http.request.field{:name "NatGatewayId", :shape "String", :location-name "natGatewayId"})) (clojure.core/contains? input :network-interface-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})) (clojure.core/contains? input :destination-ipv-6-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :destination-ipv-6-cidr-block)) #:http.request.field{:name "DestinationIpv6CidrBlock", :shape "String", :location-name "destinationIpv6CidrBlock"})) (clojure.core/contains? input :destination-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :destination-cidr-block)) #:http.request.field{:name "DestinationCidrBlock", :shape "String", :location-name "destinationCidrBlock"})) (clojure.core/contains? input :vpc-peering-connection-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpc-peering-connection-id)) #:http.request.field{:name "VpcPeeringConnectionId", :shape "String", :location-name "vpcPeeringConnectionId"})) (clojure.core/contains? input :gateway-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :gateway-id)) #:http.request.field{:name "GatewayId", :shape "String", :location-name "gatewayId"})) (clojure.core/contains? input :egress-only-internet-gateway-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :egress-only-internet-gateway-id)) #:http.request.field{:name "EgressOnlyInternetGatewayId", :shape "String", :location-name "egressOnlyInternetGatewayId"}))))

(clojure.core/defn- req-unassign-ipv-6-addresses-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ipv-6-address-list (input :ipv-6-addresses)) #:http.request.field{:name "Ipv6Addresses", :shape "Ipv6AddressList", :location-name "ipv6Addresses"}) (clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})]}))

(clojure.core/defn- req-create-spot-datafeed-subscription-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :bucket)) #:http.request.field{:name "Bucket", :shape "String", :location-name "bucket"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :prefix) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :prefix)) #:http.request.field{:name "Prefix", :shape "String", :location-name "prefix"}))))

(clojure.core/defn- req-describe-snapshot-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-snapshot-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "SnapshotAttributeName"}) (clojure.core/into (ser-string (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-authorize-security-group-egress-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :group-id)) #:http.request.field{:name "GroupId", :shape "String", :location-name "groupId"})]} (clojure.core/contains? input :source-security-group-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-security-group-owner-id)) #:http.request.field{:name "SourceSecurityGroupOwnerId", :shape "String", :location-name "sourceSecurityGroupOwnerId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :to-port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :to-port)) #:http.request.field{:name "ToPort", :shape "Integer", :location-name "toPort"})) (clojure.core/contains? input :source-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-security-group-name)) #:http.request.field{:name "SourceSecurityGroupName", :shape "String", :location-name "sourceSecurityGroupName"})) (clojure.core/contains? input :ip-protocol) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ip-protocol)) #:http.request.field{:name "IpProtocol", :shape "String", :location-name "ipProtocol"})) (clojure.core/contains? input :from-port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :from-port)) #:http.request.field{:name "FromPort", :shape "Integer", :location-name "fromPort"})) (clojure.core/contains? input :ip-permissions) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ip-permission-list (input :ip-permissions)) #:http.request.field{:name "IpPermissions", :shape "IpPermissionList", :location-name "ipPermissions"})) (clojure.core/contains? input :cidr-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidr-ip)) #:http.request.field{:name "CidrIp", :shape "String", :location-name "cidrIp"}))))

(clojure.core/defn- req-import-key-pair-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :key-name)) #:http.request.field{:name "KeyName", :shape "String", :location-name "keyName"}) (clojure.core/into (ser-blob (input :public-key-material)) #:http.request.field{:name "PublicKeyMaterial", :shape "Blob", :location-name "publicKeyMaterial"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-transit-gateway-route-table-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-id)) #:http.request.field{:name "TransitGatewayId", :shape "String"})]} (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "TagSpecificationList"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-delete-tags-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-id-list (input :resources)) #:http.request.field{:name "Resources", :shape "ResourceIdList", :location-name "resourceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList", :location-name "tag"}))))

(clojure.core/defn- req-describe-dhcp-options-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dhcp-options-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dhcp-options-id-string-list (input :dhcp-options-ids)) #:http.request.field{:name "DhcpOptionsIds", :shape "DhcpOptionsIdStringList", :location-name "DhcpOptionsId"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-export-client-vpn-client-certificate-revocation-list-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-associate-iam-instance-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-iam-instance-profile-specification (input :iam-instance-profile)) #:http.request.field{:name "IamInstanceProfile", :shape "IamInstanceProfileSpecification"}) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"})]}))

(clojure.core/defn- req-describe-host-reservations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filter) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filter)) #:http.request.field{:name "Filter", :shape "FilterList"})) (clojure.core/contains? input :host-reservation-id-set) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-host-reservation-id-set (input :host-reservation-id-set)) #:http.request.field{:name "HostReservationIdSet", :shape "HostReservationIdSet"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-modify-launch-template-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"})) (clojure.core/contains? input :launch-template-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :launch-template-id)) #:http.request.field{:name "LaunchTemplateId", :shape "String"})) (clojure.core/contains? input :launch-template-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-name (input :launch-template-name)) #:http.request.field{:name "LaunchTemplateName", :shape "LaunchTemplateName"})) (clojure.core/contains? input :default-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :default-version)) #:http.request.field{:name "DefaultVersion", :shape "String", :location-name "SetDefaultVersion"}))))

(clojure.core/defn- req-assign-private-ip-addresses-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})]} (clojure.core/contains? input :allow-reassignment) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :allow-reassignment)) #:http.request.field{:name "AllowReassignment", :shape "Boolean", :location-name "allowReassignment"})) (clojure.core/contains? input :private-ip-addresses) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-private-ip-address-string-list (input :private-ip-addresses)) #:http.request.field{:name "PrivateIpAddresses", :shape "PrivateIpAddressStringList", :location-name "privateIpAddress"})) (clojure.core/contains? input :secondary-private-ip-address-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :secondary-private-ip-address-count)) #:http.request.field{:name "SecondaryPrivateIpAddressCount", :shape "Integer", :location-name "secondaryPrivateIpAddressCount"}))))

(clojure.core/defn- req-detach-network-interface-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :attachment-id)) #:http.request.field{:name "AttachmentId", :shape "String", :location-name "attachmentId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :force)) #:http.request.field{:name "Force", :shape "Boolean", :location-name "force"}))))

(clojure.core/defn- req-associate-address-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :allocation-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :allocation-id)) #:http.request.field{:name "AllocationId", :shape "String"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"})) (clojure.core/contains? input :public-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :public-ip)) #:http.request.field{:name "PublicIp", :shape "String"})) (clojure.core/contains? input :allow-reassociation) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :allow-reassociation)) #:http.request.field{:name "AllowReassociation", :shape "Boolean", :location-name "allowReassociation"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :network-interface-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})) (clojure.core/contains? input :private-ip-address) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-ip-address)) #:http.request.field{:name "PrivateIpAddress", :shape "String", :location-name "privateIpAddress"}))))

(clojure.core/defn- req-delete-client-vpn-endpoint-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-create-internet-gateway-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-reset-fpga-image-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :fpga-image-id)) #:http.request.field{:name "FpgaImageId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :attribute) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-reset-fpga-image-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "ResetFpgaImageAttributeName"}))))

(clojure.core/defn- req-cancel-spot-instance-requests-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-spot-instance-request-id-list (input :spot-instance-request-ids)) #:http.request.field{:name "SpotInstanceRequestIds", :shape "SpotInstanceRequestIdList", :location-name "SpotInstanceRequestId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-get-console-output-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :latest) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :latest)) #:http.request.field{:name "Latest", :shape "Boolean"}))))

(clojure.core/defn- req-associate-transit-gateway-route-table-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"}) (clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-nat-gateways-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filter) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filter)) #:http.request.field{:name "Filter", :shape "FilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :nat-gateway-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :nat-gateway-ids)) #:http.request.field{:name "NatGatewayIds", :shape "ValueStringList", :location-name "NatGatewayId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-create-vpc-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cidr-block)) #:http.request.field{:name "CidrBlock", :shape "String"})]} (clojure.core/contains? input :amazon-provided-ipv-6-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :amazon-provided-ipv-6-cidr-block)) #:http.request.field{:name "AmazonProvidedIpv6CidrBlock", :shape "Boolean", :location-name "amazonProvidedIpv6CidrBlock"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :instance-tenancy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tenancy (input :instance-tenancy)) #:http.request.field{:name "InstanceTenancy", :shape "Tenancy", :location-name "instanceTenancy"}))))

(clojure.core/defn- req-request-spot-instances-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :availability-zone-group) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone-group)) #:http.request.field{:name "AvailabilityZoneGroup", :shape "String", :location-name "availabilityZoneGroup"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-instance-type (input :type)) #:http.request.field{:name "Type", :shape "SpotInstanceType", :location-name "type"})) (clojure.core/contains? input :instance-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :instance-count)) #:http.request.field{:name "InstanceCount", :shape "Integer", :location-name "instanceCount"})) (clojure.core/contains? input :block-duration-minutes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :block-duration-minutes)) #:http.request.field{:name "BlockDurationMinutes", :shape "Integer", :location-name "blockDurationMinutes"})) (clojure.core/contains? input :valid-from) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :valid-from)) #:http.request.field{:name "ValidFrom", :shape "DateTime", :location-name "validFrom"})) (clojure.core/contains? input :launch-specification) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-request-spot-launch-specification (input :launch-specification)) #:http.request.field{:name "LaunchSpecification", :shape "RequestSpotLaunchSpecification"})) (clojure.core/contains? input :spot-price) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :spot-price)) #:http.request.field{:name "SpotPrice", :shape "String", :location-name "spotPrice"})) (clojure.core/contains? input :instance-interruption-behavior) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-interruption-behavior (input :instance-interruption-behavior)) #:http.request.field{:name "InstanceInterruptionBehavior", :shape "InstanceInterruptionBehavior"})) (clojure.core/contains? input :launch-group) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :launch-group)) #:http.request.field{:name "LaunchGroup", :shape "String", :location-name "launchGroup"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String", :location-name "clientToken"})) (clojure.core/contains? input :valid-until) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :valid-until)) #:http.request.field{:name "ValidUntil", :shape "DateTime", :location-name "validUntil"}))))

(clojure.core/defn- req-create-network-acl-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-bundle-tasks-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :bundle-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-bundle-id-string-list (input :bundle-ids)) #:http.request.field{:name "BundleIds", :shape "BundleIdStringList", :location-name "BundleId"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-instances-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :instance-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id-string-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdStringList", :location-name "InstanceId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"}))))

(clojure.core/defn- req-create-nat-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :allocation-id)) #:http.request.field{:name "AllocationId", :shape "String"}) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String"})]} (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"}))))

(clojure.core/defn- req-describe-volume-status-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :volume-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-volume-id-string-list (input :volume-ids)) #:http.request.field{:name "VolumeIds", :shape "VolumeIdStringList", :location-name "VolumeId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-associate-client-vpn-target-network-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"}) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-terminate-client-vpn-connections-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"})]} (clojure.core/contains? input :connection-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :connection-id)) #:http.request.field{:name "ConnectionId", :shape "String"})) (clojure.core/contains? input :username) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :username)) #:http.request.field{:name "Username", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-allocate-address-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :domain) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-domain-type (input :domain)) #:http.request.field{:name "Domain", :shape "DomainType"})) (clojure.core/contains? input :address) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :address)) #:http.request.field{:name "Address", :shape "String"})) (clojure.core/contains? input :public-ipv-4-pool) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :public-ipv-4-pool)) #:http.request.field{:name "PublicIpv4Pool", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-import-snapshot-tasks-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList"})) (clojure.core/contains? input :import-task-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-import-task-id-list (input :import-task-ids)) #:http.request.field{:name "ImportTaskIds", :shape "ImportTaskIdList", :location-name "ImportTaskId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-describe-vpc-peering-connections-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :vpc-peering-connection-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :vpc-peering-connection-ids)) #:http.request.field{:name "VpcPeeringConnectionIds", :shape "ValueStringList", :location-name "VpcPeeringConnectionId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-describe-vpc-peering-connections-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "DescribeVpcPeeringConnectionsMaxResults"}))))

(clojure.core/defn- req-describe-network-interface-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})]} (clojure.core/contains? input :attribute) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-network-interface-attribute (input :attribute)) #:http.request.field{:name "Attribute", :shape "NetworkInterfaceAttribute", :location-name "attribute"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-client-vpn-routes-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-restore-address-to-classic-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :public-ip)) #:http.request.field{:name "PublicIp", :shape "String", :location-name "publicIp"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-disable-vpc-classic-link-dns-support-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :vpc-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"}))))

(clojure.core/defn- req-delete-route-table-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :route-table-id)) #:http.request.field{:name "RouteTableId", :shape "String", :location-name "routeTableId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-launch-templates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :launch-template-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :launch-template-ids)) #:http.request.field{:name "LaunchTemplateIds", :shape "ValueStringList", :location-name "LaunchTemplateId"})) (clojure.core/contains? input :launch-template-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-name-string-list (input :launch-template-names)) #:http.request.field{:name "LaunchTemplateNames", :shape "LaunchTemplateNameStringList", :location-name "LaunchTemplateName"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"}))))

(clojure.core/defn- req-describe-image-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-image-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "ImageAttributeName"}) (clojure.core/into (ser-string (input :image-id)) #:http.request.field{:name "ImageId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-customer-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-integer (input :bgp-asn)) #:http.request.field{:name "BgpAsn", :shape "Integer"}) (clojure.core/into (ser-string (input :public-ip)) #:http.request.field{:name "PublicIp", :shape "String", :location-name "IpAddress"}) (clojure.core/into (ser-gateway-type (input :type)) #:http.request.field{:name "Type", :shape "GatewayType"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-import-volume-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String", :location-name "availabilityZone"}) (clojure.core/into (ser-disk-image-detail (input :image)) #:http.request.field{:name "Image", :shape "DiskImageDetail", :location-name "image"}) (clojure.core/into (ser-volume-detail (input :volume)) #:http.request.field{:name "Volume", :shape "VolumeDetail", :location-name "volume"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-modify-instance-placement-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"})]} (clojure.core/contains? input :affinity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-affinity (input :affinity)) #:http.request.field{:name "Affinity", :shape "Affinity", :location-name "affinity"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String"})) (clojure.core/contains? input :host-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :host-id)) #:http.request.field{:name "HostId", :shape "String", :location-name "hostId"})) (clojure.core/contains? input :tenancy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-host-tenancy (input :tenancy)) #:http.request.field{:name "Tenancy", :shape "HostTenancy", :location-name "tenancy"})) (clojure.core/contains? input :partition-number) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :partition-number)) #:http.request.field{:name "PartitionNumber", :shape "Integer"}))))

(clojure.core/defn- req-describe-client-vpn-authorization-rules-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults"}))))

(clojure.core/defn- req-describe-egress-only-internet-gateways-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :egress-only-internet-gateway-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-egress-only-internet-gateway-id-list (input :egress-only-internet-gateway-ids)) #:http.request.field{:name "EgressOnlyInternetGatewayIds", :shape "EgressOnlyInternetGatewayIdList", :location-name "EgressOnlyInternetGatewayId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-create-vpc-peering-connection-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :peer-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :peer-owner-id)) #:http.request.field{:name "PeerOwnerId", :shape "String", :location-name "peerOwnerId"})) (clojure.core/contains? input :peer-vpc-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :peer-vpc-id)) #:http.request.field{:name "PeerVpcId", :shape "String", :location-name "peerVpcId"})) (clojure.core/contains? input :vpc-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})) (clojure.core/contains? input :peer-region) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :peer-region)) #:http.request.field{:name "PeerRegion", :shape "String"}))))

(clojure.core/defn- req-describe-client-vpn-connections-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-capacity-reservations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :capacity-reservation-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-capacity-reservation-id-set (input :capacity-reservation-ids)) #:http.request.field{:name "CapacityReservationIds", :shape "CapacityReservationIdSet", :location-name "CapacityReservationId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-provision-byoip-cidr-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cidr)) #:http.request.field{:name "Cidr", :shape "String"})]} (clojure.core/contains? input :cidr-authorization-context) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cidr-authorization-context (input :cidr-authorization-context)) #:http.request.field{:name "CidrAuthorizationContext", :shape "CidrAuthorizationContext"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-disable-vgw-route-propagation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :gateway-id)) #:http.request.field{:name "GatewayId", :shape "String"}) (clojure.core/into (ser-string (input :route-table-id)) #:http.request.field{:name "RouteTableId", :shape "String"})]}))

(clojure.core/defn- req-create-launch-template-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-launch-template-name (input :launch-template-name)) #:http.request.field{:name "LaunchTemplateName", :shape "LaunchTemplateName"}) (clojure.core/into (ser-request-launch-template-data (input :launch-template-data)) #:http.request.field{:name "LaunchTemplateData", :shape "RequestLaunchTemplateData"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"})) (clojure.core/contains? input :version-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-version-description (input :version-description)) #:http.request.field{:name "VersionDescription", :shape "VersionDescription"}))))

(clojure.core/defn- req-describe-reserved-instances-listings-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :reserved-instances-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-instances-id)) #:http.request.field{:name "ReservedInstancesId", :shape "String", :location-name "reservedInstancesId"})) (clojure.core/contains? input :reserved-instances-listing-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-instances-listing-id)) #:http.request.field{:name "ReservedInstancesListingId", :shape "String", :location-name "reservedInstancesListingId"}))))

(clojure.core/defn- req-create-subnet-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cidr-block)) #:http.request.field{:name "CidrBlock", :shape "String"}) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"})]} (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :availability-zone-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone-id)) #:http.request.field{:name "AvailabilityZoneId", :shape "String"})) (clojure.core/contains? input :ipv-6-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ipv-6-cidr-block)) #:http.request.field{:name "Ipv6CidrBlock", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-fpga-image-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :fpga-image-id)) #:http.request.field{:name "FpgaImageId", :shape "String"}) (clojure.core/into (ser-fpga-image-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "FpgaImageAttributeName"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-transit-gateway-vpc-attachments-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :transit-gateway-attachment-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-attachment-id-string-list (input :transit-gateway-attachment-ids)) #:http.request.field{:name "TransitGatewayAttachmentIds", :shape "TransitGatewayAttachmentIdStringList"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "TransitGatewayMaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-delete-client-vpn-route-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"}) (clojure.core/into (ser-string (input :destination-cidr-block)) #:http.request.field{:name "DestinationCidrBlock", :shape "String"})]} (clojure.core/contains? input :target-vpc-subnet-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :target-vpc-subnet-id)) #:http.request.field{:name "TargetVpcSubnetId", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-update-security-group-rule-descriptions-ingress-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ip-permission-list (input :ip-permissions)) #:http.request.field{:name "IpPermissions", :shape "IpPermissionList"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-id)) #:http.request.field{:name "GroupId", :shape "String"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String"}))))

(clojure.core/defn- req-modify-vpc-peering-connection-options-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-peering-connection-id)) #:http.request.field{:name "VpcPeeringConnectionId", :shape "String"})]} (clojure.core/contains? input :accepter-peering-connection-options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-peering-connection-options-request (input :accepter-peering-connection-options)) #:http.request.field{:name "AccepterPeeringConnectionOptions", :shape "PeeringConnectionOptionsRequest"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :requester-peering-connection-options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-peering-connection-options-request (input :requester-peering-connection-options)) #:http.request.field{:name "RequesterPeeringConnectionOptions", :shape "PeeringConnectionOptionsRequest"}))))

(clojure.core/defn- req-get-password-data-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-vpc-endpoint-service-configuration-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-value-string-list (input :network-load-balancer-arns)) #:http.request.field{:name "NetworkLoadBalancerArns", :shape "ValueStringList", :location-name "NetworkLoadBalancerArn"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :acceptance-required) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :acceptance-required)) #:http.request.field{:name "AcceptanceRequired", :shape "Boolean"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"}))))

(clojure.core/defn- req-describe-transit-gateway-attachments-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :transit-gateway-attachment-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-attachment-id-string-list (input :transit-gateway-attachment-ids)) #:http.request.field{:name "TransitGatewayAttachmentIds", :shape "TransitGatewayAttachmentIdStringList"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "TransitGatewayMaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-modify-volume-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :volume-id)) #:http.request.field{:name "VolumeId", :shape "String"})]} (clojure.core/contains? input :auto-enable-io) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-boolean-value (input :auto-enable-io)) #:http.request.field{:name "AutoEnableIO", :shape "AttributeBooleanValue"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-identity-id-format-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :principal-arn)) #:http.request.field{:name "PrincipalArn", :shape "String", :location-name "principalArn"})]} (clojure.core/contains? input :resource) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :resource)) #:http.request.field{:name "Resource", :shape "String", :location-name "resource"}))))

(clojure.core/defn- req-describe-spot-datafeed-subscription-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-network-acl-entry-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-boolean (input :egress)) #:http.request.field{:name "Egress", :shape "Boolean", :location-name "egress"}) (clojure.core/into (ser-string (input :network-acl-id)) #:http.request.field{:name "NetworkAclId", :shape "String", :location-name "networkAclId"}) (clojure.core/into (ser-string (input :protocol)) #:http.request.field{:name "Protocol", :shape "String", :location-name "protocol"}) (clojure.core/into (ser-rule-action (input :rule-action)) #:http.request.field{:name "RuleAction", :shape "RuleAction", :location-name "ruleAction"}) (clojure.core/into (ser-integer (input :rule-number)) #:http.request.field{:name "RuleNumber", :shape "Integer", :location-name "ruleNumber"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :icmp-type-code) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-icmp-type-code (input :icmp-type-code)) #:http.request.field{:name "IcmpTypeCode", :shape "IcmpTypeCode", :location-name "Icmp"})) (clojure.core/contains? input :cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidr-block)) #:http.request.field{:name "CidrBlock", :shape "String", :location-name "cidrBlock"})) (clojure.core/contains? input :ipv-6-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ipv-6-cidr-block)) #:http.request.field{:name "Ipv6CidrBlock", :shape "String", :location-name "ipv6CidrBlock"})) (clojure.core/contains? input :port-range) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-port-range (input :port-range)) #:http.request.field{:name "PortRange", :shape "PortRange", :location-name "portRange"}))))

(clojure.core/defn- req-enable-transit-gateway-route-table-propagation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"}) (clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-accept-vpc-endpoint-connections-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :service-id)) #:http.request.field{:name "ServiceId", :shape "String"}) (clojure.core/into (ser-value-string-list (input :vpc-endpoint-ids)) #:http.request.field{:name "VpcEndpointIds", :shape "ValueStringList", :location-name "VpcEndpointId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-delete-key-pair-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :key-name)) #:http.request.field{:name "KeyName", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-deregister-image-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :image-id)) #:http.request.field{:name "ImageId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-get-launch-template-data-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-delete-vpc-endpoints-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-value-string-list (input :vpc-endpoint-ids)) #:http.request.field{:name "VpcEndpointIds", :shape "ValueStringList", :location-name "VpcEndpointId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-copy-fpga-image-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :source-fpga-image-id)) #:http.request.field{:name "SourceFpgaImageId", :shape "String"}) (clojure.core/into (ser-string (input :source-region)) #:http.request.field{:name "SourceRegion", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"}))))

(clojure.core/defn- req-modify-capacity-reservation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :capacity-reservation-id)) #:http.request.field{:name "CapacityReservationId", :shape "String"})]} (clojure.core/contains? input :instance-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :instance-count)) #:http.request.field{:name "InstanceCount", :shape "Integer"})) (clojure.core/contains? input :end-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :end-date)) #:http.request.field{:name "EndDate", :shape "DateTime"})) (clojure.core/contains? input :end-date-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-end-date-type (input :end-date-type)) #:http.request.field{:name "EndDateType", :shape "EndDateType"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-create-dhcp-options-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-new-dhcp-configuration-list (input :dhcp-configurations)) #:http.request.field{:name "DhcpConfigurations", :shape "NewDhcpConfigurationList", :location-name "dhcpConfiguration"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-accept-transit-gateway-vpc-attachment-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-search-transit-gateway-routes-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"}) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "TransitGatewayMaxResults"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-route-tables-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :route-table-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :route-table-ids)) #:http.request.field{:name "RouteTableIds", :shape "ValueStringList", :location-name "RouteTableId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"}))))

(clojure.core/defn- req-create-launch-template-version-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-request-launch-template-data (input :launch-template-data)) #:http.request.field{:name "LaunchTemplateData", :shape "RequestLaunchTemplateData"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"})) (clojure.core/contains? input :launch-template-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :launch-template-id)) #:http.request.field{:name "LaunchTemplateId", :shape "String"})) (clojure.core/contains? input :launch-template-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-name (input :launch-template-name)) #:http.request.field{:name "LaunchTemplateName", :shape "LaunchTemplateName"})) (clojure.core/contains? input :source-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-version)) #:http.request.field{:name "SourceVersion", :shape "String"})) (clojure.core/contains? input :version-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-version-description (input :version-description)) #:http.request.field{:name "VersionDescription", :shape "VersionDescription"}))))

(clojure.core/defn- req-describe-vpc-endpoint-connection-notifications-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :connection-notification-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :connection-notification-id)) #:http.request.field{:name "ConnectionNotificationId", :shape "String"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-modify-fleet-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-fleet-identifier (input :fleet-id)) #:http.request.field{:name "FleetId", :shape "FleetIdentifier"}) (clojure.core/into (ser-target-capacity-specification-request (input :target-capacity-specification)) #:http.request.field{:name "TargetCapacitySpecification", :shape "TargetCapacitySpecificationRequest"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :excess-capacity-termination-policy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fleet-excess-capacity-termination-policy (input :excess-capacity-termination-policy)) #:http.request.field{:name "ExcessCapacityTerminationPolicy", :shape "FleetExcessCapacityTerminationPolicy"}))))

(clojure.core/defn- req-create-instance-export-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"})) (clojure.core/contains? input :export-to-s-3-task) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-export-to-s-3-task-specification (input :export-to-s-3-task)) #:http.request.field{:name "ExportToS3Task", :shape "ExportToS3TaskSpecification", :location-name "exportToS3"})) (clojure.core/contains? input :target-environment) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-export-environment (input :target-environment)) #:http.request.field{:name "TargetEnvironment", :shape "ExportEnvironment", :location-name "targetEnvironment"}))))

(clojure.core/defn- req-create-tags-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-id-list (input :resources)) #:http.request.field{:name "Resources", :shape "ResourceIdList", :location-name "ResourceId"}) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList", :location-name "Tag"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-fleet-history-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-fleet-identifier (input :fleet-id)) #:http.request.field{:name "FleetId", :shape "FleetIdentifier"}) (clojure.core/into (ser-date-time (input :start-time)) #:http.request.field{:name "StartTime", :shape "DateTime"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :event-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fleet-event-type (input :event-type)) #:http.request.field{:name "EventType", :shape "FleetEventType"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-cancel-reserved-instances-listing-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-instances-listing-id)) #:http.request.field{:name "ReservedInstancesListingId", :shape "String", :location-name "reservedInstancesListingId"})]}))

(clojure.core/defn- req-attach-vpn-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"}) (clojure.core/into (ser-string (input :vpn-gateway-id)) #:http.request.field{:name "VpnGatewayId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-transit-gateway-route-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"}) (clojure.core/into (ser-string (input :destination-cidr-block)) #:http.request.field{:name "DestinationCidrBlock", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-disassociate-client-vpn-target-network-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"}) (clojure.core/into (ser-string (input :association-id)) #:http.request.field{:name "AssociationId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-cancel-spot-fleet-requests-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-value-string-list (input :spot-fleet-request-ids)) #:http.request.field{:name "SpotFleetRequestIds", :shape "ValueStringList", :location-name "spotFleetRequestId"}) (clojure.core/into (ser-boolean (input :terminate-instances)) #:http.request.field{:name "TerminateInstances", :shape "Boolean", :location-name "terminateInstances"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-associate-route-table-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :route-table-id)) #:http.request.field{:name "RouteTableId", :shape "String", :location-name "routeTableId"}) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String", :location-name "subnetId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-public-ipv-4-pools-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :pool-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :pool-ids)) #:http.request.field{:name "PoolIds", :shape "ValueStringList", :location-name "PoolId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-pool-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PoolMaxResults"}))))

(clojure.core/defn- req-detach-internet-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :internet-gateway-id)) #:http.request.field{:name "InternetGatewayId", :shape "String", :location-name "internetGatewayId"}) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-withdraw-byoip-cidr-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cidr)) #:http.request.field{:name "Cidr", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-enable-volume-io-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :volume-id)) #:http.request.field{:name "VolumeId", :shape "String", :location-name "volumeId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-subnet-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-associate-vpc-cidr-block-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})]} (clojure.core/contains? input :amazon-provided-ipv-6-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :amazon-provided-ipv-6-cidr-block)) #:http.request.field{:name "AmazonProvidedIpv6CidrBlock", :shape "Boolean", :location-name "amazonProvidedIpv6CidrBlock"})) (clojure.core/contains? input :cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidr-block)) #:http.request.field{:name "CidrBlock", :shape "String"}))))

(clojure.core/defn- req-disable-transit-gateway-route-table-propagation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"}) (clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-modify-subnet-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String", :location-name "subnetId"})]} (clojure.core/contains? input :assign-ipv-6-address-on-creation) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-boolean-value (input :assign-ipv-6-address-on-creation)) #:http.request.field{:name "AssignIpv6AddressOnCreation", :shape "AttributeBooleanValue"})) (clojure.core/contains? input :map-public-ip-on-launch) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-boolean-value (input :map-public-ip-on-launch)) #:http.request.field{:name "MapPublicIpOnLaunch", :shape "AttributeBooleanValue"}))))

(clojure.core/defn- req-deprovision-byoip-cidr-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cidr)) #:http.request.field{:name "Cidr", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-delete-spot-datafeed-subscription-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-disassociate-vpc-cidr-block-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :association-id)) #:http.request.field{:name "AssociationId", :shape "String", :location-name "associationId"})]}))

(clojure.core/defn- req-update-security-group-rule-descriptions-egress-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ip-permission-list (input :ip-permissions)) #:http.request.field{:name "IpPermissions", :shape "IpPermissionList"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-id)) #:http.request.field{:name "GroupId", :shape "String"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String"}))))

(clojure.core/defn- req-describe-security-group-references-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-group-ids (input :group-id)) #:http.request.field{:name "GroupId", :shape "GroupIds"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-vpcs-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :vpc-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-id-string-list (input :vpc-ids)) #:http.request.field{:name "VpcIds", :shape "VpcIdStringList", :location-name "VpcId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-describe-vpcs-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "DescribeVpcsMaxResults"}))))

(clojure.core/defn- req-delete-route-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :route-table-id)) #:http.request.field{:name "RouteTableId", :shape "String", :location-name "routeTableId"})]} (clojure.core/contains? input :destination-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :destination-cidr-block)) #:http.request.field{:name "DestinationCidrBlock", :shape "String", :location-name "destinationCidrBlock"})) (clojure.core/contains? input :destination-ipv-6-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :destination-ipv-6-cidr-block)) #:http.request.field{:name "DestinationIpv6CidrBlock", :shape "String", :location-name "destinationIpv6CidrBlock"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-vpc-endpoint-services-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :service-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :service-names)) #:http.request.field{:name "ServiceNames", :shape "ValueStringList", :location-name "ServiceName"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-reboot-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id-string-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdStringList", :location-name "InstanceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-replace-network-acl-entry-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-boolean (input :egress)) #:http.request.field{:name "Egress", :shape "Boolean", :location-name "egress"}) (clojure.core/into (ser-string (input :network-acl-id)) #:http.request.field{:name "NetworkAclId", :shape "String", :location-name "networkAclId"}) (clojure.core/into (ser-string (input :protocol)) #:http.request.field{:name "Protocol", :shape "String", :location-name "protocol"}) (clojure.core/into (ser-rule-action (input :rule-action)) #:http.request.field{:name "RuleAction", :shape "RuleAction", :location-name "ruleAction"}) (clojure.core/into (ser-integer (input :rule-number)) #:http.request.field{:name "RuleNumber", :shape "Integer", :location-name "ruleNumber"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :icmp-type-code) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-icmp-type-code (input :icmp-type-code)) #:http.request.field{:name "IcmpTypeCode", :shape "IcmpTypeCode", :location-name "Icmp"})) (clojure.core/contains? input :cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidr-block)) #:http.request.field{:name "CidrBlock", :shape "String", :location-name "cidrBlock"})) (clojure.core/contains? input :ipv-6-cidr-block) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ipv-6-cidr-block)) #:http.request.field{:name "Ipv6CidrBlock", :shape "String", :location-name "ipv6CidrBlock"})) (clojure.core/contains? input :port-range) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-port-range (input :port-range)) #:http.request.field{:name "PortRange", :shape "PortRange", :location-name "portRange"}))))

(clojure.core/defn- req-delete-vpc-endpoint-service-configurations-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-value-string-list (input :service-ids)) #:http.request.field{:name "ServiceIds", :shape "ValueStringList", :location-name "ServiceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-volumes-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :volume-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-volume-id-string-list (input :volume-ids)) #:http.request.field{:name "VolumeIds", :shape "VolumeIdStringList", :location-name "VolumeId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"}))))

(clojure.core/defn- req-create-transit-gateway-vpc-attachment-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-id)) #:http.request.field{:name "TransitGatewayId", :shape "String"}) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"}) (clojure.core/into (ser-value-string-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "ValueStringList"})]} (clojure.core/contains? input :options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-create-transit-gateway-vpc-attachment-request-options (input :options)) #:http.request.field{:name "Options", :shape "CreateTransitGatewayVpcAttachmentRequestOptions"})) (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "TagSpecificationList"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-delete-transit-gateway-vpc-attachment-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-account-attributes-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :attribute-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-account-attribute-name-string-list (input :attribute-names)) #:http.request.field{:name "AttributeNames", :shape "AccountAttributeNameStringList", :location-name "attributeName"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-enable-vpc-classic-link-dns-support-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :vpc-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"}))))

(clojure.core/defn- req-describe-client-vpn-target-networks-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"})]} (clojure.core/contains? input :association-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :association-ids)) #:http.request.field{:name "AssociationIds", :shape "ValueStringList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-tags-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"}))))

(clojure.core/defn- req-attach-network-interface-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-integer (input :device-index)) #:http.request.field{:name "DeviceIndex", :shape "Integer", :location-name "deviceIndex"}) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"}) (clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-network-interface-permission-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :network-interface-permission-id)) #:http.request.field{:name "NetworkInterfacePermissionId", :shape "String"})]} (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :force)) #:http.request.field{:name "Force", :shape "Boolean"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-release-hosts-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-request-host-id-list (input :host-ids)) #:http.request.field{:name "HostIds", :shape "RequestHostIdList", :location-name "hostId"})]}))

(clojure.core/defn- req-get-reserved-instances-exchange-quote-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-reserved-instance-id-set (input :reserved-instance-ids)) #:http.request.field{:name "ReservedInstanceIds", :shape "ReservedInstanceIdSet", :location-name "ReservedInstanceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :target-configurations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-configuration-request-set (input :target-configurations)) #:http.request.field{:name "TargetConfigurations", :shape "TargetConfigurationRequestSet", :location-name "TargetConfiguration"}))))

(clojure.core/defn- req-replace-transit-gateway-route-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :destination-cidr-block)) #:http.request.field{:name "DestinationCidrBlock", :shape "String"}) (clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"})]} (clojure.core/contains? input :transit-gateway-attachment-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})) (clojure.core/contains? input :blackhole) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :blackhole)) #:http.request.field{:name "Blackhole", :shape "Boolean"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-report-instance-status-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id-string-list (input :instances)) #:http.request.field{:name "Instances", :shape "InstanceIdStringList", :location-name "instanceId"}) (clojure.core/into (ser-reason-codes-list (input :reason-codes)) #:http.request.field{:name "ReasonCodes", :shape "ReasonCodesList", :location-name "reasonCode"}) (clojure.core/into (ser-report-status-type (input :status)) #:http.request.field{:name "Status", :shape "ReportStatusType", :location-name "status"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :end-time)) #:http.request.field{:name "EndTime", :shape "DateTime", :location-name "endTime"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :start-time)) #:http.request.field{:name "StartTime", :shape "DateTime", :location-name "startTime"}))))

(clojure.core/defn- req-create-flow-logs-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-value-string-list (input :resource-ids)) #:http.request.field{:name "ResourceIds", :shape "ValueStringList", :location-name "ResourceId"}) (clojure.core/into (ser-flow-logs-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "FlowLogsResourceType"}) (clojure.core/into (ser-traffic-type (input :traffic-type)) #:http.request.field{:name "TrafficType", :shape "TrafficType"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :deliver-logs-permission-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :deliver-logs-permission-arn)) #:http.request.field{:name "DeliverLogsPermissionArn", :shape "String"})) (clojure.core/contains? input :log-destination-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-log-destination-type (input :log-destination-type)) #:http.request.field{:name "LogDestinationType", :shape "LogDestinationType"})) (clojure.core/contains? input :log-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :log-group-name)) #:http.request.field{:name "LogGroupName", :shape "String"})) (clojure.core/contains? input :log-destination) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :log-destination)) #:http.request.field{:name "LogDestination", :shape "String"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"}))))

(clojure.core/defn- req-describe-images-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :executable-users) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-executable-by-string-list (input :executable-users)) #:http.request.field{:name "ExecutableUsers", :shape "ExecutableByStringList", :location-name "ExecutableBy"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :image-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-image-id-string-list (input :image-ids)) #:http.request.field{:name "ImageIds", :shape "ImageIdStringList", :location-name "ImageId"})) (clojure.core/contains? input :owners) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-owner-string-list (input :owners)) #:http.request.field{:name "Owners", :shape "OwnerStringList", :location-name "Owner"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-modify-network-interface-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})]} (clojure.core/contains? input :attachment) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-network-interface-attachment-changes (input :attachment)) #:http.request.field{:name "Attachment", :shape "NetworkInterfaceAttachmentChanges", :location-name "attachment"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-value (input :description)) #:http.request.field{:name "Description", :shape "AttributeValue", :location-name "description"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-id-string-list (input :groups)) #:http.request.field{:name "Groups", :shape "SecurityGroupIdStringList", :location-name "SecurityGroupId"})) (clojure.core/contains? input :source-dest-check) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-boolean-value (input :source-dest-check)) #:http.request.field{:name "SourceDestCheck", :shape "AttributeBooleanValue", :location-name "sourceDestCheck"}))))

(clojure.core/defn- req-revoke-client-vpn-ingress-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"}) (clojure.core/into (ser-string (input :target-network-cidr)) #:http.request.field{:name "TargetNetworkCidr", :shape "String"})]} (clojure.core/contains? input :access-group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :access-group-id)) #:http.request.field{:name "AccessGroupId", :shape "String"})) (clojure.core/contains? input :revoke-all-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :revoke-all-groups)) #:http.request.field{:name "RevokeAllGroups", :shape "Boolean"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-cancel-bundle-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :bundle-id)) #:http.request.field{:name "BundleId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-reset-image-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-reset-image-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "ResetImageAttributeName"}) (clojure.core/into (ser-string (input :image-id)) #:http.request.field{:name "ImageId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-cancel-import-task-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :cancel-reason) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cancel-reason)) #:http.request.field{:name "CancelReason", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :import-task-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :import-task-id)) #:http.request.field{:name "ImportTaskId", :shape "String"}))))

(clojure.core/defn- req-modify-instance-credit-specification-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-credit-specification-list-request (input :instance-credit-specifications)) #:http.request.field{:name "InstanceCreditSpecifications", :shape "InstanceCreditSpecificationListRequest", :location-name "InstanceCreditSpecification"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"}))))

(clojure.core/defn- req-describe-classic-link-instances-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :instance-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id-string-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdStringList", :location-name "InstanceId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"}))))

(clojure.core/defn- req-create-default-vpc-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-vpc-endpoints-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :vpc-endpoint-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :vpc-endpoint-ids)) #:http.request.field{:name "VpcEndpointIds", :shape "ValueStringList", :location-name "VpcEndpointId"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-describe-scheduled-instance-availability-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-slot-date-time-range-request (input :first-slot-start-time-range)) #:http.request.field{:name "FirstSlotStartTimeRange", :shape "SlotDateTimeRangeRequest"}) (clojure.core/into (ser-scheduled-instance-recurrence-request (input :recurrence)) #:http.request.field{:name "Recurrence", :shape "ScheduledInstanceRecurrenceRequest"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :max-slot-duration-in-hours) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-slot-duration-in-hours)) #:http.request.field{:name "MaxSlotDurationInHours", :shape "Integer"})) (clojure.core/contains? input :min-slot-duration-in-hours) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :min-slot-duration-in-hours)) #:http.request.field{:name "MinSlotDurationInHours", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-describe-customer-gateways-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :customer-gateway-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-customer-gateway-id-string-list (input :customer-gateway-ids)) #:http.request.field{:name "CustomerGatewayIds", :shape "CustomerGatewayIdStringList", :location-name "CustomerGatewayId"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-host-reservation-offerings-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filter) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filter)) #:http.request.field{:name "Filter", :shape "FilterList"})) (clojure.core/contains? input :max-duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-duration)) #:http.request.field{:name "MaxDuration", :shape "Integer"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :min-duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :min-duration)) #:http.request.field{:name "MinDuration", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :offering-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :offering-id)) #:http.request.field{:name "OfferingId", :shape "String"}))))

(clojure.core/defn- req-reset-snapshot-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-snapshot-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "SnapshotAttributeName"}) (clojure.core/into (ser-string (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-import-client-vpn-client-certificate-revocation-list-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"}) (clojure.core/into (ser-string (input :certificate-revocation-list)) #:http.request.field{:name "CertificateRevocationList", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-delete-transit-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-id)) #:http.request.field{:name "TransitGatewayId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-fleets-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :fleet-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fleet-id-set (input :fleet-ids)) #:http.request.field{:name "FleetIds", :shape "FleetIdSet", :location-name "FleetId"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"}))))

(clojure.core/defn- req-delete-vpn-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpn-gateway-id)) #:http.request.field{:name "VpnGatewayId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-attach-classic-link-vpc-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-group-id-string-list (input :groups)) #:http.request.field{:name "Groups", :shape "GroupIdStringList", :location-name "SecurityGroupId"}) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"}) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-modify-snapshot-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "String"})]} (clojure.core/contains? input :attribute) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-snapshot-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "SnapshotAttributeName"})) (clojure.core/contains? input :create-volume-permission) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-create-volume-permission-modifications (input :create-volume-permission)) #:http.request.field{:name "CreateVolumePermission", :shape "CreateVolumePermissionModifications"})) (clojure.core/contains? input :group-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-group-name-string-list (input :group-names)) #:http.request.field{:name "GroupNames", :shape "GroupNameStringList", :location-name "UserGroup"})) (clojure.core/contains? input :operation-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-operation-type (input :operation-type)) #:http.request.field{:name "OperationType", :shape "OperationType"})) (clojure.core/contains? input :user-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-id-string-list (input :user-ids)) #:http.request.field{:name "UserIds", :shape "UserIdStringList", :location-name "UserId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-modify-fpga-image-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :fpga-image-id)) #:http.request.field{:name "FpgaImageId", :shape "String"})]} (clojure.core/contains? input :user-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-id-string-list (input :user-ids)) #:http.request.field{:name "UserIds", :shape "UserIdStringList", :location-name "UserId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :attribute) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fpga-image-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "FpgaImageAttributeName"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :operation-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-operation-type (input :operation-type)) #:http.request.field{:name "OperationType", :shape "OperationType"})) (clojure.core/contains? input :load-permission) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-load-permission-modifications (input :load-permission)) #:http.request.field{:name "LoadPermission", :shape "LoadPermissionModifications"})) (clojure.core/contains? input :product-codes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-product-code-string-list (input :product-codes)) #:http.request.field{:name "ProductCodes", :shape "ProductCodeStringList", :location-name "ProductCode"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "String"})) (clojure.core/contains? input :user-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-group-string-list (input :user-groups)) #:http.request.field{:name "UserGroups", :shape "UserGroupStringList", :location-name "UserGroup"}))))

(clojure.core/defn- req-modify-vpc-endpoint-service-configuration-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :service-id)) #:http.request.field{:name "ServiceId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :acceptance-required) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :acceptance-required)) #:http.request.field{:name "AcceptanceRequired", :shape "Boolean"})) (clojure.core/contains? input :add-network-load-balancer-arns) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :add-network-load-balancer-arns)) #:http.request.field{:name "AddNetworkLoadBalancerArns", :shape "ValueStringList", :location-name "AddNetworkLoadBalancerArn"})) (clojure.core/contains? input :remove-network-load-balancer-arns) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :remove-network-load-balancer-arns)) #:http.request.field{:name "RemoveNetworkLoadBalancerArns", :shape "ValueStringList", :location-name "RemoveNetworkLoadBalancerArn"}))))

(clojure.core/defn- req-accept-reserved-instances-exchange-quote-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-reserved-instance-id-set (input :reserved-instance-ids)) #:http.request.field{:name "ReservedInstanceIds", :shape "ReservedInstanceIdSet", :location-name "ReservedInstanceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :target-configurations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-configuration-request-set (input :target-configurations)) #:http.request.field{:name "TargetConfigurations", :shape "TargetConfigurationRequestSet", :location-name "TargetConfiguration"}))))

(clojure.core/defn- req-delete-launch-template-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-version-string-list (input :versions)) #:http.request.field{:name "Versions", :shape "VersionStringList", :location-name "LaunchTemplateVersion"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :launch-template-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :launch-template-id)) #:http.request.field{:name "LaunchTemplateId", :shape "String"})) (clojure.core/contains? input :launch-template-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-name (input :launch-template-name)) #:http.request.field{:name "LaunchTemplateName", :shape "LaunchTemplateName"}))))

(clojure.core/defn- req-detach-volume-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :volume-id)) #:http.request.field{:name "VolumeId", :shape "String"})]} (clojure.core/contains? input :device) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :device)) #:http.request.field{:name "Device", :shape "String"})) (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :force)) #:http.request.field{:name "Force", :shape "Boolean"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-purchase-reserved-instances-offering-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-integer (input :instance-count)) #:http.request.field{:name "InstanceCount", :shape "Integer"}) (clojure.core/into (ser-string (input :reserved-instances-offering-id)) #:http.request.field{:name "ReservedInstancesOfferingId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :limit-price) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-reserved-instance-limit-price (input :limit-price)) #:http.request.field{:name "LimitPrice", :shape "ReservedInstanceLimitPrice", :location-name "limitPrice"}))))

(clojure.core/defn- req-unassign-private-ip-addresses-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"}) (clojure.core/into (ser-private-ip-address-string-list (input :private-ip-addresses)) #:http.request.field{:name "PrivateIpAddresses", :shape "PrivateIpAddressStringList", :location-name "privateIpAddress"})]}))

(clojure.core/defn- req-monitor-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id-string-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdStringList", :location-name "InstanceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-placement-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String", :location-name "groupName"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-run-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-integer (input :max-count)) #:http.request.field{:name "MaxCount", :shape "Integer"}) (clojure.core/into (ser-integer (input :min-count)) #:http.request.field{:name "MinCount", :shape "Integer"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "TagSpecificationList", :location-name "TagSpecification"})) (clojure.core/contains? input :kernel-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kernel-id)) #:http.request.field{:name "KernelId", :shape "String"})) (clojure.core/contains? input :credit-specification) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-credit-specification-request (input :credit-specification)) #:http.request.field{:name "CreditSpecification", :shape "CreditSpecificationRequest"})) (clojure.core/contains? input :ipv-6-addresses) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-ipv-6-address-list (input :ipv-6-addresses)) #:http.request.field{:name "Ipv6Addresses", :shape "InstanceIpv6AddressList", :location-name "Ipv6Address"})) (clojure.core/contains? input :security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-id-string-list (input :security-group-ids)) #:http.request.field{:name "SecurityGroupIds", :shape "SecurityGroupIdStringList", :location-name "SecurityGroupId"})) (clojure.core/contains? input :image-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-id)) #:http.request.field{:name "ImageId", :shape "String"})) (clojure.core/contains? input :placement) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-placement (input :placement)) #:http.request.field{:name "Placement", :shape "Placement"})) (clojure.core/contains? input :subnet-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String"})) (clojure.core/contains? input :security-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-string-list (input :security-groups)) #:http.request.field{:name "SecurityGroups", :shape "SecurityGroupStringList", :location-name "SecurityGroup"})) (clojure.core/contains? input :ebs-optimized) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :ebs-optimized)) #:http.request.field{:name "EbsOptimized", :shape "Boolean", :location-name "ebsOptimized"})) (clojure.core/contains? input :instance-market-options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-market-options-request (input :instance-market-options)) #:http.request.field{:name "InstanceMarketOptions", :shape "InstanceMarketOptionsRequest"})) (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-type (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "InstanceType"})) (clojure.core/contains? input :launch-template) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-specification (input :launch-template)) #:http.request.field{:name "LaunchTemplate", :shape "LaunchTemplateSpecification"})) (clojure.core/contains? input :elastic-gpu-specification) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-elastic-gpu-specifications (input :elastic-gpu-specification)) #:http.request.field{:name "ElasticGpuSpecification", :shape "ElasticGpuSpecifications"})) (clojure.core/contains? input :elastic-inference-accelerators) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-elastic-inference-accelerators (input :elastic-inference-accelerators)) #:http.request.field{:name "ElasticInferenceAccelerators", :shape "ElasticInferenceAccelerators", :location-name "ElasticInferenceAccelerator"})) (clojure.core/contains? input :key-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key-name)) #:http.request.field{:name "KeyName", :shape "String"})) (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "String", :location-name "additionalInfo"})) (clojure.core/contains? input :license-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-license-specification-list-request (input :license-specifications)) #:http.request.field{:name "LicenseSpecifications", :shape "LicenseSpecificationListRequest", :location-name "LicenseSpecification"})) (clojure.core/contains? input :disable-api-termination) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :disable-api-termination)) #:http.request.field{:name "DisableApiTermination", :shape "Boolean", :location-name "disableApiTermination"})) (clojure.core/contains? input :hibernation-options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-hibernation-options-request (input :hibernation-options)) #:http.request.field{:name "HibernationOptions", :shape "HibernationOptionsRequest"})) (clojure.core/contains? input :monitoring) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-run-instances-monitoring-enabled (input :monitoring)) #:http.request.field{:name "Monitoring", :shape "RunInstancesMonitoringEnabled"})) (clojure.core/contains? input :block-device-mappings) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-block-device-mapping-request-list (input :block-device-mappings)) #:http.request.field{:name "BlockDeviceMappings", :shape "BlockDeviceMappingRequestList", :location-name "BlockDeviceMapping"})) (clojure.core/contains? input :capacity-reservation-specification) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-capacity-reservation-specification (input :capacity-reservation-specification)) #:http.request.field{:name "CapacityReservationSpecification", :shape "CapacityReservationSpecification"})) (clojure.core/contains? input :cpu-options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cpu-options-request (input :cpu-options)) #:http.request.field{:name "CpuOptions", :shape "CpuOptionsRequest"})) (clojure.core/contains? input :ramdisk-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ramdisk-id)) #:http.request.field{:name "RamdiskId", :shape "String"})) (clojure.core/contains? input :user-data) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :user-data)) #:http.request.field{:name "UserData", :shape "String"})) (clojure.core/contains? input :instance-initiated-shutdown-behavior) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-shutdown-behavior (input :instance-initiated-shutdown-behavior)) #:http.request.field{:name "InstanceInitiatedShutdownBehavior", :shape "ShutdownBehavior", :location-name "instanceInitiatedShutdownBehavior"})) (clojure.core/contains? input :iam-instance-profile) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-instance-profile-specification (input :iam-instance-profile)) #:http.request.field{:name "IamInstanceProfile", :shape "IamInstanceProfileSpecification", :location-name "iamInstanceProfile"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String", :location-name "clientToken"})) (clojure.core/contains? input :private-ip-address) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-ip-address)) #:http.request.field{:name "PrivateIpAddress", :shape "String", :location-name "privateIpAddress"})) (clojure.core/contains? input :network-interfaces) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-network-interface-specification-list (input :network-interfaces)) #:http.request.field{:name "NetworkInterfaces", :shape "InstanceNetworkInterfaceSpecificationList", :location-name "networkInterface"})) (clojure.core/contains? input :ipv-6-address-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :ipv-6-address-count)) #:http.request.field{:name "Ipv6AddressCount", :shape "Integer"}))))

(clojure.core/defn- req-describe-volumes-modifications-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :volume-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-volume-id-string-list (input :volume-ids)) #:http.request.field{:name "VolumeIds", :shape "VolumeIdStringList", :location-name "VolumeId"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"}))))

(clojure.core/defn- req-reset-instance-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "InstanceAttributeName", :location-name "attribute"}) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-modify-vpc-endpoint-service-permissions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :service-id)) #:http.request.field{:name "ServiceId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :add-allowed-principals) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :add-allowed-principals)) #:http.request.field{:name "AddAllowedPrincipals", :shape "ValueStringList"})) (clojure.core/contains? input :remove-allowed-principals) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :remove-allowed-principals)) #:http.request.field{:name "RemoveAllowedPrincipals", :shape "ValueStringList"}))))

(clojure.core/defn- req-create-default-subnet-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-purchase-scheduled-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-purchase-request-set (input :purchase-requests)) #:http.request.field{:name "PurchaseRequests", :shape "PurchaseRequestSet", :location-name "PurchaseRequest"})]} (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String", :idempotency-token true})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-move-address-to-vpc-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :public-ip)) #:http.request.field{:name "PublicIp", :shape "String", :location-name "publicIp"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-export-tasks-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :export-task-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-export-task-id-string-list (input :export-task-ids)) #:http.request.field{:name "ExportTaskIds", :shape "ExportTaskIdStringList", :location-name "exportTaskId"}))))

(clojure.core/defn- req-create-vpn-connection-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :customer-gateway-id)) #:http.request.field{:name "CustomerGatewayId", :shape "String"}) (clojure.core/into (ser-string (input :type)) #:http.request.field{:name "Type", :shape "String"})]} (clojure.core/contains? input :vpn-gateway-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpn-gateway-id)) #:http.request.field{:name "VpnGatewayId", :shape "String"})) (clojure.core/contains? input :transit-gateway-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :transit-gateway-id)) #:http.request.field{:name "TransitGatewayId", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpn-connection-options-specification (input :options)) #:http.request.field{:name "Options", :shape "VpnConnectionOptionsSpecification", :location-name "options"}))))

(clojure.core/defn- req-disassociate-route-table-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :association-id)) #:http.request.field{:name "AssociationId", :shape "String", :location-name "associationId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-hosts-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filter) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filter)) #:http.request.field{:name "Filter", :shape "FilterList", :location-name "filter"})) (clojure.core/contains? input :host-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-request-host-id-list (input :host-ids)) #:http.request.field{:name "HostIds", :shape "RequestHostIdList", :location-name "hostId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"}))))

(clojure.core/defn- req-describe-instance-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "InstanceAttributeName", :location-name "attribute"}) (clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-detach-classic-link-vpc-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"}) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-moving-addresses-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"})) (clojure.core/contains? input :public-ips) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :public-ips)) #:http.request.field{:name "PublicIps", :shape "ValueStringList", :location-name "publicIp"}))))

(clojure.core/defn- req-describe-launch-template-versions-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :versions) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-version-string-list (input :versions)) #:http.request.field{:name "Versions", :shape "VersionStringList", :location-name "LaunchTemplateVersion"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :launch-template-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-template-name (input :launch-template-name)) #:http.request.field{:name "LaunchTemplateName", :shape "LaunchTemplateName"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :launch-template-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :launch-template-id)) #:http.request.field{:name "LaunchTemplateId", :shape "String"})) (clojure.core/contains? input :min-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :min-version)) #:http.request.field{:name "MinVersion", :shape "String"})) (clojure.core/contains? input :max-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :max-version)) #:http.request.field{:name "MaxVersion", :shape "String"}))))

(clojure.core/defn- req-modify-vpc-endpoint-connection-notification-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :connection-notification-id)) #:http.request.field{:name "ConnectionNotificationId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :connection-notification-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :connection-notification-arn)) #:http.request.field{:name "ConnectionNotificationArn", :shape "String"})) (clojure.core/contains? input :connection-events) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :connection-events)) #:http.request.field{:name "ConnectionEvents", :shape "ValueStringList"}))))

(clojure.core/defn- req-accept-vpc-peering-connection-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :vpc-peering-connection-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :vpc-peering-connection-id)) #:http.request.field{:name "VpcPeeringConnectionId", :shape "String", :location-name "vpcPeeringConnectionId"}))))

(clojure.core/defn- req-describe-reserved-instances-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :offering-class) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-offering-class-type (input :offering-class)) #:http.request.field{:name "OfferingClass", :shape "OfferingClassType"})) (clojure.core/contains? input :reserved-instances-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-reserved-instances-id-string-list (input :reserved-instances-ids)) #:http.request.field{:name "ReservedInstancesIds", :shape "ReservedInstancesIdStringList", :location-name "ReservedInstancesId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :offering-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-offering-type-values (input :offering-type)) #:http.request.field{:name "OfferingType", :shape "OfferingTypeValues", :location-name "offeringType"}))))

(clojure.core/defn- req-describe-vpc-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-vpc-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "VpcAttributeName"}) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-reserved-instances-offerings-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :max-duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-long (input :max-duration)) #:http.request.field{:name "MaxDuration", :shape "Long"})) (clojure.core/contains? input :min-duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-long (input :min-duration)) #:http.request.field{:name "MinDuration", :shape "Long"})) (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-type (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "InstanceType"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"})) (clojure.core/contains? input :instance-tenancy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tenancy (input :instance-tenancy)) #:http.request.field{:name "InstanceTenancy", :shape "Tenancy", :location-name "instanceTenancy"})) (clojure.core/contains? input :include-marketplace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :include-marketplace)) #:http.request.field{:name "IncludeMarketplace", :shape "Boolean"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :product-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ri-product-description (input :product-description)) #:http.request.field{:name "ProductDescription", :shape "RIProductDescription"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"})) (clojure.core/contains? input :offering-class) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-offering-class-type (input :offering-class)) #:http.request.field{:name "OfferingClass", :shape "OfferingClassType"})) (clojure.core/contains? input :offering-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-offering-type-values (input :offering-type)) #:http.request.field{:name "OfferingType", :shape "OfferingTypeValues", :location-name "offeringType"})) (clojure.core/contains? input :max-instance-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-instance-count)) #:http.request.field{:name "MaxInstanceCount", :shape "Integer"})) (clojure.core/contains? input :reserved-instances-offering-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-reserved-instances-offering-id-string-list (input :reserved-instances-offering-ids)) #:http.request.field{:name "ReservedInstancesOfferingIds", :shape "ReservedInstancesOfferingIdStringList", :location-name "ReservedInstancesOfferingId"}))))

(clojure.core/defn- req-create-vpc-endpoint-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"}) (clojure.core/into (ser-string (input :service-name)) #:http.request.field{:name "ServiceName", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :vpc-endpoint-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-endpoint-type (input :vpc-endpoint-type)) #:http.request.field{:name "VpcEndpointType", :shape "VpcEndpointType"})) (clojure.core/contains? input :subnet-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "ValueStringList", :location-name "SubnetId"})) (clojure.core/contains? input :security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :security-group-ids)) #:http.request.field{:name "SecurityGroupIds", :shape "ValueStringList", :location-name "SecurityGroupId"})) (clojure.core/contains? input :private-dns-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :private-dns-enabled)) #:http.request.field{:name "PrivateDnsEnabled", :shape "Boolean"})) (clojure.core/contains? input :policy-document) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :policy-document)) #:http.request.field{:name "PolicyDocument", :shape "String"})) (clojure.core/contains? input :route-table-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :route-table-ids)) #:http.request.field{:name "RouteTableIds", :shape "ValueStringList", :location-name "RouteTableId"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"}))))

(clojure.core/defn- req-delete-vpc-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-associate-subnet-cidr-block-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :ipv-6-cidr-block)) #:http.request.field{:name "Ipv6CidrBlock", :shape "String", :location-name "ipv6CidrBlock"}) (clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String", :location-name "subnetId"})]}))

(clojure.core/defn- req-create-capacity-reservation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "String"}) (clojure.core/into (ser-capacity-reservation-instance-platform (input :instance-platform)) #:http.request.field{:name "InstancePlatform", :shape "CapacityReservationInstancePlatform"}) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"}) (clojure.core/into (ser-integer (input :instance-count)) #:http.request.field{:name "InstanceCount", :shape "Integer"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "TagSpecificationList"})) (clojure.core/contains? input :end-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :end-date)) #:http.request.field{:name "EndDate", :shape "DateTime"})) (clojure.core/contains? input :tenancy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-capacity-reservation-tenancy (input :tenancy)) #:http.request.field{:name "Tenancy", :shape "CapacityReservationTenancy"})) (clojure.core/contains? input :ebs-optimized) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :ebs-optimized)) #:http.request.field{:name "EbsOptimized", :shape "Boolean"})) (clojure.core/contains? input :end-date-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-end-date-type (input :end-date-type)) #:http.request.field{:name "EndDateType", :shape "EndDateType"})) (clojure.core/contains? input :ephemeral-storage) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :ephemeral-storage)) #:http.request.field{:name "EphemeralStorage", :shape "Boolean"})) (clojure.core/contains? input :instance-match-criteria) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-match-criteria (input :instance-match-criteria)) #:http.request.field{:name "InstanceMatchCriteria", :shape "InstanceMatchCriteria"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"}))))

(clojure.core/defn- req-describe-network-interfaces-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :network-interface-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-network-interface-id-list (input :network-interface-ids)) #:http.request.field{:name "NetworkInterfaceIds", :shape "NetworkInterfaceIdList", :location-name "NetworkInterfaceId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"}))))

(clojure.core/defn- req-describe-subnets-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :subnet-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-subnet-id-string-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "SubnetIdStringList", :location-name "SubnetId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-disassociate-subnet-cidr-block-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :association-id)) #:http.request.field{:name "AssociationId", :shape "String", :location-name "associationId"})]}))

(clojure.core/defn- req-modify-volume-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :volume-id)) #:http.request.field{:name "VolumeId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :size) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :size)) #:http.request.field{:name "Size", :shape "Integer"})) (clojure.core/contains? input :volume-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-volume-type (input :volume-type)) #:http.request.field{:name "VolumeType", :shape "VolumeType"})) (clojure.core/contains? input :iops) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :iops)) #:http.request.field{:name "Iops", :shape "Integer"}))))

(clojure.core/defn- req-delete-nat-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :nat-gateway-id)) #:http.request.field{:name "NatGatewayId", :shape "String"})]}))

(clojure.core/defn- req-get-transit-gateway-route-table-propagations-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "TransitGatewayMaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-modify-client-vpn-endpoint-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"})]} (clojure.core/contains? input :server-certificate-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :server-certificate-arn)) #:http.request.field{:name "ServerCertificateArn", :shape "String"})) (clojure.core/contains? input :connection-log-options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-connection-log-options (input :connection-log-options)) #:http.request.field{:name "ConnectionLogOptions", :shape "ConnectionLogOptions"})) (clojure.core/contains? input :dns-servers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dns-servers-options-modify-structure (input :dns-servers)) #:http.request.field{:name "DnsServers", :shape "DnsServersOptionsModifyStructure"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-availability-zones-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :zone-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-zone-name-string-list (input :zone-names)) #:http.request.field{:name "ZoneNames", :shape "ZoneNameStringList", :location-name "ZoneName"})) (clojure.core/contains? input :zone-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-zone-id-string-list (input :zone-ids)) #:http.request.field{:name "ZoneIds", :shape "ZoneIdStringList", :location-name "ZoneId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-disassociate-address-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :association-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :association-id)) #:http.request.field{:name "AssociationId", :shape "String"})) (clojure.core/contains? input :public-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :public-ip)) #:http.request.field{:name "PublicIp", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-create-transit-gateway-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-request-options (input :options)) #:http.request.field{:name "Options", :shape "TransitGatewayRequestOptions"})) (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "TagSpecificationList", :location-name "TagSpecification"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-create-network-interface-permission-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String"}) (clojure.core/into (ser-interface-permission-type (input :permission)) #:http.request.field{:name "Permission", :shape "InterfacePermissionType"})]} (clojure.core/contains? input :aws-account-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "String"})) (clojure.core/contains? input :aws-service) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :aws-service)) #:http.request.field{:name "AwsService", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-reject-vpc-endpoint-connections-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :service-id)) #:http.request.field{:name "ServiceId", :shape "String"}) (clojure.core/into (ser-value-string-list (input :vpc-endpoint-ids)) #:http.request.field{:name "VpcEndpointIds", :shape "ValueStringList", :location-name "VpcEndpointId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-revoke-security-group-egress-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :group-id)) #:http.request.field{:name "GroupId", :shape "String", :location-name "groupId"})]} (clojure.core/contains? input :source-security-group-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-security-group-owner-id)) #:http.request.field{:name "SourceSecurityGroupOwnerId", :shape "String", :location-name "sourceSecurityGroupOwnerId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :to-port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :to-port)) #:http.request.field{:name "ToPort", :shape "Integer", :location-name "toPort"})) (clojure.core/contains? input :source-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-security-group-name)) #:http.request.field{:name "SourceSecurityGroupName", :shape "String", :location-name "sourceSecurityGroupName"})) (clojure.core/contains? input :ip-protocol) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ip-protocol)) #:http.request.field{:name "IpProtocol", :shape "String", :location-name "ipProtocol"})) (clojure.core/contains? input :from-port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :from-port)) #:http.request.field{:name "FromPort", :shape "Integer", :location-name "fromPort"})) (clojure.core/contains? input :ip-permissions) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ip-permission-list (input :ip-permissions)) #:http.request.field{:name "IpPermissions", :shape "IpPermissionList", :location-name "ipPermissions"})) (clojure.core/contains? input :cidr-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidr-ip)) #:http.request.field{:name "CidrIp", :shape "String", :location-name "cidrIp"}))))

(clojure.core/defn- req-describe-iam-instance-profile-associations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :association-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-id-list (input :association-ids)) #:http.request.field{:name "AssociationIds", :shape "AssociationIdList", :location-name "AssociationId"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-detach-vpn-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"}) (clojure.core/into (ser-string (input :vpn-gateway-id)) #:http.request.field{:name "VpnGatewayId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-modify-vpc-tenancy-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"}) (clojure.core/into (ser-vpc-tenancy (input :instance-tenancy)) #:http.request.field{:name "InstanceTenancy", :shape "VpcTenancy"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-prefix-lists-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :prefix-list-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :prefix-list-ids)) #:http.request.field{:name "PrefixListIds", :shape "ValueStringList", :location-name "PrefixListId"}))))

(clojure.core/defn- req-terminate-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id-string-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdStringList", :location-name "InstanceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-modify-reserved-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-reserved-instances-id-string-list (input :reserved-instances-ids)) #:http.request.field{:name "ReservedInstancesIds", :shape "ReservedInstancesIdStringList", :location-name "ReservedInstancesId"}) (clojure.core/into (ser-reserved-instances-configuration-list (input :target-configurations)) #:http.request.field{:name "TargetConfigurations", :shape "ReservedInstancesConfigurationList", :location-name "ReservedInstancesConfigurationSetItemType"})]} (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String", :location-name "clientToken"}))))

(clojure.core/defn- req-delete-network-acl-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :network-acl-id)) #:http.request.field{:name "NetworkAclId", :shape "String", :location-name "networkAclId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-placement-groups-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :group-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-placement-group-string-list (input :group-names)) #:http.request.field{:name "GroupNames", :shape "PlacementGroupStringList", :location-name "groupName"}))))

(clojure.core/defn- req-modify-image-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :image-id)) #:http.request.field{:name "ImageId", :shape "String"})]} (clojure.core/contains? input :user-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-id-string-list (input :user-ids)) #:http.request.field{:name "UserIds", :shape "UserIdStringList", :location-name "UserId"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :attribute) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :attribute)) #:http.request.field{:name "Attribute", :shape "String"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "Value", :shape "String"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-value (input :description)) #:http.request.field{:name "Description", :shape "AttributeValue"})) (clojure.core/contains? input :operation-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-operation-type (input :operation-type)) #:http.request.field{:name "OperationType", :shape "OperationType"})) (clojure.core/contains? input :product-codes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-product-code-string-list (input :product-codes)) #:http.request.field{:name "ProductCodes", :shape "ProductCodeStringList", :location-name "ProductCode"})) (clojure.core/contains? input :user-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-group-string-list (input :user-groups)) #:http.request.field{:name "UserGroups", :shape "UserGroupStringList", :location-name "UserGroup"})) (clojure.core/contains? input :launch-permission) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-launch-permission-modifications (input :launch-permission)) #:http.request.field{:name "LaunchPermission", :shape "LaunchPermissionModifications"}))))

(clojure.core/defn- req-enable-vpc-classic-link-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-cancel-capacity-reservation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :capacity-reservation-id)) #:http.request.field{:name "CapacityReservationId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-describe-security-groups-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-group-id-string-list (input :group-ids)) #:http.request.field{:name "GroupIds", :shape "GroupIdStringList", :location-name "GroupId"})) (clojure.core/contains? input :group-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-group-name-string-list (input :group-names)) #:http.request.field{:name "GroupNames", :shape "GroupNameStringList", :location-name "GroupName"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"}))))

(clojure.core/defn- req-import-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-platform-values (input :platform)) #:http.request.field{:name "Platform", :shape "PlatformValues", :location-name "platform"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"})) (clojure.core/contains? input :disk-images) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-disk-image-list (input :disk-images)) #:http.request.field{:name "DiskImages", :shape "DiskImageList", :location-name "diskImage"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :launch-specification) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-import-instance-launch-specification (input :launch-specification)) #:http.request.field{:name "LaunchSpecification", :shape "ImportInstanceLaunchSpecification", :location-name "launchSpecification"}))))

(clojure.core/defn- req-describe-vpc-classic-link-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :vpc-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-classic-link-id-list (input :vpc-ids)) #:http.request.field{:name "VpcIds", :shape "VpcClassicLinkIdList", :location-name "VpcId"}))))

(clojure.core/defn- req-authorize-security-group-ingress-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :source-security-group-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-security-group-owner-id)) #:http.request.field{:name "SourceSecurityGroupOwnerId", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :to-port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :to-port)) #:http.request.field{:name "ToPort", :shape "Integer"})) (clojure.core/contains? input :source-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-security-group-name)) #:http.request.field{:name "SourceSecurityGroupName", :shape "String"})) (clojure.core/contains? input :ip-protocol) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ip-protocol)) #:http.request.field{:name "IpProtocol", :shape "String"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String"})) (clojure.core/contains? input :group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-id)) #:http.request.field{:name "GroupId", :shape "String"})) (clojure.core/contains? input :from-port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :from-port)) #:http.request.field{:name "FromPort", :shape "Integer"})) (clojure.core/contains? input :ip-permissions) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ip-permission-list (input :ip-permissions)) #:http.request.field{:name "IpPermissions", :shape "IpPermissionList"})) (clojure.core/contains? input :cidr-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidr-ip)) #:http.request.field{:name "CidrIp", :shape "String"}))))

(clojure.core/defn- req-create-fleet-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-fleet-launch-template-config-list-request (input :launch-template-configs)) #:http.request.field{:name "LaunchTemplateConfigs", :shape "FleetLaunchTemplateConfigListRequest"}) (clojure.core/into (ser-target-capacity-specification-request (input :target-capacity-specification)) #:http.request.field{:name "TargetCapacitySpecification", :shape "TargetCapacitySpecificationRequest"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "TagSpecificationList", :location-name "TagSpecification"})) (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fleet-type (input :type)) #:http.request.field{:name "Type", :shape "FleetType"})) (clojure.core/contains? input :valid-from) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :valid-from)) #:http.request.field{:name "ValidFrom", :shape "DateTime"})) (clojure.core/contains? input :excess-capacity-termination-policy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fleet-excess-capacity-termination-policy (input :excess-capacity-termination-policy)) #:http.request.field{:name "ExcessCapacityTerminationPolicy", :shape "FleetExcessCapacityTerminationPolicy"})) (clojure.core/contains? input :spot-options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-options-request (input :spot-options)) #:http.request.field{:name "SpotOptions", :shape "SpotOptionsRequest"})) (clojure.core/contains? input :on-demand-options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-on-demand-options-request (input :on-demand-options)) #:http.request.field{:name "OnDemandOptions", :shape "OnDemandOptionsRequest"})) (clojure.core/contains? input :terminate-instances-with-expiration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :terminate-instances-with-expiration)) #:http.request.field{:name "TerminateInstancesWithExpiration", :shape "Boolean"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"})) (clojure.core/contains? input :replace-unhealthy-instances) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :replace-unhealthy-instances)) #:http.request.field{:name "ReplaceUnhealthyInstances", :shape "Boolean"})) (clojure.core/contains? input :valid-until) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-date-time (input :valid-until)) #:http.request.field{:name "ValidUntil", :shape "DateTime"}))))

(clojure.core/defn- req-create-volume-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :tag-specifications) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-specification-list (input :tag-specifications)) #:http.request.field{:name "TagSpecifications", :shape "TagSpecificationList", :location-name "TagSpecification"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "Boolean", :location-name "encrypted"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :size) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :size)) #:http.request.field{:name "Size", :shape "Integer"})) (clojure.core/contains? input :iops) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :iops)) #:http.request.field{:name "Iops", :shape "Integer"})) (clojure.core/contains? input :volume-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-volume-type (input :volume-type)) #:http.request.field{:name "VolumeType", :shape "VolumeType"})) (clojure.core/contains? input :snapshot-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "String"}))))

(clojure.core/defn- req-get-transit-gateway-route-table-associations-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "TransitGatewayMaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-modify-instance-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String", :location-name "instanceId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :ebs-optimized) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-boolean-value (input :ebs-optimized)) #:http.request.field{:name "EbsOptimized", :shape "AttributeBooleanValue", :location-name "ebsOptimized"})) (clojure.core/contains? input :instance-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-value (input :instance-type)) #:http.request.field{:name "InstanceType", :shape "AttributeValue", :location-name "instanceType"})) (clojure.core/contains? input :ramdisk) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-value (input :ramdisk)) #:http.request.field{:name "Ramdisk", :shape "AttributeValue", :location-name "ramdisk"})) (clojure.core/contains? input :sriov-net-support) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-value (input :sriov-net-support)) #:http.request.field{:name "SriovNetSupport", :shape "AttributeValue", :location-name "sriovNetSupport"})) (clojure.core/contains? input :source-dest-check) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-boolean-value (input :source-dest-check)) #:http.request.field{:name "SourceDestCheck", :shape "AttributeBooleanValue"})) (clojure.core/contains? input :attribute) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-attribute-name (input :attribute)) #:http.request.field{:name "Attribute", :shape "InstanceAttributeName", :location-name "attribute"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "Value", :shape "String", :location-name "value"})) (clojure.core/contains? input :disable-api-termination) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-boolean-value (input :disable-api-termination)) #:http.request.field{:name "DisableApiTermination", :shape "AttributeBooleanValue", :location-name "disableApiTermination"})) (clojure.core/contains? input :groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-group-id-string-list (input :groups)) #:http.request.field{:name "Groups", :shape "GroupIdStringList", :location-name "GroupId"})) (clojure.core/contains? input :block-device-mappings) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-block-device-mapping-specification-list (input :block-device-mappings)) #:http.request.field{:name "BlockDeviceMappings", :shape "InstanceBlockDeviceMappingSpecificationList", :location-name "blockDeviceMapping"})) (clojure.core/contains? input :kernel) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-value (input :kernel)) #:http.request.field{:name "Kernel", :shape "AttributeValue", :location-name "kernel"})) (clojure.core/contains? input :user-data) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-blob-attribute-value (input :user-data)) #:http.request.field{:name "UserData", :shape "BlobAttributeValue", :location-name "userData"})) (clojure.core/contains? input :instance-initiated-shutdown-behavior) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-value (input :instance-initiated-shutdown-behavior)) #:http.request.field{:name "InstanceInitiatedShutdownBehavior", :shape "AttributeValue", :location-name "instanceInitiatedShutdownBehavior"})) (clojure.core/contains? input :ena-support) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-boolean-value (input :ena-support)) #:http.request.field{:name "EnaSupport", :shape "AttributeBooleanValue", :location-name "enaSupport"}))))

(clojure.core/defn- req-release-address-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :allocation-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :allocation-id)) #:http.request.field{:name "AllocationId", :shape "String"})) (clojure.core/contains? input :public-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :public-ip)) #:http.request.field{:name "PublicIp", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-vpc-classic-link-dns-support-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken", :location-name "nextToken"})) (clojure.core/contains? input :vpc-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-classic-link-id-list (input :vpc-ids)) #:http.request.field{:name "VpcIds", :shape "VpcClassicLinkIdList"}))))

(clojure.core/defn- req-assign-ipv-6-addresses-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :network-interface-id)) #:http.request.field{:name "NetworkInterfaceId", :shape "String", :location-name "networkInterfaceId"})]} (clojure.core/contains? input :ipv-6-address-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :ipv-6-address-count)) #:http.request.field{:name "Ipv6AddressCount", :shape "Integer", :location-name "ipv6AddressCount"})) (clojure.core/contains? input :ipv-6-addresses) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ipv-6-address-list (input :ipv-6-addresses)) #:http.request.field{:name "Ipv6Addresses", :shape "Ipv6AddressList", :location-name "ipv6Addresses"}))))

(clojure.core/defn- req-describe-reserved-instances-modifications-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :reserved-instances-modification-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-reserved-instances-modification-id-string-list (input :reserved-instances-modification-ids)) #:http.request.field{:name "ReservedInstancesModificationIds", :shape "ReservedInstancesModificationIdStringList", :location-name "ReservedInstancesModificationId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"}))))

(clojure.core/defn- req-create-network-interface-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subnet-id)) #:http.request.field{:name "SubnetId", :shape "String", :location-name "subnetId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :ipv-6-addresses) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-ipv-6-address-list (input :ipv-6-addresses)) #:http.request.field{:name "Ipv6Addresses", :shape "InstanceIpv6AddressList", :location-name "ipv6Addresses"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String", :location-name "description"})) (clojure.core/contains? input :groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-id-string-list (input :groups)) #:http.request.field{:name "Groups", :shape "SecurityGroupIdStringList", :location-name "SecurityGroupId"})) (clojure.core/contains? input :private-ip-addresses) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-private-ip-address-specification-list (input :private-ip-addresses)) #:http.request.field{:name "PrivateIpAddresses", :shape "PrivateIpAddressSpecificationList", :location-name "privateIpAddresses"})) (clojure.core/contains? input :secondary-private-ip-address-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :secondary-private-ip-address-count)) #:http.request.field{:name "SecondaryPrivateIpAddressCount", :shape "Integer", :location-name "secondaryPrivateIpAddressCount"})) (clojure.core/contains? input :private-ip-address) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-ip-address)) #:http.request.field{:name "PrivateIpAddress", :shape "String", :location-name "privateIpAddress"})) (clojure.core/contains? input :ipv-6-address-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :ipv-6-address-count)) #:http.request.field{:name "Ipv6AddressCount", :shape "Integer", :location-name "ipv6AddressCount"}))))

(clojure.core/defn- req-describe-stale-security-groups-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-describe-client-vpn-endpoints-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :client-vpn-endpoint-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :client-vpn-endpoint-ids)) #:http.request.field{:name "ClientVpnEndpointIds", :shape "ValueStringList", :location-name "ClientVpnEndpointId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-create-route-table-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-fpga-images-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :fpga-image-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-fpga-image-id-list (input :fpga-image-ids)) #:http.request.field{:name "FpgaImageIds", :shape "FpgaImageIdList", :location-name "FpgaImageId"})) (clojure.core/contains? input :owners) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-owner-string-list (input :owners)) #:http.request.field{:name "Owners", :shape "OwnerStringList", :location-name "Owner"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults"}))))

(clojure.core/defn- req-describe-principal-id-format-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :resources) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-list (input :resources)) #:http.request.field{:name "Resources", :shape "ResourceList", :location-name "Resource"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-describe-vpc-endpoint-connections-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"}))))

(clojure.core/defn- req-create-client-vpn-route-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"}) (clojure.core/into (ser-string (input :destination-cidr-block)) #:http.request.field{:name "DestinationCidrBlock", :shape "String"}) (clojure.core/into (ser-string (input :target-vpc-subnet-id)) #:http.request.field{:name "TargetVpcSubnetId", :shape "String"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-apply-security-groups-to-client-vpn-target-network-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :client-vpn-endpoint-id)) #:http.request.field{:name "ClientVpnEndpointId", :shape "String"}) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"}) (clojure.core/into (ser-client-vpn-security-group-id-set (input :security-group-ids)) #:http.request.field{:name "SecurityGroupIds", :shape "ClientVpnSecurityGroupIdSet", :location-name "SecurityGroupId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-associate-dhcp-options-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :dhcp-options-id)) #:http.request.field{:name "DhcpOptionsId", :shape "String"}) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-reject-vpc-peering-connection-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-peering-connection-id)) #:http.request.field{:name "VpcPeeringConnectionId", :shape "String", :location-name "vpcPeeringConnectionId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-transit-gateway-route-tables-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :transit-gateway-route-table-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-route-table-id-string-list (input :transit-gateway-route-table-ids)) #:http.request.field{:name "TransitGatewayRouteTableIds", :shape "TransitGatewayRouteTableIdStringList"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-transit-gateway-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "TransitGatewayMaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-export-transit-gateway-routes-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-route-table-id)) #:http.request.field{:name "TransitGatewayRouteTableId", :shape "String"}) (clojure.core/into (ser-string (input :s-3-bucket)) #:http.request.field{:name "S3Bucket", :shape "String"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-replace-network-acl-association-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :association-id)) #:http.request.field{:name "AssociationId", :shape "String", :location-name "associationId"}) (clojure.core/into (ser-string (input :network-acl-id)) #:http.request.field{:name "NetworkAclId", :shape "String", :location-name "networkAclId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-run-scheduled-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-scheduled-instances-launch-specification (input :launch-specification)) #:http.request.field{:name "LaunchSpecification", :shape "ScheduledInstancesLaunchSpecification"}) (clojure.core/into (ser-string (input :scheduled-instance-id)) #:http.request.field{:name "ScheduledInstanceId", :shape "String"})]} (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String", :idempotency-token true})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :instance-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :instance-count)) #:http.request.field{:name "InstanceCount", :shape "Integer"}))))

(clojure.core/defn- req-describe-spot-instance-requests-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :spot-instance-request-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-spot-instance-request-id-list (input :spot-instance-request-ids)) #:http.request.field{:name "SpotInstanceRequestIds", :shape "SpotInstanceRequestIdList", :location-name "SpotInstanceRequestId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer"}))))

(clojure.core/defn- req-describe-aggregate-id-format-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-attach-internet-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :internet-gateway-id)) #:http.request.field{:name "InternetGatewayId", :shape "String", :location-name "internetGatewayId"}) (clojure.core/into (ser-string (input :vpc-id)) #:http.request.field{:name "VpcId", :shape "String", :location-name "vpcId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-stop-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id-string-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdStringList", :location-name "InstanceId"})]} (clojure.core/contains? input :hibernate) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :hibernate)) #:http.request.field{:name "Hibernate", :shape "Boolean"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :force)) #:http.request.field{:name "Force", :shape "Boolean", :location-name "force"}))))

(clojure.core/defn- req-modify-instance-capacity-reservation-attributes-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"}) (clojure.core/into (ser-capacity-reservation-specification (input :capacity-reservation-specification)) #:http.request.field{:name "CapacityReservationSpecification", :shape "CapacityReservationSpecification"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-modify-transit-gateway-vpc-attachment-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :transit-gateway-attachment-id)) #:http.request.field{:name "TransitGatewayAttachmentId", :shape "String"})]} (clojure.core/contains? input :add-subnet-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :add-subnet-ids)) #:http.request.field{:name "AddSubnetIds", :shape "ValueStringList"})) (clojure.core/contains? input :remove-subnet-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :remove-subnet-ids)) #:http.request.field{:name "RemoveSubnetIds", :shape "ValueStringList"})) (clojure.core/contains? input :options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-modify-transit-gateway-vpc-attachment-request-options (input :options)) #:http.request.field{:name "Options", :shape "ModifyTransitGatewayVpcAttachmentRequestOptions"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-delete-egress-only-internet-gateway-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-egress-only-internet-gateway-id (input :egress-only-internet-gateway-id)) #:http.request.field{:name "EgressOnlyInternetGatewayId", :shape "EgressOnlyInternetGatewayId"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-purchase-host-reservation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-request-host-id-set (input :host-id-set)) #:http.request.field{:name "HostIdSet", :shape "RequestHostIdSet"}) (clojure.core/into (ser-string (input :offering-id)) #:http.request.field{:name "OfferingId", :shape "String"})]} (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-token)) #:http.request.field{:name "ClientToken", :shape "String"})) (clojure.core/contains? input :currency-code) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-currency-code-values (input :currency-code)) #:http.request.field{:name "CurrencyCode", :shape "CurrencyCodeValues"})) (clojure.core/contains? input :limit-price) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :limit-price)) #:http.request.field{:name "LimitPrice", :shape "String"}))))

(clojure.core/defn- req-get-host-reservation-purchase-preview-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-request-host-id-set (input :host-id-set)) #:http.request.field{:name "HostIdSet", :shape "RequestHostIdSet"}) (clojure.core/into (ser-string (input :offering-id)) #:http.request.field{:name "OfferingId", :shape "String"})]}))

(clojure.core/defn- req-modify-vpc-endpoint-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :vpc-endpoint-id)) #:http.request.field{:name "VpcEndpointId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :remove-subnet-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :remove-subnet-ids)) #:http.request.field{:name "RemoveSubnetIds", :shape "ValueStringList", :location-name "RemoveSubnetId"})) (clojure.core/contains? input :private-dns-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :private-dns-enabled)) #:http.request.field{:name "PrivateDnsEnabled", :shape "Boolean"})) (clojure.core/contains? input :add-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :add-security-group-ids)) #:http.request.field{:name "AddSecurityGroupIds", :shape "ValueStringList", :location-name "AddSecurityGroupId"})) (clojure.core/contains? input :policy-document) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :policy-document)) #:http.request.field{:name "PolicyDocument", :shape "String"})) (clojure.core/contains? input :remove-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :remove-security-group-ids)) #:http.request.field{:name "RemoveSecurityGroupIds", :shape "ValueStringList", :location-name "RemoveSecurityGroupId"})) (clojure.core/contains? input :add-subnet-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :add-subnet-ids)) #:http.request.field{:name "AddSubnetIds", :shape "ValueStringList", :location-name "AddSubnetId"})) (clojure.core/contains? input :remove-route-table-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :remove-route-table-ids)) #:http.request.field{:name "RemoveRouteTableIds", :shape "ValueStringList", :location-name "RemoveRouteTableId"})) (clojure.core/contains? input :reset-policy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :reset-policy)) #:http.request.field{:name "ResetPolicy", :shape "Boolean"})) (clojure.core/contains? input :add-route-table-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-value-string-list (input :add-route-table-ids)) #:http.request.field{:name "AddRouteTableIds", :shape "ValueStringList", :location-name "AddRouteTableId"}))))

(clojure.core/defn- req-get-console-screenshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"})) (clojure.core/contains? input :wake-up) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :wake-up)) #:http.request.field{:name "WakeUp", :shape "Boolean"}))))

(clojure.core/defn- req-describe-id-format-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :resource) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :resource)) #:http.request.field{:name "Resource", :shape "String"}))))

(clojure.core/defn- req-describe-key-pairs-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "FilterList", :location-name "Filter"})) (clojure.core/contains? input :key-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-key-name-string-list (input :key-names)) #:http.request.field{:name "KeyNames", :shape "KeyNameStringList", :location-name "KeyName"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-delete-dhcp-options-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :dhcp-options-id)) #:http.request.field{:name "DhcpOptionsId", :shape "String"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"}))))

(clojure.core/defn- req-describe-spot-fleet-request-history-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :spot-fleet-request-id)) #:http.request.field{:name "SpotFleetRequestId", :shape "String", :location-name "spotFleetRequestId"}) (clojure.core/into (ser-date-time (input :start-time)) #:http.request.field{:name "StartTime", :shape "DateTime", :location-name "startTime"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :event-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-event-type (input :event-type)) #:http.request.field{:name "EventType", :shape "EventType", :location-name "eventType"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-results)) #:http.request.field{:name "MaxResults", :shape "Integer", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location-name "nextToken"}))))

(clojure.core/defn- req-delete-fleets-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-fleet-id-set (input :fleet-ids)) #:http.request.field{:name "FleetIds", :shape "FleetIdSet", :location-name "FleetId"}) (clojure.core/into (ser-boolean (input :terminate-instances)) #:http.request.field{:name "TerminateInstances", :shape "Boolean"})]} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean"}))))

(clojure.core/defn- req-create-placement-group-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :dry-run)) #:http.request.field{:name "DryRun", :shape "Boolean", :location-name "dryRun"})) (clojure.core/contains? input :group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :group-name)) #:http.request.field{:name "GroupName", :shape "String", :location-name "groupName"})) (clojure.core/contains? input :strategy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-placement-strategy (input :strategy)) #:http.request.field{:name "Strategy", :shape "PlacementStrategy", :location-name "strategy"})) (clojure.core/contains? input :partition-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :partition-count)) #:http.request.field{:name "PartitionCount", :shape "Integer"}))))

(clojure.core/declare deser-transit-gateway-vpc-attachment-options)

(clojure.core/declare deser-export-task-list)

(clojure.core/declare deser-client-vpn-authorization-rule-status)

(clojure.core/declare deser-event-code)

(clojure.core/declare deser-flow-log)

(clojure.core/declare deser-vpc-list)

(clojure.core/declare deser-launch-template-and-overrides-response)

(clojure.core/declare deser-history-record-entry)

(clojure.core/declare deser-spot-allocation-strategy)

(clojure.core/declare deser-volume-status-action)

(clojure.core/declare deser-transit-gateway-attachment)

(clojure.core/declare deser-permission-group)

(clojure.core/declare deser-address)

(clojure.core/declare deser-response-error)

(clojure.core/declare deser-bundle-task)

(clojure.core/declare deser-client-certificate-revocation-list-status-code)

(clojure.core/declare deser-launch-template-config-list)

(clojure.core/declare deser-elastic-inference-accelerator-association)

(clojure.core/declare deser-security-group-list)

(clojure.core/declare deser-service-type-detail-set)

(clojure.core/declare deser-principal-type)

(clojure.core/declare deser-instance-count-list)

(clojure.core/declare deser-describe-conversion-task-list)

(clojure.core/declare deser-route)

(clojure.core/declare deser-dns-entry)

(clojure.core/declare deser-nat-gateway-list)

(clojure.core/declare deser-moving-address-status-set)

(clojure.core/declare deser-instance-state-change-list)

(clojure.core/declare deser-client-vpn-connection-status)

(clojure.core/declare deser-iam-instance-profile-association-set)

(clojure.core/declare deser-double)

(clojure.core/declare deser-service-type)

(clojure.core/declare deser-associated-target-network)

(clojure.core/declare deser-default-route-table-association-value)

(clojure.core/declare deser-ebs-instance-block-device)

(clojure.core/declare deser-route-table)

(clojure.core/declare deser-license-list)

(clojure.core/declare deser-scheduled-instance-set)

(clojure.core/declare deser-launch-template-set)

(clojure.core/declare deser-target-groups-config)

(clojure.core/declare deser-propagating-vgw)

(clojure.core/declare deser-flow-log-set)

(clojure.core/declare deser-prefix-list-id-set)

(clojure.core/declare deser-instance-network-interface-list)

(clojure.core/declare deser-vpn-connection-list)

(clojure.core/declare deser-on-demand-allocation-strategy)

(clojure.core/declare deser-reserved-instances-offering)

(clojure.core/declare deser-vpc-endpoint-type)

(clojure.core/declare deser-storage)

(clojure.core/declare deser-value-string-list)

(clojure.core/declare deser-transit-gateway-route-table-state)

(clojure.core/declare deser-volume-modification)

(clojure.core/declare deser-ip-ranges)

(clojure.core/declare deser-instance-status-event-list)

(clojure.core/declare deser-client-vpn-authentication-type)

(clojure.core/declare deser-connection-notification-set)

(clojure.core/declare deser-instance-id)

(clojure.core/declare deser-group-identifier-set)

(clojure.core/declare deser-reserved-instances-modification-result-list)

(clojure.core/declare deser-vpn-protocol)

(clojure.core/declare deser-vpc-peering-connection-vpc-info)

(clojure.core/declare deser-instance-monitoring-list)

(clojure.core/declare deser-vpc-peering-connection)

(clojure.core/declare deser-target-groups)

(clojure.core/declare deser-target-reservation-value-set)

(clojure.core/declare deser-image-state)

(clojure.core/declare deser-network-interface-ipv-6-address)

(clojure.core/declare deser-vpn-state)

(clojure.core/declare deser-account-attribute-list)

(clojure.core/declare deser-instance-lifecycle)

(clojure.core/declare deser-ipv-6-range-list)

(clojure.core/declare deser-move-status)

(clojure.core/declare deser-credit-specification)

(clojure.core/declare deser-prefix-list-id)

(clojure.core/declare deser-pricing-details-list)

(clojure.core/declare deser-purchase)

(clojure.core/declare deser-hypervisor-type)

(clojure.core/declare deser-history-record)

(clojure.core/declare deser-connection-notification-type)

(clojure.core/declare deser-route-table-list)

(clojure.core/declare deser-create-fleet-error)

(clojure.core/declare deser-transit-gateway-vpc-attachment)

(clojure.core/declare deser-architecture-values)

(clojure.core/declare deser-cancelled-spot-instance-request)

(clojure.core/declare deser-transit-gateway-route)

(clojure.core/declare deser-volume-attachment-list)

(clojure.core/declare deser-export-environment)

(clojure.core/declare deser-load-permission-list)

(clojure.core/declare deser-instance-export-details)

(clojure.core/declare deser-service-type-detail)

(clojure.core/declare deser-volume-attachment-state)

(clojure.core/declare deser-volume-modification-list)

(clojure.core/declare deser-internet-gateway-attachment)

(clojure.core/declare deser-launch-template-ebs-block-device)

(clojure.core/declare deser-fleet-identifier)

(clojure.core/declare deser-instance-monitoring)

(clojure.core/declare deser-spot-price-history-list)

(clojure.core/declare deser-byoip-cidr-state)

(clojure.core/declare deser-vpn-connection-options)

(clojure.core/declare deser-network-acl-entry)

(clojure.core/declare deser-terminate-connection-status)

(clojure.core/declare deser-provisioned-bandwidth)

(clojure.core/declare deser-pci-id)

(clojure.core/declare deser-vgw-telemetry-list)

(clojure.core/declare deser-volume-state)

(clojure.core/declare deser-spot-placement)

(clojure.core/declare deser-security-group)

(clojure.core/declare deser-recurring-charges-list)

(clojure.core/declare deser-snapshot-detail-list)

(clojure.core/declare deser-id-format)

(clojure.core/declare deser-volume)

(clojure.core/declare deser-spot-instance-type)

(clojure.core/declare deser-ebs-block-device)

(clojure.core/declare deser-spot-fleet-tag-specification-list)

(clojure.core/declare deser-placement)

(clojure.core/declare deser-reserved-instances-configuration)

(clojure.core/declare deser-interface-permission-type)

(clojure.core/declare deser-user-bucket-details)

(clojure.core/declare deser-occurrence-day-set)

(clojure.core/declare deser-snapshot-list)

(clojure.core/declare deser-instance-lifecycle-type)

(clojure.core/declare deser-transit-gateway-route-list)

(clojure.core/declare deser-availability-zone-state)

(clojure.core/declare deser-client-vpn-endpoint-status-code)

(clojure.core/declare deser-subnet)

(clojure.core/declare deser-terminate-connection-status-set)

(clojure.core/declare deser-capacity-reservation-specification-response)

(clojure.core/declare deser-dhcp-configuration-list)

(clojure.core/declare deser-spot-datafeed-subscription)

(clojure.core/declare deser-fleet-activity-status)

(clojure.core/declare deser-instance-count)

(clojure.core/declare deser-host-instance-list)

(clojure.core/declare deser-response-launch-template-data)

(clojure.core/declare deser-import-instance-volume-detail-item)

(clojure.core/declare deser-fleet-launch-template-specification)

(clojure.core/declare deser-delete-fleet-success-set)

(clojure.core/declare deser-tenancy)

(clojure.core/declare deser-ipv-6-support-value)

(clojure.core/declare deser-instance-network-interface-attachment)

(clojure.core/declare deser-snapshot-detail)

(clojure.core/declare deser-delete-launch-template-versions-response-success-item)

(clojure.core/declare deser-fpga-image)

(clojure.core/declare deser-spot-instance-state-fault)

(clojure.core/declare deser-transit-gateway-vpc-attachment-list)

(clojure.core/declare deser-dhcp-configuration-value-list)

(clojure.core/declare deser-instance-network-interface-association)

(clojure.core/declare deser-fleet-set)

(clojure.core/declare deser-bundle-task-list)

(clojure.core/declare deser-describe-fleets-instances)

(clojure.core/declare deser-create-fleet-instance)

(clojure.core/declare deser-fleet-launch-template-config-list)

(clojure.core/declare deser-disk-image-volume-description)

(clojure.core/declare deser-host-properties)

(clojure.core/declare deser-association-status-code)

(clojure.core/declare deser-delete-launch-template-versions-response-error-item)

(clojure.core/declare deser-scheduled-instance)

(clojure.core/declare deser-transit-gateway-attachment-association)

(clojure.core/declare deser-active-instance-set)

(clojure.core/declare deser-instance-type)

(clojure.core/declare deser-route-state)

(clojure.core/declare deser-client-vpn-connection-status-code)

(clojure.core/declare deser-transit-gateway)

(clojure.core/declare deser-subnet-state)

(clojure.core/declare deser-client-vpn-authentication)

(clojure.core/declare deser-stale-ip-permission-set)

(clojure.core/declare deser-reserved-instances-modification-result)

(clojure.core/declare deser-transit-gateway-attachment-propagation-list)

(clojure.core/declare deser-import-instance-task-details)

(clojure.core/declare deser-create-volume-permission)

(clojure.core/declare deser-client-vpn-endpoint-status)

(clojure.core/declare deser-instance-status-details)

(clojure.core/declare deser-subnet-cidr-block-state)

(clojure.core/declare deser-iam-instance-profile-specification)

(clojure.core/declare deser-spot-instance-request-list)

(clojure.core/declare deser-region-list)

(clojure.core/declare deser-end-date-type)

(clojure.core/declare deser-delete-fleet-success-item)

(clojure.core/declare deser-public-ipv-4-pool-range-set)

(clojure.core/declare deser-response-host-id-set)

(clojure.core/declare deser-disk-image-description)

(clojure.core/declare deser-launch-template)

(clojure.core/declare deser-client-certificate-revocation-list-status)

(clojure.core/declare deser-available-capacity)

(clojure.core/declare deser-service-detail-set)

(clojure.core/declare deser-bundle-task-state)

(clojure.core/declare deser-icmp-type-code)

(clojure.core/declare deser-instance-private-ip-address)

(clojure.core/declare deser-capacity-reservation-target-response)

(clojure.core/declare deser-reserved-instances-listing-list)

(clojure.core/declare deser-service-state)

(clojure.core/declare deser-capacity-reservation-set)

(clojure.core/declare deser-vpc-classic-link)

(clojure.core/declare deser-snapshot-task-detail)

(clojure.core/declare deser-launch-specification)

(clojure.core/declare deser-id-format-list)

(clojure.core/declare deser-launch-template-tag-specification-list)

(clojure.core/declare deser-allowed-principal-set)

(clojure.core/declare deser-instance-ipv-6-address-list)

(clojure.core/declare deser-capacity-reservation-instance-platform)

(clojure.core/declare deser-prefix-list-set)

(clojure.core/declare deser-endpoint-set)

(clojure.core/declare deser-instance-credit-specification)

(clojure.core/declare deser-fleet-event-type)

(clojure.core/declare deser-fleet-state-code)

(clojure.core/declare deser-attribute-boolean-value)

(clojure.core/declare deser-spot-instance-request)

(clojure.core/declare deser-rule-action)

(clojure.core/declare deser-vpc-attachment-list)

(clojure.core/declare deser-associated-network-type)

(clojure.core/declare deser-associated-target-network-set)

(clojure.core/declare deser-service-configuration-set)

(clojure.core/declare deser-successful-instance-credit-specification-item)

(clojure.core/declare deser-vpn-static-route)

(clojure.core/declare deser-fleet-type)

(clojure.core/declare deser-vpc-endpoint)

(clojure.core/declare deser-key-pair-list)

(clojure.core/declare deser-purchased-scheduled-instance-set)

(clojure.core/declare deser-group-identifier-list)

(clojure.core/declare deser-cancel-spot-fleet-requests-error-item)

(clojure.core/declare deser-payment-option)

(clojure.core/declare deser-instance-status-details-list)

(clojure.core/declare deser-key-pair-info)

(clojure.core/declare deser-association-status)

(clojure.core/declare deser-instance-network-interface)

(clojure.core/declare deser-cancel-spot-fleet-requests-error)

(clojure.core/declare deser-vpn-static-route-list)

(clojure.core/declare deser-reservation)

(clojure.core/declare deser-unsuccessful-item-error)

(clojure.core/declare deser-elastic-gpu-association-list)

(clojure.core/declare deser-vpc-peering-connection-list)

(clojure.core/declare deser-unsuccessful-item-set)

(clojure.core/declare deser-security-group-references)

(clojure.core/declare deser-stale-ip-permission)

(clojure.core/declare deser-transit-gateway-association-state)

(clojure.core/declare deser-traffic-type)

(clojure.core/declare deser-vpc-cidr-block-association-set)

(clojure.core/declare deser-availability-zone-list)

(clojure.core/declare deser-launch-template-tag-specification)

(clojure.core/declare deser-vpc-endpoint-connection)

(clojure.core/declare deser-launch-template-spot-market-options)

(clojure.core/declare deser-availability-zone)

(clojure.core/declare deser-route-origin)

(clojure.core/declare deser-fpga-image-attribute)

(clojure.core/declare deser-create-volume-permission-list)

(clojure.core/declare deser-target-network)

(clojure.core/declare deser-status)

(clojure.core/declare deser-network-interface-type)

(clojure.core/declare deser-cancelled-spot-instance-request-list)

(clojure.core/declare deser-vpc-ipv-6-cidr-block-association)

(clojure.core/declare deser-transit-gateway-attachment-list)

(clojure.core/declare deser-event-type)

(clojure.core/declare deser-moving-address-status)

(clojure.core/declare deser-reserved-instances)

(clojure.core/declare deser-transit-gateway-list)

(clojure.core/declare deser-network-interface-permission-state)

(clojure.core/declare deser-next-token)

(clojure.core/declare deser-elastic-gpu-association)

(clojure.core/declare deser-egress-only-internet-gateway-list)

(clojure.core/declare deser-excess-capacity-termination-policy)

(clojure.core/declare deser-prefix-list)

(clojure.core/declare deser-import-instance-volume-detail-set)

(clojure.core/declare deser-status-type)

(clojure.core/declare deser-spot-fleet-monitoring)

(clojure.core/declare deser-reserved-instances-listing)

(clojure.core/declare deser-vpc-cidr-block-state)

(clojure.core/declare deser-instance-status-summary)

(clojure.core/declare deser-transit-gateway-attachment-state)

(clojure.core/declare deser-nat-gateway-address)

(clojure.core/declare deser-instance-status-list)

(clojure.core/declare deser-placement-group-list)

(clojure.core/declare deser-address-list)

(clojure.core/declare deser-reserved-instances-offering-list)

(clojure.core/declare deser-cidr-block)

(clojure.core/declare deser-client-vpn-route)

(clojure.core/declare deser-reserved-instances-list)

(clojure.core/declare deser-image-list)

(clojure.core/declare deser-launch-template-capacity-reservation-specification-response)

(clojure.core/declare deser-user-id-group-pair-list)

(clojure.core/declare deser-s-3-storage)

(clojure.core/declare deser-recurring-charge)

(clojure.core/declare deser-spot-fleet-request-config-set)

(clojure.core/declare deser-byoip-cidr)

(clojure.core/declare deser-launch-permission-list)

(clojure.core/declare deser-price-schedule-list)

(clojure.core/declare deser-instance-private-ip-address-list)

(clojure.core/declare deser-instance-ipv-6-address)

(clojure.core/declare deser-group-identifier)

(clojure.core/declare deser-fpga-image-list)

(clojure.core/declare deser-spot-price)

(clojure.core/declare deser-client-vpn-connection-set)

(clojure.core/declare deser-instance-id-set)

(clojure.core/declare deser-scheduled-instance-availability-set)

(clojure.core/declare deser-nat-gateway)

(clojure.core/declare deser-elastic-gpu-status)

(clojure.core/declare deser-launch-template-iam-instance-profile-specification)

(clojure.core/declare deser-spot-instance-status)

(clojure.core/declare deser-delete-launch-template-versions-response-success-set)

(clojure.core/declare deser-tag-description)

(clojure.core/declare deser-transit-gateway-attachment-resource-type)

(clojure.core/declare deser-account-attribute-value-list)

(clojure.core/declare deser-import-snapshot-task-list)

(clojure.core/declare deser-launch-template-license-configuration)

(clojure.core/declare deser-dhcp-options)

(clojure.core/declare deser-spot-instance-interruption-behavior)

(clojure.core/declare deser-run-instances-monitoring-enabled)

(clojure.core/declare deser-authorization-rule-set)

(clojure.core/declare deser-user-id-group-pair-set)

(clojure.core/declare deser-tag-list)

(clojure.core/declare deser-network-acl-association-list)

(clojure.core/declare deser-client-vpn-authorization-rule-status-code)

(clojure.core/declare deser-product-code-list)

(clojure.core/declare deser-volume-status-info-status)

(clojure.core/declare deser-spot-fleet-request-config-data)

(clojure.core/declare deser-authorization-rule)

(clojure.core/declare deser-launch-template-overrides)

(clojure.core/declare deser-host-offering)

(clojure.core/declare deser-unsuccessful-instance-credit-specification-error-code)

(clojure.core/declare deser-listing-state)

(clojure.core/declare deser-volume-status-events-list)

(clojure.core/declare deser-datafeed-subscription-state)

(clojure.core/declare deser-service-detail)

(clojure.core/declare deser-network-interface-list)

(clojure.core/declare deser-cancel-batch-error-code)

(clojure.core/declare deser-target-configuration)

(clojure.core/declare deser-allocation-strategy)

(clojure.core/declare deser-status-name)

(clojure.core/declare deser-volume-status-event)

(clojure.core/declare deser-describe-fleets-error-set)

(clojure.core/declare deser-target-reservation-value)

(clojure.core/declare deser-reserved-intances-ids)

(clojure.core/declare deser-attribute-value)

(clojure.core/declare deser-launch-template-block-device-mapping-list)

(clojure.core/declare deser-network-acl-association)

(clojure.core/declare deser-private-ip-address-specification-list)

(clojure.core/declare deser-auto-placement)

(clojure.core/declare deser-prefix-list-id-list)

(clojure.core/declare deser-auto-accept-shared-attachments-value)

(clojure.core/declare deser-availability-zone-message-list)

(clojure.core/declare deser-launch-template-hibernation-options)

(clojure.core/declare deser-history-records)

(clojure.core/declare deser-tag-description-list)

(clojure.core/declare deser-product-code-values)

(clojure.core/declare deser-fleet-launch-template-config)

(clojure.core/declare deser-instance-health-status)

(clojure.core/declare deser-purchase-set)

(clojure.core/declare deser-client-vpn-route-set)

(clojure.core/declare deser-client-vpn-route-status)

(clojure.core/declare deser-create-fleet-instances-set)

(clojure.core/declare deser-ipv-6-cidr-block)

(clojure.core/declare deser-placement-strategy)

(clojure.core/declare deser-internet-gateway-attachment-list)

(clojure.core/declare deser-license-configuration)

(clojure.core/declare deser-volume-status-info)

(clojure.core/declare deser-instance-capacity)

(clojure.core/declare deser-instance-block-device-mapping)

(clojure.core/declare deser-connection-notification-state)

(clojure.core/declare deser-instance-interruption-behavior)

(clojure.core/declare deser-customer-gateway-list)

(clojure.core/declare deser-spot-options)

(clojure.core/declare deser-classic-link-dns-support)

(clojure.core/declare deser-vpc-cidr-block-state-code)

(clojure.core/declare deser-public-ipv-4-pool-set)

(clojure.core/declare deser-monitoring-state)

(clojure.core/declare deser-reserved-instance-reservation-value-set)

(clojure.core/declare deser-hibernation-options)

(clojure.core/declare deserscope)

(clojure.core/declare deser-network-interface-permission-state-code)

(clojure.core/declare deser-connection-log-response-options)

(clojure.core/declare deser-device-type)

(clojure.core/declare deser-route-list)

(clojure.core/declare deser-pricing-detail)

(clojure.core/declare deser-transit-gateway-route-type)

(clojure.core/declare deser-import-volume-task-details)

(clojure.core/declare deser-instance-match-criteria)

(clojure.core/declare deser-transit-gateway-route-table)

(clojure.core/declare deser-subnet-cidr-block-state-code)

(clojure.core/declare deser-fpga-image-state-code)

(clojure.core/declare deser-launch-template-license-list)

(clojure.core/declare deser-on-demand-options)

(clojure.core/declare deser-network-interface-status)

(clojure.core/declare deser-vpc-classic-link-list)

(clojure.core/declare deser-group-id-string-list)

(clojure.core/declare deser-fleet-data)

(clojure.core/declare deser-price-schedule)

(clojure.core/declare deser-iam-instance-profile-association)

(clojure.core/declare deser-reserved-instance-state)

(clojure.core/declare deser-allocation-state)

(clojure.core/declare deser-connection-notification)

(clojure.core/declare deser-launch-template-block-device-mapping)

(clojure.core/declare deser-export-task-state)

(clojure.core/declare deser-log-destination-type)

(clojure.core/declare deser-instance-state-change)

(clojure.core/declare deser-monitoring)

(clojure.core/declare deser-elastic-gpu-health)

(clojure.core/declare deser-event-information)

(clojure.core/declare deser-launch-template-instance-network-interface-specification-list)

(clojure.core/declare deser-launch-specs-list)

(clojure.core/declare deser-unsuccessful-instance-credit-specification-item)

(clojure.core/declare deser-volume-status-details)

(clojure.core/declare deser-load-balancers-config)

(clojure.core/declare deser-integer)

(clojure.core/declare deser-string)

(clojure.core/declare deser-elastic-gpus)

(clojure.core/declare deser-transit-gateway-route-table-propagation)

(clojure.core/declare deser-classic-load-balancer)

(clojure.core/declare deser-ip-permission)

(clojure.core/declare deser-ip-permission-list)

(clojure.core/declare deser-transit-gateway-route-attachment-list)

(clojure.core/declare deser-ri-product-description)

(clojure.core/declare deser-instance-ids-set)

(clojure.core/declare deser-volume-list)

(clojure.core/declare deser-vpc-endpoint-connection-set)

(clojure.core/declare deser-dhcp-options-list)

(clojure.core/declare deser-transit-gateway-route-table-list)

(clojure.core/declare deser-default-route-table-propagation-value)

(clojure.core/declare deser-unsuccessful-item)

(clojure.core/declare deser-principal-id-format-list)

(clojure.core/declare deser-cancel-spot-fleet-requests-success-item)

(clojure.core/declare deser-client-vpn-endpoint)

(clojure.core/declare deser-launch-template-config)

(clojure.core/declare deser-propagating-vgw-list)

(clojure.core/declare deser-disk-image-format)

(clojure.core/declare deser-network-interface-attachment)

(clojure.core/declare deser-security-group-id-string-list)

(clojure.core/declare deser-spot-fleet-request-config)

(clojure.core/declare deser-domain-type)

(clojure.core/declare deser-vgw-telemetry)

(clojure.core/declare deser-cancel-spot-instance-request-state)

(clojure.core/declare deser-subnet-ipv-6-cidr-block-association-set)

(clojure.core/declare deser-network-interface)

(clojure.core/declare deser-launch-template-name)

(clojure.core/declare deser-snapshot)

(clojure.core/declare deser-resource-type)

(clojure.core/declare deser-instance-status-event)

(clojure.core/declare deser-vpc-peering-connection-options-description)

(clojure.core/declare deser-transit-gateway-options)

(clojure.core/declare deser-volume-status-name)

(clojure.core/declare deser-internet-gateway)

(clojure.core/declare deser-vpc)

(clojure.core/declare deser-ipv-6-address-list)

(clojure.core/declare deser-transit-gateway-route-state)

(clojure.core/declare deser-network-interface-permission-list)

(clojure.core/declare deser-batch-state)

(clojure.core/declare deser-fleet-on-demand-allocation-strategy)

(clojure.core/declare deser-reservation-value)

(clojure.core/declare deser-host-instance)

(clojure.core/declare deser-launch-template-cpu-options)

(clojure.core/declare deser-currency-code-values)

(clojure.core/declare deser-import-image-task)

(clojure.core/declare deser-load-permission)

(clojure.core/declare deser-volume-status-details-list)

(clojure.core/declare deser-byoip-cidr-set)

(clojure.core/declare deser-fleet-launch-template-overrides-list)

(clojure.core/declare deser-summary-status)

(clojure.core/declare deser-fleet-launch-template-overrides)

(clojure.core/declare deser-instance-list)

(clojure.core/declare deser-launch-template-elastic-inference-accelerator-response-list)

(clojure.core/declare deser-volume-type)

(clojure.core/declare deser-capacity-reservation-state)

(clojure.core/declare deser-client-vpn-route-status-code)

(clojure.core/declare deser-customer-gateway)

(clojure.core/declare deser-network-interface-permission)

(clojure.core/declare deser-response-host-id-list)

(clojure.core/declare deser-transit-gateway-route-table-association)

(clojure.core/declare deser-vpn-ecmp-support-value)

(clojure.core/declare deser-vpc-cidr-block-association)

(clojure.core/declare deser-launch-template-instance-network-interface-specification)

(clojure.core/declare deser-host-list)

(clojure.core/declare deser-stale-security-group-set)

(clojure.core/declare deser-elastic-gpu-specification-response-list)

(clojure.core/declare deser-classic-load-balancers-config)

(clojure.core/declare deser-volume-status-list)

(clojure.core/declare deser-export-task)

(clojure.core/declare deser-transit-gateway-association)

(clojure.core/declare deser-transit-gateway-state)

(clojure.core/declare deser-dns-support-value)

(clojure.core/declare deser-network-interface-private-ip-address)

(clojure.core/declare deser-transit-gateway-propagation)

(clojure.core/declare deser-placement-group-state)

(clojure.core/declare deser-long)

(clojure.core/declare deser-describe-fleet-error)

(clojure.core/declare deser-volume-status-actions-list)

(clojure.core/declare deser-vpn-static-route-source)

(clojure.core/declare deser-host-offering-set)

(clojure.core/declare deser-vpc-endpoint-set)

(clojure.core/declare deser-scheduled-instance-recurrence)

(clojure.core/declare deser-allowed-principal)

(clojure.core/declare deser-unsuccessful-instance-credit-specification-set)

(clojure.core/declare deser-instance-state)

(clojure.core/declare deser-volume-status-item)

(clojure.core/declare deser-spot-instance-state)

(clojure.core/declare deser-capacity-reservation)

(clojure.core/declare deser-instance-state-name)

(clojure.core/declare deser-availability-zone-message)

(clojure.core/declare deser-launch-template-version-set)

(clojure.core/declare deser-version-description)

(clojure.core/declare deser-elastic-inference-accelerator-association-list)

(clojure.core/declare deser-host-reservation-set)

(clojure.core/declare deser-unsuccessful-item-list)

(clojure.core/declare deser-virtualization-type)

(clojure.core/declare deser-launch-template-elastic-inference-accelerator-response)

(clojure.core/declare deser-reserved-instances-id)

(clojure.core/declare deser-instance-credit-specification-list)

(clojure.core/declare deser-default-target-capacity-type)

(clojure.core/declare deser-instance-network-interface-specification-list)

(clojure.core/declare deser-conversion-task)

(clojure.core/declare deser-successful-instance-credit-specification-set)

(clojure.core/declare deser-bundle-task-error)

(clojure.core/declare deser-dhcp-configuration)

(clojure.core/declare deser-block-device-mapping)

(clojure.core/declare deser-state)

(clojure.core/declare deser-export-to-s-3-task)

(clojure.core/declare deser-network-acl-list)

(clojure.core/declare deser-target-network-set)

(clojure.core/declare deser-public-ipv-4-pool)

(clojure.core/declare deser-cpu-options)

(clojure.core/declare deser-tag)

(clojure.core/declare deser-client-vpn-connection)

(clojure.core/declare deser-recurring-charge-frequency)

(clojure.core/declare deser-spot-fleet-tag-specification)

(clojure.core/declare deser-platform-values)

(clojure.core/declare deser-cancel-spot-fleet-requests-success-set)

(clojure.core/declare deser-product-code)

(clojure.core/declare deser-client-vpn-authentication-list)

(clojure.core/declare deser-port-range)

(clojure.core/declare deser-vpc-state)

(clojure.core/declare deser-attachment-status)

(clojure.core/declare deser-peering-connection-options)

(clojure.core/declare deser-launch-templates-monitoring)

(clojure.core/declare deser-dns-entry-set)

(clojure.core/declare deser-launch-template-version)

(clojure.core/declare deser-vpc-attachment)

(clojure.core/declare deser-instance-status)

(clojure.core/declare deser-spot-fleet-launch-specification)

(clojure.core/declare deser-ipv-6-cidr-block-set)

(clojure.core/declare deser-ip-range)

(clojure.core/declare deser-cidr-block-set)

(clojure.core/declare deser-stale-security-group)

(clojure.core/declare deser-import-snapshot-task)

(clojure.core/declare deser-elastic-gpu-specification-response)

(clojure.core/declare deser-container-format)

(clojure.core/declare deser-network-interface-ipv-6-addresses-list)

(clojure.core/declare deser-vpc-peering-connection-state-reason)

(clojure.core/declare deser-market-type)

(clojure.core/declare deser-instance)

(clojure.core/declare deser-nat-gateway-state)

(clojure.core/declare deser-block-device-mapping-list)

(clojure.core/declare deser-blob)

(clojure.core/declare deser-describe-fleets-instances-set)

(clojure.core/declare deser-delete-fleet-error-item)

(clojure.core/declare deser-instance-block-device-mapping-list)

(clojure.core/declare deser-security-group-reference)

(clojure.core/declare deser-classic-link-dns-support-list)

(clojure.core/declare deser-gateway-type)

(clojure.core/declare deser-image)

(clojure.core/declare deser-transport-protocol)

(clojure.core/declare deser-ip-range-list)

(clojure.core/declare deser-image-type-values)

(clojure.core/declare deser-classic-link-instance)

(clojure.core/declare deser-certificate-authentication)

(clojure.core/declare deser-classic-load-balancers)

(clojure.core/declare deser-transit-gateway-route-attachment)

(clojure.core/declare deser-security-group-identifier)

(clojure.core/declare deser-transit-gateway-attachment-propagation)

(clojure.core/declare deser-cancel-spot-fleet-requests-error-set)

(clojure.core/declare deser-reserved-instances-modification-list)

(clojure.core/declare deser-network-acl-entry-list)

(clojure.core/declare deser-network-interface-private-ip-address-list)

(clojure.core/declare deser-target-group)

(clojure.core/declare deser-instance-event-id)

(clojure.core/declare deser-conversion-task-state)

(clojure.core/declare deser-transit-gateway-route-table-association-list)

(clojure.core/declare deser-offering-class-type)

(clojure.core/declare deser-launch-template-error-code)

(clojure.core/declare deser-nat-gateway-address-list)

(clojure.core/declare deser-transit-gateway-route-table-propagation-list)

(clojure.core/declare deser-reserved-instances-modification)

(clojure.core/declare deser-listing-status)

(clojure.core/declare deser-launch-template-overrides-list)

(clojure.core/declare deser-classic-link-instance-list)

(clojure.core/declare deser-import-image-task-list)

(clojure.core/declare deser-capacity-reservation-preference)

(clojure.core/declare deser-route-table-association-list)

(clojure.core/declare deser-iam-instance-profile-association-state)

(clojure.core/declare deser-service-configuration)

(clojure.core/declare deser-offering-type-values)

(clojure.core/declare deser-float)

(clojure.core/declare deser-network-acl)

(clojure.core/declare deser-target-capacity-specification)

(clojure.core/declare deser-delete-launch-template-versions-response-error-set)

(clojure.core/declare deser-unsuccessful-instance-credit-specification-item-error)

(clojure.core/declare deser-volume-attachment)

(clojure.core/declare deser-route-table-association)

(clojure.core/declare deser-subnet-ipv-6-cidr-block-association)

(clojure.core/declare deser-public-ipv-4-pool-range)

(clojure.core/declare deser-principal-id-format)

(clojure.core/declare deser-vpn-connection)

(clojure.core/declare deser-region)

(clojure.core/declare deser-fpga-image-state)

(clojure.core/declare deser-state-reason)

(clojure.core/declare deser-elastic-gpu-state)

(clojure.core/declare deser-iam-instance-profile)

(clojure.core/declare deser-scheduled-instance-availability)

(clojure.core/declare deser-active-instance)

(clojure.core/declare deser-fleet-excess-capacity-termination-policy)

(clojure.core/declare deser-subnet-list)

(clojure.core/declare deser-account-attribute-value)

(clojure.core/declare deser-vpc-peering-connection-state-reason-code)

(clojure.core/declare deser-launch-permission)

(clojure.core/declare deser-elastic-gpu-set)

(clojure.core/declare deser-internet-gateway-list)

(clojure.core/declare deser-delete-fleet-error)

(clojure.core/declare deser-account-attribute)

(clojure.core/declare deser-history-record-set)

(clojure.core/declare deser-launch-template-instance-market-options)

(clojure.core/declare deser-ipv-6-range)

(clojure.core/declare deser-host)

(clojure.core/declare deser-egress-only-internet-gateway-id)

(clojure.core/declare deser-transit-gateway-propagation-state)

(clojure.core/declare deser-activity-status)

(clojure.core/declare deser-placement-group)

(clojure.core/declare deser-reserved-instance-reservation-value)

(clojure.core/declare deser-private-ip-address-specification)

(clojure.core/declare deser-reservation-list)

(clojure.core/declare deser-delete-fleet-error-set)

(clojure.core/declare deser-vpc-ipv-6-cidr-block-association-set)

(clojure.core/declare deser-volume-modification-state)

(clojure.core/declare deser-directory-service-authentication)

(clojure.core/declare deser-user-id-group-pair)

(clojure.core/declare deser-host-reservation)

(clojure.core/declare deser-capacity-reservation-tenancy)

(clojure.core/declare deser-telemetry-status)

(clojure.core/declare deser-create-fleet-errors-set)

(clojure.core/declare deser-delete-fleet-error-code)

(clojure.core/declare deser-vpn-gateway)

(clojure.core/declare deser-network-interface-association)

(clojure.core/declare deser-launch-template-placement)

(clojure.core/declare deser-placement-response)

(clojure.core/declare deser-date-time)

(clojure.core/declare deser-shutdown-behavior)

(clojure.core/declare deser-egress-only-internet-gateway)

(clojure.core/declare deser-boolean)

(clojure.core/declare deser-instance-network-interface-specification)

(clojure.core/declare deser-client-vpn-security-group-id-set)

(clojure.core/declare deser-reservation-state)

(clojure.core/declare deser-available-instance-capacity-list)

(clojure.core/declare deser-snapshot-state)

(clojure.core/declare deser-vpn-gateway-list)

(clojure.core/defn- deser-transit-gateway-vpc-attachment-options [input] (clojure.core/let [letvar612091 {"dnsSupport" (portkey.aws/search-for-tag input "dnsSupport" :flattened? nil :xmlAttribute? nil), "ipv6Support" (portkey.aws/search-for-tag input "ipv6Support" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar612091 "dnsSupport") (clojure.core/assoc :dns-support (deser-dns-support-value (clojure.core/get-in letvar612091 ["dnsSupport" :content]))) (letvar612091 "ipv6Support") (clojure.core/assoc :ipv-6-support (deser-ipv-6-support-value (clojure.core/get-in letvar612091 ["ipv6Support" :content]))))))

(clojure.core/defn- deser-export-task-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-export-task coll))) input))

(clojure.core/defn- deser-client-vpn-authorization-rule-status [input] (clojure.core/let [letvar612216 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar612216 "code") (clojure.core/assoc :code (deser-client-vpn-authorization-rule-status-code (clojure.core/get-in letvar612216 ["code" :content]))) (letvar612216 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar612216 ["message" :content]))))))

(clojure.core/defn- deser-event-code [input] (clojure.core/get {"instance-reboot" :instancereboot, "system-reboot" :systemreboot, "system-maintenance" :systemmaintenance, "instance-retirement" :instanceretirement, "instance-stop" :instancestop} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-flow-log [input] (clojure.core/let [letvar612329 {"logDestinationType" (portkey.aws/search-for-tag input "logDestinationType" :flattened? nil :xmlAttribute? nil), "resourceId" (portkey.aws/search-for-tag input "resourceId" :flattened? nil :xmlAttribute? nil), "deliverLogsPermissionArn" (portkey.aws/search-for-tag input "deliverLogsPermissionArn" :flattened? nil :xmlAttribute? nil), "deliverLogsErrorMessage" (portkey.aws/search-for-tag input "deliverLogsErrorMessage" :flattened? nil :xmlAttribute? nil), "logGroupName" (portkey.aws/search-for-tag input "logGroupName" :flattened? nil :xmlAttribute? nil), "deliverLogsStatus" (portkey.aws/search-for-tag input "deliverLogsStatus" :flattened? nil :xmlAttribute? nil), "creationTime" (portkey.aws/search-for-tag input "creationTime" :flattened? nil :xmlAttribute? nil), "flowLogStatus" (portkey.aws/search-for-tag input "flowLogStatus" :flattened? nil :xmlAttribute? nil), "logDestination" (portkey.aws/search-for-tag input "logDestination" :flattened? nil :xmlAttribute? nil), "trafficType" (portkey.aws/search-for-tag input "trafficType" :flattened? nil :xmlAttribute? nil), "flowLogId" (portkey.aws/search-for-tag input "flowLogId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar612329 "flowLogStatus") (clojure.core/assoc :flow-log-status (deser-string (clojure.core/get-in letvar612329 ["flowLogStatus" :content]))) (letvar612329 "trafficType") (clojure.core/assoc :traffic-type (deser-traffic-type (clojure.core/get-in letvar612329 ["trafficType" :content]))) (letvar612329 "resourceId") (clojure.core/assoc :resource-id (deser-string (clojure.core/get-in letvar612329 ["resourceId" :content]))) (letvar612329 "deliverLogsErrorMessage") (clojure.core/assoc :deliver-logs-error-message (deser-string (clojure.core/get-in letvar612329 ["deliverLogsErrorMessage" :content]))) (letvar612329 "deliverLogsStatus") (clojure.core/assoc :deliver-logs-status (deser-string (clojure.core/get-in letvar612329 ["deliverLogsStatus" :content]))) (letvar612329 "deliverLogsPermissionArn") (clojure.core/assoc :deliver-logs-permission-arn (deser-string (clojure.core/get-in letvar612329 ["deliverLogsPermissionArn" :content]))) (letvar612329 "logDestinationType") (clojure.core/assoc :log-destination-type (deser-log-destination-type (clojure.core/get-in letvar612329 ["logDestinationType" :content]))) (letvar612329 "flowLogId") (clojure.core/assoc :flow-log-id (deser-string (clojure.core/get-in letvar612329 ["flowLogId" :content]))) (letvar612329 "logGroupName") (clojure.core/assoc :log-group-name (deser-string (clojure.core/get-in letvar612329 ["logGroupName" :content]))) (letvar612329 "creationTime") (clojure.core/assoc :creation-time (deser-date-time (clojure.core/get-in letvar612329 ["creationTime" :content]))) (letvar612329 "logDestination") (clojure.core/assoc :log-destination (deser-string (clojure.core/get-in letvar612329 ["logDestination" :content]))))))

(clojure.core/defn- deser-vpc-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc coll))) input))

(clojure.core/defn- deser-launch-template-and-overrides-response [input] (clojure.core/let [letvar612454 {"launchTemplateSpecification" (portkey.aws/search-for-tag input "launchTemplateSpecification" :flattened? nil :xmlAttribute? nil), "overrides" (portkey.aws/search-for-tag input "overrides" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar612454 "launchTemplateSpecification") (clojure.core/assoc :launch-template-specification (deser-fleet-launch-template-specification (clojure.core/get-in letvar612454 ["launchTemplateSpecification" :content]))) (letvar612454 "overrides") (clojure.core/assoc :overrides (deser-fleet-launch-template-overrides (clojure.core/get-in letvar612454 ["overrides" :content]))))))

(clojure.core/defn- deser-history-record-entry [input] (clojure.core/let [letvar612562 {"eventInformation" (portkey.aws/search-for-tag input "eventInformation" :flattened? nil :xmlAttribute? nil), "eventType" (portkey.aws/search-for-tag input "eventType" :flattened? nil :xmlAttribute? nil), "timestamp" (portkey.aws/search-for-tag input "timestamp" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar612562 "eventInformation") (clojure.core/assoc :event-information (deser-event-information (clojure.core/get-in letvar612562 ["eventInformation" :content]))) (letvar612562 "eventType") (clojure.core/assoc :event-type (deser-fleet-event-type (clojure.core/get-in letvar612562 ["eventType" :content]))) (letvar612562 "timestamp") (clojure.core/assoc :timestamp (deser-date-time (clojure.core/get-in letvar612562 ["timestamp" :content]))))))

(clojure.core/defn- deser-spot-allocation-strategy [input] (clojure.core/get {"lowest-price" :lowestprice, "diversified" :diversified} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-volume-status-action [input] (clojure.core/let [letvar612675 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "eventId" (portkey.aws/search-for-tag input "eventId" :flattened? nil :xmlAttribute? nil), "eventType" (portkey.aws/search-for-tag input "eventType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar612675 "code") (clojure.core/assoc :code (deser-string (clojure.core/get-in letvar612675 ["code" :content]))) (letvar612675 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar612675 ["description" :content]))) (letvar612675 "eventId") (clojure.core/assoc :event-id (deser-string (clojure.core/get-in letvar612675 ["eventId" :content]))) (letvar612675 "eventType") (clojure.core/assoc :event-type (deser-string (clojure.core/get-in letvar612675 ["eventType" :content]))))))

(clojure.core/defn- deser-transit-gateway-attachment [input] (clojure.core/let [letvar612783 {"resourceOwnerId" (portkey.aws/search-for-tag input "resourceOwnerId" :flattened? nil :xmlAttribute? nil), "association" (portkey.aws/search-for-tag input "association" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "resourceId" (portkey.aws/search-for-tag input "resourceId" :flattened? nil :xmlAttribute? nil), "transitGatewayId" (portkey.aws/search-for-tag input "transitGatewayId" :flattened? nil :xmlAttribute? nil), "transitGatewayAttachmentId" (portkey.aws/search-for-tag input "transitGatewayAttachmentId" :flattened? nil :xmlAttribute? nil), "transitGatewayOwnerId" (portkey.aws/search-for-tag input "transitGatewayOwnerId" :flattened? nil :xmlAttribute? nil), "creationTime" (portkey.aws/search-for-tag input "creationTime" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "resourceType" (portkey.aws/search-for-tag input "resourceType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar612783 "transitGatewayId") (clojure.core/assoc :transit-gateway-id (deser-string (clojure.core/get-in letvar612783 ["transitGatewayId" :content]))) (letvar612783 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar612783 ["tagSet" :content]))) (letvar612783 "transitGatewayOwnerId") (clojure.core/assoc :transit-gateway-owner-id (deser-string (clojure.core/get-in letvar612783 ["transitGatewayOwnerId" :content]))) (letvar612783 "resourceId") (clojure.core/assoc :resource-id (deser-string (clojure.core/get-in letvar612783 ["resourceId" :content]))) (letvar612783 "transitGatewayAttachmentId") (clojure.core/assoc :transit-gateway-attachment-id (deser-string (clojure.core/get-in letvar612783 ["transitGatewayAttachmentId" :content]))) (letvar612783 "resourceType") (clojure.core/assoc :resource-type (deser-transit-gateway-attachment-resource-type (clojure.core/get-in letvar612783 ["resourceType" :content]))) (letvar612783 "creationTime") (clojure.core/assoc :creation-time (deser-date-time (clojure.core/get-in letvar612783 ["creationTime" :content]))) (letvar612783 "state") (clojure.core/assoc :state (deser-transit-gateway-attachment-state (clojure.core/get-in letvar612783 ["state" :content]))) (letvar612783 "association") (clojure.core/assoc :association (deser-transit-gateway-attachment-association (clojure.core/get-in letvar612783 ["association" :content]))) (letvar612783 "resourceOwnerId") (clojure.core/assoc :resource-owner-id (deser-string (clojure.core/get-in letvar612783 ["resourceOwnerId" :content]))))))

(clojure.core/defn- deser-permission-group [input] (clojure.core/get {"all" :all} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-address [input] (clojure.core/let [letvar612896 {"publicIpv4Pool" (portkey.aws/search-for-tag input "publicIpv4Pool" :flattened? nil :xmlAttribute? nil), "privateIpAddress" (portkey.aws/search-for-tag input "privateIpAddress" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "publicIp" (portkey.aws/search-for-tag input "publicIp" :flattened? nil :xmlAttribute? nil), "associationId" (portkey.aws/search-for-tag input "associationId" :flattened? nil :xmlAttribute? nil), "domain" (portkey.aws/search-for-tag input "domain" :flattened? nil :xmlAttribute? nil), "networkInterfaceOwnerId" (portkey.aws/search-for-tag input "networkInterfaceOwnerId" :flattened? nil :xmlAttribute? nil), "networkInterfaceId" (portkey.aws/search-for-tag input "networkInterfaceId" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "allocationId" (portkey.aws/search-for-tag input "allocationId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar612896 "publicIp") (clojure.core/assoc :public-ip (deser-string (clojure.core/get-in letvar612896 ["publicIp" :content]))) (letvar612896 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar612896 ["instanceId" :content]))) (letvar612896 "networkInterfaceOwnerId") (clojure.core/assoc :network-interface-owner-id (deser-string (clojure.core/get-in letvar612896 ["networkInterfaceOwnerId" :content]))) (letvar612896 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar612896 ["associationId" :content]))) (letvar612896 "allocationId") (clojure.core/assoc :allocation-id (deser-string (clojure.core/get-in letvar612896 ["allocationId" :content]))) (letvar612896 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar612896 ["tagSet" :content]))) (letvar612896 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar612896 ["networkInterfaceId" :content]))) (letvar612896 "domain") (clojure.core/assoc :domain (deser-domain-type (clojure.core/get-in letvar612896 ["domain" :content]))) (letvar612896 "publicIpv4Pool") (clojure.core/assoc :public-ipv-4-pool (deser-string (clojure.core/get-in letvar612896 ["publicIpv4Pool" :content]))) (letvar612896 "privateIpAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar612896 ["privateIpAddress" :content]))))))

(clojure.core/defn- deser-response-error [input] (clojure.core/let [letvar613004 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar613004 "code") (clojure.core/assoc :code (deser-launch-template-error-code (clojure.core/get-in letvar613004 ["code" :content]))) (letvar613004 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar613004 ["message" :content]))))))

(clojure.core/defn- deser-bundle-task [input] (clojure.core/let [letvar613112 {"bundleId" (portkey.aws/search-for-tag input "bundleId" :flattened? nil :xmlAttribute? nil), "error" (portkey.aws/search-for-tag input "error" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "progress" (portkey.aws/search-for-tag input "progress" :flattened? nil :xmlAttribute? nil), "startTime" (portkey.aws/search-for-tag input "startTime" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "storage" (portkey.aws/search-for-tag input "storage" :flattened? nil :xmlAttribute? nil), "updateTime" (portkey.aws/search-for-tag input "updateTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar613112 "bundleId") (clojure.core/assoc :bundle-id (deser-string (clojure.core/get-in letvar613112 ["bundleId" :content]))) (letvar613112 "error") (clojure.core/assoc :bundle-task-error (deser-bundle-task-error (clojure.core/get-in letvar613112 ["error" :content]))) (letvar613112 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar613112 ["instanceId" :content]))) (letvar613112 "progress") (clojure.core/assoc :progress (deser-string (clojure.core/get-in letvar613112 ["progress" :content]))) (letvar613112 "startTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar613112 ["startTime" :content]))) (letvar613112 "state") (clojure.core/assoc :state (deser-bundle-task-state (clojure.core/get-in letvar613112 ["state" :content]))) (letvar613112 "storage") (clojure.core/assoc :storage (deser-storage (clojure.core/get-in letvar613112 ["storage" :content]))) (letvar613112 "updateTime") (clojure.core/assoc :update-time (deser-date-time (clojure.core/get-in letvar613112 ["updateTime" :content]))))))

(clojure.core/defn- deser-client-certificate-revocation-list-status-code [input] (clojure.core/get {"pending" :pending, "active" :active} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-launch-template-config-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-launch-template-config coll))) input))

(clojure.core/defn- deser-elastic-inference-accelerator-association [input] (clojure.core/let [letvar613242 {"elasticInferenceAcceleratorArn" (portkey.aws/search-for-tag input "elasticInferenceAcceleratorArn" :flattened? nil :xmlAttribute? nil), "elasticInferenceAcceleratorAssociationId" (portkey.aws/search-for-tag input "elasticInferenceAcceleratorAssociationId" :flattened? nil :xmlAttribute? nil), "elasticInferenceAcceleratorAssociationState" (portkey.aws/search-for-tag input "elasticInferenceAcceleratorAssociationState" :flattened? nil :xmlAttribute? nil), "elasticInferenceAcceleratorAssociationTime" (portkey.aws/search-for-tag input "elasticInferenceAcceleratorAssociationTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar613242 "elasticInferenceAcceleratorArn") (clojure.core/assoc :elastic-inference-accelerator-arn (deser-string (clojure.core/get-in letvar613242 ["elasticInferenceAcceleratorArn" :content]))) (letvar613242 "elasticInferenceAcceleratorAssociationId") (clojure.core/assoc :elastic-inference-accelerator-association-id (deser-string (clojure.core/get-in letvar613242 ["elasticInferenceAcceleratorAssociationId" :content]))) (letvar613242 "elasticInferenceAcceleratorAssociationState") (clojure.core/assoc :elastic-inference-accelerator-association-state (deser-string (clojure.core/get-in letvar613242 ["elasticInferenceAcceleratorAssociationState" :content]))) (letvar613242 "elasticInferenceAcceleratorAssociationTime") (clojure.core/assoc :elastic-inference-accelerator-association-time (deser-date-time (clojure.core/get-in letvar613242 ["elasticInferenceAcceleratorAssociationTime" :content]))))))

(clojure.core/defn- deser-security-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-security-group coll))) input))

(clojure.core/defn- deser-service-type-detail-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-service-type-detail coll))) input))

(clojure.core/defn- deser-principal-type [input] (clojure.core/get {"All" :all, "Service" :service, "OrganizationUnit" :organization-unit, "Account" :account, "User" :user, "Role" :role} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-instance-count-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-count coll))) input))

(clojure.core/defn- deser-describe-conversion-task-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-conversion-task coll))) input))

(clojure.core/defn- deser-route [input] (clojure.core/let [letvar613423 {"origin" (portkey.aws/search-for-tag input "origin" :flattened? nil :xmlAttribute? nil), "instanceOwnerId" (portkey.aws/search-for-tag input "instanceOwnerId" :flattened? nil :xmlAttribute? nil), "transitGatewayId" (portkey.aws/search-for-tag input "transitGatewayId" :flattened? nil :xmlAttribute? nil), "egressOnlyInternetGatewayId" (portkey.aws/search-for-tag input "egressOnlyInternetGatewayId" :flattened? nil :xmlAttribute? nil), "destinationIpv6CidrBlock" (portkey.aws/search-for-tag input "destinationIpv6CidrBlock" :flattened? nil :xmlAttribute? nil), "natGatewayId" (portkey.aws/search-for-tag input "natGatewayId" :flattened? nil :xmlAttribute? nil), "destinationCidrBlock" (portkey.aws/search-for-tag input "destinationCidrBlock" :flattened? nil :xmlAttribute? nil), "gatewayId" (portkey.aws/search-for-tag input "gatewayId" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "vpcPeeringConnectionId" (portkey.aws/search-for-tag input "vpcPeeringConnectionId" :flattened? nil :xmlAttribute? nil), "destinationPrefixListId" (portkey.aws/search-for-tag input "destinationPrefixListId" :flattened? nil :xmlAttribute? nil), "networkInterfaceId" (portkey.aws/search-for-tag input "networkInterfaceId" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar613423 "instanceOwnerId") (clojure.core/assoc :instance-owner-id (deser-string (clojure.core/get-in letvar613423 ["instanceOwnerId" :content]))) (letvar613423 "transitGatewayId") (clojure.core/assoc :transit-gateway-id (deser-string (clojure.core/get-in letvar613423 ["transitGatewayId" :content]))) (letvar613423 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar613423 ["instanceId" :content]))) (letvar613423 "natGatewayId") (clojure.core/assoc :nat-gateway-id (deser-string (clojure.core/get-in letvar613423 ["natGatewayId" :content]))) (letvar613423 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar613423 ["networkInterfaceId" :content]))) (letvar613423 "destinationIpv6CidrBlock") (clojure.core/assoc :destination-ipv-6-cidr-block (deser-string (clojure.core/get-in letvar613423 ["destinationIpv6CidrBlock" :content]))) (letvar613423 "origin") (clojure.core/assoc :origin (deser-route-origin (clojure.core/get-in letvar613423 ["origin" :content]))) (letvar613423 "destinationCidrBlock") (clojure.core/assoc :destination-cidr-block (deser-string (clojure.core/get-in letvar613423 ["destinationCidrBlock" :content]))) (letvar613423 "destinationPrefixListId") (clojure.core/assoc :destination-prefix-list-id (deser-string (clojure.core/get-in letvar613423 ["destinationPrefixListId" :content]))) (letvar613423 "vpcPeeringConnectionId") (clojure.core/assoc :vpc-peering-connection-id (deser-string (clojure.core/get-in letvar613423 ["vpcPeeringConnectionId" :content]))) (letvar613423 "state") (clojure.core/assoc :state (deser-route-state (clojure.core/get-in letvar613423 ["state" :content]))) (letvar613423 "gatewayId") (clojure.core/assoc :gateway-id (deser-string (clojure.core/get-in letvar613423 ["gatewayId" :content]))) (letvar613423 "egressOnlyInternetGatewayId") (clojure.core/assoc :egress-only-internet-gateway-id (deser-string (clojure.core/get-in letvar613423 ["egressOnlyInternetGatewayId" :content]))))))

(clojure.core/defn- deser-dns-entry [input] (clojure.core/let [letvar613531 {"dnsName" (portkey.aws/search-for-tag input "dnsName" :flattened? nil :xmlAttribute? nil), "hostedZoneId" (portkey.aws/search-for-tag input "hostedZoneId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar613531 "dnsName") (clojure.core/assoc :dns-name (deser-string (clojure.core/get-in letvar613531 ["dnsName" :content]))) (letvar613531 "hostedZoneId") (clojure.core/assoc :hosted-zone-id (deser-string (clojure.core/get-in letvar613531 ["hostedZoneId" :content]))))))

(clojure.core/defn- deser-nat-gateway-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-nat-gateway coll))) input))

(clojure.core/defn- deser-moving-address-status-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-moving-address-status coll))) input))

(clojure.core/defn- deser-instance-state-change-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-state-change coll))) input))

(clojure.core/defn- deser-client-vpn-connection-status [input] (clojure.core/let [letvar613690 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar613690 "code") (clojure.core/assoc :code (deser-client-vpn-connection-status-code (clojure.core/get-in letvar613690 ["code" :content]))) (letvar613690 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar613690 ["message" :content]))))))

(clojure.core/defn- deser-iam-instance-profile-association-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-iam-instance-profile-association coll))) input))

(clojure.core/defn- deser-double [input] (java.lang.Double. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-service-type [input] (clojure.core/get {"Interface" :interface, "Gateway" :gateway} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-associated-target-network [input] (clojure.core/let [letvar613822 {"networkId" (portkey.aws/search-for-tag input "networkId" :flattened? nil :xmlAttribute? nil), "networkType" (portkey.aws/search-for-tag input "networkType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar613822 "networkId") (clojure.core/assoc :network-id (deser-string (clojure.core/get-in letvar613822 ["networkId" :content]))) (letvar613822 "networkType") (clojure.core/assoc :network-type (deser-associated-network-type (clojure.core/get-in letvar613822 ["networkType" :content]))))))

(clojure.core/defn- deser-default-route-table-association-value [input] (clojure.core/get {"enable" :enable, "disable" :disable} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-ebs-instance-block-device [input] (clojure.core/let [letvar613935 {"attachTime" (portkey.aws/search-for-tag input "attachTime" :flattened? nil :xmlAttribute? nil), "deleteOnTermination" (portkey.aws/search-for-tag input "deleteOnTermination" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "volumeId" (portkey.aws/search-for-tag input "volumeId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar613935 "attachTime") (clojure.core/assoc :attach-time (deser-date-time (clojure.core/get-in letvar613935 ["attachTime" :content]))) (letvar613935 "deleteOnTermination") (clojure.core/assoc :delete-on-termination (deser-boolean (clojure.core/get-in letvar613935 ["deleteOnTermination" :content]))) (letvar613935 "status") (clojure.core/assoc :status (deser-attachment-status (clojure.core/get-in letvar613935 ["status" :content]))) (letvar613935 "volumeId") (clojure.core/assoc :volume-id (deser-string (clojure.core/get-in letvar613935 ["volumeId" :content]))))))

(clojure.core/defn- deser-route-table [input] (clojure.core/let [letvar614043 {"associationSet" (portkey.aws/search-for-tag input "associationSet" :flattened? nil :xmlAttribute? nil), "propagatingVgwSet" (portkey.aws/search-for-tag input "propagatingVgwSet" :flattened? nil :xmlAttribute? nil), "routeTableId" (portkey.aws/search-for-tag input "routeTableId" :flattened? nil :xmlAttribute? nil), "routeSet" (portkey.aws/search-for-tag input "routeSet" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar614043 "associationSet") (clojure.core/assoc :associations (deser-route-table-association-list (clojure.core/get-in letvar614043 ["associationSet" :content]))) (letvar614043 "propagatingVgwSet") (clojure.core/assoc :propagating-vgws (deser-propagating-vgw-list (clojure.core/get-in letvar614043 ["propagatingVgwSet" :content]))) (letvar614043 "routeTableId") (clojure.core/assoc :route-table-id (deser-string (clojure.core/get-in letvar614043 ["routeTableId" :content]))) (letvar614043 "routeSet") (clojure.core/assoc :routes (deser-route-list (clojure.core/get-in letvar614043 ["routeSet" :content]))) (letvar614043 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar614043 ["tagSet" :content]))) (letvar614043 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar614043 ["vpcId" :content]))) (letvar614043 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar614043 ["ownerId" :content]))))))

(clojure.core/defn- deser-license-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-license-configuration coll))) input))

(clojure.core/defn- deser-scheduled-instance-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-scheduled-instance coll))) input))

(clojure.core/defn- deser-launch-template-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-launch-template coll))) input))

(clojure.core/defn- deser-target-groups-config [input] (clojure.core/let [letvar614202 {"targetGroups" (portkey.aws/search-for-tag input "targetGroups" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar614202 "targetGroups") (clojure.core/assoc :target-groups (deser-target-groups (clojure.core/get-in letvar614202 ["targetGroups" :content]))))))

(clojure.core/defn- deser-propagating-vgw [input] (clojure.core/let [letvar614310 {"gatewayId" (portkey.aws/search-for-tag input "gatewayId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar614310 "gatewayId") (clojure.core/assoc :gateway-id (deser-string (clojure.core/get-in letvar614310 ["gatewayId" :content]))))))

(clojure.core/defn- deser-flow-log-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-flow-log coll))) input))

(clojure.core/defn- deser-prefix-list-id-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-instance-network-interface-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-network-interface coll))) input))

(clojure.core/defn- deser-vpn-connection-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpn-connection coll))) input))

(clojure.core/defn- deser-on-demand-allocation-strategy [input] (clojure.core/get {"lowestPrice" :lowest-price, "prioritized" :prioritized} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-reserved-instances-offering [input] (clojure.core/let [letvar614491 {"marketplace" (portkey.aws/search-for-tag input "marketplace" :flattened? nil :xmlAttribute? nil), "reservedInstancesOfferingId" (portkey.aws/search-for-tag input "reservedInstancesOfferingId" :flattened? nil :xmlAttribute? nil), "instanceTenancy" (portkey.aws/search-for-tag input "instanceTenancy" :flattened? nil :xmlAttribute? nil), "offeringType" (portkey.aws/search-for-tag input "offeringType" :flattened? nil :xmlAttribute? nil), "fixedPrice" (portkey.aws/search-for-tag input "fixedPrice" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "scope" (portkey.aws/search-for-tag input "scope" :flattened? nil :xmlAttribute? nil), "currencyCode" (portkey.aws/search-for-tag input "currencyCode" :flattened? nil :xmlAttribute? nil), "recurringCharges" (portkey.aws/search-for-tag input "recurringCharges" :flattened? nil :xmlAttribute? nil), "pricingDetailsSet" (portkey.aws/search-for-tag input "pricingDetailsSet" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "duration" (portkey.aws/search-for-tag input "duration" :flattened? nil :xmlAttribute? nil), "productDescription" (portkey.aws/search-for-tag input "productDescription" :flattened? nil :xmlAttribute? nil), "offeringClass" (portkey.aws/search-for-tag input "offeringClass" :flattened? nil :xmlAttribute? nil), "usagePrice" (portkey.aws/search-for-tag input "usagePrice" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar614491 "currencyCode") (clojure.core/assoc :currency-code (deser-currency-code-values (clojure.core/get-in letvar614491 ["currencyCode" :content]))) (letvar614491 "reservedInstancesOfferingId") (clojure.core/assoc :reserved-instances-offering-id (deser-string (clojure.core/get-in letvar614491 ["reservedInstancesOfferingId" :content]))) (letvar614491 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar614491 ["instanceType" :content]))) (letvar614491 "fixedPrice") (clojure.core/assoc :fixed-price (deser-float (clojure.core/get-in letvar614491 ["fixedPrice" :content]))) (letvar614491 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar614491 ["availabilityZone" :content]))) (letvar614491 "pricingDetailsSet") (clojure.core/assoc :pricing-details (deser-pricing-details-list (clojure.core/get-in letvar614491 ["pricingDetailsSet" :content]))) (letvar614491 "instanceTenancy") (clojure.core/assoc :instance-tenancy (deser-tenancy (clojure.core/get-in letvar614491 ["instanceTenancy" :content]))) (letvar614491 "marketplace") (clojure.core/assoc :marketplace (deser-boolean (clojure.core/get-in letvar614491 ["marketplace" :content]))) (letvar614491 "duration") (clojure.core/assoc :duration (deser-long (clojure.core/get-in letvar614491 ["duration" :content]))) (letvar614491 "usagePrice") (clojure.core/assoc :usage-price (deser-float (clojure.core/get-in letvar614491 ["usagePrice" :content]))) (letvar614491 "productDescription") (clojure.core/assoc :product-description (deser-ri-product-description (clojure.core/get-in letvar614491 ["productDescription" :content]))) (letvar614491 "offeringClass") (clojure.core/assoc :offering-class (deser-offering-class-type (clojure.core/get-in letvar614491 ["offeringClass" :content]))) (letvar614491 "recurringCharges") (clojure.core/assoc :recurring-charges (deser-recurring-charges-list (clojure.core/get-in letvar614491 ["recurringCharges" :content]))) (letvar614491 "offeringType") (clojure.core/assoc :offering-type (deser-offering-type-values (clojure.core/get-in letvar614491 ["offeringType" :content]))) (letvar614491 "scope") (clojure.core/assoc :scope (deserscope (clojure.core/get-in letvar614491 ["scope" :content]))))))

(clojure.core/defn- deser-vpc-endpoint-type [input] (clojure.core/get {"Interface" :interface, "Gateway" :gateway} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-storage [input] (clojure.core/let [letvar614604 {"S3" (portkey.aws/search-for-tag input "S3" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar614604 "S3") (clojure.core/assoc :s-3 (deser-s-3-storage (clojure.core/get-in letvar614604 ["S3" :content]))))))

(clojure.core/defn- deser-value-string-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-transit-gateway-route-table-state [input] (clojure.core/get {"pending" :pending, "available" :available, "deleting" :deleting, "deleted" :deleted} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-volume-modification [input] (clojure.core/let [letvar614734 {"progress" (portkey.aws/search-for-tag input "progress" :flattened? nil :xmlAttribute? nil), "targetVolumeType" (portkey.aws/search-for-tag input "targetVolumeType" :flattened? nil :xmlAttribute? nil), "targetIops" (portkey.aws/search-for-tag input "targetIops" :flattened? nil :xmlAttribute? nil), "originalVolumeType" (portkey.aws/search-for-tag input "originalVolumeType" :flattened? nil :xmlAttribute? nil), "originalSize" (portkey.aws/search-for-tag input "originalSize" :flattened? nil :xmlAttribute? nil), "startTime" (portkey.aws/search-for-tag input "startTime" :flattened? nil :xmlAttribute? nil), "originalIops" (portkey.aws/search-for-tag input "originalIops" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil), "volumeId" (portkey.aws/search-for-tag input "volumeId" :flattened? nil :xmlAttribute? nil), "modificationState" (portkey.aws/search-for-tag input "modificationState" :flattened? nil :xmlAttribute? nil), "endTime" (portkey.aws/search-for-tag input "endTime" :flattened? nil :xmlAttribute? nil), "targetSize" (portkey.aws/search-for-tag input "targetSize" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar614734 "endTime") (clojure.core/assoc :end-time (deser-date-time (clojure.core/get-in letvar614734 ["endTime" :content]))) (letvar614734 "targetVolumeType") (clojure.core/assoc :target-volume-type (deser-volume-type (clojure.core/get-in letvar614734 ["targetVolumeType" :content]))) (letvar614734 "originalVolumeType") (clojure.core/assoc :original-volume-type (deser-volume-type (clojure.core/get-in letvar614734 ["originalVolumeType" :content]))) (letvar614734 "startTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar614734 ["startTime" :content]))) (letvar614734 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar614734 ["statusMessage" :content]))) (letvar614734 "originalIops") (clojure.core/assoc :original-iops (deser-integer (clojure.core/get-in letvar614734 ["originalIops" :content]))) (letvar614734 "progress") (clojure.core/assoc :progress (deser-long (clojure.core/get-in letvar614734 ["progress" :content]))) (letvar614734 "originalSize") (clojure.core/assoc :original-size (deser-integer (clojure.core/get-in letvar614734 ["originalSize" :content]))) (letvar614734 "modificationState") (clojure.core/assoc :modification-state (deser-volume-modification-state (clojure.core/get-in letvar614734 ["modificationState" :content]))) (letvar614734 "volumeId") (clojure.core/assoc :volume-id (deser-string (clojure.core/get-in letvar614734 ["volumeId" :content]))) (letvar614734 "targetIops") (clojure.core/assoc :target-iops (deser-integer (clojure.core/get-in letvar614734 ["targetIops" :content]))) (letvar614734 "targetSize") (clojure.core/assoc :target-size (deser-integer (clojure.core/get-in letvar614734 ["targetSize" :content]))))))

(clojure.core/defn- deser-ip-ranges [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-instance-status-event-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-status-event coll))) input))

(clojure.core/defn- deser-client-vpn-authentication-type [input] (clojure.core/get {"certificate-authentication" :certificateauthentication, "directory-service-authentication" :directoryserviceauthentication} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-connection-notification-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-connection-notification coll))) input))

(clojure.core/defn- deser-instance-id [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-group-identifier-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-security-group-identifier coll))) input))

(clojure.core/defn- deser-reserved-instances-modification-result-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-instances-modification-result coll))) input))

(clojure.core/defn- deser-vpn-protocol [input] (clojure.core/get {"openvpn" :openvpn} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-vpc-peering-connection-vpc-info [input] (clojure.core/let [letvar614942 {"cidrBlock" (portkey.aws/search-for-tag input "cidrBlock" :flattened? nil :xmlAttribute? nil), "ipv6CidrBlockSet" (portkey.aws/search-for-tag input "ipv6CidrBlockSet" :flattened? nil :xmlAttribute? nil), "cidrBlockSet" (portkey.aws/search-for-tag input "cidrBlockSet" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "peeringOptions" (portkey.aws/search-for-tag input "peeringOptions" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "region" (portkey.aws/search-for-tag input "region" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar614942 "cidrBlock") (clojure.core/assoc :cidr-block (deser-string (clojure.core/get-in letvar614942 ["cidrBlock" :content]))) (letvar614942 "ipv6CidrBlockSet") (clojure.core/assoc :ipv-6-cidr-block-set (deser-ipv-6-cidr-block-set (clojure.core/get-in letvar614942 ["ipv6CidrBlockSet" :content]))) (letvar614942 "cidrBlockSet") (clojure.core/assoc :cidr-block-set (deser-cidr-block-set (clojure.core/get-in letvar614942 ["cidrBlockSet" :content]))) (letvar614942 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar614942 ["ownerId" :content]))) (letvar614942 "peeringOptions") (clojure.core/assoc :peering-options (deser-vpc-peering-connection-options-description (clojure.core/get-in letvar614942 ["peeringOptions" :content]))) (letvar614942 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar614942 ["vpcId" :content]))) (letvar614942 "region") (clojure.core/assoc :region (deser-string (clojure.core/get-in letvar614942 ["region" :content]))))))

(clojure.core/defn- deser-instance-monitoring-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-monitoring coll))) input))

(clojure.core/defn- deser-vpc-peering-connection [input] (clojure.core/let [letvar615067 {"accepterVpcInfo" (portkey.aws/search-for-tag input "accepterVpcInfo" :flattened? nil :xmlAttribute? nil), "expirationTime" (portkey.aws/search-for-tag input "expirationTime" :flattened? nil :xmlAttribute? nil), "requesterVpcInfo" (portkey.aws/search-for-tag input "requesterVpcInfo" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "vpcPeeringConnectionId" (portkey.aws/search-for-tag input "vpcPeeringConnectionId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar615067 "accepterVpcInfo") (clojure.core/assoc :accepter-vpc-info (deser-vpc-peering-connection-vpc-info (clojure.core/get-in letvar615067 ["accepterVpcInfo" :content]))) (letvar615067 "expirationTime") (clojure.core/assoc :expiration-time (deser-date-time (clojure.core/get-in letvar615067 ["expirationTime" :content]))) (letvar615067 "requesterVpcInfo") (clojure.core/assoc :requester-vpc-info (deser-vpc-peering-connection-vpc-info (clojure.core/get-in letvar615067 ["requesterVpcInfo" :content]))) (letvar615067 "status") (clojure.core/assoc :status (deser-vpc-peering-connection-state-reason (clojure.core/get-in letvar615067 ["status" :content]))) (letvar615067 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar615067 ["tagSet" :content]))) (letvar615067 "vpcPeeringConnectionId") (clojure.core/assoc :vpc-peering-connection-id (deser-string (clojure.core/get-in letvar615067 ["vpcPeeringConnectionId" :content]))))))

(clojure.core/defn- deser-target-groups [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-group coll))) input))

(clojure.core/defn- deser-target-reservation-value-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-reservation-value coll))) input))

(clojure.core/defn- deser-image-state [input] (clojure.core/get {"pending" :pending, "available" :available, "invalid" :invalid, "deregistered" :deregistered, "transient" :transient, "failed" :failed, "error" :error} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-network-interface-ipv-6-address [input] (clojure.core/let [letvar615214 {"ipv6Address" (portkey.aws/search-for-tag input "ipv6Address" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar615214 "ipv6Address") (clojure.core/assoc :ipv-6-address (deser-string (clojure.core/get-in letvar615214 ["ipv6Address" :content]))))))

(clojure.core/defn- deser-vpn-state [input] (clojure.core/get {"pending" :pending, "available" :available, "deleting" :deleting, "deleted" :deleted} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-account-attribute-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-account-attribute coll))) input))

(clojure.core/defn- deser-instance-lifecycle [input] (clojure.core/get {"spot" :spot, "on-demand" :ondemand} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-ipv-6-range-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ipv-6-range coll))) input))

(clojure.core/defn- deser-move-status [input] (clojure.core/get {"movingToVpc" :moving-to-vpc, "restoringToClassic" :restoring-to-classic} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-credit-specification [input] (clojure.core/let [letvar615371 {"cpuCredits" (portkey.aws/search-for-tag input "cpuCredits" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar615371 "cpuCredits") (clojure.core/assoc :cpu-credits (deser-string (clojure.core/get-in letvar615371 ["cpuCredits" :content]))))))

(clojure.core/defn- deser-prefix-list-id [input] (clojure.core/let [letvar615479 {"description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "prefixListId" (portkey.aws/search-for-tag input "prefixListId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar615479 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar615479 ["description" :content]))) (letvar615479 "prefixListId") (clojure.core/assoc :prefix-list-id (deser-string (clojure.core/get-in letvar615479 ["prefixListId" :content]))))))

(clojure.core/defn- deser-pricing-details-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-pricing-detail coll))) input))

(clojure.core/defn- deser-purchase [input] (clojure.core/let [letvar615604 {"currencyCode" (portkey.aws/search-for-tag input "currencyCode" :flattened? nil :xmlAttribute? nil), "duration" (portkey.aws/search-for-tag input "duration" :flattened? nil :xmlAttribute? nil), "hostIdSet" (portkey.aws/search-for-tag input "hostIdSet" :flattened? nil :xmlAttribute? nil), "hostReservationId" (portkey.aws/search-for-tag input "hostReservationId" :flattened? nil :xmlAttribute? nil), "hourlyPrice" (portkey.aws/search-for-tag input "hourlyPrice" :flattened? nil :xmlAttribute? nil), "instanceFamily" (portkey.aws/search-for-tag input "instanceFamily" :flattened? nil :xmlAttribute? nil), "paymentOption" (portkey.aws/search-for-tag input "paymentOption" :flattened? nil :xmlAttribute? nil), "upfrontPrice" (portkey.aws/search-for-tag input "upfrontPrice" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar615604 "currencyCode") (clojure.core/assoc :currency-code (deser-currency-code-values (clojure.core/get-in letvar615604 ["currencyCode" :content]))) (letvar615604 "duration") (clojure.core/assoc :duration (deser-integer (clojure.core/get-in letvar615604 ["duration" :content]))) (letvar615604 "hostIdSet") (clojure.core/assoc :host-id-set (deser-response-host-id-set (clojure.core/get-in letvar615604 ["hostIdSet" :content]))) (letvar615604 "hostReservationId") (clojure.core/assoc :host-reservation-id (deser-string (clojure.core/get-in letvar615604 ["hostReservationId" :content]))) (letvar615604 "hourlyPrice") (clojure.core/assoc :hourly-price (deser-string (clojure.core/get-in letvar615604 ["hourlyPrice" :content]))) (letvar615604 "instanceFamily") (clojure.core/assoc :instance-family (deser-string (clojure.core/get-in letvar615604 ["instanceFamily" :content]))) (letvar615604 "paymentOption") (clojure.core/assoc :payment-option (deser-payment-option (clojure.core/get-in letvar615604 ["paymentOption" :content]))) (letvar615604 "upfrontPrice") (clojure.core/assoc :upfront-price (deser-string (clojure.core/get-in letvar615604 ["upfrontPrice" :content]))))))

(clojure.core/defn- deser-hypervisor-type [input] (clojure.core/get {"ovm" :ovm, "xen" :xen} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-history-record [input] (clojure.core/let [letvar615717 {"eventInformation" (portkey.aws/search-for-tag input "eventInformation" :flattened? nil :xmlAttribute? nil), "eventType" (portkey.aws/search-for-tag input "eventType" :flattened? nil :xmlAttribute? nil), "timestamp" (portkey.aws/search-for-tag input "timestamp" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar615717 "eventInformation") (clojure.core/assoc :event-information (deser-event-information (clojure.core/get-in letvar615717 ["eventInformation" :content]))) (letvar615717 "eventType") (clojure.core/assoc :event-type (deser-event-type (clojure.core/get-in letvar615717 ["eventType" :content]))) (letvar615717 "timestamp") (clojure.core/assoc :timestamp (deser-date-time (clojure.core/get-in letvar615717 ["timestamp" :content]))))))

(clojure.core/defn- deser-connection-notification-type [input] (clojure.core/get {"Topic" :topic} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-route-table-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-route-table coll))) input))

(clojure.core/defn- deser-create-fleet-error [input] (clojure.core/let [letvar615847 {"launchTemplateAndOverrides" (portkey.aws/search-for-tag input "launchTemplateAndOverrides" :flattened? nil :xmlAttribute? nil), "lifecycle" (portkey.aws/search-for-tag input "lifecycle" :flattened? nil :xmlAttribute? nil), "errorCode" (portkey.aws/search-for-tag input "errorCode" :flattened? nil :xmlAttribute? nil), "errorMessage" (portkey.aws/search-for-tag input "errorMessage" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar615847 "launchTemplateAndOverrides") (clojure.core/assoc :launch-template-and-overrides (deser-launch-template-and-overrides-response (clojure.core/get-in letvar615847 ["launchTemplateAndOverrides" :content]))) (letvar615847 "lifecycle") (clojure.core/assoc :lifecycle (deser-instance-lifecycle (clojure.core/get-in letvar615847 ["lifecycle" :content]))) (letvar615847 "errorCode") (clojure.core/assoc :error-code (deser-string (clojure.core/get-in letvar615847 ["errorCode" :content]))) (letvar615847 "errorMessage") (clojure.core/assoc :error-message (deser-string (clojure.core/get-in letvar615847 ["errorMessage" :content]))))))

(clojure.core/defn- deser-transit-gateway-vpc-attachment [input] (clojure.core/let [letvar615955 {"subnetIds" (portkey.aws/search-for-tag input "subnetIds" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "vpcOwnerId" (portkey.aws/search-for-tag input "vpcOwnerId" :flattened? nil :xmlAttribute? nil), "transitGatewayId" (portkey.aws/search-for-tag input "transitGatewayId" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "transitGatewayAttachmentId" (portkey.aws/search-for-tag input "transitGatewayAttachmentId" :flattened? nil :xmlAttribute? nil), "creationTime" (portkey.aws/search-for-tag input "creationTime" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "options" (portkey.aws/search-for-tag input "options" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar615955 "transitGatewayId") (clojure.core/assoc :transit-gateway-id (deser-string (clojure.core/get-in letvar615955 ["transitGatewayId" :content]))) (letvar615955 "subnetIds") (clojure.core/assoc :subnet-ids (deser-value-string-list (clojure.core/get-in letvar615955 ["subnetIds" :content]))) (letvar615955 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar615955 ["tagSet" :content]))) (letvar615955 "transitGatewayAttachmentId") (clojure.core/assoc :transit-gateway-attachment-id (deser-string (clojure.core/get-in letvar615955 ["transitGatewayAttachmentId" :content]))) (letvar615955 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar615955 ["vpcId" :content]))) (letvar615955 "creationTime") (clojure.core/assoc :creation-time (deser-date-time (clojure.core/get-in letvar615955 ["creationTime" :content]))) (letvar615955 "vpcOwnerId") (clojure.core/assoc :vpc-owner-id (deser-string (clojure.core/get-in letvar615955 ["vpcOwnerId" :content]))) (letvar615955 "state") (clojure.core/assoc :state (deser-transit-gateway-attachment-state (clojure.core/get-in letvar615955 ["state" :content]))) (letvar615955 "options") (clojure.core/assoc :options (deser-transit-gateway-vpc-attachment-options (clojure.core/get-in letvar615955 ["options" :content]))))))

(clojure.core/defn- deser-architecture-values [input] (clojure.core/get {"i386" :i-386, "x86_64" :x-86-64, "arm64" :arm-64} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-cancelled-spot-instance-request [input] (clojure.core/let [letvar616068 {"spotInstanceRequestId" (portkey.aws/search-for-tag input "spotInstanceRequestId" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar616068 "spotInstanceRequestId") (clojure.core/assoc :spot-instance-request-id (deser-string (clojure.core/get-in letvar616068 ["spotInstanceRequestId" :content]))) (letvar616068 "state") (clojure.core/assoc :state (deser-cancel-spot-instance-request-state (clojure.core/get-in letvar616068 ["state" :content]))))))

(clojure.core/defn- deser-transit-gateway-route [input] (clojure.core/let [letvar616176 {"destinationCidrBlock" (portkey.aws/search-for-tag input "destinationCidrBlock" :flattened? nil :xmlAttribute? nil), "transitGatewayAttachments" (portkey.aws/search-for-tag input "transitGatewayAttachments" :flattened? nil :xmlAttribute? nil), "type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar616176 "destinationCidrBlock") (clojure.core/assoc :destination-cidr-block (deser-string (clojure.core/get-in letvar616176 ["destinationCidrBlock" :content]))) (letvar616176 "transitGatewayAttachments") (clojure.core/assoc :transit-gateway-attachments (deser-transit-gateway-route-attachment-list (clojure.core/get-in letvar616176 ["transitGatewayAttachments" :content]))) (letvar616176 "type") (clojure.core/assoc :type (deser-transit-gateway-route-type (clojure.core/get-in letvar616176 ["type" :content]))) (letvar616176 "state") (clojure.core/assoc :state (deser-transit-gateway-route-state (clojure.core/get-in letvar616176 ["state" :content]))))))

(clojure.core/defn- deser-volume-attachment-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-volume-attachment coll))) input))

(clojure.core/defn- deser-export-environment [input] (clojure.core/get {"citrix" :citrix, "vmware" :vmware, "microsoft" :microsoft} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-load-permission-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-load-permission coll))) input))

(clojure.core/defn- deser-instance-export-details [input] (clojure.core/let [letvar616323 {"instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "targetEnvironment" (portkey.aws/search-for-tag input "targetEnvironment" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar616323 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar616323 ["instanceId" :content]))) (letvar616323 "targetEnvironment") (clojure.core/assoc :target-environment (deser-export-environment (clojure.core/get-in letvar616323 ["targetEnvironment" :content]))))))

(clojure.core/defn- deser-service-type-detail [input] (clojure.core/let [letvar616431 {"serviceType" (portkey.aws/search-for-tag input "serviceType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar616431 "serviceType") (clojure.core/assoc :service-type (deser-service-type (clojure.core/get-in letvar616431 ["serviceType" :content]))))))

(clojure.core/defn- deser-volume-attachment-state [input] (clojure.core/get {"attaching" :attaching, "attached" :attached, "detaching" :detaching, "detached" :detached, "busy" :busy} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-volume-modification-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-volume-modification coll))) input))

(clojure.core/defn- deser-internet-gateway-attachment [input] (clojure.core/let [letvar616561 {"state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar616561 "state") (clojure.core/assoc :state (deser-attachment-status (clojure.core/get-in letvar616561 ["state" :content]))) (letvar616561 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar616561 ["vpcId" :content]))))))

(clojure.core/defn- deser-launch-template-ebs-block-device [input] (clojure.core/let [letvar616669 {"encrypted" (portkey.aws/search-for-tag input "encrypted" :flattened? nil :xmlAttribute? nil), "deleteOnTermination" (portkey.aws/search-for-tag input "deleteOnTermination" :flattened? nil :xmlAttribute? nil), "iops" (portkey.aws/search-for-tag input "iops" :flattened? nil :xmlAttribute? nil), "kmsKeyId" (portkey.aws/search-for-tag input "kmsKeyId" :flattened? nil :xmlAttribute? nil), "snapshotId" (portkey.aws/search-for-tag input "snapshotId" :flattened? nil :xmlAttribute? nil), "volumeSize" (portkey.aws/search-for-tag input "volumeSize" :flattened? nil :xmlAttribute? nil), "volumeType" (portkey.aws/search-for-tag input "volumeType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar616669 "encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar616669 ["encrypted" :content]))) (letvar616669 "deleteOnTermination") (clojure.core/assoc :delete-on-termination (deser-boolean (clojure.core/get-in letvar616669 ["deleteOnTermination" :content]))) (letvar616669 "iops") (clojure.core/assoc :iops (deser-integer (clojure.core/get-in letvar616669 ["iops" :content]))) (letvar616669 "kmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar616669 ["kmsKeyId" :content]))) (letvar616669 "snapshotId") (clojure.core/assoc :snapshot-id (deser-string (clojure.core/get-in letvar616669 ["snapshotId" :content]))) (letvar616669 "volumeSize") (clojure.core/assoc :volume-size (deser-integer (clojure.core/get-in letvar616669 ["volumeSize" :content]))) (letvar616669 "volumeType") (clojure.core/assoc :volume-type (deser-volume-type (clojure.core/get-in letvar616669 ["volumeType" :content]))))))

(clojure.core/defn- deser-fleet-identifier [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-instance-monitoring [input] (clojure.core/let [letvar616782 {"instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "monitoring" (portkey.aws/search-for-tag input "monitoring" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar616782 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar616782 ["instanceId" :content]))) (letvar616782 "monitoring") (clojure.core/assoc :monitoring (deser-monitoring (clojure.core/get-in letvar616782 ["monitoring" :content]))))))

(clojure.core/defn- deser-spot-price-history-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-spot-price coll))) input))

(clojure.core/defn- deser-byoip-cidr-state [input] (clojure.core/get {"advertised" :advertised, "deprovisioned" :deprovisioned, "failed-deprovision" :faileddeprovision, "failed-provision" :failedprovision, "pending-deprovision" :pendingdeprovision, "pending-provision" :pendingprovision, "provisioned" :provisioned} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-vpn-connection-options [input] (clojure.core/let [letvar616912 {"staticRoutesOnly" (portkey.aws/search-for-tag input "staticRoutesOnly" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar616912 "staticRoutesOnly") (clojure.core/assoc :static-routes-only (deser-boolean (clojure.core/get-in letvar616912 ["staticRoutesOnly" :content]))))))

(clojure.core/defn- deser-network-acl-entry [input] (clojure.core/let [letvar617020 {"cidrBlock" (portkey.aws/search-for-tag input "cidrBlock" :flattened? nil :xmlAttribute? nil), "egress" (portkey.aws/search-for-tag input "egress" :flattened? nil :xmlAttribute? nil), "icmpTypeCode" (portkey.aws/search-for-tag input "icmpTypeCode" :flattened? nil :xmlAttribute? nil), "ipv6CidrBlock" (portkey.aws/search-for-tag input "ipv6CidrBlock" :flattened? nil :xmlAttribute? nil), "portRange" (portkey.aws/search-for-tag input "portRange" :flattened? nil :xmlAttribute? nil), "protocol" (portkey.aws/search-for-tag input "protocol" :flattened? nil :xmlAttribute? nil), "ruleAction" (portkey.aws/search-for-tag input "ruleAction" :flattened? nil :xmlAttribute? nil), "ruleNumber" (portkey.aws/search-for-tag input "ruleNumber" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar617020 "cidrBlock") (clojure.core/assoc :cidr-block (deser-string (clojure.core/get-in letvar617020 ["cidrBlock" :content]))) (letvar617020 "egress") (clojure.core/assoc :egress (deser-boolean (clojure.core/get-in letvar617020 ["egress" :content]))) (letvar617020 "icmpTypeCode") (clojure.core/assoc :icmp-type-code (deser-icmp-type-code (clojure.core/get-in letvar617020 ["icmpTypeCode" :content]))) (letvar617020 "ipv6CidrBlock") (clojure.core/assoc :ipv-6-cidr-block (deser-string (clojure.core/get-in letvar617020 ["ipv6CidrBlock" :content]))) (letvar617020 "portRange") (clojure.core/assoc :port-range (deser-port-range (clojure.core/get-in letvar617020 ["portRange" :content]))) (letvar617020 "protocol") (clojure.core/assoc :protocol (deser-string (clojure.core/get-in letvar617020 ["protocol" :content]))) (letvar617020 "ruleAction") (clojure.core/assoc :rule-action (deser-rule-action (clojure.core/get-in letvar617020 ["ruleAction" :content]))) (letvar617020 "ruleNumber") (clojure.core/assoc :rule-number (deser-integer (clojure.core/get-in letvar617020 ["ruleNumber" :content]))))))

(clojure.core/defn- deser-terminate-connection-status [input] (clojure.core/let [letvar617128 {"connectionId" (portkey.aws/search-for-tag input "connectionId" :flattened? nil :xmlAttribute? nil), "previousStatus" (portkey.aws/search-for-tag input "previousStatus" :flattened? nil :xmlAttribute? nil), "currentStatus" (portkey.aws/search-for-tag input "currentStatus" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar617128 "connectionId") (clojure.core/assoc :connection-id (deser-string (clojure.core/get-in letvar617128 ["connectionId" :content]))) (letvar617128 "previousStatus") (clojure.core/assoc :previous-status (deser-client-vpn-connection-status (clojure.core/get-in letvar617128 ["previousStatus" :content]))) (letvar617128 "currentStatus") (clojure.core/assoc :current-status (deser-client-vpn-connection-status (clojure.core/get-in letvar617128 ["currentStatus" :content]))))))

(clojure.core/defn- deser-provisioned-bandwidth [input] (clojure.core/let [letvar617236 {"provisionTime" (portkey.aws/search-for-tag input "provisionTime" :flattened? nil :xmlAttribute? nil), "provisioned" (portkey.aws/search-for-tag input "provisioned" :flattened? nil :xmlAttribute? nil), "requestTime" (portkey.aws/search-for-tag input "requestTime" :flattened? nil :xmlAttribute? nil), "requested" (portkey.aws/search-for-tag input "requested" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar617236 "provisionTime") (clojure.core/assoc :provision-time (deser-date-time (clojure.core/get-in letvar617236 ["provisionTime" :content]))) (letvar617236 "provisioned") (clojure.core/assoc :provisioned (deser-string (clojure.core/get-in letvar617236 ["provisioned" :content]))) (letvar617236 "requestTime") (clojure.core/assoc :request-time (deser-date-time (clojure.core/get-in letvar617236 ["requestTime" :content]))) (letvar617236 "requested") (clojure.core/assoc :requested (deser-string (clojure.core/get-in letvar617236 ["requested" :content]))) (letvar617236 "status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar617236 ["status" :content]))))))

(clojure.core/defn- deser-pci-id [input] (clojure.core/let [letvar617344 {"DeviceId" (portkey.aws/search-for-tag input "DeviceId" :flattened? nil :xmlAttribute? nil), "VendorId" (portkey.aws/search-for-tag input "VendorId" :flattened? nil :xmlAttribute? nil), "SubsystemId" (portkey.aws/search-for-tag input "SubsystemId" :flattened? nil :xmlAttribute? nil), "SubsystemVendorId" (portkey.aws/search-for-tag input "SubsystemVendorId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar617344 "DeviceId") (clojure.core/assoc :device-id (deser-string (clojure.core/get-in letvar617344 ["DeviceId" :content]))) (letvar617344 "VendorId") (clojure.core/assoc :vendor-id (deser-string (clojure.core/get-in letvar617344 ["VendorId" :content]))) (letvar617344 "SubsystemId") (clojure.core/assoc :subsystem-id (deser-string (clojure.core/get-in letvar617344 ["SubsystemId" :content]))) (letvar617344 "SubsystemVendorId") (clojure.core/assoc :subsystem-vendor-id (deser-string (clojure.core/get-in letvar617344 ["SubsystemVendorId" :content]))))))

(clojure.core/defn- deser-vgw-telemetry-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vgw-telemetry coll))) input))

(clojure.core/defn- deser-volume-state [input] (clojure.core/get {"creating" :creating, "available" :available, "in-use" :inuse, "deleting" :deleting, "deleted" :deleted, "error" :error} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-spot-placement [input] (clojure.core/let [letvar617474 {"availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "groupName" (portkey.aws/search-for-tag input "groupName" :flattened? nil :xmlAttribute? nil), "tenancy" (portkey.aws/search-for-tag input "tenancy" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar617474 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar617474 ["availabilityZone" :content]))) (letvar617474 "groupName") (clojure.core/assoc :group-name (deser-string (clojure.core/get-in letvar617474 ["groupName" :content]))) (letvar617474 "tenancy") (clojure.core/assoc :tenancy (deser-tenancy (clojure.core/get-in letvar617474 ["tenancy" :content]))))))

(clojure.core/defn- deser-security-group [input] (clojure.core/let [letvar617582 {"groupDescription" (portkey.aws/search-for-tag input "groupDescription" :flattened? nil :xmlAttribute? nil), "groupName" (portkey.aws/search-for-tag input "groupName" :flattened? nil :xmlAttribute? nil), "ipPermissions" (portkey.aws/search-for-tag input "ipPermissions" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "groupId" (portkey.aws/search-for-tag input "groupId" :flattened? nil :xmlAttribute? nil), "ipPermissionsEgress" (portkey.aws/search-for-tag input "ipPermissionsEgress" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar617582 "groupDescription") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar617582 ["groupDescription" :content]))) (letvar617582 "groupName") (clojure.core/assoc :group-name (deser-string (clojure.core/get-in letvar617582 ["groupName" :content]))) (letvar617582 "ipPermissions") (clojure.core/assoc :ip-permissions (deser-ip-permission-list (clojure.core/get-in letvar617582 ["ipPermissions" :content]))) (letvar617582 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar617582 ["ownerId" :content]))) (letvar617582 "groupId") (clojure.core/assoc :group-id (deser-string (clojure.core/get-in letvar617582 ["groupId" :content]))) (letvar617582 "ipPermissionsEgress") (clojure.core/assoc :ip-permissions-egress (deser-ip-permission-list (clojure.core/get-in letvar617582 ["ipPermissionsEgress" :content]))) (letvar617582 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar617582 ["tagSet" :content]))) (letvar617582 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar617582 ["vpcId" :content]))))))

(clojure.core/defn- deser-recurring-charges-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-recurring-charge coll))) input))

(clojure.core/defn- deser-snapshot-detail-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot-detail coll))) input))

(clojure.core/defn- deser-id-format [input] (clojure.core/let [letvar617724 {"deadline" (portkey.aws/search-for-tag input "deadline" :flattened? nil :xmlAttribute? nil), "resource" (portkey.aws/search-for-tag input "resource" :flattened? nil :xmlAttribute? nil), "useLongIds" (portkey.aws/search-for-tag input "useLongIds" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar617724 "deadline") (clojure.core/assoc :deadline (deser-date-time (clojure.core/get-in letvar617724 ["deadline" :content]))) (letvar617724 "resource") (clojure.core/assoc :resource (deser-string (clojure.core/get-in letvar617724 ["resource" :content]))) (letvar617724 "useLongIds") (clojure.core/assoc :use-long-ids (deser-boolean (clojure.core/get-in letvar617724 ["useLongIds" :content]))))))

(clojure.core/defn- deser-volume [input] (clojure.core/let [letvar617832 {"tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "kmsKeyId" (portkey.aws/search-for-tag input "kmsKeyId" :flattened? nil :xmlAttribute? nil), "createTime" (portkey.aws/search-for-tag input "createTime" :flattened? nil :xmlAttribute? nil), "encrypted" (portkey.aws/search-for-tag input "encrypted" :flattened? nil :xmlAttribute? nil), "attachmentSet" (portkey.aws/search-for-tag input "attachmentSet" :flattened? nil :xmlAttribute? nil), "iops" (portkey.aws/search-for-tag input "iops" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "volumeType" (portkey.aws/search-for-tag input "volumeType" :flattened? nil :xmlAttribute? nil), "volumeId" (portkey.aws/search-for-tag input "volumeId" :flattened? nil :xmlAttribute? nil), "size" (portkey.aws/search-for-tag input "size" :flattened? nil :xmlAttribute? nil), "snapshotId" (portkey.aws/search-for-tag input "snapshotId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar617832 "encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar617832 ["encrypted" :content]))) (letvar617832 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar617832 ["tagSet" :content]))) (letvar617832 "attachmentSet") (clojure.core/assoc :attachments (deser-volume-attachment-list (clojure.core/get-in letvar617832 ["attachmentSet" :content]))) (letvar617832 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar617832 ["availabilityZone" :content]))) (letvar617832 "kmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar617832 ["kmsKeyId" :content]))) (letvar617832 "size") (clojure.core/assoc :size (deser-integer (clojure.core/get-in letvar617832 ["size" :content]))) (letvar617832 "iops") (clojure.core/assoc :iops (deser-integer (clojure.core/get-in letvar617832 ["iops" :content]))) (letvar617832 "volumeType") (clojure.core/assoc :volume-type (deser-volume-type (clojure.core/get-in letvar617832 ["volumeType" :content]))) (letvar617832 "volumeId") (clojure.core/assoc :volume-id (deser-string (clojure.core/get-in letvar617832 ["volumeId" :content]))) (letvar617832 "createTime") (clojure.core/assoc :create-time (deser-date-time (clojure.core/get-in letvar617832 ["createTime" :content]))) (letvar617832 "status") (clojure.core/assoc :state (deser-volume-state (clojure.core/get-in letvar617832 ["status" :content]))) (letvar617832 "snapshotId") (clojure.core/assoc :snapshot-id (deser-string (clojure.core/get-in letvar617832 ["snapshotId" :content]))))))

(clojure.core/defn- deser-spot-instance-type [input] (clojure.core/get {"one-time" :onetime, "persistent" :persistent} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-ebs-block-device [input] (clojure.core/let [letvar617945 {"deleteOnTermination" (portkey.aws/search-for-tag input "deleteOnTermination" :flattened? nil :xmlAttribute? nil), "iops" (portkey.aws/search-for-tag input "iops" :flattened? nil :xmlAttribute? nil), "snapshotId" (portkey.aws/search-for-tag input "snapshotId" :flattened? nil :xmlAttribute? nil), "volumeSize" (portkey.aws/search-for-tag input "volumeSize" :flattened? nil :xmlAttribute? nil), "volumeType" (portkey.aws/search-for-tag input "volumeType" :flattened? nil :xmlAttribute? nil), "encrypted" (portkey.aws/search-for-tag input "encrypted" :flattened? nil :xmlAttribute? nil), "KmsKeyId" (portkey.aws/search-for-tag input "KmsKeyId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar617945 "deleteOnTermination") (clojure.core/assoc :delete-on-termination (deser-boolean (clojure.core/get-in letvar617945 ["deleteOnTermination" :content]))) (letvar617945 "iops") (clojure.core/assoc :iops (deser-integer (clojure.core/get-in letvar617945 ["iops" :content]))) (letvar617945 "snapshotId") (clojure.core/assoc :snapshot-id (deser-string (clojure.core/get-in letvar617945 ["snapshotId" :content]))) (letvar617945 "volumeSize") (clojure.core/assoc :volume-size (deser-integer (clojure.core/get-in letvar617945 ["volumeSize" :content]))) (letvar617945 "volumeType") (clojure.core/assoc :volume-type (deser-volume-type (clojure.core/get-in letvar617945 ["volumeType" :content]))) (letvar617945 "encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar617945 ["encrypted" :content]))) (letvar617945 "KmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar617945 ["KmsKeyId" :content]))))))

(clojure.core/defn- deser-spot-fleet-tag-specification-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-spot-fleet-tag-specification coll))) input))

(clojure.core/defn- deser-placement [input] (clojure.core/let [letvar618070 {"availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "affinity" (portkey.aws/search-for-tag input "affinity" :flattened? nil :xmlAttribute? nil), "groupName" (portkey.aws/search-for-tag input "groupName" :flattened? nil :xmlAttribute? nil), "partitionNumber" (portkey.aws/search-for-tag input "partitionNumber" :flattened? nil :xmlAttribute? nil), "hostId" (portkey.aws/search-for-tag input "hostId" :flattened? nil :xmlAttribute? nil), "tenancy" (portkey.aws/search-for-tag input "tenancy" :flattened? nil :xmlAttribute? nil), "spreadDomain" (portkey.aws/search-for-tag input "spreadDomain" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar618070 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar618070 ["availabilityZone" :content]))) (letvar618070 "affinity") (clojure.core/assoc :affinity (deser-string (clojure.core/get-in letvar618070 ["affinity" :content]))) (letvar618070 "groupName") (clojure.core/assoc :group-name (deser-string (clojure.core/get-in letvar618070 ["groupName" :content]))) (letvar618070 "partitionNumber") (clojure.core/assoc :partition-number (deser-integer (clojure.core/get-in letvar618070 ["partitionNumber" :content]))) (letvar618070 "hostId") (clojure.core/assoc :host-id (deser-string (clojure.core/get-in letvar618070 ["hostId" :content]))) (letvar618070 "tenancy") (clojure.core/assoc :tenancy (deser-tenancy (clojure.core/get-in letvar618070 ["tenancy" :content]))) (letvar618070 "spreadDomain") (clojure.core/assoc :spread-domain (deser-string (clojure.core/get-in letvar618070 ["spreadDomain" :content]))))))

(clojure.core/defn- deser-reserved-instances-configuration [input] (clojure.core/let [letvar618178 {"availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "instanceCount" (portkey.aws/search-for-tag input "instanceCount" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "platform" (portkey.aws/search-for-tag input "platform" :flattened? nil :xmlAttribute? nil), "scope" (portkey.aws/search-for-tag input "scope" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar618178 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar618178 ["availabilityZone" :content]))) (letvar618178 "instanceCount") (clojure.core/assoc :instance-count (deser-integer (clojure.core/get-in letvar618178 ["instanceCount" :content]))) (letvar618178 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar618178 ["instanceType" :content]))) (letvar618178 "platform") (clojure.core/assoc :platform (deser-string (clojure.core/get-in letvar618178 ["platform" :content]))) (letvar618178 "scope") (clojure.core/assoc :scope (deserscope (clojure.core/get-in letvar618178 ["scope" :content]))))))

(clojure.core/defn- deser-interface-permission-type [input] (clojure.core/get {"INSTANCE-ATTACH" :instanceattach, "EIP-ASSOCIATE" :eipassociate} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-user-bucket-details [input] (clojure.core/let [letvar618291 {"s3Bucket" (portkey.aws/search-for-tag input "s3Bucket" :flattened? nil :xmlAttribute? nil), "s3Key" (portkey.aws/search-for-tag input "s3Key" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar618291 "s3Bucket") (clojure.core/assoc :s-3-bucket (deser-string (clojure.core/get-in letvar618291 ["s3Bucket" :content]))) (letvar618291 "s3Key") (clojure.core/assoc :s-3-key (deser-string (clojure.core/get-in letvar618291 ["s3Key" :content]))))))

(clojure.core/defn- deser-occurrence-day-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-integer coll))) input))

(clojure.core/defn- deser-snapshot-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot coll))) input))

(clojure.core/defn- deser-instance-lifecycle-type [input] (clojure.core/get {"spot" :spot, "scheduled" :scheduled} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-transit-gateway-route-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-transit-gateway-route coll))) input))

(clojure.core/defn- deser-availability-zone-state [input] (clojure.core/get {"available" :available, "information" :information, "impaired" :impaired, "unavailable" :unavailable} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-client-vpn-endpoint-status-code [input] (clojure.core/get {"pending-associate" :pendingassociate, "available" :available, "deleting" :deleting, "deleted" :deleted} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-subnet [input] (clojure.core/let [letvar618465 {"subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "availableIpAddressCount" (portkey.aws/search-for-tag input "availableIpAddressCount" :flattened? nil :xmlAttribute? nil), "availabilityZoneId" (portkey.aws/search-for-tag input "availabilityZoneId" :flattened? nil :xmlAttribute? nil), "ipv6CidrBlockAssociationSet" (portkey.aws/search-for-tag input "ipv6CidrBlockAssociationSet" :flattened? nil :xmlAttribute? nil), "subnetArn" (portkey.aws/search-for-tag input "subnetArn" :flattened? nil :xmlAttribute? nil), "cidrBlock" (portkey.aws/search-for-tag input "cidrBlock" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "mapPublicIpOnLaunch" (portkey.aws/search-for-tag input "mapPublicIpOnLaunch" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "assignIpv6AddressOnCreation" (portkey.aws/search-for-tag input "assignIpv6AddressOnCreation" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "defaultForAz" (portkey.aws/search-for-tag input "defaultForAz" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar618465 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar618465 ["subnetId" :content]))) (letvar618465 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar618465 ["ownerId" :content]))) (letvar618465 "defaultForAz") (clojure.core/assoc :default-for-az (deser-boolean (clojure.core/get-in letvar618465 ["defaultForAz" :content]))) (letvar618465 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar618465 ["tagSet" :content]))) (letvar618465 "availableIpAddressCount") (clojure.core/assoc :available-ip-address-count (deser-integer (clojure.core/get-in letvar618465 ["availableIpAddressCount" :content]))) (letvar618465 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar618465 ["availabilityZone" :content]))) (letvar618465 "cidrBlock") (clojure.core/assoc :cidr-block (deser-string (clojure.core/get-in letvar618465 ["cidrBlock" :content]))) (letvar618465 "subnetArn") (clojure.core/assoc :subnet-arn (deser-string (clojure.core/get-in letvar618465 ["subnetArn" :content]))) (letvar618465 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar618465 ["vpcId" :content]))) (letvar618465 "assignIpv6AddressOnCreation") (clojure.core/assoc :assign-ipv-6-address-on-creation (deser-boolean (clojure.core/get-in letvar618465 ["assignIpv6AddressOnCreation" :content]))) (letvar618465 "state") (clojure.core/assoc :state (deser-subnet-state (clojure.core/get-in letvar618465 ["state" :content]))) (letvar618465 "mapPublicIpOnLaunch") (clojure.core/assoc :map-public-ip-on-launch (deser-boolean (clojure.core/get-in letvar618465 ["mapPublicIpOnLaunch" :content]))) (letvar618465 "ipv6CidrBlockAssociationSet") (clojure.core/assoc :ipv-6-cidr-block-association-set (deser-subnet-ipv-6-cidr-block-association-set (clojure.core/get-in letvar618465 ["ipv6CidrBlockAssociationSet" :content]))) (letvar618465 "availabilityZoneId") (clojure.core/assoc :availability-zone-id (deser-string (clojure.core/get-in letvar618465 ["availabilityZoneId" :content]))))))

(clojure.core/defn- deser-terminate-connection-status-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-terminate-connection-status coll))) input))

(clojure.core/defn- deser-capacity-reservation-specification-response [input] (clojure.core/let [letvar618590 {"capacityReservationPreference" (portkey.aws/search-for-tag input "capacityReservationPreference" :flattened? nil :xmlAttribute? nil), "capacityReservationTarget" (portkey.aws/search-for-tag input "capacityReservationTarget" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar618590 "capacityReservationPreference") (clojure.core/assoc :capacity-reservation-preference (deser-capacity-reservation-preference (clojure.core/get-in letvar618590 ["capacityReservationPreference" :content]))) (letvar618590 "capacityReservationTarget") (clojure.core/assoc :capacity-reservation-target (deser-capacity-reservation-target-response (clojure.core/get-in letvar618590 ["capacityReservationTarget" :content]))))))

(clojure.core/defn- deser-dhcp-configuration-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-dhcp-configuration coll))) input))

(clojure.core/defn- deser-spot-datafeed-subscription [input] (clojure.core/let [letvar618715 {"bucket" (portkey.aws/search-for-tag input "bucket" :flattened? nil :xmlAttribute? nil), "fault" (portkey.aws/search-for-tag input "fault" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "prefix" (portkey.aws/search-for-tag input "prefix" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar618715 "bucket") (clojure.core/assoc :bucket (deser-string (clojure.core/get-in letvar618715 ["bucket" :content]))) (letvar618715 "fault") (clojure.core/assoc :fault (deser-spot-instance-state-fault (clojure.core/get-in letvar618715 ["fault" :content]))) (letvar618715 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar618715 ["ownerId" :content]))) (letvar618715 "prefix") (clojure.core/assoc :prefix (deser-string (clojure.core/get-in letvar618715 ["prefix" :content]))) (letvar618715 "state") (clojure.core/assoc :state (deser-datafeed-subscription-state (clojure.core/get-in letvar618715 ["state" :content]))))))

(clojure.core/defn- deser-fleet-activity-status [input] (clojure.core/get {"error" :error, "pending-fulfillment" :pendingfulfillment, "pending-termination" :pendingtermination, "fulfilled" :fulfilled} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-instance-count [input] (clojure.core/let [letvar618828 {"instanceCount" (portkey.aws/search-for-tag input "instanceCount" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar618828 "instanceCount") (clojure.core/assoc :instance-count (deser-integer (clojure.core/get-in letvar618828 ["instanceCount" :content]))) (letvar618828 "state") (clojure.core/assoc :state (deser-listing-state (clojure.core/get-in letvar618828 ["state" :content]))))))

(clojure.core/defn- deser-host-instance-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-host-instance coll))) input))

(clojure.core/defn- deser-response-launch-template-data [input] (clojure.core/let [letvar618953 {"securityGroupIdSet" (portkey.aws/search-for-tag input "securityGroupIdSet" :flattened? nil :xmlAttribute? nil), "keyName" (portkey.aws/search-for-tag input "keyName" :flattened? nil :xmlAttribute? nil), "cpuOptions" (portkey.aws/search-for-tag input "cpuOptions" :flattened? nil :xmlAttribute? nil), "elasticInferenceAcceleratorSet" (portkey.aws/search-for-tag input "elasticInferenceAcceleratorSet" :flattened? nil :xmlAttribute? nil), "placement" (portkey.aws/search-for-tag input "placement" :flattened? nil :xmlAttribute? nil), "licenseSet" (portkey.aws/search-for-tag input "licenseSet" :flattened? nil :xmlAttribute? nil), "instanceMarketOptions" (portkey.aws/search-for-tag input "instanceMarketOptions" :flattened? nil :xmlAttribute? nil), "disableApiTermination" (portkey.aws/search-for-tag input "disableApiTermination" :flattened? nil :xmlAttribute? nil), "monitoring" (portkey.aws/search-for-tag input "monitoring" :flattened? nil :xmlAttribute? nil), "tagSpecificationSet" (portkey.aws/search-for-tag input "tagSpecificationSet" :flattened? nil :xmlAttribute? nil), "iamInstanceProfile" (portkey.aws/search-for-tag input "iamInstanceProfile" :flattened? nil :xmlAttribute? nil), "userData" (portkey.aws/search-for-tag input "userData" :flattened? nil :xmlAttribute? nil), "imageId" (portkey.aws/search-for-tag input "imageId" :flattened? nil :xmlAttribute? nil), "ebsOptimized" (portkey.aws/search-for-tag input "ebsOptimized" :flattened? nil :xmlAttribute? nil), "blockDeviceMappingSet" (portkey.aws/search-for-tag input "blockDeviceMappingSet" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "capacityReservationSpecification" (portkey.aws/search-for-tag input "capacityReservationSpecification" :flattened? nil :xmlAttribute? nil), "ramDiskId" (portkey.aws/search-for-tag input "ramDiskId" :flattened? nil :xmlAttribute? nil), "kernelId" (portkey.aws/search-for-tag input "kernelId" :flattened? nil :xmlAttribute? nil), "networkInterfaceSet" (portkey.aws/search-for-tag input "networkInterfaceSet" :flattened? nil :xmlAttribute? nil), "instanceInitiatedShutdownBehavior" (portkey.aws/search-for-tag input "instanceInitiatedShutdownBehavior" :flattened? nil :xmlAttribute? nil), "hibernationOptions" (portkey.aws/search-for-tag input "hibernationOptions" :flattened? nil :xmlAttribute? nil), "creditSpecification" (portkey.aws/search-for-tag input "creditSpecification" :flattened? nil :xmlAttribute? nil), "securityGroupSet" (portkey.aws/search-for-tag input "securityGroupSet" :flattened? nil :xmlAttribute? nil), "elasticGpuSpecificationSet" (portkey.aws/search-for-tag input "elasticGpuSpecificationSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar618953 "tagSpecificationSet") (clojure.core/assoc :tag-specifications (deser-launch-template-tag-specification-list (clojure.core/get-in letvar618953 ["tagSpecificationSet" :content]))) (letvar618953 "kernelId") (clojure.core/assoc :kernel-id (deser-string (clojure.core/get-in letvar618953 ["kernelId" :content]))) (letvar618953 "creditSpecification") (clojure.core/assoc :credit-specification (deser-credit-specification (clojure.core/get-in letvar618953 ["creditSpecification" :content]))) (letvar618953 "securityGroupIdSet") (clojure.core/assoc :security-group-ids (deser-value-string-list (clojure.core/get-in letvar618953 ["securityGroupIdSet" :content]))) (letvar618953 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar618953 ["imageId" :content]))) (letvar618953 "placement") (clojure.core/assoc :placement (deser-launch-template-placement (clojure.core/get-in letvar618953 ["placement" :content]))) (letvar618953 "securityGroupSet") (clojure.core/assoc :security-groups (deser-value-string-list (clojure.core/get-in letvar618953 ["securityGroupSet" :content]))) (letvar618953 "ebsOptimized") (clojure.core/assoc :ebs-optimized (deser-boolean (clojure.core/get-in letvar618953 ["ebsOptimized" :content]))) (letvar618953 "instanceMarketOptions") (clojure.core/assoc :instance-market-options (deser-launch-template-instance-market-options (clojure.core/get-in letvar618953 ["instanceMarketOptions" :content]))) (letvar618953 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar618953 ["instanceType" :content]))) (letvar618953 "elasticInferenceAcceleratorSet") (clojure.core/assoc :elastic-inference-accelerators (deser-launch-template-elastic-inference-accelerator-response-list (clojure.core/get-in letvar618953 ["elasticInferenceAcceleratorSet" :content]))) (letvar618953 "keyName") (clojure.core/assoc :key-name (deser-string (clojure.core/get-in letvar618953 ["keyName" :content]))) (letvar618953 "elasticGpuSpecificationSet") (clojure.core/assoc :elastic-gpu-specifications (deser-elastic-gpu-specification-response-list (clojure.core/get-in letvar618953 ["elasticGpuSpecificationSet" :content]))) (letvar618953 "licenseSet") (clojure.core/assoc :license-specifications (deser-launch-template-license-list (clojure.core/get-in letvar618953 ["licenseSet" :content]))) (letvar618953 "ramDiskId") (clojure.core/assoc :ram-disk-id (deser-string (clojure.core/get-in letvar618953 ["ramDiskId" :content]))) (letvar618953 "disableApiTermination") (clojure.core/assoc :disable-api-termination (deser-boolean (clojure.core/get-in letvar618953 ["disableApiTermination" :content]))) (letvar618953 "hibernationOptions") (clojure.core/assoc :hibernation-options (deser-launch-template-hibernation-options (clojure.core/get-in letvar618953 ["hibernationOptions" :content]))) (letvar618953 "monitoring") (clojure.core/assoc :monitoring (deser-launch-templates-monitoring (clojure.core/get-in letvar618953 ["monitoring" :content]))) (letvar618953 "blockDeviceMappingSet") (clojure.core/assoc :block-device-mappings (deser-launch-template-block-device-mapping-list (clojure.core/get-in letvar618953 ["blockDeviceMappingSet" :content]))) (letvar618953 "capacityReservationSpecification") (clojure.core/assoc :capacity-reservation-specification (deser-launch-template-capacity-reservation-specification-response (clojure.core/get-in letvar618953 ["capacityReservationSpecification" :content]))) (letvar618953 "cpuOptions") (clojure.core/assoc :cpu-options (deser-launch-template-cpu-options (clojure.core/get-in letvar618953 ["cpuOptions" :content]))) (letvar618953 "userData") (clojure.core/assoc :user-data (deser-string (clojure.core/get-in letvar618953 ["userData" :content]))) (letvar618953 "instanceInitiatedShutdownBehavior") (clojure.core/assoc :instance-initiated-shutdown-behavior (deser-shutdown-behavior (clojure.core/get-in letvar618953 ["instanceInitiatedShutdownBehavior" :content]))) (letvar618953 "iamInstanceProfile") (clojure.core/assoc :iam-instance-profile (deser-launch-template-iam-instance-profile-specification (clojure.core/get-in letvar618953 ["iamInstanceProfile" :content]))) (letvar618953 "networkInterfaceSet") (clojure.core/assoc :network-interfaces (deser-launch-template-instance-network-interface-specification-list (clojure.core/get-in letvar618953 ["networkInterfaceSet" :content]))))))

(clojure.core/defn- deser-import-instance-volume-detail-item [input] (clojure.core/let [letvar619061 {"availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "bytesConverted" (portkey.aws/search-for-tag input "bytesConverted" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "image" (portkey.aws/search-for-tag input "image" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil), "volume" (portkey.aws/search-for-tag input "volume" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar619061 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar619061 ["availabilityZone" :content]))) (letvar619061 "bytesConverted") (clojure.core/assoc :bytes-converted (deser-long (clojure.core/get-in letvar619061 ["bytesConverted" :content]))) (letvar619061 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar619061 ["description" :content]))) (letvar619061 "image") (clojure.core/assoc :image (deser-disk-image-description (clojure.core/get-in letvar619061 ["image" :content]))) (letvar619061 "status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar619061 ["status" :content]))) (letvar619061 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar619061 ["statusMessage" :content]))) (letvar619061 "volume") (clojure.core/assoc :volume (deser-disk-image-volume-description (clojure.core/get-in letvar619061 ["volume" :content]))))))

(clojure.core/defn- deser-fleet-launch-template-specification [input] (clojure.core/let [letvar619169 {"launchTemplateId" (portkey.aws/search-for-tag input "launchTemplateId" :flattened? nil :xmlAttribute? nil), "launchTemplateName" (portkey.aws/search-for-tag input "launchTemplateName" :flattened? nil :xmlAttribute? nil), "version" (portkey.aws/search-for-tag input "version" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar619169 "launchTemplateId") (clojure.core/assoc :launch-template-id (deser-string (clojure.core/get-in letvar619169 ["launchTemplateId" :content]))) (letvar619169 "launchTemplateName") (clojure.core/assoc :launch-template-name (deser-launch-template-name (clojure.core/get-in letvar619169 ["launchTemplateName" :content]))) (letvar619169 "version") (clojure.core/assoc :version (deser-string (clojure.core/get-in letvar619169 ["version" :content]))))))

(clojure.core/defn- deser-delete-fleet-success-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-delete-fleet-success-item coll))) input))

(clojure.core/defn- deser-tenancy [input] (clojure.core/get {"default" :default, "dedicated" :dedicated, "host" :host} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-ipv-6-support-value [input] (clojure.core/get {"enable" :enable, "disable" :disable} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-instance-network-interface-attachment [input] (clojure.core/let [letvar619304 {"attachTime" (portkey.aws/search-for-tag input "attachTime" :flattened? nil :xmlAttribute? nil), "attachmentId" (portkey.aws/search-for-tag input "attachmentId" :flattened? nil :xmlAttribute? nil), "deleteOnTermination" (portkey.aws/search-for-tag input "deleteOnTermination" :flattened? nil :xmlAttribute? nil), "deviceIndex" (portkey.aws/search-for-tag input "deviceIndex" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar619304 "attachTime") (clojure.core/assoc :attach-time (deser-date-time (clojure.core/get-in letvar619304 ["attachTime" :content]))) (letvar619304 "attachmentId") (clojure.core/assoc :attachment-id (deser-string (clojure.core/get-in letvar619304 ["attachmentId" :content]))) (letvar619304 "deleteOnTermination") (clojure.core/assoc :delete-on-termination (deser-boolean (clojure.core/get-in letvar619304 ["deleteOnTermination" :content]))) (letvar619304 "deviceIndex") (clojure.core/assoc :device-index (deser-integer (clojure.core/get-in letvar619304 ["deviceIndex" :content]))) (letvar619304 "status") (clojure.core/assoc :status (deser-attachment-status (clojure.core/get-in letvar619304 ["status" :content]))))))

(clojure.core/defn- deser-snapshot-detail [input] (clojure.core/let [letvar619412 {"progress" (portkey.aws/search-for-tag input "progress" :flattened? nil :xmlAttribute? nil), "url" (portkey.aws/search-for-tag input "url" :flattened? nil :xmlAttribute? nil), "deviceName" (portkey.aws/search-for-tag input "deviceName" :flattened? nil :xmlAttribute? nil), "userBucket" (portkey.aws/search-for-tag input "userBucket" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil), "diskImageSize" (portkey.aws/search-for-tag input "diskImageSize" :flattened? nil :xmlAttribute? nil), "snapshotId" (portkey.aws/search-for-tag input "snapshotId" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "format" (portkey.aws/search-for-tag input "format" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar619412 "diskImageSize") (clojure.core/assoc :disk-image-size (deser-double (clojure.core/get-in letvar619412 ["diskImageSize" :content]))) (letvar619412 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar619412 ["statusMessage" :content]))) (letvar619412 "format") (clojure.core/assoc :format (deser-string (clojure.core/get-in letvar619412 ["format" :content]))) (letvar619412 "status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar619412 ["status" :content]))) (letvar619412 "progress") (clojure.core/assoc :progress (deser-string (clojure.core/get-in letvar619412 ["progress" :content]))) (letvar619412 "url") (clojure.core/assoc :url (deser-string (clojure.core/get-in letvar619412 ["url" :content]))) (letvar619412 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar619412 ["description" :content]))) (letvar619412 "deviceName") (clojure.core/assoc :device-name (deser-string (clojure.core/get-in letvar619412 ["deviceName" :content]))) (letvar619412 "userBucket") (clojure.core/assoc :user-bucket (deser-user-bucket-details (clojure.core/get-in letvar619412 ["userBucket" :content]))) (letvar619412 "snapshotId") (clojure.core/assoc :snapshot-id (deser-string (clojure.core/get-in letvar619412 ["snapshotId" :content]))))))

(clojure.core/defn- deser-delete-launch-template-versions-response-success-item [input] (clojure.core/let [letvar619520 {"launchTemplateId" (portkey.aws/search-for-tag input "launchTemplateId" :flattened? nil :xmlAttribute? nil), "launchTemplateName" (portkey.aws/search-for-tag input "launchTemplateName" :flattened? nil :xmlAttribute? nil), "versionNumber" (portkey.aws/search-for-tag input "versionNumber" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar619520 "launchTemplateId") (clojure.core/assoc :launch-template-id (deser-string (clojure.core/get-in letvar619520 ["launchTemplateId" :content]))) (letvar619520 "launchTemplateName") (clojure.core/assoc :launch-template-name (deser-string (clojure.core/get-in letvar619520 ["launchTemplateName" :content]))) (letvar619520 "versionNumber") (clojure.core/assoc :version-number (deser-long (clojure.core/get-in letvar619520 ["versionNumber" :content]))))))

(clojure.core/defn- deser-fpga-image [input] (clojure.core/let [letvar619628 {"productCodes" (portkey.aws/search-for-tag input "productCodes" :flattened? nil :xmlAttribute? nil), "fpgaImageId" (portkey.aws/search-for-tag input "fpgaImageId" :flattened? nil :xmlAttribute? nil), "fpgaImageGlobalId" (portkey.aws/search-for-tag input "fpgaImageGlobalId" :flattened? nil :xmlAttribute? nil), "tags" (portkey.aws/search-for-tag input "tags" :flattened? nil :xmlAttribute? nil), "name" (portkey.aws/search-for-tag input "name" :flattened? nil :xmlAttribute? nil), "createTime" (portkey.aws/search-for-tag input "createTime" :flattened? nil :xmlAttribute? nil), "updateTime" (portkey.aws/search-for-tag input "updateTime" :flattened? nil :xmlAttribute? nil), "pciId" (portkey.aws/search-for-tag input "pciId" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "public" (portkey.aws/search-for-tag input "public" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "shellVersion" (portkey.aws/search-for-tag input "shellVersion" :flattened? nil :xmlAttribute? nil), "ownerAlias" (portkey.aws/search-for-tag input "ownerAlias" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar619628 "fpgaImageGlobalId") (clojure.core/assoc :fpga-image-global-id (deser-string (clojure.core/get-in letvar619628 ["fpgaImageGlobalId" :content]))) (letvar619628 "shellVersion") (clojure.core/assoc :shell-version (deser-string (clojure.core/get-in letvar619628 ["shellVersion" :content]))) (letvar619628 "pciId") (clojure.core/assoc :pci-id (deser-pci-id (clojure.core/get-in letvar619628 ["pciId" :content]))) (letvar619628 "updateTime") (clojure.core/assoc :update-time (deser-date-time (clojure.core/get-in letvar619628 ["updateTime" :content]))) (letvar619628 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar619628 ["ownerId" :content]))) (letvar619628 "tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar619628 ["tags" :content]))) (letvar619628 "ownerAlias") (clojure.core/assoc :owner-alias (deser-string (clojure.core/get-in letvar619628 ["ownerAlias" :content]))) (letvar619628 "public") (clojure.core/assoc :public (deser-boolean (clojure.core/get-in letvar619628 ["public" :content]))) (letvar619628 "fpgaImageId") (clojure.core/assoc :fpga-image-id (deser-string (clojure.core/get-in letvar619628 ["fpgaImageId" :content]))) (letvar619628 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar619628 ["description" :content]))) (letvar619628 "createTime") (clojure.core/assoc :create-time (deser-date-time (clojure.core/get-in letvar619628 ["createTime" :content]))) (letvar619628 "productCodes") (clojure.core/assoc :product-codes (deser-product-code-list (clojure.core/get-in letvar619628 ["productCodes" :content]))) (letvar619628 "state") (clojure.core/assoc :state (deser-fpga-image-state (clojure.core/get-in letvar619628 ["state" :content]))) (letvar619628 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar619628 ["name" :content]))))))

(clojure.core/defn- deser-spot-instance-state-fault [input] (clojure.core/let [letvar619736 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar619736 "code") (clojure.core/assoc :code (deser-string (clojure.core/get-in letvar619736 ["code" :content]))) (letvar619736 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar619736 ["message" :content]))))))

(clojure.core/defn- deser-transit-gateway-vpc-attachment-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-transit-gateway-vpc-attachment coll))) input))

(clojure.core/defn- deser-dhcp-configuration-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-attribute-value coll))) input))

(clojure.core/defn- deser-instance-network-interface-association [input] (clojure.core/let [letvar619878 {"ipOwnerId" (portkey.aws/search-for-tag input "ipOwnerId" :flattened? nil :xmlAttribute? nil), "publicDnsName" (portkey.aws/search-for-tag input "publicDnsName" :flattened? nil :xmlAttribute? nil), "publicIp" (portkey.aws/search-for-tag input "publicIp" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar619878 "ipOwnerId") (clojure.core/assoc :ip-owner-id (deser-string (clojure.core/get-in letvar619878 ["ipOwnerId" :content]))) (letvar619878 "publicDnsName") (clojure.core/assoc :public-dns-name (deser-string (clojure.core/get-in letvar619878 ["publicDnsName" :content]))) (letvar619878 "publicIp") (clojure.core/assoc :public-ip (deser-string (clojure.core/get-in letvar619878 ["publicIp" :content]))))))

(clojure.core/defn- deser-fleet-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-fleet-data coll))) input))

(clojure.core/defn- deser-bundle-task-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-bundle-task coll))) input))

(clojure.core/defn- deser-describe-fleets-instances [input] (clojure.core/let [letvar620020 {"launchTemplateAndOverrides" (portkey.aws/search-for-tag input "launchTemplateAndOverrides" :flattened? nil :xmlAttribute? nil), "lifecycle" (portkey.aws/search-for-tag input "lifecycle" :flattened? nil :xmlAttribute? nil), "instanceIds" (portkey.aws/search-for-tag input "instanceIds" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "platform" (portkey.aws/search-for-tag input "platform" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar620020 "launchTemplateAndOverrides") (clojure.core/assoc :launch-template-and-overrides (deser-launch-template-and-overrides-response (clojure.core/get-in letvar620020 ["launchTemplateAndOverrides" :content]))) (letvar620020 "lifecycle") (clojure.core/assoc :lifecycle (deser-instance-lifecycle (clojure.core/get-in letvar620020 ["lifecycle" :content]))) (letvar620020 "instanceIds") (clojure.core/assoc :instance-ids (deser-instance-ids-set (clojure.core/get-in letvar620020 ["instanceIds" :content]))) (letvar620020 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar620020 ["instanceType" :content]))) (letvar620020 "platform") (clojure.core/assoc :platform (deser-platform-values (clojure.core/get-in letvar620020 ["platform" :content]))))))

(clojure.core/defn- deser-create-fleet-instance [input] (clojure.core/let [letvar620128 {"launchTemplateAndOverrides" (portkey.aws/search-for-tag input "launchTemplateAndOverrides" :flattened? nil :xmlAttribute? nil), "lifecycle" (portkey.aws/search-for-tag input "lifecycle" :flattened? nil :xmlAttribute? nil), "instanceIds" (portkey.aws/search-for-tag input "instanceIds" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "platform" (portkey.aws/search-for-tag input "platform" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar620128 "launchTemplateAndOverrides") (clojure.core/assoc :launch-template-and-overrides (deser-launch-template-and-overrides-response (clojure.core/get-in letvar620128 ["launchTemplateAndOverrides" :content]))) (letvar620128 "lifecycle") (clojure.core/assoc :lifecycle (deser-instance-lifecycle (clojure.core/get-in letvar620128 ["lifecycle" :content]))) (letvar620128 "instanceIds") (clojure.core/assoc :instance-ids (deser-instance-ids-set (clojure.core/get-in letvar620128 ["instanceIds" :content]))) (letvar620128 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar620128 ["instanceType" :content]))) (letvar620128 "platform") (clojure.core/assoc :platform (deser-platform-values (clojure.core/get-in letvar620128 ["platform" :content]))))))

(clojure.core/defn- deser-fleet-launch-template-config-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-fleet-launch-template-config coll))) input))

(clojure.core/defn- deser-disk-image-volume-description [input] (clojure.core/let [letvar620253 {"id" (portkey.aws/search-for-tag input "id" :flattened? nil :xmlAttribute? nil), "size" (portkey.aws/search-for-tag input "size" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar620253 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar620253 ["id" :content]))) (letvar620253 "size") (clojure.core/assoc :size (deser-long (clojure.core/get-in letvar620253 ["size" :content]))))))

(clojure.core/defn- deser-host-properties [input] (clojure.core/let [letvar620361 {"cores" (portkey.aws/search-for-tag input "cores" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "sockets" (portkey.aws/search-for-tag input "sockets" :flattened? nil :xmlAttribute? nil), "totalVCpus" (portkey.aws/search-for-tag input "totalVCpus" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar620361 "cores") (clojure.core/assoc :cores (deser-integer (clojure.core/get-in letvar620361 ["cores" :content]))) (letvar620361 "instanceType") (clojure.core/assoc :instance-type (deser-string (clojure.core/get-in letvar620361 ["instanceType" :content]))) (letvar620361 "sockets") (clojure.core/assoc :sockets (deser-integer (clojure.core/get-in letvar620361 ["sockets" :content]))) (letvar620361 "totalVCpus") (clojure.core/assoc :total-v-cpus (deser-integer (clojure.core/get-in letvar620361 ["totalVCpus" :content]))))))

(clojure.core/defn- deser-association-status-code [input] (clojure.core/get {"associating" :associating, "associated" :associated, "association-failed" :associationfailed, "disassociating" :disassociating, "disassociated" :disassociated} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-delete-launch-template-versions-response-error-item [input] (clojure.core/let [letvar620474 {"launchTemplateId" (portkey.aws/search-for-tag input "launchTemplateId" :flattened? nil :xmlAttribute? nil), "launchTemplateName" (portkey.aws/search-for-tag input "launchTemplateName" :flattened? nil :xmlAttribute? nil), "versionNumber" (portkey.aws/search-for-tag input "versionNumber" :flattened? nil :xmlAttribute? nil), "responseError" (portkey.aws/search-for-tag input "responseError" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar620474 "launchTemplateId") (clojure.core/assoc :launch-template-id (deser-string (clojure.core/get-in letvar620474 ["launchTemplateId" :content]))) (letvar620474 "launchTemplateName") (clojure.core/assoc :launch-template-name (deser-string (clojure.core/get-in letvar620474 ["launchTemplateName" :content]))) (letvar620474 "versionNumber") (clojure.core/assoc :version-number (deser-long (clojure.core/get-in letvar620474 ["versionNumber" :content]))) (letvar620474 "responseError") (clojure.core/assoc :response-error (deser-response-error (clojure.core/get-in letvar620474 ["responseError" :content]))))))

(clojure.core/defn- deser-scheduled-instance [input] (clojure.core/let [letvar620582 {"previousSlotEndTime" (portkey.aws/search-for-tag input "previousSlotEndTime" :flattened? nil :xmlAttribute? nil), "createDate" (portkey.aws/search-for-tag input "createDate" :flattened? nil :xmlAttribute? nil), "instanceCount" (portkey.aws/search-for-tag input "instanceCount" :flattened? nil :xmlAttribute? nil), "termStartDate" (portkey.aws/search-for-tag input "termStartDate" :flattened? nil :xmlAttribute? nil), "networkPlatform" (portkey.aws/search-for-tag input "networkPlatform" :flattened? nil :xmlAttribute? nil), "hourlyPrice" (portkey.aws/search-for-tag input "hourlyPrice" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "recurrence" (portkey.aws/search-for-tag input "recurrence" :flattened? nil :xmlAttribute? nil), "totalScheduledInstanceHours" (portkey.aws/search-for-tag input "totalScheduledInstanceHours" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "slotDurationInHours" (portkey.aws/search-for-tag input "slotDurationInHours" :flattened? nil :xmlAttribute? nil), "scheduledInstanceId" (portkey.aws/search-for-tag input "scheduledInstanceId" :flattened? nil :xmlAttribute? nil), "platform" (portkey.aws/search-for-tag input "platform" :flattened? nil :xmlAttribute? nil), "termEndDate" (portkey.aws/search-for-tag input "termEndDate" :flattened? nil :xmlAttribute? nil), "nextSlotStartTime" (portkey.aws/search-for-tag input "nextSlotStartTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar620582 "platform") (clojure.core/assoc :platform (deser-string (clojure.core/get-in letvar620582 ["platform" :content]))) (letvar620582 "termEndDate") (clojure.core/assoc :term-end-date (deser-date-time (clojure.core/get-in letvar620582 ["termEndDate" :content]))) (letvar620582 "networkPlatform") (clojure.core/assoc :network-platform (deser-string (clojure.core/get-in letvar620582 ["networkPlatform" :content]))) (letvar620582 "instanceCount") (clojure.core/assoc :instance-count (deser-integer (clojure.core/get-in letvar620582 ["instanceCount" :content]))) (letvar620582 "recurrence") (clojure.core/assoc :recurrence (deser-scheduled-instance-recurrence (clojure.core/get-in letvar620582 ["recurrence" :content]))) (letvar620582 "createDate") (clojure.core/assoc :create-date (deser-date-time (clojure.core/get-in letvar620582 ["createDate" :content]))) (letvar620582 "instanceType") (clojure.core/assoc :instance-type (deser-string (clojure.core/get-in letvar620582 ["instanceType" :content]))) (letvar620582 "nextSlotStartTime") (clojure.core/assoc :next-slot-start-time (deser-date-time (clojure.core/get-in letvar620582 ["nextSlotStartTime" :content]))) (letvar620582 "totalScheduledInstanceHours") (clojure.core/assoc :total-scheduled-instance-hours (deser-integer (clojure.core/get-in letvar620582 ["totalScheduledInstanceHours" :content]))) (letvar620582 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar620582 ["availabilityZone" :content]))) (letvar620582 "hourlyPrice") (clojure.core/assoc :hourly-price (deser-string (clojure.core/get-in letvar620582 ["hourlyPrice" :content]))) (letvar620582 "slotDurationInHours") (clojure.core/assoc :slot-duration-in-hours (deser-integer (clojure.core/get-in letvar620582 ["slotDurationInHours" :content]))) (letvar620582 "previousSlotEndTime") (clojure.core/assoc :previous-slot-end-time (deser-date-time (clojure.core/get-in letvar620582 ["previousSlotEndTime" :content]))) (letvar620582 "scheduledInstanceId") (clojure.core/assoc :scheduled-instance-id (deser-string (clojure.core/get-in letvar620582 ["scheduledInstanceId" :content]))) (letvar620582 "termStartDate") (clojure.core/assoc :term-start-date (deser-date-time (clojure.core/get-in letvar620582 ["termStartDate" :content]))))))

(clojure.core/defn- deser-transit-gateway-attachment-association [input] (clojure.core/let [letvar620690 {"transitGatewayRouteTableId" (portkey.aws/search-for-tag input "transitGatewayRouteTableId" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar620690 "transitGatewayRouteTableId") (clojure.core/assoc :transit-gateway-route-table-id (deser-string (clojure.core/get-in letvar620690 ["transitGatewayRouteTableId" :content]))) (letvar620690 "state") (clojure.core/assoc :state (deser-transit-gateway-association-state (clojure.core/get-in letvar620690 ["state" :content]))))))

(clojure.core/defn- deser-active-instance-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-active-instance coll))) input))

(clojure.core/defn- deser-instance-type [input] (clojure.core/get {"m1.large" :m-1large, "t3.small" :t-3small, "cc1.4xlarge" :cc-14xlarge, "z1d.large" :z-1dlarge, "x1e.32xlarge" :x-1e-32xlarge, "r5d.xlarge" :r-5dxlarge, "r5a.large" :r-5alarge, "r5a.xlarge" :r-5axlarge, "m5d.24xlarge" :m-5d-24xlarge, "c1.medium" :c-1medium, "r4.2xlarge" :r-42xlarge, "r3.8xlarge" :r-38xlarge, "r5.4xlarge" :r-54xlarge, "d2.xlarge" :d-2xlarge, "m3.2xlarge" :m-32xlarge, "i2.8xlarge" :i-28xlarge, "h1.16xlarge" :h-116xlarge, "m5.xlarge" :m-5xlarge, "r5a.2xlarge" :r-5a-2xlarge, "t3.2xlarge" :t-32xlarge, "g2.2xlarge" :g-22xlarge, "g3.8xlarge" :g-38xlarge, "t3.xlarge" :t-3xlarge, "c3.8xlarge" :c-38xlarge, "t2.large" :t-2large, "x1e.4xlarge" :x-1e-4xlarge, "t3.nano" :t-3nano, "p2.16xlarge" :p-216xlarge, "m1.xlarge" :m-1xlarge, "m5a.24xlarge" :m-5a-24xlarge, "d2.8xlarge" :d-28xlarge, "r5d.large" :r-5dlarge, "m4.4xlarge" :m-44xlarge, "t2.2xlarge" :t-22xlarge, "r4.16xlarge" :r-416xlarge, "u-12tb1.metal" :u-12tb-1metal, "r5d.4xlarge" :r-5d-4xlarge, "g3.16xlarge" :g-316xlarge, "z1d.2xlarge" :z-1d-2xlarge, "t3.large" :t-3large, "h1.2xlarge" :h-12xlarge, "g3.4xlarge" :g-34xlarge, "cr1.8xlarge" :cr-18xlarge, "t1.micro" :t-1micro, "a1.2xlarge" :a-12xlarge, "c5d.large" :c-5dlarge, "r5a.24xlarge" :r-5a-24xlarge, "z1d.xlarge" :z-1dxlarge, "c5.4xlarge" :c-54xlarge, "p3dn.24xlarge" :p-3dn-24xlarge, "c3.2xlarge" :c-32xlarge, "g2.8xlarge" :g-28xlarge, "z1d.3xlarge" :z-1d-3xlarge, "c5d.18xlarge" :c-5d-18xlarge, "c4.8xlarge" :c-48xlarge, "c5.18xlarge" :c-518xlarge, "x1e.2xlarge" :x-1e-2xlarge, "r5.metal" :r-5metal, "z1d.6xlarge" :z-1d-6xlarge, "m2.xlarge" :m-2xlarge, "m1.small" :m-1small, "i2.4xlarge" :i-24xlarge, "c3.4xlarge" :c-34xlarge, "i3.16xlarge" :i-316xlarge, "t2.micro" :t-2micro, "z1d.metal" :z-1dmetal, "g3s.xlarge" :g-3sxlarge, "d2.2xlarge" :d-22xlarge, "x1.32xlarge" :x-132xlarge, "m4.2xlarge" :m-42xlarge, "r5d.24xlarge" :r-5d-24xlarge, "u-6tb1.metal" :u-6tb-1metal, "i3.4xlarge" :i-34xlarge, "m4.10xlarge" :m-410xlarge, "i3.metal" :i-3metal, "m1.medium" :m-1medium, "c5n.xlarge" :c-5nxlarge, "c4.4xlarge" :c-44xlarge, "hi1.4xlarge" :hi-14xlarge, "r3.xlarge" :r-3xlarge, "c5n.large" :c-5nlarge, "x1e.16xlarge" :x-1e-16xlarge, "m5.large" :m-5large, "r5.xlarge" :r-5xlarge, "c4.2xlarge" :c-42xlarge, "i3.8xlarge" :i-38xlarge, "p3.2xlarge" :p-32xlarge, "m5.4xlarge" :m-54xlarge, "t3.medium" :t-3medium, "u-9tb1.metal" :u-9tb-1metal, "t2.small" :t-2small, "c5n.4xlarge" :c-5n-4xlarge, "r4.xlarge" :r-4xlarge, "m5a.2xlarge" :m-5a-2xlarge, "m5.2xlarge" :m-52xlarge, "z1d.12xlarge" :z-1d-12xlarge, "t3.micro" :t-3micro, "c5.large" :c-5large, "c5.2xlarge" :c-52xlarge, "f1.2xlarge" :f-12xlarge, "m5d.4xlarge" :m-5d-4xlarge, "c5d.xlarge" :c-5dxlarge, "m3.xlarge" :m-3xlarge, "c5d.9xlarge" :c-5d-9xlarge, "r3.2xlarge" :r-32xlarge, "m5d.metal" :m-5dmetal, "cg1.4xlarge" :cg-14xlarge, "r3.4xlarge" :r-34xlarge, "t2.xlarge" :t-2xlarge, "c4.xlarge" :c-4xlarge, "m2.2xlarge" :m-22xlarge, "f1.4xlarge" :f-14xlarge, "r5.large" :r-5large, "p2.8xlarge" :p-28xlarge, "r5d.12xlarge" :r-5d-12xlarge, "m5.metal" :m-5metal, "x1.16xlarge" :x-116xlarge, "m4.large" :m-4large, "c5n.2xlarge" :c-5n-2xlarge, "m4.16xlarge" :m-416xlarge, "r3.large" :r-3large, "d2.4xlarge" :d-24xlarge, "h1.8xlarge" :h-18xlarge, "i3.2xlarge" :i-32xlarge, "c4.large" :c-4large, "h1.4xlarge" :h-14xlarge, "m5d.12xlarge" :m-5d-12xlarge, "m4.xlarge" :m-4xlarge, "m5a.large" :m-5alarge, "f1.16xlarge" :f-116xlarge, "r5.12xlarge" :r-512xlarge, "m5a.4xlarge" :m-5a-4xlarge, "i2.2xlarge" :i-22xlarge, "p3.16xlarge" :p-316xlarge, "i3.xlarge" :i-3xlarge, "c5n.9xlarge" :c-5n-9xlarge, "t2.nano" :t-2nano, "m2.4xlarge" :m-24xlarge, "r5a.4xlarge" :r-5a-4xlarge, "r5d.metal" :r-5dmetal, "r4.large" :r-4large, "m5a.xlarge" :m-5axlarge, "c3.xlarge" :c-3xlarge, "p2.xlarge" :p-2xlarge, "c5d.4xlarge" :c-5d-4xlarge, "i3.large" :i-3large, "a1.4xlarge" :a-14xlarge, "r4.8xlarge" :r-48xlarge, "a1.xlarge" :a-1xlarge, "t2.medium" :t-2medium, "p3.8xlarge" :p-38xlarge, "m5a.12xlarge" :m-5a-12xlarge, "c3.large" :c-3large, "m3.medium" :m-3medium, "a1.medium" :a-1medium, "m5d.2xlarge" :m-5d-2xlarge, "r5d.2xlarge" :r-5d-2xlarge, "i2.xlarge" :i-2xlarge, "m5.24xlarge" :m-524xlarge, "c5n.18xlarge" :c-5n-18xlarge, "r5a.12xlarge" :r-5a-12xlarge, "c5.9xlarge" :c-59xlarge, "m5d.large" :m-5dlarge, "m5.12xlarge" :m-512xlarge, "cc2.8xlarge" :cc-28xlarge, "hs1.8xlarge" :hs-18xlarge, "m3.large" :m-3large, "x1e.xlarge" :x-1exlarge, "c1.xlarge" :c-1xlarge, "c5d.2xlarge" :c-5d-2xlarge, "x1e.8xlarge" :x-1e-8xlarge, "r5.2xlarge" :r-52xlarge, "m5d.xlarge" :m-5dxlarge, "a1.large" :a-1large, "c5.xlarge" :c-5xlarge, "r4.4xlarge" :r-44xlarge, "r5.24xlarge" :r-524xlarge} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-route-state [input] (clojure.core/get {"active" :active, "blackhole" :blackhole} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-client-vpn-connection-status-code [input] (clojure.core/get {"active" :active, "failed-to-terminate" :failedtoterminate, "terminating" :terminating, "terminated" :terminated} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-transit-gateway [input] (clojure.core/let [letvar620830 {"transitGatewayId" (portkey.aws/search-for-tag input "transitGatewayId" :flattened? nil :xmlAttribute? nil), "transitGatewayArn" (portkey.aws/search-for-tag input "transitGatewayArn" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "creationTime" (portkey.aws/search-for-tag input "creationTime" :flattened? nil :xmlAttribute? nil), "options" (portkey.aws/search-for-tag input "options" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar620830 "transitGatewayId") (clojure.core/assoc :transit-gateway-id (deser-string (clojure.core/get-in letvar620830 ["transitGatewayId" :content]))) (letvar620830 "transitGatewayArn") (clojure.core/assoc :transit-gateway-arn (deser-string (clojure.core/get-in letvar620830 ["transitGatewayArn" :content]))) (letvar620830 "state") (clojure.core/assoc :state (deser-transit-gateway-state (clojure.core/get-in letvar620830 ["state" :content]))) (letvar620830 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar620830 ["ownerId" :content]))) (letvar620830 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar620830 ["description" :content]))) (letvar620830 "creationTime") (clojure.core/assoc :creation-time (deser-date-time (clojure.core/get-in letvar620830 ["creationTime" :content]))) (letvar620830 "options") (clojure.core/assoc :options (deser-transit-gateway-options (clojure.core/get-in letvar620830 ["options" :content]))) (letvar620830 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar620830 ["tagSet" :content]))))))

(clojure.core/defn- deser-subnet-state [input] (clojure.core/get {"pending" :pending, "available" :available} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-client-vpn-authentication [input] (clojure.core/let [letvar620943 {"type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil), "activeDirectory" (portkey.aws/search-for-tag input "activeDirectory" :flattened? nil :xmlAttribute? nil), "mutualAuthentication" (portkey.aws/search-for-tag input "mutualAuthentication" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar620943 "type") (clojure.core/assoc :type (deser-client-vpn-authentication-type (clojure.core/get-in letvar620943 ["type" :content]))) (letvar620943 "activeDirectory") (clojure.core/assoc :active-directory (deser-directory-service-authentication (clojure.core/get-in letvar620943 ["activeDirectory" :content]))) (letvar620943 "mutualAuthentication") (clojure.core/assoc :mutual-authentication (deser-certificate-authentication (clojure.core/get-in letvar620943 ["mutualAuthentication" :content]))))))

(clojure.core/defn- deser-stale-ip-permission-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-stale-ip-permission coll))) input))

(clojure.core/defn- deser-reserved-instances-modification-result [input] (clojure.core/let [letvar621068 {"reservedInstancesId" (portkey.aws/search-for-tag input "reservedInstancesId" :flattened? nil :xmlAttribute? nil), "targetConfiguration" (portkey.aws/search-for-tag input "targetConfiguration" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar621068 "reservedInstancesId") (clojure.core/assoc :reserved-instances-id (deser-string (clojure.core/get-in letvar621068 ["reservedInstancesId" :content]))) (letvar621068 "targetConfiguration") (clojure.core/assoc :target-configuration (deser-reserved-instances-configuration (clojure.core/get-in letvar621068 ["targetConfiguration" :content]))))))

(clojure.core/defn- deser-transit-gateway-attachment-propagation-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-transit-gateway-attachment-propagation coll))) input))

(clojure.core/defn- deser-import-instance-task-details [input] (clojure.core/let [letvar621193 {"description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "platform" (portkey.aws/search-for-tag input "platform" :flattened? nil :xmlAttribute? nil), "volumes" (portkey.aws/search-for-tag input "volumes" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar621193 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar621193 ["description" :content]))) (letvar621193 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar621193 ["instanceId" :content]))) (letvar621193 "platform") (clojure.core/assoc :platform (deser-platform-values (clojure.core/get-in letvar621193 ["platform" :content]))) (letvar621193 "volumes") (clojure.core/assoc :volumes (deser-import-instance-volume-detail-set (clojure.core/get-in letvar621193 ["volumes" :content]))))))

(clojure.core/defn- deser-create-volume-permission [input] (clojure.core/let [letvar621301 {"group" (portkey.aws/search-for-tag input "group" :flattened? nil :xmlAttribute? nil), "userId" (portkey.aws/search-for-tag input "userId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar621301 "group") (clojure.core/assoc :group (deser-permission-group (clojure.core/get-in letvar621301 ["group" :content]))) (letvar621301 "userId") (clojure.core/assoc :user-id (deser-string (clojure.core/get-in letvar621301 ["userId" :content]))))))

(clojure.core/defn- deser-client-vpn-endpoint-status [input] (clojure.core/let [letvar621409 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar621409 "code") (clojure.core/assoc :code (deser-client-vpn-endpoint-status-code (clojure.core/get-in letvar621409 ["code" :content]))) (letvar621409 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar621409 ["message" :content]))))))

(clojure.core/defn- deser-instance-status-details [input] (clojure.core/let [letvar621517 {"impairedSince" (portkey.aws/search-for-tag input "impairedSince" :flattened? nil :xmlAttribute? nil), "name" (portkey.aws/search-for-tag input "name" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar621517 "impairedSince") (clojure.core/assoc :impaired-since (deser-date-time (clojure.core/get-in letvar621517 ["impairedSince" :content]))) (letvar621517 "name") (clojure.core/assoc :name (deser-status-name (clojure.core/get-in letvar621517 ["name" :content]))) (letvar621517 "status") (clojure.core/assoc :status (deser-status-type (clojure.core/get-in letvar621517 ["status" :content]))))))

(clojure.core/defn- deser-subnet-cidr-block-state [input] (clojure.core/let [letvar621625 {"state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar621625 "state") (clojure.core/assoc :state (deser-subnet-cidr-block-state-code (clojure.core/get-in letvar621625 ["state" :content]))) (letvar621625 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar621625 ["statusMessage" :content]))))))

(clojure.core/defn- deser-iam-instance-profile-specification [input] (clojure.core/let [letvar621733 {"arn" (portkey.aws/search-for-tag input "arn" :flattened? nil :xmlAttribute? nil), "name" (portkey.aws/search-for-tag input "name" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar621733 "arn") (clojure.core/assoc :arn (deser-string (clojure.core/get-in letvar621733 ["arn" :content]))) (letvar621733 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar621733 ["name" :content]))))))

(clojure.core/defn- deser-spot-instance-request-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-spot-instance-request coll))) input))

(clojure.core/defn- deser-region-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-region coll))) input))

(clojure.core/defn- deser-end-date-type [input] (clojure.core/get {"unlimited" :unlimited, "limited" :limited} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-delete-fleet-success-item [input] (clojure.core/let [letvar621880 {"currentFleetState" (portkey.aws/search-for-tag input "currentFleetState" :flattened? nil :xmlAttribute? nil), "previousFleetState" (portkey.aws/search-for-tag input "previousFleetState" :flattened? nil :xmlAttribute? nil), "fleetId" (portkey.aws/search-for-tag input "fleetId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar621880 "currentFleetState") (clojure.core/assoc :current-fleet-state (deser-fleet-state-code (clojure.core/get-in letvar621880 ["currentFleetState" :content]))) (letvar621880 "previousFleetState") (clojure.core/assoc :previous-fleet-state (deser-fleet-state-code (clojure.core/get-in letvar621880 ["previousFleetState" :content]))) (letvar621880 "fleetId") (clojure.core/assoc :fleet-id (deser-fleet-identifier (clojure.core/get-in letvar621880 ["fleetId" :content]))))))

(clojure.core/defn- deser-public-ipv-4-pool-range-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-public-ipv-4-pool-range coll))) input))

(clojure.core/defn- deser-response-host-id-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-disk-image-description [input] (clojure.core/let [letvar622022 {"checksum" (portkey.aws/search-for-tag input "checksum" :flattened? nil :xmlAttribute? nil), "format" (portkey.aws/search-for-tag input "format" :flattened? nil :xmlAttribute? nil), "importManifestUrl" (portkey.aws/search-for-tag input "importManifestUrl" :flattened? nil :xmlAttribute? nil), "size" (portkey.aws/search-for-tag input "size" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar622022 "checksum") (clojure.core/assoc :checksum (deser-string (clojure.core/get-in letvar622022 ["checksum" :content]))) (letvar622022 "format") (clojure.core/assoc :format (deser-disk-image-format (clojure.core/get-in letvar622022 ["format" :content]))) (letvar622022 "importManifestUrl") (clojure.core/assoc :import-manifest-url (deser-string (clojure.core/get-in letvar622022 ["importManifestUrl" :content]))) (letvar622022 "size") (clojure.core/assoc :size (deser-long (clojure.core/get-in letvar622022 ["size" :content]))))))

(clojure.core/defn- deser-launch-template [input] (clojure.core/let [letvar622130 {"launchTemplateId" (portkey.aws/search-for-tag input "launchTemplateId" :flattened? nil :xmlAttribute? nil), "launchTemplateName" (portkey.aws/search-for-tag input "launchTemplateName" :flattened? nil :xmlAttribute? nil), "createTime" (portkey.aws/search-for-tag input "createTime" :flattened? nil :xmlAttribute? nil), "createdBy" (portkey.aws/search-for-tag input "createdBy" :flattened? nil :xmlAttribute? nil), "defaultVersionNumber" (portkey.aws/search-for-tag input "defaultVersionNumber" :flattened? nil :xmlAttribute? nil), "latestVersionNumber" (portkey.aws/search-for-tag input "latestVersionNumber" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar622130 "launchTemplateId") (clojure.core/assoc :launch-template-id (deser-string (clojure.core/get-in letvar622130 ["launchTemplateId" :content]))) (letvar622130 "launchTemplateName") (clojure.core/assoc :launch-template-name (deser-launch-template-name (clojure.core/get-in letvar622130 ["launchTemplateName" :content]))) (letvar622130 "createTime") (clojure.core/assoc :create-time (deser-date-time (clojure.core/get-in letvar622130 ["createTime" :content]))) (letvar622130 "createdBy") (clojure.core/assoc :created-by (deser-string (clojure.core/get-in letvar622130 ["createdBy" :content]))) (letvar622130 "defaultVersionNumber") (clojure.core/assoc :default-version-number (deser-long (clojure.core/get-in letvar622130 ["defaultVersionNumber" :content]))) (letvar622130 "latestVersionNumber") (clojure.core/assoc :latest-version-number (deser-long (clojure.core/get-in letvar622130 ["latestVersionNumber" :content]))) (letvar622130 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar622130 ["tagSet" :content]))))))

(clojure.core/defn- deser-client-certificate-revocation-list-status [input] (clojure.core/let [letvar622238 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar622238 "code") (clojure.core/assoc :code (deser-client-certificate-revocation-list-status-code (clojure.core/get-in letvar622238 ["code" :content]))) (letvar622238 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar622238 ["message" :content]))))))

(clojure.core/defn- deser-available-capacity [input] (clojure.core/let [letvar622346 {"availableInstanceCapacity" (portkey.aws/search-for-tag input "availableInstanceCapacity" :flattened? nil :xmlAttribute? nil), "availableVCpus" (portkey.aws/search-for-tag input "availableVCpus" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar622346 "availableInstanceCapacity") (clojure.core/assoc :available-instance-capacity (deser-available-instance-capacity-list (clojure.core/get-in letvar622346 ["availableInstanceCapacity" :content]))) (letvar622346 "availableVCpus") (clojure.core/assoc :available-v-cpus (deser-integer (clojure.core/get-in letvar622346 ["availableVCpus" :content]))))))

(clojure.core/defn- deser-service-detail-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-service-detail coll))) input))

(clojure.core/defn- deser-bundle-task-state [input] (clojure.core/get {"pending" :pending, "waiting-for-shutdown" :waitingforshutdown, "bundling" :bundling, "storing" :storing, "cancelling" :cancelling, "complete" :complete, "failed" :failed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-icmp-type-code [input] (clojure.core/let [letvar622476 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar622476 "code") (clojure.core/assoc :code (deser-integer (clojure.core/get-in letvar622476 ["code" :content]))) (letvar622476 "type") (clojure.core/assoc :type (deser-integer (clojure.core/get-in letvar622476 ["type" :content]))))))

(clojure.core/defn- deser-instance-private-ip-address [input] (clojure.core/let [letvar622584 {"association" (portkey.aws/search-for-tag input "association" :flattened? nil :xmlAttribute? nil), "primary" (portkey.aws/search-for-tag input "primary" :flattened? nil :xmlAttribute? nil), "privateDnsName" (portkey.aws/search-for-tag input "privateDnsName" :flattened? nil :xmlAttribute? nil), "privateIpAddress" (portkey.aws/search-for-tag input "privateIpAddress" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar622584 "association") (clojure.core/assoc :association (deser-instance-network-interface-association (clojure.core/get-in letvar622584 ["association" :content]))) (letvar622584 "primary") (clojure.core/assoc :primary (deser-boolean (clojure.core/get-in letvar622584 ["primary" :content]))) (letvar622584 "privateDnsName") (clojure.core/assoc :private-dns-name (deser-string (clojure.core/get-in letvar622584 ["privateDnsName" :content]))) (letvar622584 "privateIpAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar622584 ["privateIpAddress" :content]))))))

(clojure.core/defn- deser-capacity-reservation-target-response [input] (clojure.core/let [letvar622692 {"capacityReservationId" (portkey.aws/search-for-tag input "capacityReservationId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar622692 "capacityReservationId") (clojure.core/assoc :capacity-reservation-id (deser-string (clojure.core/get-in letvar622692 ["capacityReservationId" :content]))))))

(clojure.core/defn- deser-reserved-instances-listing-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-instances-listing coll))) input))

(clojure.core/defn- deser-service-state [input] (clojure.core/get {"Pending" :pending, "Available" :available, "Deleting" :deleting, "Deleted" :deleted, "Failed" :failed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-capacity-reservation-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-capacity-reservation coll))) input))

(clojure.core/defn- deser-vpc-classic-link [input] (clojure.core/let [letvar622839 {"classicLinkEnabled" (portkey.aws/search-for-tag input "classicLinkEnabled" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar622839 "classicLinkEnabled") (clojure.core/assoc :classic-link-enabled (deser-boolean (clojure.core/get-in letvar622839 ["classicLinkEnabled" :content]))) (letvar622839 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar622839 ["tagSet" :content]))) (letvar622839 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar622839 ["vpcId" :content]))))))

(clojure.core/defn- deser-snapshot-task-detail [input] (clojure.core/let [letvar622947 {"progress" (portkey.aws/search-for-tag input "progress" :flattened? nil :xmlAttribute? nil), "url" (portkey.aws/search-for-tag input "url" :flattened? nil :xmlAttribute? nil), "kmsKeyId" (portkey.aws/search-for-tag input "kmsKeyId" :flattened? nil :xmlAttribute? nil), "userBucket" (portkey.aws/search-for-tag input "userBucket" :flattened? nil :xmlAttribute? nil), "encrypted" (portkey.aws/search-for-tag input "encrypted" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil), "diskImageSize" (portkey.aws/search-for-tag input "diskImageSize" :flattened? nil :xmlAttribute? nil), "snapshotId" (portkey.aws/search-for-tag input "snapshotId" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "format" (portkey.aws/search-for-tag input "format" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar622947 "diskImageSize") (clojure.core/assoc :disk-image-size (deser-double (clojure.core/get-in letvar622947 ["diskImageSize" :content]))) (letvar622947 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar622947 ["statusMessage" :content]))) (letvar622947 "encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar622947 ["encrypted" :content]))) (letvar622947 "format") (clojure.core/assoc :format (deser-string (clojure.core/get-in letvar622947 ["format" :content]))) (letvar622947 "status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar622947 ["status" :content]))) (letvar622947 "progress") (clojure.core/assoc :progress (deser-string (clojure.core/get-in letvar622947 ["progress" :content]))) (letvar622947 "url") (clojure.core/assoc :url (deser-string (clojure.core/get-in letvar622947 ["url" :content]))) (letvar622947 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar622947 ["description" :content]))) (letvar622947 "kmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar622947 ["kmsKeyId" :content]))) (letvar622947 "userBucket") (clojure.core/assoc :user-bucket (deser-user-bucket-details (clojure.core/get-in letvar622947 ["userBucket" :content]))) (letvar622947 "snapshotId") (clojure.core/assoc :snapshot-id (deser-string (clojure.core/get-in letvar622947 ["snapshotId" :content]))))))

(clojure.core/defn- deser-launch-specification [input] (clojure.core/let [letvar623055 {"groupSet" (portkey.aws/search-for-tag input "groupSet" :flattened? nil :xmlAttribute? nil), "ramdiskId" (portkey.aws/search-for-tag input "ramdiskId" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "addressingType" (portkey.aws/search-for-tag input "addressingType" :flattened? nil :xmlAttribute? nil), "blockDeviceMapping" (portkey.aws/search-for-tag input "blockDeviceMapping" :flattened? nil :xmlAttribute? nil), "keyName" (portkey.aws/search-for-tag input "keyName" :flattened? nil :xmlAttribute? nil), "placement" (portkey.aws/search-for-tag input "placement" :flattened? nil :xmlAttribute? nil), "monitoring" (portkey.aws/search-for-tag input "monitoring" :flattened? nil :xmlAttribute? nil), "iamInstanceProfile" (portkey.aws/search-for-tag input "iamInstanceProfile" :flattened? nil :xmlAttribute? nil), "userData" (portkey.aws/search-for-tag input "userData" :flattened? nil :xmlAttribute? nil), "imageId" (portkey.aws/search-for-tag input "imageId" :flattened? nil :xmlAttribute? nil), "ebsOptimized" (portkey.aws/search-for-tag input "ebsOptimized" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "kernelId" (portkey.aws/search-for-tag input "kernelId" :flattened? nil :xmlAttribute? nil), "networkInterfaceSet" (portkey.aws/search-for-tag input "networkInterfaceSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar623055 "kernelId") (clojure.core/assoc :kernel-id (deser-string (clojure.core/get-in letvar623055 ["kernelId" :content]))) (letvar623055 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar623055 ["imageId" :content]))) (letvar623055 "placement") (clojure.core/assoc :placement (deser-spot-placement (clojure.core/get-in letvar623055 ["placement" :content]))) (letvar623055 "addressingType") (clojure.core/assoc :addressing-type (deser-string (clojure.core/get-in letvar623055 ["addressingType" :content]))) (letvar623055 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar623055 ["subnetId" :content]))) (letvar623055 "groupSet") (clojure.core/assoc :security-groups (deser-group-identifier-list (clojure.core/get-in letvar623055 ["groupSet" :content]))) (letvar623055 "ebsOptimized") (clojure.core/assoc :ebs-optimized (deser-boolean (clojure.core/get-in letvar623055 ["ebsOptimized" :content]))) (letvar623055 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar623055 ["instanceType" :content]))) (letvar623055 "keyName") (clojure.core/assoc :key-name (deser-string (clojure.core/get-in letvar623055 ["keyName" :content]))) (letvar623055 "monitoring") (clojure.core/assoc :monitoring (deser-run-instances-monitoring-enabled (clojure.core/get-in letvar623055 ["monitoring" :content]))) (letvar623055 "blockDeviceMapping") (clojure.core/assoc :block-device-mappings (deser-block-device-mapping-list (clojure.core/get-in letvar623055 ["blockDeviceMapping" :content]))) (letvar623055 "ramdiskId") (clojure.core/assoc :ramdisk-id (deser-string (clojure.core/get-in letvar623055 ["ramdiskId" :content]))) (letvar623055 "userData") (clojure.core/assoc :user-data (deser-string (clojure.core/get-in letvar623055 ["userData" :content]))) (letvar623055 "iamInstanceProfile") (clojure.core/assoc :iam-instance-profile (deser-iam-instance-profile-specification (clojure.core/get-in letvar623055 ["iamInstanceProfile" :content]))) (letvar623055 "networkInterfaceSet") (clojure.core/assoc :network-interfaces (deser-instance-network-interface-specification-list (clojure.core/get-in letvar623055 ["networkInterfaceSet" :content]))))))

(clojure.core/defn- deser-id-format-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-id-format coll))) input))

(clojure.core/defn- deser-launch-template-tag-specification-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-launch-template-tag-specification coll))) input))

(clojure.core/defn- deser-allowed-principal-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-allowed-principal coll))) input))

(clojure.core/defn- deser-instance-ipv-6-address-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-ipv-6-address coll))) input))

(clojure.core/defn- deser-capacity-reservation-instance-platform [input] (clojure.core/get {"Red Hat Enterprise Linux" :red-hat-enterprise-linux, "Windows with SQL Server Standard" :windowswith-sql-server-standard, "Windows with SQL Server Enterprise" :windowswith-sql-server-enterprise, "Windows with SQL Server Web" :windowswith-sql-server-web, "SUSE Linux" :suse-linux, "Linux with SQL Server Standard" :linuxwith-sql-server-standard, "Windows" :windows, "Linux/UNIX" :linux-unix, "Windows with SQL Server" :windowswith-sql-server, "Linux with SQL Server Enterprise" :linuxwith-sql-server-enterprise, "Linux with SQL Server Web" :linuxwith-sql-server-web} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-prefix-list-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-prefix-list coll))) input))

(clojure.core/defn- deser-endpoint-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-client-vpn-endpoint coll))) input))

(clojure.core/defn- deser-instance-credit-specification [input] (clojure.core/let [letvar623270 {"instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "cpuCredits" (portkey.aws/search-for-tag input "cpuCredits" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar623270 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar623270 ["instanceId" :content]))) (letvar623270 "cpuCredits") (clojure.core/assoc :cpu-credits (deser-string (clojure.core/get-in letvar623270 ["cpuCredits" :content]))))))

(clojure.core/defn- deser-fleet-event-type [input] (clojure.core/get {"instance-change" :instancechange, "fleet-change" :fleetchange, "service-error" :serviceerror} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-fleet-state-code [input] (clojure.core/get {"submitted" :submitted, "active" :active, "deleted" :deleted, "failed" :failed, "deleted-running" :deletedrunning, "deleted-terminating" :deletedterminating, "modifying" :modifying} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-attribute-boolean-value [input] (clojure.core/let [letvar623388 {"value" (portkey.aws/search-for-tag input "value" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar623388 "value") (clojure.core/assoc :value (deser-boolean (clojure.core/get-in letvar623388 ["value" :content]))))))

(clojure.core/defn- deser-spot-instance-request [input] (clojure.core/let [letvar623496 {"instanceInterruptionBehavior" (portkey.aws/search-for-tag input "instanceInterruptionBehavior" :flattened? nil :xmlAttribute? nil), "validFrom" (portkey.aws/search-for-tag input "validFrom" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "spotInstanceRequestId" (portkey.aws/search-for-tag input "spotInstanceRequestId" :flattened? nil :xmlAttribute? nil), "launchGroup" (portkey.aws/search-for-tag input "launchGroup" :flattened? nil :xmlAttribute? nil), "blockDurationMinutes" (portkey.aws/search-for-tag input "blockDurationMinutes" :flattened? nil :xmlAttribute? nil), "createTime" (portkey.aws/search-for-tag input "createTime" :flattened? nil :xmlAttribute? nil), "spotPrice" (portkey.aws/search-for-tag input "spotPrice" :flattened? nil :xmlAttribute? nil), "launchedAvailabilityZone" (portkey.aws/search-for-tag input "launchedAvailabilityZone" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "actualBlockHourlyPrice" (portkey.aws/search-for-tag input "actualBlockHourlyPrice" :flattened? nil :xmlAttribute? nil), "type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "productDescription" (portkey.aws/search-for-tag input "productDescription" :flattened? nil :xmlAttribute? nil), "validUntil" (portkey.aws/search-for-tag input "validUntil" :flattened? nil :xmlAttribute? nil), "availabilityZoneGroup" (portkey.aws/search-for-tag input "availabilityZoneGroup" :flattened? nil :xmlAttribute? nil), "fault" (portkey.aws/search-for-tag input "fault" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "launchSpecification" (portkey.aws/search-for-tag input "launchSpecification" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar623496 "availabilityZoneGroup") (clojure.core/assoc :availability-zone-group (deser-string (clojure.core/get-in letvar623496 ["availabilityZoneGroup" :content]))) (letvar623496 "spotInstanceRequestId") (clojure.core/assoc :spot-instance-request-id (deser-string (clojure.core/get-in letvar623496 ["spotInstanceRequestId" :content]))) (letvar623496 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar623496 ["instanceId" :content]))) (letvar623496 "type") (clojure.core/assoc :type (deser-spot-instance-type (clojure.core/get-in letvar623496 ["type" :content]))) (letvar623496 "actualBlockHourlyPrice") (clojure.core/assoc :actual-block-hourly-price (deser-string (clojure.core/get-in letvar623496 ["actualBlockHourlyPrice" :content]))) (letvar623496 "blockDurationMinutes") (clojure.core/assoc :block-duration-minutes (deser-integer (clojure.core/get-in letvar623496 ["blockDurationMinutes" :content]))) (letvar623496 "validFrom") (clojure.core/assoc :valid-from (deser-date-time (clojure.core/get-in letvar623496 ["validFrom" :content]))) (letvar623496 "launchSpecification") (clojure.core/assoc :launch-specification (deser-launch-specification (clojure.core/get-in letvar623496 ["launchSpecification" :content]))) (letvar623496 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar623496 ["tagSet" :content]))) (letvar623496 "status") (clojure.core/assoc :status (deser-spot-instance-status (clojure.core/get-in letvar623496 ["status" :content]))) (letvar623496 "spotPrice") (clojure.core/assoc :spot-price (deser-string (clojure.core/get-in letvar623496 ["spotPrice" :content]))) (letvar623496 "launchedAvailabilityZone") (clojure.core/assoc :launched-availability-zone (deser-string (clojure.core/get-in letvar623496 ["launchedAvailabilityZone" :content]))) (letvar623496 "instanceInterruptionBehavior") (clojure.core/assoc :instance-interruption-behavior (deser-instance-interruption-behavior (clojure.core/get-in letvar623496 ["instanceInterruptionBehavior" :content]))) (letvar623496 "launchGroup") (clojure.core/assoc :launch-group (deser-string (clojure.core/get-in letvar623496 ["launchGroup" :content]))) (letvar623496 "productDescription") (clojure.core/assoc :product-description (deser-ri-product-description (clojure.core/get-in letvar623496 ["productDescription" :content]))) (letvar623496 "createTime") (clojure.core/assoc :create-time (deser-date-time (clojure.core/get-in letvar623496 ["createTime" :content]))) (letvar623496 "fault") (clojure.core/assoc :fault (deser-spot-instance-state-fault (clojure.core/get-in letvar623496 ["fault" :content]))) (letvar623496 "state") (clojure.core/assoc :state (deser-spot-instance-state (clojure.core/get-in letvar623496 ["state" :content]))) (letvar623496 "validUntil") (clojure.core/assoc :valid-until (deser-date-time (clojure.core/get-in letvar623496 ["validUntil" :content]))))))

(clojure.core/defn- deser-rule-action [input] (clojure.core/get {"allow" :allow, "deny" :deny} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-vpc-attachment-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-attachment coll))) input))

(clojure.core/defn- deser-associated-network-type [input] (clojure.core/get {"vpc" :vpc} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-associated-target-network-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-associated-target-network coll))) input))

(clojure.core/defn- deser-service-configuration-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-service-configuration coll))) input))

(clojure.core/defn- deser-successful-instance-credit-specification-item [input] (clojure.core/let [letvar623665 {"instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar623665 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar623665 ["instanceId" :content]))))))

(clojure.core/defn- deser-vpn-static-route [input] (clojure.core/let [letvar623773 {"destinationCidrBlock" (portkey.aws/search-for-tag input "destinationCidrBlock" :flattened? nil :xmlAttribute? nil), "source" (portkey.aws/search-for-tag input "source" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar623773 "destinationCidrBlock") (clojure.core/assoc :destination-cidr-block (deser-string (clojure.core/get-in letvar623773 ["destinationCidrBlock" :content]))) (letvar623773 "source") (clojure.core/assoc :source (deser-vpn-static-route-source (clojure.core/get-in letvar623773 ["source" :content]))) (letvar623773 "state") (clojure.core/assoc :state (deser-vpn-state (clojure.core/get-in letvar623773 ["state" :content]))))))

(clojure.core/defn- deser-fleet-type [input] (clojure.core/get {"request" :request, "maintain" :maintain, "instant" :instant} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-vpc-endpoint [input] (clojure.core/let [letvar623886 {"groupSet" (portkey.aws/search-for-tag input "groupSet" :flattened? nil :xmlAttribute? nil), "routeTableIdSet" (portkey.aws/search-for-tag input "routeTableIdSet" :flattened? nil :xmlAttribute? nil), "privateDnsEnabled" (portkey.aws/search-for-tag input "privateDnsEnabled" :flattened? nil :xmlAttribute? nil), "vpcEndpointId" (portkey.aws/search-for-tag input "vpcEndpointId" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "dnsEntrySet" (portkey.aws/search-for-tag input "dnsEntrySet" :flattened? nil :xmlAttribute? nil), "networkInterfaceIdSet" (portkey.aws/search-for-tag input "networkInterfaceIdSet" :flattened? nil :xmlAttribute? nil), "serviceName" (portkey.aws/search-for-tag input "serviceName" :flattened? nil :xmlAttribute? nil), "subnetIdSet" (portkey.aws/search-for-tag input "subnetIdSet" :flattened? nil :xmlAttribute? nil), "creationTimestamp" (portkey.aws/search-for-tag input "creationTimestamp" :flattened? nil :xmlAttribute? nil), "policyDocument" (portkey.aws/search-for-tag input "policyDocument" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "vpcEndpointType" (portkey.aws/search-for-tag input "vpcEndpointType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar623886 "vpcEndpointType") (clojure.core/assoc :vpc-endpoint-type (deser-vpc-endpoint-type (clojure.core/get-in letvar623886 ["vpcEndpointType" :content]))) (letvar623886 "subnetIdSet") (clojure.core/assoc :subnet-ids (deser-value-string-list (clojure.core/get-in letvar623886 ["subnetIdSet" :content]))) (letvar623886 "vpcEndpointId") (clojure.core/assoc :vpc-endpoint-id (deser-string (clojure.core/get-in letvar623886 ["vpcEndpointId" :content]))) (letvar623886 "privateDnsEnabled") (clojure.core/assoc :private-dns-enabled (deser-boolean (clojure.core/get-in letvar623886 ["privateDnsEnabled" :content]))) (letvar623886 "policyDocument") (clojure.core/assoc :policy-document (deser-string (clojure.core/get-in letvar623886 ["policyDocument" :content]))) (letvar623886 "creationTimestamp") (clojure.core/assoc :creation-timestamp (deser-date-time (clojure.core/get-in letvar623886 ["creationTimestamp" :content]))) (letvar623886 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar623886 ["vpcId" :content]))) (letvar623886 "networkInterfaceIdSet") (clojure.core/assoc :network-interface-ids (deser-value-string-list (clojure.core/get-in letvar623886 ["networkInterfaceIdSet" :content]))) (letvar623886 "groupSet") (clojure.core/assoc :groups (deser-group-identifier-set (clojure.core/get-in letvar623886 ["groupSet" :content]))) (letvar623886 "state") (clojure.core/assoc :state (deser-state (clojure.core/get-in letvar623886 ["state" :content]))) (letvar623886 "serviceName") (clojure.core/assoc :service-name (deser-string (clojure.core/get-in letvar623886 ["serviceName" :content]))) (letvar623886 "dnsEntrySet") (clojure.core/assoc :dns-entries (deser-dns-entry-set (clojure.core/get-in letvar623886 ["dnsEntrySet" :content]))) (letvar623886 "routeTableIdSet") (clojure.core/assoc :route-table-ids (deser-value-string-list (clojure.core/get-in letvar623886 ["routeTableIdSet" :content]))))))

(clojure.core/defn- deser-key-pair-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-key-pair-info coll))) input))

(clojure.core/defn- deser-purchased-scheduled-instance-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-scheduled-instance coll))) input))

(clojure.core/defn- deser-group-identifier-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-group-identifier coll))) input))

(clojure.core/defn- deser-cancel-spot-fleet-requests-error-item [input] (clojure.core/let [letvar624045 {"error" (portkey.aws/search-for-tag input "error" :flattened? nil :xmlAttribute? nil), "spotFleetRequestId" (portkey.aws/search-for-tag input "spotFleetRequestId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar624045 "error") (clojure.core/assoc :error (deser-cancel-spot-fleet-requests-error (clojure.core/get-in letvar624045 ["error" :content]))) (letvar624045 "spotFleetRequestId") (clojure.core/assoc :spot-fleet-request-id (deser-string (clojure.core/get-in letvar624045 ["spotFleetRequestId" :content]))))))

(clojure.core/defn- deser-payment-option [input] (clojure.core/get {"AllUpfront" :all-upfront, "PartialUpfront" :partial-upfront, "NoUpfront" :no-upfront} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-instance-status-details-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-status-details coll))) input))

(clojure.core/defn- deser-key-pair-info [input] (clojure.core/let [letvar624175 {"keyFingerprint" (portkey.aws/search-for-tag input "keyFingerprint" :flattened? nil :xmlAttribute? nil), "keyName" (portkey.aws/search-for-tag input "keyName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar624175 "keyFingerprint") (clojure.core/assoc :key-fingerprint (deser-string (clojure.core/get-in letvar624175 ["keyFingerprint" :content]))) (letvar624175 "keyName") (clojure.core/assoc :key-name (deser-string (clojure.core/get-in letvar624175 ["keyName" :content]))))))

(clojure.core/defn- deser-association-status [input] (clojure.core/let [letvar624283 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar624283 "code") (clojure.core/assoc :code (deser-association-status-code (clojure.core/get-in letvar624283 ["code" :content]))) (letvar624283 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar624283 ["message" :content]))))))

(clojure.core/defn- deser-instance-network-interface [input] (clojure.core/let [letvar624391 {"groupSet" (portkey.aws/search-for-tag input "groupSet" :flattened? nil :xmlAttribute? nil), "association" (portkey.aws/search-for-tag input "association" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "privateIpAddressesSet" (portkey.aws/search-for-tag input "privateIpAddressesSet" :flattened? nil :xmlAttribute? nil), "privateIpAddress" (portkey.aws/search-for-tag input "privateIpAddress" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "privateDnsName" (portkey.aws/search-for-tag input "privateDnsName" :flattened? nil :xmlAttribute? nil), "macAddress" (portkey.aws/search-for-tag input "macAddress" :flattened? nil :xmlAttribute? nil), "attachment" (portkey.aws/search-for-tag input "attachment" :flattened? nil :xmlAttribute? nil), "sourceDestCheck" (portkey.aws/search-for-tag input "sourceDestCheck" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "ipv6AddressesSet" (portkey.aws/search-for-tag input "ipv6AddressesSet" :flattened? nil :xmlAttribute? nil), "networkInterfaceId" (portkey.aws/search-for-tag input "networkInterfaceId" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar624391 "attachment") (clojure.core/assoc :attachment (deser-instance-network-interface-attachment (clojure.core/get-in letvar624391 ["attachment" :content]))) (letvar624391 "ipv6AddressesSet") (clojure.core/assoc :ipv-6-addresses (deser-instance-ipv-6-address-list (clojure.core/get-in letvar624391 ["ipv6AddressesSet" :content]))) (letvar624391 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar624391 ["subnetId" :content]))) (letvar624391 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar624391 ["ownerId" :content]))) (letvar624391 "macAddress") (clojure.core/assoc :mac-address (deser-string (clojure.core/get-in letvar624391 ["macAddress" :content]))) (letvar624391 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar624391 ["networkInterfaceId" :content]))) (letvar624391 "sourceDestCheck") (clojure.core/assoc :source-dest-check (deser-boolean (clojure.core/get-in letvar624391 ["sourceDestCheck" :content]))) (letvar624391 "status") (clojure.core/assoc :status (deser-network-interface-status (clojure.core/get-in letvar624391 ["status" :content]))) (letvar624391 "privateDnsName") (clojure.core/assoc :private-dns-name (deser-string (clojure.core/get-in letvar624391 ["privateDnsName" :content]))) (letvar624391 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar624391 ["description" :content]))) (letvar624391 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar624391 ["vpcId" :content]))) (letvar624391 "groupSet") (clojure.core/assoc :groups (deser-group-identifier-list (clojure.core/get-in letvar624391 ["groupSet" :content]))) (letvar624391 "privateIpAddressesSet") (clojure.core/assoc :private-ip-addresses (deser-instance-private-ip-address-list (clojure.core/get-in letvar624391 ["privateIpAddressesSet" :content]))) (letvar624391 "association") (clojure.core/assoc :association (deser-instance-network-interface-association (clojure.core/get-in letvar624391 ["association" :content]))) (letvar624391 "privateIpAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar624391 ["privateIpAddress" :content]))))))

(clojure.core/defn- deser-cancel-spot-fleet-requests-error [input] (clojure.core/let [letvar624499 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar624499 "code") (clojure.core/assoc :code (deser-cancel-batch-error-code (clojure.core/get-in letvar624499 ["code" :content]))) (letvar624499 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar624499 ["message" :content]))))))

(clojure.core/defn- deser-vpn-static-route-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpn-static-route coll))) input))

(clojure.core/defn- deser-reservation [input] (clojure.core/let [letvar624624 {"groupSet" (portkey.aws/search-for-tag input "groupSet" :flattened? nil :xmlAttribute? nil), "instancesSet" (portkey.aws/search-for-tag input "instancesSet" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "requesterId" (portkey.aws/search-for-tag input "requesterId" :flattened? nil :xmlAttribute? nil), "reservationId" (portkey.aws/search-for-tag input "reservationId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar624624 "groupSet") (clojure.core/assoc :groups (deser-group-identifier-list (clojure.core/get-in letvar624624 ["groupSet" :content]))) (letvar624624 "instancesSet") (clojure.core/assoc :instances (deser-instance-list (clojure.core/get-in letvar624624 ["instancesSet" :content]))) (letvar624624 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar624624 ["ownerId" :content]))) (letvar624624 "requesterId") (clojure.core/assoc :requester-id (deser-string (clojure.core/get-in letvar624624 ["requesterId" :content]))) (letvar624624 "reservationId") (clojure.core/assoc :reservation-id (deser-string (clojure.core/get-in letvar624624 ["reservationId" :content]))))))

(clojure.core/defn- deser-unsuccessful-item-error [input] (clojure.core/let [letvar624732 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar624732 "code") (clojure.core/assoc :code (deser-string (clojure.core/get-in letvar624732 ["code" :content]))) (letvar624732 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar624732 ["message" :content]))))))

(clojure.core/defn- deser-elastic-gpu-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-elastic-gpu-association coll))) input))

(clojure.core/defn- deser-vpc-peering-connection-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-peering-connection coll))) input))

(clojure.core/defn- deser-unsuccessful-item-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-unsuccessful-item coll))) input))

(clojure.core/defn- deser-security-group-references [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-security-group-reference coll))) input))

(clojure.core/defn- deser-stale-ip-permission [input] (clojure.core/let [letvar624908 {"fromPort" (portkey.aws/search-for-tag input "fromPort" :flattened? nil :xmlAttribute? nil), "ipProtocol" (portkey.aws/search-for-tag input "ipProtocol" :flattened? nil :xmlAttribute? nil), "ipRanges" (portkey.aws/search-for-tag input "ipRanges" :flattened? nil :xmlAttribute? nil), "prefixListIds" (portkey.aws/search-for-tag input "prefixListIds" :flattened? nil :xmlAttribute? nil), "toPort" (portkey.aws/search-for-tag input "toPort" :flattened? nil :xmlAttribute? nil), "groups" (portkey.aws/search-for-tag input "groups" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar624908 "fromPort") (clojure.core/assoc :from-port (deser-integer (clojure.core/get-in letvar624908 ["fromPort" :content]))) (letvar624908 "ipProtocol") (clojure.core/assoc :ip-protocol (deser-string (clojure.core/get-in letvar624908 ["ipProtocol" :content]))) (letvar624908 "ipRanges") (clojure.core/assoc :ip-ranges (deser-ip-ranges (clojure.core/get-in letvar624908 ["ipRanges" :content]))) (letvar624908 "prefixListIds") (clojure.core/assoc :prefix-list-ids (deser-prefix-list-id-set (clojure.core/get-in letvar624908 ["prefixListIds" :content]))) (letvar624908 "toPort") (clojure.core/assoc :to-port (deser-integer (clojure.core/get-in letvar624908 ["toPort" :content]))) (letvar624908 "groups") (clojure.core/assoc :user-id-group-pairs (deser-user-id-group-pair-set (clojure.core/get-in letvar624908 ["groups" :content]))))))

(clojure.core/defn- deser-transit-gateway-association-state [input] (clojure.core/get {"associating" :associating, "associated" :associated, "disassociating" :disassociating, "disassociated" :disassociated} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-traffic-type [input] (clojure.core/get {"ACCEPT" :accept, "REJECT" :reject, "ALL" :all} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-vpc-cidr-block-association-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-cidr-block-association coll))) input))

(clojure.core/defn- deser-availability-zone-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-availability-zone coll))) input))

(clojure.core/defn- deser-launch-template-tag-specification [input] (clojure.core/let [letvar625060 {"resourceType" (portkey.aws/search-for-tag input "resourceType" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar625060 "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (clojure.core/get-in letvar625060 ["resourceType" :content]))) (letvar625060 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar625060 ["tagSet" :content]))))))

(clojure.core/defn- deser-vpc-endpoint-connection [input] (clojure.core/let [letvar625168 {"serviceId" (portkey.aws/search-for-tag input "serviceId" :flattened? nil :xmlAttribute? nil), "vpcEndpointId" (portkey.aws/search-for-tag input "vpcEndpointId" :flattened? nil :xmlAttribute? nil), "vpcEndpointOwner" (portkey.aws/search-for-tag input "vpcEndpointOwner" :flattened? nil :xmlAttribute? nil), "vpcEndpointState" (portkey.aws/search-for-tag input "vpcEndpointState" :flattened? nil :xmlAttribute? nil), "creationTimestamp" (portkey.aws/search-for-tag input "creationTimestamp" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar625168 "serviceId") (clojure.core/assoc :service-id (deser-string (clojure.core/get-in letvar625168 ["serviceId" :content]))) (letvar625168 "vpcEndpointId") (clojure.core/assoc :vpc-endpoint-id (deser-string (clojure.core/get-in letvar625168 ["vpcEndpointId" :content]))) (letvar625168 "vpcEndpointOwner") (clojure.core/assoc :vpc-endpoint-owner (deser-string (clojure.core/get-in letvar625168 ["vpcEndpointOwner" :content]))) (letvar625168 "vpcEndpointState") (clojure.core/assoc :vpc-endpoint-state (deser-state (clojure.core/get-in letvar625168 ["vpcEndpointState" :content]))) (letvar625168 "creationTimestamp") (clojure.core/assoc :creation-timestamp (deser-date-time (clojure.core/get-in letvar625168 ["creationTimestamp" :content]))))))

(clojure.core/defn- deser-launch-template-spot-market-options [input] (clojure.core/let [letvar625276 {"maxPrice" (portkey.aws/search-for-tag input "maxPrice" :flattened? nil :xmlAttribute? nil), "spotInstanceType" (portkey.aws/search-for-tag input "spotInstanceType" :flattened? nil :xmlAttribute? nil), "blockDurationMinutes" (portkey.aws/search-for-tag input "blockDurationMinutes" :flattened? nil :xmlAttribute? nil), "validUntil" (portkey.aws/search-for-tag input "validUntil" :flattened? nil :xmlAttribute? nil), "instanceInterruptionBehavior" (portkey.aws/search-for-tag input "instanceInterruptionBehavior" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar625276 "maxPrice") (clojure.core/assoc :max-price (deser-string (clojure.core/get-in letvar625276 ["maxPrice" :content]))) (letvar625276 "spotInstanceType") (clojure.core/assoc :spot-instance-type (deser-spot-instance-type (clojure.core/get-in letvar625276 ["spotInstanceType" :content]))) (letvar625276 "blockDurationMinutes") (clojure.core/assoc :block-duration-minutes (deser-integer (clojure.core/get-in letvar625276 ["blockDurationMinutes" :content]))) (letvar625276 "validUntil") (clojure.core/assoc :valid-until (deser-date-time (clojure.core/get-in letvar625276 ["validUntil" :content]))) (letvar625276 "instanceInterruptionBehavior") (clojure.core/assoc :instance-interruption-behavior (deser-instance-interruption-behavior (clojure.core/get-in letvar625276 ["instanceInterruptionBehavior" :content]))))))

(clojure.core/defn- deser-availability-zone [input] (clojure.core/let [letvar625384 {"zoneState" (portkey.aws/search-for-tag input "zoneState" :flattened? nil :xmlAttribute? nil), "messageSet" (portkey.aws/search-for-tag input "messageSet" :flattened? nil :xmlAttribute? nil), "regionName" (portkey.aws/search-for-tag input "regionName" :flattened? nil :xmlAttribute? nil), "zoneName" (portkey.aws/search-for-tag input "zoneName" :flattened? nil :xmlAttribute? nil), "zoneId" (portkey.aws/search-for-tag input "zoneId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar625384 "zoneState") (clojure.core/assoc :state (deser-availability-zone-state (clojure.core/get-in letvar625384 ["zoneState" :content]))) (letvar625384 "messageSet") (clojure.core/assoc :messages (deser-availability-zone-message-list (clojure.core/get-in letvar625384 ["messageSet" :content]))) (letvar625384 "regionName") (clojure.core/assoc :region-name (deser-string (clojure.core/get-in letvar625384 ["regionName" :content]))) (letvar625384 "zoneName") (clojure.core/assoc :zone-name (deser-string (clojure.core/get-in letvar625384 ["zoneName" :content]))) (letvar625384 "zoneId") (clojure.core/assoc :zone-id (deser-string (clojure.core/get-in letvar625384 ["zoneId" :content]))))))

(clojure.core/defn- deser-route-origin [input] (clojure.core/get {"CreateRouteTable" :create-route-table, "CreateRoute" :create-route, "EnableVgwRoutePropagation" :enable-vgw-route-propagation} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-fpga-image-attribute [input] (clojure.core/let [letvar625497 {"fpgaImageId" (portkey.aws/search-for-tag input "fpgaImageId" :flattened? nil :xmlAttribute? nil), "name" (portkey.aws/search-for-tag input "name" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "loadPermissions" (portkey.aws/search-for-tag input "loadPermissions" :flattened? nil :xmlAttribute? nil), "productCodes" (portkey.aws/search-for-tag input "productCodes" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar625497 "fpgaImageId") (clojure.core/assoc :fpga-image-id (deser-string (clojure.core/get-in letvar625497 ["fpgaImageId" :content]))) (letvar625497 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar625497 ["name" :content]))) (letvar625497 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar625497 ["description" :content]))) (letvar625497 "loadPermissions") (clojure.core/assoc :load-permissions (deser-load-permission-list (clojure.core/get-in letvar625497 ["loadPermissions" :content]))) (letvar625497 "productCodes") (clojure.core/assoc :product-codes (deser-product-code-list (clojure.core/get-in letvar625497 ["productCodes" :content]))))))

(clojure.core/defn- deser-create-volume-permission-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-create-volume-permission coll))) input))

(clojure.core/defn- deser-target-network [input] (clojure.core/let [letvar625622 {"associationId" (portkey.aws/search-for-tag input "associationId" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "targetNetworkId" (portkey.aws/search-for-tag input "targetNetworkId" :flattened? nil :xmlAttribute? nil), "clientVpnEndpointId" (portkey.aws/search-for-tag input "clientVpnEndpointId" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "securityGroups" (portkey.aws/search-for-tag input "securityGroups" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar625622 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar625622 ["associationId" :content]))) (letvar625622 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar625622 ["vpcId" :content]))) (letvar625622 "targetNetworkId") (clojure.core/assoc :target-network-id (deser-string (clojure.core/get-in letvar625622 ["targetNetworkId" :content]))) (letvar625622 "clientVpnEndpointId") (clojure.core/assoc :client-vpn-endpoint-id (deser-string (clojure.core/get-in letvar625622 ["clientVpnEndpointId" :content]))) (letvar625622 "status") (clojure.core/assoc :status (deser-association-status (clojure.core/get-in letvar625622 ["status" :content]))) (letvar625622 "securityGroups") (clojure.core/assoc :security-groups (deser-value-string-list (clojure.core/get-in letvar625622 ["securityGroups" :content]))))))

(clojure.core/defn- deser-status [input] (clojure.core/get {"MoveInProgress" :move-in-progress, "InVpc" :in-vpc, "InClassic" :in-classic} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-network-interface-type [input] (clojure.core/get {"interface" :interface, "natGateway" :nat-gateway} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-cancelled-spot-instance-request-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cancelled-spot-instance-request coll))) input))

(clojure.core/defn- deser-vpc-ipv-6-cidr-block-association [input] (clojure.core/let [letvar625757 {"associationId" (portkey.aws/search-for-tag input "associationId" :flattened? nil :xmlAttribute? nil), "ipv6CidrBlock" (portkey.aws/search-for-tag input "ipv6CidrBlock" :flattened? nil :xmlAttribute? nil), "ipv6CidrBlockState" (portkey.aws/search-for-tag input "ipv6CidrBlockState" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar625757 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar625757 ["associationId" :content]))) (letvar625757 "ipv6CidrBlock") (clojure.core/assoc :ipv-6-cidr-block (deser-string (clojure.core/get-in letvar625757 ["ipv6CidrBlock" :content]))) (letvar625757 "ipv6CidrBlockState") (clojure.core/assoc :ipv-6-cidr-block-state (deser-vpc-cidr-block-state (clojure.core/get-in letvar625757 ["ipv6CidrBlockState" :content]))))))

(clojure.core/defn- deser-transit-gateway-attachment-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-transit-gateway-attachment coll))) input))

(clojure.core/defn- deser-event-type [input] (clojure.core/get {"instanceChange" :instance-change, "fleetRequestChange" :fleet-request-change, "error" :error} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-moving-address-status [input] (clojure.core/let [letvar625887 {"moveStatus" (portkey.aws/search-for-tag input "moveStatus" :flattened? nil :xmlAttribute? nil), "publicIp" (portkey.aws/search-for-tag input "publicIp" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar625887 "moveStatus") (clojure.core/assoc :move-status (deser-move-status (clojure.core/get-in letvar625887 ["moveStatus" :content]))) (letvar625887 "publicIp") (clojure.core/assoc :public-ip (deser-string (clojure.core/get-in letvar625887 ["publicIp" :content]))))))

(clojure.core/defn- deser-reserved-instances [input] (clojure.core/let [letvar625995 {"tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "instanceCount" (portkey.aws/search-for-tag input "instanceCount" :flattened? nil :xmlAttribute? nil), "instanceTenancy" (portkey.aws/search-for-tag input "instanceTenancy" :flattened? nil :xmlAttribute? nil), "offeringType" (portkey.aws/search-for-tag input "offeringType" :flattened? nil :xmlAttribute? nil), "fixedPrice" (portkey.aws/search-for-tag input "fixedPrice" :flattened? nil :xmlAttribute? nil), "start" (portkey.aws/search-for-tag input "start" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "scope" (portkey.aws/search-for-tag input "scope" :flattened? nil :xmlAttribute? nil), "currencyCode" (portkey.aws/search-for-tag input "currencyCode" :flattened? nil :xmlAttribute? nil), "recurringCharges" (portkey.aws/search-for-tag input "recurringCharges" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "duration" (portkey.aws/search-for-tag input "duration" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "productDescription" (portkey.aws/search-for-tag input "productDescription" :flattened? nil :xmlAttribute? nil), "offeringClass" (portkey.aws/search-for-tag input "offeringClass" :flattened? nil :xmlAttribute? nil), "reservedInstancesId" (portkey.aws/search-for-tag input "reservedInstancesId" :flattened? nil :xmlAttribute? nil), "usagePrice" (portkey.aws/search-for-tag input "usagePrice" :flattened? nil :xmlAttribute? nil), "end" (portkey.aws/search-for-tag input "end" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar625995 "currencyCode") (clojure.core/assoc :currency-code (deser-currency-code-values (clojure.core/get-in letvar625995 ["currencyCode" :content]))) (letvar625995 "instanceCount") (clojure.core/assoc :instance-count (deser-integer (clojure.core/get-in letvar625995 ["instanceCount" :content]))) (letvar625995 "start") (clojure.core/assoc :start (deser-date-time (clojure.core/get-in letvar625995 ["start" :content]))) (letvar625995 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar625995 ["instanceType" :content]))) (letvar625995 "fixedPrice") (clojure.core/assoc :fixed-price (deser-float (clojure.core/get-in letvar625995 ["fixedPrice" :content]))) (letvar625995 "end") (clojure.core/assoc :end (deser-date-time (clojure.core/get-in letvar625995 ["end" :content]))) (letvar625995 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar625995 ["tagSet" :content]))) (letvar625995 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar625995 ["availabilityZone" :content]))) (letvar625995 "instanceTenancy") (clojure.core/assoc :instance-tenancy (deser-tenancy (clojure.core/get-in letvar625995 ["instanceTenancy" :content]))) (letvar625995 "duration") (clojure.core/assoc :duration (deser-long (clojure.core/get-in letvar625995 ["duration" :content]))) (letvar625995 "usagePrice") (clojure.core/assoc :usage-price (deser-float (clojure.core/get-in letvar625995 ["usagePrice" :content]))) (letvar625995 "productDescription") (clojure.core/assoc :product-description (deser-ri-product-description (clojure.core/get-in letvar625995 ["productDescription" :content]))) (letvar625995 "reservedInstancesId") (clojure.core/assoc :reserved-instances-id (deser-string (clojure.core/get-in letvar625995 ["reservedInstancesId" :content]))) (letvar625995 "state") (clojure.core/assoc :state (deser-reserved-instance-state (clojure.core/get-in letvar625995 ["state" :content]))) (letvar625995 "offeringClass") (clojure.core/assoc :offering-class (deser-offering-class-type (clojure.core/get-in letvar625995 ["offeringClass" :content]))) (letvar625995 "recurringCharges") (clojure.core/assoc :recurring-charges (deser-recurring-charges-list (clojure.core/get-in letvar625995 ["recurringCharges" :content]))) (letvar625995 "offeringType") (clojure.core/assoc :offering-type (deser-offering-type-values (clojure.core/get-in letvar625995 ["offeringType" :content]))) (letvar625995 "scope") (clojure.core/assoc :scope (deserscope (clojure.core/get-in letvar625995 ["scope" :content]))))))

(clojure.core/defn- deser-transit-gateway-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-transit-gateway coll))) input))

(clojure.core/defn- deser-network-interface-permission-state [input] (clojure.core/let [letvar626120 {"state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar626120 "state") (clojure.core/assoc :state (deser-network-interface-permission-state-code (clojure.core/get-in letvar626120 ["state" :content]))) (letvar626120 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar626120 ["statusMessage" :content]))))))

(clojure.core/defn- deser-next-token [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-elastic-gpu-association [input] (clojure.core/let [letvar626233 {"elasticGpuId" (portkey.aws/search-for-tag input "elasticGpuId" :flattened? nil :xmlAttribute? nil), "elasticGpuAssociationId" (portkey.aws/search-for-tag input "elasticGpuAssociationId" :flattened? nil :xmlAttribute? nil), "elasticGpuAssociationState" (portkey.aws/search-for-tag input "elasticGpuAssociationState" :flattened? nil :xmlAttribute? nil), "elasticGpuAssociationTime" (portkey.aws/search-for-tag input "elasticGpuAssociationTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar626233 "elasticGpuId") (clojure.core/assoc :elastic-gpu-id (deser-string (clojure.core/get-in letvar626233 ["elasticGpuId" :content]))) (letvar626233 "elasticGpuAssociationId") (clojure.core/assoc :elastic-gpu-association-id (deser-string (clojure.core/get-in letvar626233 ["elasticGpuAssociationId" :content]))) (letvar626233 "elasticGpuAssociationState") (clojure.core/assoc :elastic-gpu-association-state (deser-string (clojure.core/get-in letvar626233 ["elasticGpuAssociationState" :content]))) (letvar626233 "elasticGpuAssociationTime") (clojure.core/assoc :elastic-gpu-association-time (deser-string (clojure.core/get-in letvar626233 ["elasticGpuAssociationTime" :content]))))))

(clojure.core/defn- deser-egress-only-internet-gateway-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-egress-only-internet-gateway coll))) input))

(clojure.core/defn- deser-excess-capacity-termination-policy [input] (clojure.core/get {"noTermination" :no-termination, "default" :default} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-prefix-list [input] (clojure.core/let [letvar626363 {"cidrSet" (portkey.aws/search-for-tag input "cidrSet" :flattened? nil :xmlAttribute? nil), "prefixListId" (portkey.aws/search-for-tag input "prefixListId" :flattened? nil :xmlAttribute? nil), "prefixListName" (portkey.aws/search-for-tag input "prefixListName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar626363 "cidrSet") (clojure.core/assoc :cidrs (deser-value-string-list (clojure.core/get-in letvar626363 ["cidrSet" :content]))) (letvar626363 "prefixListId") (clojure.core/assoc :prefix-list-id (deser-string (clojure.core/get-in letvar626363 ["prefixListId" :content]))) (letvar626363 "prefixListName") (clojure.core/assoc :prefix-list-name (deser-string (clojure.core/get-in letvar626363 ["prefixListName" :content]))))))

(clojure.core/defn- deser-import-instance-volume-detail-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-import-instance-volume-detail-item coll))) input))

(clojure.core/defn- deser-status-type [input] (clojure.core/get {"passed" :passed, "failed" :failed, "insufficient-data" :insufficientdata, "initializing" :initializing} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-spot-fleet-monitoring [input] (clojure.core/let [letvar626493 {"enabled" (portkey.aws/search-for-tag input "enabled" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar626493 "enabled") (clojure.core/assoc :enabled (deser-boolean (clojure.core/get-in letvar626493 ["enabled" :content]))))))

(clojure.core/defn- deser-reserved-instances-listing [input] (clojure.core/let [letvar626601 {"updateDate" (portkey.aws/search-for-tag input "updateDate" :flattened? nil :xmlAttribute? nil), "createDate" (portkey.aws/search-for-tag input "createDate" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "clientToken" (portkey.aws/search-for-tag input "clientToken" :flattened? nil :xmlAttribute? nil), "reservedInstancesListingId" (portkey.aws/search-for-tag input "reservedInstancesListingId" :flattened? nil :xmlAttribute? nil), "instanceCounts" (portkey.aws/search-for-tag input "instanceCounts" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil), "priceSchedules" (portkey.aws/search-for-tag input "priceSchedules" :flattened? nil :xmlAttribute? nil), "reservedInstancesId" (portkey.aws/search-for-tag input "reservedInstancesId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar626601 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar626601 ["statusMessage" :content]))) (letvar626601 "createDate") (clojure.core/assoc :create-date (deser-date-time (clojure.core/get-in letvar626601 ["createDate" :content]))) (letvar626601 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar626601 ["tagSet" :content]))) (letvar626601 "status") (clojure.core/assoc :status (deser-listing-status (clojure.core/get-in letvar626601 ["status" :content]))) (letvar626601 "priceSchedules") (clojure.core/assoc :price-schedules (deser-price-schedule-list (clojure.core/get-in letvar626601 ["priceSchedules" :content]))) (letvar626601 "updateDate") (clojure.core/assoc :update-date (deser-date-time (clojure.core/get-in letvar626601 ["updateDate" :content]))) (letvar626601 "reservedInstancesId") (clojure.core/assoc :reserved-instances-id (deser-string (clojure.core/get-in letvar626601 ["reservedInstancesId" :content]))) (letvar626601 "reservedInstancesListingId") (clojure.core/assoc :reserved-instances-listing-id (deser-string (clojure.core/get-in letvar626601 ["reservedInstancesListingId" :content]))) (letvar626601 "instanceCounts") (clojure.core/assoc :instance-counts (deser-instance-count-list (clojure.core/get-in letvar626601 ["instanceCounts" :content]))) (letvar626601 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar626601 ["clientToken" :content]))))))

(clojure.core/defn- deser-vpc-cidr-block-state [input] (clojure.core/let [letvar626709 {"state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar626709 "state") (clojure.core/assoc :state (deser-vpc-cidr-block-state-code (clojure.core/get-in letvar626709 ["state" :content]))) (letvar626709 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar626709 ["statusMessage" :content]))))))

(clojure.core/defn- deser-instance-status-summary [input] (clojure.core/let [letvar626817 {"details" (portkey.aws/search-for-tag input "details" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar626817 "details") (clojure.core/assoc :details (deser-instance-status-details-list (clojure.core/get-in letvar626817 ["details" :content]))) (letvar626817 "status") (clojure.core/assoc :status (deser-summary-status (clojure.core/get-in letvar626817 ["status" :content]))))))

(clojure.core/defn- deser-transit-gateway-attachment-state [input] (clojure.core/get {"rejecting" :rejecting, "deleting" :deleting, "failed" :failed, "pendingAcceptance" :pending-acceptance, "rollingBack" :rolling-back, "failing" :failing, "deleted" :deleted, "modifying" :modifying, "rejected" :rejected, "pending" :pending, "available" :available} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-nat-gateway-address [input] (clojure.core/let [letvar626930 {"allocationId" (portkey.aws/search-for-tag input "allocationId" :flattened? nil :xmlAttribute? nil), "networkInterfaceId" (portkey.aws/search-for-tag input "networkInterfaceId" :flattened? nil :xmlAttribute? nil), "privateIp" (portkey.aws/search-for-tag input "privateIp" :flattened? nil :xmlAttribute? nil), "publicIp" (portkey.aws/search-for-tag input "publicIp" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar626930 "allocationId") (clojure.core/assoc :allocation-id (deser-string (clojure.core/get-in letvar626930 ["allocationId" :content]))) (letvar626930 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar626930 ["networkInterfaceId" :content]))) (letvar626930 "privateIp") (clojure.core/assoc :private-ip (deser-string (clojure.core/get-in letvar626930 ["privateIp" :content]))) (letvar626930 "publicIp") (clojure.core/assoc :public-ip (deser-string (clojure.core/get-in letvar626930 ["publicIp" :content]))))))

(clojure.core/defn- deser-instance-status-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-status coll))) input))

(clojure.core/defn- deser-placement-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-placement-group coll))) input))

(clojure.core/defn- deser-address-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-address coll))) input))

(clojure.core/defn- deser-reserved-instances-offering-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-instances-offering coll))) input))

(clojure.core/defn- deser-cidr-block [input] (clojure.core/let [letvar627106 {"cidrBlock" (portkey.aws/search-for-tag input "cidrBlock" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar627106 "cidrBlock") (clojure.core/assoc :cidr-block (deser-string (clojure.core/get-in letvar627106 ["cidrBlock" :content]))))))

(clojure.core/defn- deser-client-vpn-route [input] (clojure.core/let [letvar627214 {"clientVpnEndpointId" (portkey.aws/search-for-tag input "clientVpnEndpointId" :flattened? nil :xmlAttribute? nil), "destinationCidr" (portkey.aws/search-for-tag input "destinationCidr" :flattened? nil :xmlAttribute? nil), "targetSubnet" (portkey.aws/search-for-tag input "targetSubnet" :flattened? nil :xmlAttribute? nil), "type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil), "origin" (portkey.aws/search-for-tag input "origin" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar627214 "clientVpnEndpointId") (clojure.core/assoc :client-vpn-endpoint-id (deser-string (clojure.core/get-in letvar627214 ["clientVpnEndpointId" :content]))) (letvar627214 "destinationCidr") (clojure.core/assoc :destination-cidr (deser-string (clojure.core/get-in letvar627214 ["destinationCidr" :content]))) (letvar627214 "targetSubnet") (clojure.core/assoc :target-subnet (deser-string (clojure.core/get-in letvar627214 ["targetSubnet" :content]))) (letvar627214 "type") (clojure.core/assoc :type (deser-string (clojure.core/get-in letvar627214 ["type" :content]))) (letvar627214 "origin") (clojure.core/assoc :origin (deser-string (clojure.core/get-in letvar627214 ["origin" :content]))) (letvar627214 "status") (clojure.core/assoc :status (deser-client-vpn-route-status (clojure.core/get-in letvar627214 ["status" :content]))) (letvar627214 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar627214 ["description" :content]))))))

(clojure.core/defn- deser-reserved-instances-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-instances coll))) input))

(clojure.core/defn- deser-image-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-image coll))) input))

(clojure.core/defn- deser-launch-template-capacity-reservation-specification-response [input] (clojure.core/let [letvar627356 {"capacityReservationPreference" (portkey.aws/search-for-tag input "capacityReservationPreference" :flattened? nil :xmlAttribute? nil), "capacityReservationTarget" (portkey.aws/search-for-tag input "capacityReservationTarget" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar627356 "capacityReservationPreference") (clojure.core/assoc :capacity-reservation-preference (deser-capacity-reservation-preference (clojure.core/get-in letvar627356 ["capacityReservationPreference" :content]))) (letvar627356 "capacityReservationTarget") (clojure.core/assoc :capacity-reservation-target (deser-capacity-reservation-target-response (clojure.core/get-in letvar627356 ["capacityReservationTarget" :content]))))))

(clojure.core/defn- deser-user-id-group-pair-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-user-id-group-pair coll))) input))

(clojure.core/defn- deser-s-3-storage [input] (clojure.core/let [letvar627481 {"AWSAccessKeyId" (portkey.aws/search-for-tag input "AWSAccessKeyId" :flattened? nil :xmlAttribute? nil), "bucket" (portkey.aws/search-for-tag input "bucket" :flattened? nil :xmlAttribute? nil), "prefix" (portkey.aws/search-for-tag input "prefix" :flattened? nil :xmlAttribute? nil), "uploadPolicy" (portkey.aws/search-for-tag input "uploadPolicy" :flattened? nil :xmlAttribute? nil), "uploadPolicySignature" (portkey.aws/search-for-tag input "uploadPolicySignature" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar627481 "AWSAccessKeyId") (clojure.core/assoc :aws-access-key-id (deser-string (clojure.core/get-in letvar627481 ["AWSAccessKeyId" :content]))) (letvar627481 "bucket") (clojure.core/assoc :bucket (deser-string (clojure.core/get-in letvar627481 ["bucket" :content]))) (letvar627481 "prefix") (clojure.core/assoc :prefix (deser-string (clojure.core/get-in letvar627481 ["prefix" :content]))) (letvar627481 "uploadPolicy") (clojure.core/assoc :upload-policy (deser-blob (clojure.core/get-in letvar627481 ["uploadPolicy" :content]))) (letvar627481 "uploadPolicySignature") (clojure.core/assoc :upload-policy-signature (deser-string (clojure.core/get-in letvar627481 ["uploadPolicySignature" :content]))))))

(clojure.core/defn- deser-recurring-charge [input] (clojure.core/let [letvar627589 {"amount" (portkey.aws/search-for-tag input "amount" :flattened? nil :xmlAttribute? nil), "frequency" (portkey.aws/search-for-tag input "frequency" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar627589 "amount") (clojure.core/assoc :amount (deser-double (clojure.core/get-in letvar627589 ["amount" :content]))) (letvar627589 "frequency") (clojure.core/assoc :frequency (deser-recurring-charge-frequency (clojure.core/get-in letvar627589 ["frequency" :content]))))))

(clojure.core/defn- deser-spot-fleet-request-config-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-spot-fleet-request-config coll))) input))

(clojure.core/defn- deser-byoip-cidr [input] (clojure.core/let [letvar627714 {"cidr" (portkey.aws/search-for-tag input "cidr" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar627714 "cidr") (clojure.core/assoc :cidr (deser-string (clojure.core/get-in letvar627714 ["cidr" :content]))) (letvar627714 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar627714 ["description" :content]))) (letvar627714 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar627714 ["statusMessage" :content]))) (letvar627714 "state") (clojure.core/assoc :state (deser-byoip-cidr-state (clojure.core/get-in letvar627714 ["state" :content]))))))

(clojure.core/defn- deser-launch-permission-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-launch-permission coll))) input))

(clojure.core/defn- deser-price-schedule-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-price-schedule coll))) input))

(clojure.core/defn- deser-instance-private-ip-address-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-private-ip-address coll))) input))

(clojure.core/defn- deser-instance-ipv-6-address [input] (clojure.core/let [letvar627873 {"ipv6Address" (portkey.aws/search-for-tag input "ipv6Address" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar627873 "ipv6Address") (clojure.core/assoc :ipv-6-address (deser-string (clojure.core/get-in letvar627873 ["ipv6Address" :content]))))))

(clojure.core/defn- deser-group-identifier [input] (clojure.core/let [letvar627981 {"groupName" (portkey.aws/search-for-tag input "groupName" :flattened? nil :xmlAttribute? nil), "groupId" (portkey.aws/search-for-tag input "groupId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar627981 "groupName") (clojure.core/assoc :group-name (deser-string (clojure.core/get-in letvar627981 ["groupName" :content]))) (letvar627981 "groupId") (clojure.core/assoc :group-id (deser-string (clojure.core/get-in letvar627981 ["groupId" :content]))))))

(clojure.core/defn- deser-fpga-image-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-fpga-image coll))) input))

(clojure.core/defn- deser-spot-price [input] (clojure.core/let [letvar628106 {"availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "productDescription" (portkey.aws/search-for-tag input "productDescription" :flattened? nil :xmlAttribute? nil), "spotPrice" (portkey.aws/search-for-tag input "spotPrice" :flattened? nil :xmlAttribute? nil), "timestamp" (portkey.aws/search-for-tag input "timestamp" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar628106 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar628106 ["availabilityZone" :content]))) (letvar628106 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar628106 ["instanceType" :content]))) (letvar628106 "productDescription") (clojure.core/assoc :product-description (deser-ri-product-description (clojure.core/get-in letvar628106 ["productDescription" :content]))) (letvar628106 "spotPrice") (clojure.core/assoc :spot-price (deser-string (clojure.core/get-in letvar628106 ["spotPrice" :content]))) (letvar628106 "timestamp") (clojure.core/assoc :timestamp (deser-date-time (clojure.core/get-in letvar628106 ["timestamp" :content]))))))

(clojure.core/defn- deser-client-vpn-connection-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-client-vpn-connection coll))) input))

(clojure.core/defn- deser-instance-id-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-scheduled-instance-availability-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-scheduled-instance-availability coll))) input))

(clojure.core/defn- deser-nat-gateway [input] (clojure.core/let [letvar628265 {"subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "failureMessage" (portkey.aws/search-for-tag input "failureMessage" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "deleteTime" (portkey.aws/search-for-tag input "deleteTime" :flattened? nil :xmlAttribute? nil), "createTime" (portkey.aws/search-for-tag input "createTime" :flattened? nil :xmlAttribute? nil), "natGatewayId" (portkey.aws/search-for-tag input "natGatewayId" :flattened? nil :xmlAttribute? nil), "failureCode" (portkey.aws/search-for-tag input "failureCode" :flattened? nil :xmlAttribute? nil), "natGatewayAddressSet" (portkey.aws/search-for-tag input "natGatewayAddressSet" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "provisionedBandwidth" (portkey.aws/search-for-tag input "provisionedBandwidth" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar628265 "deleteTime") (clojure.core/assoc :delete-time (deser-date-time (clojure.core/get-in letvar628265 ["deleteTime" :content]))) (letvar628265 "provisionedBandwidth") (clojure.core/assoc :provisioned-bandwidth (deser-provisioned-bandwidth (clojure.core/get-in letvar628265 ["provisionedBandwidth" :content]))) (letvar628265 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar628265 ["subnetId" :content]))) (letvar628265 "natGatewayId") (clojure.core/assoc :nat-gateway-id (deser-string (clojure.core/get-in letvar628265 ["natGatewayId" :content]))) (letvar628265 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar628265 ["tagSet" :content]))) (letvar628265 "failureMessage") (clojure.core/assoc :failure-message (deser-string (clojure.core/get-in letvar628265 ["failureMessage" :content]))) (letvar628265 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar628265 ["vpcId" :content]))) (letvar628265 "natGatewayAddressSet") (clojure.core/assoc :nat-gateway-addresses (deser-nat-gateway-address-list (clojure.core/get-in letvar628265 ["natGatewayAddressSet" :content]))) (letvar628265 "createTime") (clojure.core/assoc :create-time (deser-date-time (clojure.core/get-in letvar628265 ["createTime" :content]))) (letvar628265 "state") (clojure.core/assoc :state (deser-nat-gateway-state (clojure.core/get-in letvar628265 ["state" :content]))) (letvar628265 "failureCode") (clojure.core/assoc :failure-code (deser-string (clojure.core/get-in letvar628265 ["failureCode" :content]))))))

(clojure.core/defn- deser-elastic-gpu-status [input] (clojure.core/get {"OK" :ok, "IMPAIRED" :impaired} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-launch-template-iam-instance-profile-specification [input] (clojure.core/let [letvar628378 {"arn" (portkey.aws/search-for-tag input "arn" :flattened? nil :xmlAttribute? nil), "name" (portkey.aws/search-for-tag input "name" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar628378 "arn") (clojure.core/assoc :arn (deser-string (clojure.core/get-in letvar628378 ["arn" :content]))) (letvar628378 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar628378 ["name" :content]))))))

(clojure.core/defn- deser-spot-instance-status [input] (clojure.core/let [letvar628486 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil), "updateTime" (portkey.aws/search-for-tag input "updateTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar628486 "code") (clojure.core/assoc :code (deser-string (clojure.core/get-in letvar628486 ["code" :content]))) (letvar628486 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar628486 ["message" :content]))) (letvar628486 "updateTime") (clojure.core/assoc :update-time (deser-date-time (clojure.core/get-in letvar628486 ["updateTime" :content]))))))

(clojure.core/defn- deser-delete-launch-template-versions-response-success-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-delete-launch-template-versions-response-success-item coll))) input))

(clojure.core/defn- deser-tag-description [input] (clojure.core/let [letvar628611 {"key" (portkey.aws/search-for-tag input "key" :flattened? nil :xmlAttribute? nil), "resourceId" (portkey.aws/search-for-tag input "resourceId" :flattened? nil :xmlAttribute? nil), "resourceType" (portkey.aws/search-for-tag input "resourceType" :flattened? nil :xmlAttribute? nil), "value" (portkey.aws/search-for-tag input "value" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar628611 "key") (clojure.core/assoc :key (deser-string (clojure.core/get-in letvar628611 ["key" :content]))) (letvar628611 "resourceId") (clojure.core/assoc :resource-id (deser-string (clojure.core/get-in letvar628611 ["resourceId" :content]))) (letvar628611 "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (clojure.core/get-in letvar628611 ["resourceType" :content]))) (letvar628611 "value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar628611 ["value" :content]))))))

(clojure.core/defn- deser-transit-gateway-attachment-resource-type [input] (clojure.core/get {"vpc" :vpc, "vpn" :vpn} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-account-attribute-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-account-attribute-value coll))) input))

(clojure.core/defn- deser-import-snapshot-task-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-import-snapshot-task coll))) input))

(clojure.core/defn- deser-launch-template-license-configuration [input] (clojure.core/let [letvar628758 {"licenseConfigurationArn" (portkey.aws/search-for-tag input "licenseConfigurationArn" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar628758 "licenseConfigurationArn") (clojure.core/assoc :license-configuration-arn (deser-string (clojure.core/get-in letvar628758 ["licenseConfigurationArn" :content]))))))

(clojure.core/defn- deser-dhcp-options [input] (clojure.core/let [letvar628866 {"dhcpConfigurationSet" (portkey.aws/search-for-tag input "dhcpConfigurationSet" :flattened? nil :xmlAttribute? nil), "dhcpOptionsId" (portkey.aws/search-for-tag input "dhcpOptionsId" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar628866 "dhcpConfigurationSet") (clojure.core/assoc :dhcp-configurations (deser-dhcp-configuration-list (clojure.core/get-in letvar628866 ["dhcpConfigurationSet" :content]))) (letvar628866 "dhcpOptionsId") (clojure.core/assoc :dhcp-options-id (deser-string (clojure.core/get-in letvar628866 ["dhcpOptionsId" :content]))) (letvar628866 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar628866 ["ownerId" :content]))) (letvar628866 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar628866 ["tagSet" :content]))))))

(clojure.core/defn- deser-spot-instance-interruption-behavior [input] (clojure.core/get {"hibernate" :hibernate, "stop" :stop, "terminate" :terminate} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-run-instances-monitoring-enabled [input] (clojure.core/let [letvar628979 {"enabled" (portkey.aws/search-for-tag input "enabled" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {:enabled (deser-boolean (clojure.core/get-in letvar628979 ["enabled" :content]))})))

(clojure.core/defn- deser-authorization-rule-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-authorization-rule coll))) input))

(clojure.core/defn- deser-user-id-group-pair-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-user-id-group-pair coll))) input))

(clojure.core/defn- deser-tag-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tag coll))) input))

(clojure.core/defn- deser-network-acl-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-network-acl-association coll))) input))

(clojure.core/defn- deser-client-vpn-authorization-rule-status-code [input] (clojure.core/get {"authorizing" :authorizing, "active" :active, "failed" :failed, "revoking" :revoking} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-product-code-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-product-code coll))) input))

(clojure.core/defn- deser-volume-status-info-status [input] (clojure.core/get {"ok" :ok, "impaired" :impaired, "insufficient-data" :insufficientdata} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-spot-fleet-request-config-data [input] (clojure.core/let [letvar629182 {"replaceUnhealthyInstances" (portkey.aws/search-for-tag input "replaceUnhealthyInstances" :flattened? nil :xmlAttribute? nil), "instanceInterruptionBehavior" (portkey.aws/search-for-tag input "instanceInterruptionBehavior" :flattened? nil :xmlAttribute? nil), "onDemandTargetCapacity" (portkey.aws/search-for-tag input "onDemandTargetCapacity" :flattened? nil :xmlAttribute? nil), "validFrom" (portkey.aws/search-for-tag input "validFrom" :flattened? nil :xmlAttribute? nil), "targetCapacity" (portkey.aws/search-for-tag input "targetCapacity" :flattened? nil :xmlAttribute? nil), "clientToken" (portkey.aws/search-for-tag input "clientToken" :flattened? nil :xmlAttribute? nil), "loadBalancersConfig" (portkey.aws/search-for-tag input "loadBalancersConfig" :flattened? nil :xmlAttribute? nil), "launchTemplateConfigs" (portkey.aws/search-for-tag input "launchTemplateConfigs" :flattened? nil :xmlAttribute? nil), "iamFleetRole" (portkey.aws/search-for-tag input "iamFleetRole" :flattened? nil :xmlAttribute? nil), "fulfilledCapacity" (portkey.aws/search-for-tag input "fulfilledCapacity" :flattened? nil :xmlAttribute? nil), "onDemandAllocationStrategy" (portkey.aws/search-for-tag input "onDemandAllocationStrategy" :flattened? nil :xmlAttribute? nil), "allocationStrategy" (portkey.aws/search-for-tag input "allocationStrategy" :flattened? nil :xmlAttribute? nil), "instancePoolsToUseCount" (portkey.aws/search-for-tag input "instancePoolsToUseCount" :flattened? nil :xmlAttribute? nil), "excessCapacityTerminationPolicy" (portkey.aws/search-for-tag input "excessCapacityTerminationPolicy" :flattened? nil :xmlAttribute? nil), "launchSpecifications" (portkey.aws/search-for-tag input "launchSpecifications" :flattened? nil :xmlAttribute? nil), "spotPrice" (portkey.aws/search-for-tag input "spotPrice" :flattened? nil :xmlAttribute? nil), "onDemandFulfilledCapacity" (portkey.aws/search-for-tag input "onDemandFulfilledCapacity" :flattened? nil :xmlAttribute? nil), "terminateInstancesWithExpiration" (portkey.aws/search-for-tag input "terminateInstancesWithExpiration" :flattened? nil :xmlAttribute? nil), "type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil), "validUntil" (portkey.aws/search-for-tag input "validUntil" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {:iam-fleet-role (deser-string (clojure.core/get-in letvar629182 ["iamFleetRole" :content])), :target-capacity (deser-integer (clojure.core/get-in letvar629182 ["targetCapacity" :content]))} (letvar629182 "onDemandAllocationStrategy") (clojure.core/assoc :on-demand-allocation-strategy (deser-on-demand-allocation-strategy (clojure.core/get-in letvar629182 ["onDemandAllocationStrategy" :content]))) (letvar629182 "type") (clojure.core/assoc :type (deser-fleet-type (clojure.core/get-in letvar629182 ["type" :content]))) (letvar629182 "validFrom") (clojure.core/assoc :valid-from (deser-date-time (clojure.core/get-in letvar629182 ["validFrom" :content]))) (letvar629182 "instancePoolsToUseCount") (clojure.core/assoc :instance-pools-to-use-count (deser-integer (clojure.core/get-in letvar629182 ["instancePoolsToUseCount" :content]))) (letvar629182 "excessCapacityTerminationPolicy") (clojure.core/assoc :excess-capacity-termination-policy (deser-excess-capacity-termination-policy (clojure.core/get-in letvar629182 ["excessCapacityTerminationPolicy" :content]))) (letvar629182 "spotPrice") (clojure.core/assoc :spot-price (deser-string (clojure.core/get-in letvar629182 ["spotPrice" :content]))) (letvar629182 "allocationStrategy") (clojure.core/assoc :allocation-strategy (deser-allocation-strategy (clojure.core/get-in letvar629182 ["allocationStrategy" :content]))) (letvar629182 "instanceInterruptionBehavior") (clojure.core/assoc :instance-interruption-behavior (deser-instance-interruption-behavior (clojure.core/get-in letvar629182 ["instanceInterruptionBehavior" :content]))) (letvar629182 "launchTemplateConfigs") (clojure.core/assoc :launch-template-configs (deser-launch-template-config-list (clojure.core/get-in letvar629182 ["launchTemplateConfigs" :content]))) (letvar629182 "loadBalancersConfig") (clojure.core/assoc :load-balancers-config (deser-load-balancers-config (clojure.core/get-in letvar629182 ["loadBalancersConfig" :content]))) (letvar629182 "fulfilledCapacity") (clojure.core/assoc :fulfilled-capacity (deser-double (clojure.core/get-in letvar629182 ["fulfilledCapacity" :content]))) (letvar629182 "terminateInstancesWithExpiration") (clojure.core/assoc :terminate-instances-with-expiration (deser-boolean (clojure.core/get-in letvar629182 ["terminateInstancesWithExpiration" :content]))) (letvar629182 "onDemandFulfilledCapacity") (clojure.core/assoc :on-demand-fulfilled-capacity (deser-double (clojure.core/get-in letvar629182 ["onDemandFulfilledCapacity" :content]))) (letvar629182 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar629182 ["clientToken" :content]))) (letvar629182 "launchSpecifications") (clojure.core/assoc :launch-specifications (deser-launch-specs-list (clojure.core/get-in letvar629182 ["launchSpecifications" :content]))) (letvar629182 "replaceUnhealthyInstances") (clojure.core/assoc :replace-unhealthy-instances (deser-boolean (clojure.core/get-in letvar629182 ["replaceUnhealthyInstances" :content]))) (letvar629182 "onDemandTargetCapacity") (clojure.core/assoc :on-demand-target-capacity (deser-integer (clojure.core/get-in letvar629182 ["onDemandTargetCapacity" :content]))) (letvar629182 "validUntil") (clojure.core/assoc :valid-until (deser-date-time (clojure.core/get-in letvar629182 ["validUntil" :content]))))))

(clojure.core/defn- deser-authorization-rule [input] (clojure.core/let [letvar629290 {"clientVpnEndpointId" (portkey.aws/search-for-tag input "clientVpnEndpointId" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "groupId" (portkey.aws/search-for-tag input "groupId" :flattened? nil :xmlAttribute? nil), "accessAll" (portkey.aws/search-for-tag input "accessAll" :flattened? nil :xmlAttribute? nil), "destinationCidr" (portkey.aws/search-for-tag input "destinationCidr" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar629290 "clientVpnEndpointId") (clojure.core/assoc :client-vpn-endpoint-id (deser-string (clojure.core/get-in letvar629290 ["clientVpnEndpointId" :content]))) (letvar629290 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar629290 ["description" :content]))) (letvar629290 "groupId") (clojure.core/assoc :group-id (deser-string (clojure.core/get-in letvar629290 ["groupId" :content]))) (letvar629290 "accessAll") (clojure.core/assoc :access-all (deser-boolean (clojure.core/get-in letvar629290 ["accessAll" :content]))) (letvar629290 "destinationCidr") (clojure.core/assoc :destination-cidr (deser-string (clojure.core/get-in letvar629290 ["destinationCidr" :content]))) (letvar629290 "status") (clojure.core/assoc :status (deser-client-vpn-authorization-rule-status (clojure.core/get-in letvar629290 ["status" :content]))))))

(clojure.core/defn- deser-launch-template-overrides [input] (clojure.core/let [letvar629398 {"instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "spotPrice" (portkey.aws/search-for-tag input "spotPrice" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "weightedCapacity" (portkey.aws/search-for-tag input "weightedCapacity" :flattened? nil :xmlAttribute? nil), "priority" (portkey.aws/search-for-tag input "priority" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar629398 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar629398 ["instanceType" :content]))) (letvar629398 "spotPrice") (clojure.core/assoc :spot-price (deser-string (clojure.core/get-in letvar629398 ["spotPrice" :content]))) (letvar629398 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar629398 ["subnetId" :content]))) (letvar629398 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar629398 ["availabilityZone" :content]))) (letvar629398 "weightedCapacity") (clojure.core/assoc :weighted-capacity (deser-double (clojure.core/get-in letvar629398 ["weightedCapacity" :content]))) (letvar629398 "priority") (clojure.core/assoc :priority (deser-double (clojure.core/get-in letvar629398 ["priority" :content]))))))

(clojure.core/defn- deser-host-offering [input] (clojure.core/let [letvar629506 {"currencyCode" (portkey.aws/search-for-tag input "currencyCode" :flattened? nil :xmlAttribute? nil), "duration" (portkey.aws/search-for-tag input "duration" :flattened? nil :xmlAttribute? nil), "hourlyPrice" (portkey.aws/search-for-tag input "hourlyPrice" :flattened? nil :xmlAttribute? nil), "instanceFamily" (portkey.aws/search-for-tag input "instanceFamily" :flattened? nil :xmlAttribute? nil), "offeringId" (portkey.aws/search-for-tag input "offeringId" :flattened? nil :xmlAttribute? nil), "paymentOption" (portkey.aws/search-for-tag input "paymentOption" :flattened? nil :xmlAttribute? nil), "upfrontPrice" (portkey.aws/search-for-tag input "upfrontPrice" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar629506 "currencyCode") (clojure.core/assoc :currency-code (deser-currency-code-values (clojure.core/get-in letvar629506 ["currencyCode" :content]))) (letvar629506 "duration") (clojure.core/assoc :duration (deser-integer (clojure.core/get-in letvar629506 ["duration" :content]))) (letvar629506 "hourlyPrice") (clojure.core/assoc :hourly-price (deser-string (clojure.core/get-in letvar629506 ["hourlyPrice" :content]))) (letvar629506 "instanceFamily") (clojure.core/assoc :instance-family (deser-string (clojure.core/get-in letvar629506 ["instanceFamily" :content]))) (letvar629506 "offeringId") (clojure.core/assoc :offering-id (deser-string (clojure.core/get-in letvar629506 ["offeringId" :content]))) (letvar629506 "paymentOption") (clojure.core/assoc :payment-option (deser-payment-option (clojure.core/get-in letvar629506 ["paymentOption" :content]))) (letvar629506 "upfrontPrice") (clojure.core/assoc :upfront-price (deser-string (clojure.core/get-in letvar629506 ["upfrontPrice" :content]))))))

(clojure.core/defn- deser-unsuccessful-instance-credit-specification-error-code [input] (clojure.core/get {"InvalidInstanceID.Malformed" :invalid-instance-id-malformed, "InvalidInstanceID.NotFound" :invalid-instance-id-not-found, "IncorrectInstanceState" :incorrect-instance-state, "InstanceCreditSpecification.NotSupported" :instance-credit-specification-not-supported} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-listing-state [input] (clojure.core/get {"available" :available, "sold" :sold, "cancelled" :cancelled, "pending" :pending} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-volume-status-events-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-volume-status-event coll))) input))

(clojure.core/defn- deser-datafeed-subscription-state [input] (clojure.core/get {"Active" :active, "Inactive" :inactive} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-service-detail [input] (clojure.core/let [letvar629646 {"serviceName" (portkey.aws/search-for-tag input "serviceName" :flattened? nil :xmlAttribute? nil), "serviceType" (portkey.aws/search-for-tag input "serviceType" :flattened? nil :xmlAttribute? nil), "availabilityZoneSet" (portkey.aws/search-for-tag input "availabilityZoneSet" :flattened? nil :xmlAttribute? nil), "owner" (portkey.aws/search-for-tag input "owner" :flattened? nil :xmlAttribute? nil), "baseEndpointDnsNameSet" (portkey.aws/search-for-tag input "baseEndpointDnsNameSet" :flattened? nil :xmlAttribute? nil), "privateDnsName" (portkey.aws/search-for-tag input "privateDnsName" :flattened? nil :xmlAttribute? nil), "vpcEndpointPolicySupported" (portkey.aws/search-for-tag input "vpcEndpointPolicySupported" :flattened? nil :xmlAttribute? nil), "acceptanceRequired" (portkey.aws/search-for-tag input "acceptanceRequired" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar629646 "serviceName") (clojure.core/assoc :service-name (deser-string (clojure.core/get-in letvar629646 ["serviceName" :content]))) (letvar629646 "serviceType") (clojure.core/assoc :service-type (deser-service-type-detail-set (clojure.core/get-in letvar629646 ["serviceType" :content]))) (letvar629646 "availabilityZoneSet") (clojure.core/assoc :availability-zones (deser-value-string-list (clojure.core/get-in letvar629646 ["availabilityZoneSet" :content]))) (letvar629646 "owner") (clojure.core/assoc :owner (deser-string (clojure.core/get-in letvar629646 ["owner" :content]))) (letvar629646 "baseEndpointDnsNameSet") (clojure.core/assoc :base-endpoint-dns-names (deser-value-string-list (clojure.core/get-in letvar629646 ["baseEndpointDnsNameSet" :content]))) (letvar629646 "privateDnsName") (clojure.core/assoc :private-dns-name (deser-string (clojure.core/get-in letvar629646 ["privateDnsName" :content]))) (letvar629646 "vpcEndpointPolicySupported") (clojure.core/assoc :vpc-endpoint-policy-supported (deser-boolean (clojure.core/get-in letvar629646 ["vpcEndpointPolicySupported" :content]))) (letvar629646 "acceptanceRequired") (clojure.core/assoc :acceptance-required (deser-boolean (clojure.core/get-in letvar629646 ["acceptanceRequired" :content]))))))

(clojure.core/defn- deser-network-interface-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-network-interface coll))) input))

(clojure.core/defn- deser-cancel-batch-error-code [input] (clojure.core/get {"fleetRequestIdDoesNotExist" :fleet-request-id-does-not-exist, "fleetRequestIdMalformed" :fleet-request-id-malformed, "fleetRequestNotInCancellableState" :fleet-request-not-in-cancellable-state, "unexpectedError" :unexpected-error} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-target-configuration [input] (clojure.core/let [letvar629776 {"instanceCount" (portkey.aws/search-for-tag input "instanceCount" :flattened? nil :xmlAttribute? nil), "offeringId" (portkey.aws/search-for-tag input "offeringId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar629776 "instanceCount") (clojure.core/assoc :instance-count (deser-integer (clojure.core/get-in letvar629776 ["instanceCount" :content]))) (letvar629776 "offeringId") (clojure.core/assoc :offering-id (deser-string (clojure.core/get-in letvar629776 ["offeringId" :content]))))))

(clojure.core/defn- deser-allocation-strategy [input] (clojure.core/get {"lowestPrice" :lowest-price, "diversified" :diversified} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-status-name [input] (clojure.core/get {"reachability" :reachability} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-volume-status-event [input] (clojure.core/let [letvar629894 {"description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "eventId" (portkey.aws/search-for-tag input "eventId" :flattened? nil :xmlAttribute? nil), "eventType" (portkey.aws/search-for-tag input "eventType" :flattened? nil :xmlAttribute? nil), "notAfter" (portkey.aws/search-for-tag input "notAfter" :flattened? nil :xmlAttribute? nil), "notBefore" (portkey.aws/search-for-tag input "notBefore" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar629894 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar629894 ["description" :content]))) (letvar629894 "eventId") (clojure.core/assoc :event-id (deser-string (clojure.core/get-in letvar629894 ["eventId" :content]))) (letvar629894 "eventType") (clojure.core/assoc :event-type (deser-string (clojure.core/get-in letvar629894 ["eventType" :content]))) (letvar629894 "notAfter") (clojure.core/assoc :not-after (deser-date-time (clojure.core/get-in letvar629894 ["notAfter" :content]))) (letvar629894 "notBefore") (clojure.core/assoc :not-before (deser-date-time (clojure.core/get-in letvar629894 ["notBefore" :content]))))))

(clojure.core/defn- deser-describe-fleets-error-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-describe-fleet-error coll))) input))

(clojure.core/defn- deser-target-reservation-value [input] (clojure.core/let [letvar630019 {"reservationValue" (portkey.aws/search-for-tag input "reservationValue" :flattened? nil :xmlAttribute? nil), "targetConfiguration" (portkey.aws/search-for-tag input "targetConfiguration" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar630019 "reservationValue") (clojure.core/assoc :reservation-value (deser-reservation-value (clojure.core/get-in letvar630019 ["reservationValue" :content]))) (letvar630019 "targetConfiguration") (clojure.core/assoc :target-configuration (deser-target-configuration (clojure.core/get-in letvar630019 ["targetConfiguration" :content]))))))

(clojure.core/defn- deser-reserved-intances-ids [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-instances-id coll))) input))

(clojure.core/defn- deser-attribute-value [input] (clojure.core/let [letvar630144 {"value" (portkey.aws/search-for-tag input "value" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar630144 "value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar630144 ["value" :content]))))))

(clojure.core/defn- deser-launch-template-block-device-mapping-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-launch-template-block-device-mapping coll))) input))

(clojure.core/defn- deser-network-acl-association [input] (clojure.core/let [letvar630269 {"networkAclAssociationId" (portkey.aws/search-for-tag input "networkAclAssociationId" :flattened? nil :xmlAttribute? nil), "networkAclId" (portkey.aws/search-for-tag input "networkAclId" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar630269 "networkAclAssociationId") (clojure.core/assoc :network-acl-association-id (deser-string (clojure.core/get-in letvar630269 ["networkAclAssociationId" :content]))) (letvar630269 "networkAclId") (clojure.core/assoc :network-acl-id (deser-string (clojure.core/get-in letvar630269 ["networkAclId" :content]))) (letvar630269 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar630269 ["subnetId" :content]))))))

(clojure.core/defn- deser-private-ip-address-specification-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-private-ip-address-specification coll))) input))

(clojure.core/defn- deser-auto-placement [input] (clojure.core/get {"on" :on, "off" :off} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-prefix-list-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-prefix-list-id coll))) input))

(clojure.core/defn- deser-auto-accept-shared-attachments-value [input] (clojure.core/get {"enable" :enable, "disable" :disable} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-availability-zone-message-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-availability-zone-message coll))) input))

(clojure.core/defn- deser-launch-template-hibernation-options [input] (clojure.core/let [letvar630438 {"configured" (portkey.aws/search-for-tag input "configured" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar630438 "configured") (clojure.core/assoc :configured (deser-boolean (clojure.core/get-in letvar630438 ["configured" :content]))))))

(clojure.core/defn- deser-history-records [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-history-record coll))) input))

(clojure.core/defn- deser-tag-description-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tag-description coll))) input))

(clojure.core/defn- deser-product-code-values [input] (clojure.core/get {"devpay" :devpay, "marketplace" :marketplace} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-fleet-launch-template-config [input] (clojure.core/let [letvar630585 {"launchTemplateSpecification" (portkey.aws/search-for-tag input "launchTemplateSpecification" :flattened? nil :xmlAttribute? nil), "overrides" (portkey.aws/search-for-tag input "overrides" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar630585 "launchTemplateSpecification") (clojure.core/assoc :launch-template-specification (deser-fleet-launch-template-specification (clojure.core/get-in letvar630585 ["launchTemplateSpecification" :content]))) (letvar630585 "overrides") (clojure.core/assoc :overrides (deser-fleet-launch-template-overrides-list (clojure.core/get-in letvar630585 ["overrides" :content]))))))

(clojure.core/defn- deser-instance-health-status [input] (clojure.core/get {"healthy" :healthy, "unhealthy" :unhealthy} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-purchase-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-purchase coll))) input))

(clojure.core/defn- deser-client-vpn-route-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-client-vpn-route coll))) input))

(clojure.core/defn- deser-client-vpn-route-status [input] (clojure.core/let [letvar630732 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar630732 "code") (clojure.core/assoc :code (deser-client-vpn-route-status-code (clojure.core/get-in letvar630732 ["code" :content]))) (letvar630732 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar630732 ["message" :content]))))))

(clojure.core/defn- deser-create-fleet-instances-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-create-fleet-instance coll))) input))

(clojure.core/defn- deser-ipv-6-cidr-block [input] (clojure.core/let [letvar630857 {"ipv6CidrBlock" (portkey.aws/search-for-tag input "ipv6CidrBlock" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar630857 "ipv6CidrBlock") (clojure.core/assoc :ipv-6-cidr-block (deser-string (clojure.core/get-in letvar630857 ["ipv6CidrBlock" :content]))))))

(clojure.core/defn- deser-placement-strategy [input] (clojure.core/get {"cluster" :cluster, "spread" :spread, "partition" :partition} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-internet-gateway-attachment-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-internet-gateway-attachment coll))) input))

(clojure.core/defn- deser-license-configuration [input] (clojure.core/let [letvar630987 {"licenseConfigurationArn" (portkey.aws/search-for-tag input "licenseConfigurationArn" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar630987 "licenseConfigurationArn") (clojure.core/assoc :license-configuration-arn (deser-string (clojure.core/get-in letvar630987 ["licenseConfigurationArn" :content]))))))

(clojure.core/defn- deser-volume-status-info [input] (clojure.core/let [letvar631095 {"details" (portkey.aws/search-for-tag input "details" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar631095 "details") (clojure.core/assoc :details (deser-volume-status-details-list (clojure.core/get-in letvar631095 ["details" :content]))) (letvar631095 "status") (clojure.core/assoc :status (deser-volume-status-info-status (clojure.core/get-in letvar631095 ["status" :content]))))))

(clojure.core/defn- deser-instance-capacity [input] (clojure.core/let [letvar631203 {"availableCapacity" (portkey.aws/search-for-tag input "availableCapacity" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "totalCapacity" (portkey.aws/search-for-tag input "totalCapacity" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar631203 "availableCapacity") (clojure.core/assoc :available-capacity (deser-integer (clojure.core/get-in letvar631203 ["availableCapacity" :content]))) (letvar631203 "instanceType") (clojure.core/assoc :instance-type (deser-string (clojure.core/get-in letvar631203 ["instanceType" :content]))) (letvar631203 "totalCapacity") (clojure.core/assoc :total-capacity (deser-integer (clojure.core/get-in letvar631203 ["totalCapacity" :content]))))))

(clojure.core/defn- deser-instance-block-device-mapping [input] (clojure.core/let [letvar631311 {"deviceName" (portkey.aws/search-for-tag input "deviceName" :flattened? nil :xmlAttribute? nil), "ebs" (portkey.aws/search-for-tag input "ebs" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar631311 "deviceName") (clojure.core/assoc :device-name (deser-string (clojure.core/get-in letvar631311 ["deviceName" :content]))) (letvar631311 "ebs") (clojure.core/assoc :ebs (deser-ebs-instance-block-device (clojure.core/get-in letvar631311 ["ebs" :content]))))))

(clojure.core/defn- deser-connection-notification-state [input] (clojure.core/get {"Enabled" :enabled, "Disabled" :disabled} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-instance-interruption-behavior [input] (clojure.core/get {"hibernate" :hibernate, "stop" :stop, "terminate" :terminate} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-customer-gateway-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-customer-gateway coll))) input))

(clojure.core/defn- deser-spot-options [input] (clojure.core/let [letvar631446 {"allocationStrategy" (portkey.aws/search-for-tag input "allocationStrategy" :flattened? nil :xmlAttribute? nil), "instanceInterruptionBehavior" (portkey.aws/search-for-tag input "instanceInterruptionBehavior" :flattened? nil :xmlAttribute? nil), "instancePoolsToUseCount" (portkey.aws/search-for-tag input "instancePoolsToUseCount" :flattened? nil :xmlAttribute? nil), "singleInstanceType" (portkey.aws/search-for-tag input "singleInstanceType" :flattened? nil :xmlAttribute? nil), "singleAvailabilityZone" (portkey.aws/search-for-tag input "singleAvailabilityZone" :flattened? nil :xmlAttribute? nil), "minTargetCapacity" (portkey.aws/search-for-tag input "minTargetCapacity" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar631446 "allocationStrategy") (clojure.core/assoc :allocation-strategy (deser-spot-allocation-strategy (clojure.core/get-in letvar631446 ["allocationStrategy" :content]))) (letvar631446 "instanceInterruptionBehavior") (clojure.core/assoc :instance-interruption-behavior (deser-spot-instance-interruption-behavior (clojure.core/get-in letvar631446 ["instanceInterruptionBehavior" :content]))) (letvar631446 "instancePoolsToUseCount") (clojure.core/assoc :instance-pools-to-use-count (deser-integer (clojure.core/get-in letvar631446 ["instancePoolsToUseCount" :content]))) (letvar631446 "singleInstanceType") (clojure.core/assoc :single-instance-type (deser-boolean (clojure.core/get-in letvar631446 ["singleInstanceType" :content]))) (letvar631446 "singleAvailabilityZone") (clojure.core/assoc :single-availability-zone (deser-boolean (clojure.core/get-in letvar631446 ["singleAvailabilityZone" :content]))) (letvar631446 "minTargetCapacity") (clojure.core/assoc :min-target-capacity (deser-integer (clojure.core/get-in letvar631446 ["minTargetCapacity" :content]))))))

(clojure.core/defn- deser-classic-link-dns-support [input] (clojure.core/let [letvar631554 {"classicLinkDnsSupported" (portkey.aws/search-for-tag input "classicLinkDnsSupported" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar631554 "classicLinkDnsSupported") (clojure.core/assoc :classic-link-dns-supported (deser-boolean (clojure.core/get-in letvar631554 ["classicLinkDnsSupported" :content]))) (letvar631554 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar631554 ["vpcId" :content]))))))

(clojure.core/defn- deser-vpc-cidr-block-state-code [input] (clojure.core/get {"associating" :associating, "associated" :associated, "disassociating" :disassociating, "disassociated" :disassociated, "failing" :failing, "failed" :failed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-public-ipv-4-pool-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-public-ipv-4-pool coll))) input))

(clojure.core/defn- deser-monitoring-state [input] (clojure.core/get {"disabled" :disabled, "disabling" :disabling, "enabled" :enabled, "pending" :pending} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-reserved-instance-reservation-value-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-instance-reservation-value coll))) input))

(clojure.core/defn- deser-hibernation-options [input] (clojure.core/let [letvar631706 {"configured" (portkey.aws/search-for-tag input "configured" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar631706 "configured") (clojure.core/assoc :configured (deser-boolean (clojure.core/get-in letvar631706 ["configured" :content]))))))

(clojure.core/defn- deserscope [input] (clojure.core/get {"Availability Zone" :availability-zone, "Region" :region} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-network-interface-permission-state-code [input] (clojure.core/get {"pending" :pending, "granted" :granted, "revoking" :revoking, "revoked" :revoked} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-connection-log-response-options [input] (clojure.core/let [letvar631824 {"Enabled" (portkey.aws/search-for-tag input "Enabled" :flattened? nil :xmlAttribute? nil), "CloudwatchLogGroup" (portkey.aws/search-for-tag input "CloudwatchLogGroup" :flattened? nil :xmlAttribute? nil), "CloudwatchLogStream" (portkey.aws/search-for-tag input "CloudwatchLogStream" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar631824 "Enabled") (clojure.core/assoc :enabled (deser-boolean (clojure.core/get-in letvar631824 ["Enabled" :content]))) (letvar631824 "CloudwatchLogGroup") (clojure.core/assoc :cloudwatch-log-group (deser-string (clojure.core/get-in letvar631824 ["CloudwatchLogGroup" :content]))) (letvar631824 "CloudwatchLogStream") (clojure.core/assoc :cloudwatch-log-stream (deser-string (clojure.core/get-in letvar631824 ["CloudwatchLogStream" :content]))))))

(clojure.core/defn- deser-device-type [input] (clojure.core/get {"ebs" :ebs, "instance-store" :instancestore} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-route-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-route coll))) input))

(clojure.core/defn- deser-pricing-detail [input] (clojure.core/let [letvar631954 {"count" (portkey.aws/search-for-tag input "count" :flattened? nil :xmlAttribute? nil), "price" (portkey.aws/search-for-tag input "price" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar631954 "count") (clojure.core/assoc :count (deser-integer (clojure.core/get-in letvar631954 ["count" :content]))) (letvar631954 "price") (clojure.core/assoc :price (deser-double (clojure.core/get-in letvar631954 ["price" :content]))))))

(clojure.core/defn- deser-transit-gateway-route-type [input] (clojure.core/get {"static" :static, "propagated" :propagated} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-import-volume-task-details [input] (clojure.core/let [letvar632067 {"availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "bytesConverted" (portkey.aws/search-for-tag input "bytesConverted" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "image" (portkey.aws/search-for-tag input "image" :flattened? nil :xmlAttribute? nil), "volume" (portkey.aws/search-for-tag input "volume" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar632067 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar632067 ["availabilityZone" :content]))) (letvar632067 "bytesConverted") (clojure.core/assoc :bytes-converted (deser-long (clojure.core/get-in letvar632067 ["bytesConverted" :content]))) (letvar632067 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar632067 ["description" :content]))) (letvar632067 "image") (clojure.core/assoc :image (deser-disk-image-description (clojure.core/get-in letvar632067 ["image" :content]))) (letvar632067 "volume") (clojure.core/assoc :volume (deser-disk-image-volume-description (clojure.core/get-in letvar632067 ["volume" :content]))))))

(clojure.core/defn- deser-instance-match-criteria [input] (clojure.core/get {"open" :open, "targeted" :targeted} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-transit-gateway-route-table [input] (clojure.core/let [letvar632180 {"transitGatewayRouteTableId" (portkey.aws/search-for-tag input "transitGatewayRouteTableId" :flattened? nil :xmlAttribute? nil), "transitGatewayId" (portkey.aws/search-for-tag input "transitGatewayId" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "defaultAssociationRouteTable" (portkey.aws/search-for-tag input "defaultAssociationRouteTable" :flattened? nil :xmlAttribute? nil), "defaultPropagationRouteTable" (portkey.aws/search-for-tag input "defaultPropagationRouteTable" :flattened? nil :xmlAttribute? nil), "creationTime" (portkey.aws/search-for-tag input "creationTime" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar632180 "transitGatewayRouteTableId") (clojure.core/assoc :transit-gateway-route-table-id (deser-string (clojure.core/get-in letvar632180 ["transitGatewayRouteTableId" :content]))) (letvar632180 "transitGatewayId") (clojure.core/assoc :transit-gateway-id (deser-string (clojure.core/get-in letvar632180 ["transitGatewayId" :content]))) (letvar632180 "state") (clojure.core/assoc :state (deser-transit-gateway-route-table-state (clojure.core/get-in letvar632180 ["state" :content]))) (letvar632180 "defaultAssociationRouteTable") (clojure.core/assoc :default-association-route-table (deser-boolean (clojure.core/get-in letvar632180 ["defaultAssociationRouteTable" :content]))) (letvar632180 "defaultPropagationRouteTable") (clojure.core/assoc :default-propagation-route-table (deser-boolean (clojure.core/get-in letvar632180 ["defaultPropagationRouteTable" :content]))) (letvar632180 "creationTime") (clojure.core/assoc :creation-time (deser-date-time (clojure.core/get-in letvar632180 ["creationTime" :content]))) (letvar632180 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar632180 ["tagSet" :content]))))))

(clojure.core/defn- deser-subnet-cidr-block-state-code [input] (clojure.core/get {"associating" :associating, "associated" :associated, "disassociating" :disassociating, "disassociated" :disassociated, "failing" :failing, "failed" :failed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-fpga-image-state-code [input] (clojure.core/get {"pending" :pending, "failed" :failed, "available" :available, "unavailable" :unavailable} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-launch-template-license-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-launch-template-license-configuration coll))) input))

(clojure.core/defn- deser-on-demand-options [input] (clojure.core/let [letvar632315 {"allocationStrategy" (portkey.aws/search-for-tag input "allocationStrategy" :flattened? nil :xmlAttribute? nil), "singleInstanceType" (portkey.aws/search-for-tag input "singleInstanceType" :flattened? nil :xmlAttribute? nil), "singleAvailabilityZone" (portkey.aws/search-for-tag input "singleAvailabilityZone" :flattened? nil :xmlAttribute? nil), "minTargetCapacity" (portkey.aws/search-for-tag input "minTargetCapacity" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar632315 "allocationStrategy") (clojure.core/assoc :allocation-strategy (deser-fleet-on-demand-allocation-strategy (clojure.core/get-in letvar632315 ["allocationStrategy" :content]))) (letvar632315 "singleInstanceType") (clojure.core/assoc :single-instance-type (deser-boolean (clojure.core/get-in letvar632315 ["singleInstanceType" :content]))) (letvar632315 "singleAvailabilityZone") (clojure.core/assoc :single-availability-zone (deser-boolean (clojure.core/get-in letvar632315 ["singleAvailabilityZone" :content]))) (letvar632315 "minTargetCapacity") (clojure.core/assoc :min-target-capacity (deser-integer (clojure.core/get-in letvar632315 ["minTargetCapacity" :content]))))))

(clojure.core/defn- deser-network-interface-status [input] (clojure.core/get {"available" :available, "associated" :associated, "attaching" :attaching, "in-use" :inuse, "detaching" :detaching} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-vpc-classic-link-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-classic-link coll))) input))

(clojure.core/defn- deser-group-id-string-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-fleet-data [input] (clojure.core/let [letvar632462 {"spotOptions" (portkey.aws/search-for-tag input "spotOptions" :flattened? nil :xmlAttribute? nil), "replaceUnhealthyInstances" (portkey.aws/search-for-tag input "replaceUnhealthyInstances" :flattened? nil :xmlAttribute? nil), "errorSet" (portkey.aws/search-for-tag input "errorSet" :flattened? nil :xmlAttribute? nil), "validFrom" (portkey.aws/search-for-tag input "validFrom" :flattened? nil :xmlAttribute? nil), "fleetId" (portkey.aws/search-for-tag input "fleetId" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "clientToken" (portkey.aws/search-for-tag input "clientToken" :flattened? nil :xmlAttribute? nil), "fleetInstanceSet" (portkey.aws/search-for-tag input "fleetInstanceSet" :flattened? nil :xmlAttribute? nil), "launchTemplateConfigs" (portkey.aws/search-for-tag input "launchTemplateConfigs" :flattened? nil :xmlAttribute? nil), "fulfilledCapacity" (portkey.aws/search-for-tag input "fulfilledCapacity" :flattened? nil :xmlAttribute? nil), "targetCapacitySpecification" (portkey.aws/search-for-tag input "targetCapacitySpecification" :flattened? nil :xmlAttribute? nil), "fleetState" (portkey.aws/search-for-tag input "fleetState" :flattened? nil :xmlAttribute? nil), "createTime" (portkey.aws/search-for-tag input "createTime" :flattened? nil :xmlAttribute? nil), "excessCapacityTerminationPolicy" (portkey.aws/search-for-tag input "excessCapacityTerminationPolicy" :flattened? nil :xmlAttribute? nil), "activityStatus" (portkey.aws/search-for-tag input "activityStatus" :flattened? nil :xmlAttribute? nil), "terminateInstancesWithExpiration" (portkey.aws/search-for-tag input "terminateInstancesWithExpiration" :flattened? nil :xmlAttribute? nil), "onDemandOptions" (portkey.aws/search-for-tag input "onDemandOptions" :flattened? nil :xmlAttribute? nil), "type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil), "validUntil" (portkey.aws/search-for-tag input "validUntil" :flattened? nil :xmlAttribute? nil), "fulfilledOnDemandCapacity" (portkey.aws/search-for-tag input "fulfilledOnDemandCapacity" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar632462 "type") (clojure.core/assoc :type (deser-fleet-type (clojure.core/get-in letvar632462 ["type" :content]))) (letvar632462 "fleetId") (clojure.core/assoc :fleet-id (deser-fleet-identifier (clojure.core/get-in letvar632462 ["fleetId" :content]))) (letvar632462 "fulfilledOnDemandCapacity") (clojure.core/assoc :fulfilled-on-demand-capacity (deser-double (clojure.core/get-in letvar632462 ["fulfilledOnDemandCapacity" :content]))) (letvar632462 "validFrom") (clojure.core/assoc :valid-from (deser-date-time (clojure.core/get-in letvar632462 ["validFrom" :content]))) (letvar632462 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar632462 ["tagSet" :content]))) (letvar632462 "excessCapacityTerminationPolicy") (clojure.core/assoc :excess-capacity-termination-policy (deser-fleet-excess-capacity-termination-policy (clojure.core/get-in letvar632462 ["excessCapacityTerminationPolicy" :content]))) (letvar632462 "spotOptions") (clojure.core/assoc :spot-options (deser-spot-options (clojure.core/get-in letvar632462 ["spotOptions" :content]))) (letvar632462 "launchTemplateConfigs") (clojure.core/assoc :launch-template-configs (deser-fleet-launch-template-config-list (clojure.core/get-in letvar632462 ["launchTemplateConfigs" :content]))) (letvar632462 "onDemandOptions") (clojure.core/assoc :on-demand-options (deser-on-demand-options (clojure.core/get-in letvar632462 ["onDemandOptions" :content]))) (letvar632462 "fulfilledCapacity") (clojure.core/assoc :fulfilled-capacity (deser-double (clojure.core/get-in letvar632462 ["fulfilledCapacity" :content]))) (letvar632462 "createTime") (clojure.core/assoc :create-time (deser-date-time (clojure.core/get-in letvar632462 ["createTime" :content]))) (letvar632462 "fleetState") (clojure.core/assoc :fleet-state (deser-fleet-state-code (clojure.core/get-in letvar632462 ["fleetState" :content]))) (letvar632462 "terminateInstancesWithExpiration") (clojure.core/assoc :terminate-instances-with-expiration (deser-boolean (clojure.core/get-in letvar632462 ["terminateInstancesWithExpiration" :content]))) (letvar632462 "targetCapacitySpecification") (clojure.core/assoc :target-capacity-specification (deser-target-capacity-specification (clojure.core/get-in letvar632462 ["targetCapacitySpecification" :content]))) (letvar632462 "fleetInstanceSet") (clojure.core/assoc :instances (deser-describe-fleets-instances-set (clojure.core/get-in letvar632462 ["fleetInstanceSet" :content]))) (letvar632462 "activityStatus") (clojure.core/assoc :activity-status (deser-fleet-activity-status (clojure.core/get-in letvar632462 ["activityStatus" :content]))) (letvar632462 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar632462 ["clientToken" :content]))) (letvar632462 "replaceUnhealthyInstances") (clojure.core/assoc :replace-unhealthy-instances (deser-boolean (clojure.core/get-in letvar632462 ["replaceUnhealthyInstances" :content]))) (letvar632462 "validUntil") (clojure.core/assoc :valid-until (deser-date-time (clojure.core/get-in letvar632462 ["validUntil" :content]))) (letvar632462 "errorSet") (clojure.core/assoc :errors (deser-describe-fleets-error-set (clojure.core/get-in letvar632462 ["errorSet" :content]))))))

(clojure.core/defn- deser-price-schedule [input] (clojure.core/let [letvar632570 {"active" (portkey.aws/search-for-tag input "active" :flattened? nil :xmlAttribute? nil), "currencyCode" (portkey.aws/search-for-tag input "currencyCode" :flattened? nil :xmlAttribute? nil), "price" (portkey.aws/search-for-tag input "price" :flattened? nil :xmlAttribute? nil), "term" (portkey.aws/search-for-tag input "term" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar632570 "active") (clojure.core/assoc :active (deser-boolean (clojure.core/get-in letvar632570 ["active" :content]))) (letvar632570 "currencyCode") (clojure.core/assoc :currency-code (deser-currency-code-values (clojure.core/get-in letvar632570 ["currencyCode" :content]))) (letvar632570 "price") (clojure.core/assoc :price (deser-double (clojure.core/get-in letvar632570 ["price" :content]))) (letvar632570 "term") (clojure.core/assoc :term (deser-long (clojure.core/get-in letvar632570 ["term" :content]))))))

(clojure.core/defn- deser-iam-instance-profile-association [input] (clojure.core/let [letvar632678 {"associationId" (portkey.aws/search-for-tag input "associationId" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "iamInstanceProfile" (portkey.aws/search-for-tag input "iamInstanceProfile" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "timestamp" (portkey.aws/search-for-tag input "timestamp" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar632678 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar632678 ["associationId" :content]))) (letvar632678 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar632678 ["instanceId" :content]))) (letvar632678 "iamInstanceProfile") (clojure.core/assoc :iam-instance-profile (deser-iam-instance-profile (clojure.core/get-in letvar632678 ["iamInstanceProfile" :content]))) (letvar632678 "state") (clojure.core/assoc :state (deser-iam-instance-profile-association-state (clojure.core/get-in letvar632678 ["state" :content]))) (letvar632678 "timestamp") (clojure.core/assoc :timestamp (deser-date-time (clojure.core/get-in letvar632678 ["timestamp" :content]))))))

(clojure.core/defn- deser-reserved-instance-state [input] (clojure.core/get {"payment-pending" :paymentpending, "active" :active, "payment-failed" :paymentfailed, "retired" :retired} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-allocation-state [input] (clojure.core/get {"available" :available, "under-assessment" :underassessment, "permanent-failure" :permanentfailure, "released" :released, "released-permanent-failure" :releasedpermanentfailure} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-connection-notification [input] (clojure.core/let [letvar632796 {"connectionNotificationId" (portkey.aws/search-for-tag input "connectionNotificationId" :flattened? nil :xmlAttribute? nil), "serviceId" (portkey.aws/search-for-tag input "serviceId" :flattened? nil :xmlAttribute? nil), "vpcEndpointId" (portkey.aws/search-for-tag input "vpcEndpointId" :flattened? nil :xmlAttribute? nil), "connectionNotificationType" (portkey.aws/search-for-tag input "connectionNotificationType" :flattened? nil :xmlAttribute? nil), "connectionNotificationArn" (portkey.aws/search-for-tag input "connectionNotificationArn" :flattened? nil :xmlAttribute? nil), "connectionEvents" (portkey.aws/search-for-tag input "connectionEvents" :flattened? nil :xmlAttribute? nil), "connectionNotificationState" (portkey.aws/search-for-tag input "connectionNotificationState" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar632796 "connectionNotificationId") (clojure.core/assoc :connection-notification-id (deser-string (clojure.core/get-in letvar632796 ["connectionNotificationId" :content]))) (letvar632796 "serviceId") (clojure.core/assoc :service-id (deser-string (clojure.core/get-in letvar632796 ["serviceId" :content]))) (letvar632796 "vpcEndpointId") (clojure.core/assoc :vpc-endpoint-id (deser-string (clojure.core/get-in letvar632796 ["vpcEndpointId" :content]))) (letvar632796 "connectionNotificationType") (clojure.core/assoc :connection-notification-type (deser-connection-notification-type (clojure.core/get-in letvar632796 ["connectionNotificationType" :content]))) (letvar632796 "connectionNotificationArn") (clojure.core/assoc :connection-notification-arn (deser-string (clojure.core/get-in letvar632796 ["connectionNotificationArn" :content]))) (letvar632796 "connectionEvents") (clojure.core/assoc :connection-events (deser-value-string-list (clojure.core/get-in letvar632796 ["connectionEvents" :content]))) (letvar632796 "connectionNotificationState") (clojure.core/assoc :connection-notification-state (deser-connection-notification-state (clojure.core/get-in letvar632796 ["connectionNotificationState" :content]))))))

(clojure.core/defn- deser-launch-template-block-device-mapping [input] (clojure.core/let [letvar632904 {"deviceName" (portkey.aws/search-for-tag input "deviceName" :flattened? nil :xmlAttribute? nil), "virtualName" (portkey.aws/search-for-tag input "virtualName" :flattened? nil :xmlAttribute? nil), "ebs" (portkey.aws/search-for-tag input "ebs" :flattened? nil :xmlAttribute? nil), "noDevice" (portkey.aws/search-for-tag input "noDevice" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar632904 "deviceName") (clojure.core/assoc :device-name (deser-string (clojure.core/get-in letvar632904 ["deviceName" :content]))) (letvar632904 "virtualName") (clojure.core/assoc :virtual-name (deser-string (clojure.core/get-in letvar632904 ["virtualName" :content]))) (letvar632904 "ebs") (clojure.core/assoc :ebs (deser-launch-template-ebs-block-device (clojure.core/get-in letvar632904 ["ebs" :content]))) (letvar632904 "noDevice") (clojure.core/assoc :no-device (deser-string (clojure.core/get-in letvar632904 ["noDevice" :content]))))))

(clojure.core/defn- deser-export-task-state [input] (clojure.core/get {"active" :active, "cancelling" :cancelling, "cancelled" :cancelled, "completed" :completed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-log-destination-type [input] (clojure.core/get {"cloud-watch-logs" :cloudwatchlogs, "s3" :s-3} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-instance-state-change [input] (clojure.core/let [letvar633022 {"currentState" (portkey.aws/search-for-tag input "currentState" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "previousState" (portkey.aws/search-for-tag input "previousState" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar633022 "currentState") (clojure.core/assoc :current-state (deser-instance-state (clojure.core/get-in letvar633022 ["currentState" :content]))) (letvar633022 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar633022 ["instanceId" :content]))) (letvar633022 "previousState") (clojure.core/assoc :previous-state (deser-instance-state (clojure.core/get-in letvar633022 ["previousState" :content]))))))

(clojure.core/defn- deser-monitoring [input] (clojure.core/let [letvar633130 {"state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar633130 "state") (clojure.core/assoc :state (deser-monitoring-state (clojure.core/get-in letvar633130 ["state" :content]))))))

(clojure.core/defn- deser-elastic-gpu-health [input] (clojure.core/let [letvar633238 {"status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar633238 "status") (clojure.core/assoc :status (deser-elastic-gpu-status (clojure.core/get-in letvar633238 ["status" :content]))))))

(clojure.core/defn- deser-event-information [input] (clojure.core/let [letvar633346 {"eventDescription" (portkey.aws/search-for-tag input "eventDescription" :flattened? nil :xmlAttribute? nil), "eventSubType" (portkey.aws/search-for-tag input "eventSubType" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar633346 "eventDescription") (clojure.core/assoc :event-description (deser-string (clojure.core/get-in letvar633346 ["eventDescription" :content]))) (letvar633346 "eventSubType") (clojure.core/assoc :event-sub-type (deser-string (clojure.core/get-in letvar633346 ["eventSubType" :content]))) (letvar633346 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar633346 ["instanceId" :content]))))))

(clojure.core/defn- deser-launch-template-instance-network-interface-specification-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-launch-template-instance-network-interface-specification coll))) input))

(clojure.core/defn- deser-launch-specs-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-spot-fleet-launch-specification coll))) input))

(clojure.core/defn- deser-unsuccessful-instance-credit-specification-item [input] (clojure.core/let [letvar633488 {"instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "error" (portkey.aws/search-for-tag input "error" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar633488 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar633488 ["instanceId" :content]))) (letvar633488 "error") (clojure.core/assoc :error (deser-unsuccessful-instance-credit-specification-item-error (clojure.core/get-in letvar633488 ["error" :content]))))))

(clojure.core/defn- deser-volume-status-details [input] (clojure.core/let [letvar633596 {"name" (portkey.aws/search-for-tag input "name" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar633596 "name") (clojure.core/assoc :name (deser-volume-status-name (clojure.core/get-in letvar633596 ["name" :content]))) (letvar633596 "status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar633596 ["status" :content]))))))

(clojure.core/defn- deser-load-balancers-config [input] (clojure.core/let [letvar633704 {"classicLoadBalancersConfig" (portkey.aws/search-for-tag input "classicLoadBalancersConfig" :flattened? nil :xmlAttribute? nil), "targetGroupsConfig" (portkey.aws/search-for-tag input "targetGroupsConfig" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar633704 "classicLoadBalancersConfig") (clojure.core/assoc :classic-load-balancers-config (deser-classic-load-balancers-config (clojure.core/get-in letvar633704 ["classicLoadBalancersConfig" :content]))) (letvar633704 "targetGroupsConfig") (clojure.core/assoc :target-groups-config (deser-target-groups-config (clojure.core/get-in letvar633704 ["targetGroupsConfig" :content]))))))

(clojure.core/defn- deser-integer [input] (java.lang.Integer. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-string [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-elastic-gpus [input] (clojure.core/let [letvar633819 {"elasticGpuId" (portkey.aws/search-for-tag input "elasticGpuId" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "elasticGpuType" (portkey.aws/search-for-tag input "elasticGpuType" :flattened? nil :xmlAttribute? nil), "elasticGpuHealth" (portkey.aws/search-for-tag input "elasticGpuHealth" :flattened? nil :xmlAttribute? nil), "elasticGpuState" (portkey.aws/search-for-tag input "elasticGpuState" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar633819 "elasticGpuId") (clojure.core/assoc :elastic-gpu-id (deser-string (clojure.core/get-in letvar633819 ["elasticGpuId" :content]))) (letvar633819 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar633819 ["availabilityZone" :content]))) (letvar633819 "elasticGpuType") (clojure.core/assoc :elastic-gpu-type (deser-string (clojure.core/get-in letvar633819 ["elasticGpuType" :content]))) (letvar633819 "elasticGpuHealth") (clojure.core/assoc :elastic-gpu-health (deser-elastic-gpu-health (clojure.core/get-in letvar633819 ["elasticGpuHealth" :content]))) (letvar633819 "elasticGpuState") (clojure.core/assoc :elastic-gpu-state (deser-elastic-gpu-state (clojure.core/get-in letvar633819 ["elasticGpuState" :content]))) (letvar633819 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar633819 ["instanceId" :content]))))))

(clojure.core/defn- deser-transit-gateway-route-table-propagation [input] (clojure.core/let [letvar633927 {"transitGatewayAttachmentId" (portkey.aws/search-for-tag input "transitGatewayAttachmentId" :flattened? nil :xmlAttribute? nil), "resourceId" (portkey.aws/search-for-tag input "resourceId" :flattened? nil :xmlAttribute? nil), "resourceType" (portkey.aws/search-for-tag input "resourceType" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar633927 "transitGatewayAttachmentId") (clojure.core/assoc :transit-gateway-attachment-id (deser-string (clojure.core/get-in letvar633927 ["transitGatewayAttachmentId" :content]))) (letvar633927 "resourceId") (clojure.core/assoc :resource-id (deser-string (clojure.core/get-in letvar633927 ["resourceId" :content]))) (letvar633927 "resourceType") (clojure.core/assoc :resource-type (deser-transit-gateway-attachment-resource-type (clojure.core/get-in letvar633927 ["resourceType" :content]))) (letvar633927 "state") (clojure.core/assoc :state (deser-transit-gateway-propagation-state (clojure.core/get-in letvar633927 ["state" :content]))))))

(clojure.core/defn- deser-classic-load-balancer [input] (clojure.core/let [letvar634035 {"name" (portkey.aws/search-for-tag input "name" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar634035 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar634035 ["name" :content]))))))

(clojure.core/defn- deser-ip-permission [input] (clojure.core/let [letvar634143 {"fromPort" (portkey.aws/search-for-tag input "fromPort" :flattened? nil :xmlAttribute? nil), "ipProtocol" (portkey.aws/search-for-tag input "ipProtocol" :flattened? nil :xmlAttribute? nil), "ipRanges" (portkey.aws/search-for-tag input "ipRanges" :flattened? nil :xmlAttribute? nil), "ipv6Ranges" (portkey.aws/search-for-tag input "ipv6Ranges" :flattened? nil :xmlAttribute? nil), "prefixListIds" (portkey.aws/search-for-tag input "prefixListIds" :flattened? nil :xmlAttribute? nil), "toPort" (portkey.aws/search-for-tag input "toPort" :flattened? nil :xmlAttribute? nil), "groups" (portkey.aws/search-for-tag input "groups" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar634143 "fromPort") (clojure.core/assoc :from-port (deser-integer (clojure.core/get-in letvar634143 ["fromPort" :content]))) (letvar634143 "ipProtocol") (clojure.core/assoc :ip-protocol (deser-string (clojure.core/get-in letvar634143 ["ipProtocol" :content]))) (letvar634143 "ipRanges") (clojure.core/assoc :ip-ranges (deser-ip-range-list (clojure.core/get-in letvar634143 ["ipRanges" :content]))) (letvar634143 "ipv6Ranges") (clojure.core/assoc :ipv-6-ranges (deser-ipv-6-range-list (clojure.core/get-in letvar634143 ["ipv6Ranges" :content]))) (letvar634143 "prefixListIds") (clojure.core/assoc :prefix-list-ids (deser-prefix-list-id-list (clojure.core/get-in letvar634143 ["prefixListIds" :content]))) (letvar634143 "toPort") (clojure.core/assoc :to-port (deser-integer (clojure.core/get-in letvar634143 ["toPort" :content]))) (letvar634143 "groups") (clojure.core/assoc :user-id-group-pairs (deser-user-id-group-pair-list (clojure.core/get-in letvar634143 ["groups" :content]))))))

(clojure.core/defn- deser-ip-permission-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ip-permission coll))) input))

(clojure.core/defn- deser-transit-gateway-route-attachment-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-transit-gateway-route-attachment coll))) input))

(clojure.core/defn- deser-ri-product-description [input] (clojure.core/get {"Linux/UNIX" :linux-unix, "Linux/UNIX (Amazon VPC)" :linux-unix-amazon-vpc, "Windows" :windows, "Windows (Amazon VPC)" :windows-amazon-vpc} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-instance-ids-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-id coll))) input))

(clojure.core/defn- deser-volume-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-volume coll))) input))

(clojure.core/defn- deser-vpc-endpoint-connection-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-endpoint-connection coll))) input))

(clojure.core/defn- deser-dhcp-options-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-dhcp-options coll))) input))

(clojure.core/defn- deser-transit-gateway-route-table-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-transit-gateway-route-table coll))) input))

(clojure.core/defn- deser-default-route-table-propagation-value [input] (clojure.core/get {"enable" :enable, "disable" :disable} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-unsuccessful-item [input] (clojure.core/let [letvar634380 {"error" (portkey.aws/search-for-tag input "error" :flattened? nil :xmlAttribute? nil), "resourceId" (portkey.aws/search-for-tag input "resourceId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar634380 "error") (clojure.core/assoc :error (deser-unsuccessful-item-error (clojure.core/get-in letvar634380 ["error" :content]))) (letvar634380 "resourceId") (clojure.core/assoc :resource-id (deser-string (clojure.core/get-in letvar634380 ["resourceId" :content]))))))

(clojure.core/defn- deser-principal-id-format-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-principal-id-format coll))) input))

(clojure.core/defn- deser-cancel-spot-fleet-requests-success-item [input] (clojure.core/let [letvar634505 {"currentSpotFleetRequestState" (portkey.aws/search-for-tag input "currentSpotFleetRequestState" :flattened? nil :xmlAttribute? nil), "previousSpotFleetRequestState" (portkey.aws/search-for-tag input "previousSpotFleetRequestState" :flattened? nil :xmlAttribute? nil), "spotFleetRequestId" (portkey.aws/search-for-tag input "spotFleetRequestId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar634505 "currentSpotFleetRequestState") (clojure.core/assoc :current-spot-fleet-request-state (deser-batch-state (clojure.core/get-in letvar634505 ["currentSpotFleetRequestState" :content]))) (letvar634505 "previousSpotFleetRequestState") (clojure.core/assoc :previous-spot-fleet-request-state (deser-batch-state (clojure.core/get-in letvar634505 ["previousSpotFleetRequestState" :content]))) (letvar634505 "spotFleetRequestId") (clojure.core/assoc :spot-fleet-request-id (deser-string (clojure.core/get-in letvar634505 ["spotFleetRequestId" :content]))))))

(clojure.core/defn- deser-client-vpn-endpoint [input] (clojure.core/let [letvar634613 {"transportProtocol" (portkey.aws/search-for-tag input "transportProtocol" :flattened? nil :xmlAttribute? nil), "serverCertificateArn" (portkey.aws/search-for-tag input "serverCertificateArn" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "connectionLogOptions" (portkey.aws/search-for-tag input "connectionLogOptions" :flattened? nil :xmlAttribute? nil), "clientCidrBlock" (portkey.aws/search-for-tag input "clientCidrBlock" :flattened? nil :xmlAttribute? nil), "clientVpnEndpointId" (portkey.aws/search-for-tag input "clientVpnEndpointId" :flattened? nil :xmlAttribute? nil), "associatedTargetNetwork" (portkey.aws/search-for-tag input "associatedTargetNetwork" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "authenticationOptions" (portkey.aws/search-for-tag input "authenticationOptions" :flattened? nil :xmlAttribute? nil), "deletionTime" (portkey.aws/search-for-tag input "deletionTime" :flattened? nil :xmlAttribute? nil), "vpnProtocol" (portkey.aws/search-for-tag input "vpnProtocol" :flattened? nil :xmlAttribute? nil), "creationTime" (portkey.aws/search-for-tag input "creationTime" :flattened? nil :xmlAttribute? nil), "dnsServer" (portkey.aws/search-for-tag input "dnsServer" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "dnsName" (portkey.aws/search-for-tag input "dnsName" :flattened? nil :xmlAttribute? nil), "splitTunnel" (portkey.aws/search-for-tag input "splitTunnel" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar634613 "associatedTargetNetwork") (clojure.core/assoc :associated-target-networks (deser-associated-target-network-set (clojure.core/get-in letvar634613 ["associatedTargetNetwork" :content]))) (letvar634613 "dnsName") (clojure.core/assoc :dns-name (deser-string (clojure.core/get-in letvar634613 ["dnsName" :content]))) (letvar634613 "vpnProtocol") (clojure.core/assoc :vpn-protocol (deser-vpn-protocol (clojure.core/get-in letvar634613 ["vpnProtocol" :content]))) (letvar634613 "clientCidrBlock") (clojure.core/assoc :client-cidr-block (deser-string (clojure.core/get-in letvar634613 ["clientCidrBlock" :content]))) (letvar634613 "deletionTime") (clojure.core/assoc :deletion-time (deser-string (clojure.core/get-in letvar634613 ["deletionTime" :content]))) (letvar634613 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar634613 ["tagSet" :content]))) (letvar634613 "status") (clojure.core/assoc :status (deser-client-vpn-endpoint-status (clojure.core/get-in letvar634613 ["status" :content]))) (letvar634613 "authenticationOptions") (clojure.core/assoc :authentication-options (deser-client-vpn-authentication-list (clojure.core/get-in letvar634613 ["authenticationOptions" :content]))) (letvar634613 "connectionLogOptions") (clojure.core/assoc :connection-log-options (deser-connection-log-response-options (clojure.core/get-in letvar634613 ["connectionLogOptions" :content]))) (letvar634613 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar634613 ["description" :content]))) (letvar634613 "serverCertificateArn") (clojure.core/assoc :server-certificate-arn (deser-string (clojure.core/get-in letvar634613 ["serverCertificateArn" :content]))) (letvar634613 "creationTime") (clojure.core/assoc :creation-time (deser-string (clojure.core/get-in letvar634613 ["creationTime" :content]))) (letvar634613 "transportProtocol") (clojure.core/assoc :transport-protocol (deser-transport-protocol (clojure.core/get-in letvar634613 ["transportProtocol" :content]))) (letvar634613 "dnsServer") (clojure.core/assoc :dns-servers (deser-value-string-list (clojure.core/get-in letvar634613 ["dnsServer" :content]))) (letvar634613 "splitTunnel") (clojure.core/assoc :split-tunnel (deser-boolean (clojure.core/get-in letvar634613 ["splitTunnel" :content]))) (letvar634613 "clientVpnEndpointId") (clojure.core/assoc :client-vpn-endpoint-id (deser-string (clojure.core/get-in letvar634613 ["clientVpnEndpointId" :content]))))))

(clojure.core/defn- deser-launch-template-config [input] (clojure.core/let [letvar634721 {"launchTemplateSpecification" (portkey.aws/search-for-tag input "launchTemplateSpecification" :flattened? nil :xmlAttribute? nil), "overrides" (portkey.aws/search-for-tag input "overrides" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar634721 "launchTemplateSpecification") (clojure.core/assoc :launch-template-specification (deser-fleet-launch-template-specification (clojure.core/get-in letvar634721 ["launchTemplateSpecification" :content]))) (letvar634721 "overrides") (clojure.core/assoc :overrides (deser-launch-template-overrides-list (clojure.core/get-in letvar634721 ["overrides" :content]))))))

(clojure.core/defn- deser-propagating-vgw-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-propagating-vgw coll))) input))

(clojure.core/defn- deser-disk-image-format [input] (clojure.core/get {"VMDK" :vmdk, "RAW" :raw, "VHD" :vhd} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-network-interface-attachment [input] (clojure.core/let [letvar634851 {"attachTime" (portkey.aws/search-for-tag input "attachTime" :flattened? nil :xmlAttribute? nil), "attachmentId" (portkey.aws/search-for-tag input "attachmentId" :flattened? nil :xmlAttribute? nil), "deleteOnTermination" (portkey.aws/search-for-tag input "deleteOnTermination" :flattened? nil :xmlAttribute? nil), "deviceIndex" (portkey.aws/search-for-tag input "deviceIndex" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "instanceOwnerId" (portkey.aws/search-for-tag input "instanceOwnerId" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar634851 "attachTime") (clojure.core/assoc :attach-time (deser-date-time (clojure.core/get-in letvar634851 ["attachTime" :content]))) (letvar634851 "attachmentId") (clojure.core/assoc :attachment-id (deser-string (clojure.core/get-in letvar634851 ["attachmentId" :content]))) (letvar634851 "deleteOnTermination") (clojure.core/assoc :delete-on-termination (deser-boolean (clojure.core/get-in letvar634851 ["deleteOnTermination" :content]))) (letvar634851 "deviceIndex") (clojure.core/assoc :device-index (deser-integer (clojure.core/get-in letvar634851 ["deviceIndex" :content]))) (letvar634851 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar634851 ["instanceId" :content]))) (letvar634851 "instanceOwnerId") (clojure.core/assoc :instance-owner-id (deser-string (clojure.core/get-in letvar634851 ["instanceOwnerId" :content]))) (letvar634851 "status") (clojure.core/assoc :status (deser-attachment-status (clojure.core/get-in letvar634851 ["status" :content]))))))

(clojure.core/defn- deser-security-group-id-string-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-spot-fleet-request-config [input] (clojure.core/let [letvar634976 {"activityStatus" (portkey.aws/search-for-tag input "activityStatus" :flattened? nil :xmlAttribute? nil), "createTime" (portkey.aws/search-for-tag input "createTime" :flattened? nil :xmlAttribute? nil), "spotFleetRequestConfig" (portkey.aws/search-for-tag input "spotFleetRequestConfig" :flattened? nil :xmlAttribute? nil), "spotFleetRequestId" (portkey.aws/search-for-tag input "spotFleetRequestId" :flattened? nil :xmlAttribute? nil), "spotFleetRequestState" (portkey.aws/search-for-tag input "spotFleetRequestState" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar634976 "activityStatus") (clojure.core/assoc :activity-status (deser-activity-status (clojure.core/get-in letvar634976 ["activityStatus" :content]))) (letvar634976 "createTime") (clojure.core/assoc :create-time (deser-date-time (clojure.core/get-in letvar634976 ["createTime" :content]))) (letvar634976 "spotFleetRequestConfig") (clojure.core/assoc :spot-fleet-request-config (deser-spot-fleet-request-config-data (clojure.core/get-in letvar634976 ["spotFleetRequestConfig" :content]))) (letvar634976 "spotFleetRequestId") (clojure.core/assoc :spot-fleet-request-id (deser-string (clojure.core/get-in letvar634976 ["spotFleetRequestId" :content]))) (letvar634976 "spotFleetRequestState") (clojure.core/assoc :spot-fleet-request-state (deser-batch-state (clojure.core/get-in letvar634976 ["spotFleetRequestState" :content]))))))

(clojure.core/defn- deser-domain-type [input] (clojure.core/get {"vpc" :vpc, "standard" :standard} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-vgw-telemetry [input] (clojure.core/let [letvar635089 {"acceptedRouteCount" (portkey.aws/search-for-tag input "acceptedRouteCount" :flattened? nil :xmlAttribute? nil), "lastStatusChange" (portkey.aws/search-for-tag input "lastStatusChange" :flattened? nil :xmlAttribute? nil), "outsideIpAddress" (portkey.aws/search-for-tag input "outsideIpAddress" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar635089 "acceptedRouteCount") (clojure.core/assoc :accepted-route-count (deser-integer (clojure.core/get-in letvar635089 ["acceptedRouteCount" :content]))) (letvar635089 "lastStatusChange") (clojure.core/assoc :last-status-change (deser-date-time (clojure.core/get-in letvar635089 ["lastStatusChange" :content]))) (letvar635089 "outsideIpAddress") (clojure.core/assoc :outside-ip-address (deser-string (clojure.core/get-in letvar635089 ["outsideIpAddress" :content]))) (letvar635089 "status") (clojure.core/assoc :status (deser-telemetry-status (clojure.core/get-in letvar635089 ["status" :content]))) (letvar635089 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar635089 ["statusMessage" :content]))))))

(clojure.core/defn- deser-cancel-spot-instance-request-state [input] (clojure.core/get {"active" :active, "open" :open, "closed" :closed, "cancelled" :cancelled, "completed" :completed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-subnet-ipv-6-cidr-block-association-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-subnet-ipv-6-cidr-block-association coll))) input))

(clojure.core/defn- deser-network-interface [input] (clojure.core/let [letvar635219 {"groupSet" (portkey.aws/search-for-tag input "groupSet" :flattened? nil :xmlAttribute? nil), "association" (portkey.aws/search-for-tag input "association" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "privateIpAddressesSet" (portkey.aws/search-for-tag input "privateIpAddressesSet" :flattened? nil :xmlAttribute? nil), "privateIpAddress" (portkey.aws/search-for-tag input "privateIpAddress" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "requesterId" (portkey.aws/search-for-tag input "requesterId" :flattened? nil :xmlAttribute? nil), "interfaceType" (portkey.aws/search-for-tag input "interfaceType" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "privateDnsName" (portkey.aws/search-for-tag input "privateDnsName" :flattened? nil :xmlAttribute? nil), "macAddress" (portkey.aws/search-for-tag input "macAddress" :flattened? nil :xmlAttribute? nil), "attachment" (portkey.aws/search-for-tag input "attachment" :flattened? nil :xmlAttribute? nil), "sourceDestCheck" (portkey.aws/search-for-tag input "sourceDestCheck" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "ipv6AddressesSet" (portkey.aws/search-for-tag input "ipv6AddressesSet" :flattened? nil :xmlAttribute? nil), "networkInterfaceId" (portkey.aws/search-for-tag input "networkInterfaceId" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "requesterManaged" (portkey.aws/search-for-tag input "requesterManaged" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar635219 "attachment") (clojure.core/assoc :attachment (deser-network-interface-attachment (clojure.core/get-in letvar635219 ["attachment" :content]))) (letvar635219 "tagSet") (clojure.core/assoc :tag-set (deser-tag-list (clojure.core/get-in letvar635219 ["tagSet" :content]))) (letvar635219 "ipv6AddressesSet") (clojure.core/assoc :ipv-6-addresses (deser-network-interface-ipv-6-addresses-list (clojure.core/get-in letvar635219 ["ipv6AddressesSet" :content]))) (letvar635219 "interfaceType") (clojure.core/assoc :interface-type (deser-network-interface-type (clojure.core/get-in letvar635219 ["interfaceType" :content]))) (letvar635219 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar635219 ["subnetId" :content]))) (letvar635219 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar635219 ["ownerId" :content]))) (letvar635219 "macAddress") (clojure.core/assoc :mac-address (deser-string (clojure.core/get-in letvar635219 ["macAddress" :content]))) (letvar635219 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar635219 ["networkInterfaceId" :content]))) (letvar635219 "sourceDestCheck") (clojure.core/assoc :source-dest-check (deser-boolean (clojure.core/get-in letvar635219 ["sourceDestCheck" :content]))) (letvar635219 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar635219 ["availabilityZone" :content]))) (letvar635219 "status") (clojure.core/assoc :status (deser-network-interface-status (clojure.core/get-in letvar635219 ["status" :content]))) (letvar635219 "privateDnsName") (clojure.core/assoc :private-dns-name (deser-string (clojure.core/get-in letvar635219 ["privateDnsName" :content]))) (letvar635219 "requesterManaged") (clojure.core/assoc :requester-managed (deser-boolean (clojure.core/get-in letvar635219 ["requesterManaged" :content]))) (letvar635219 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar635219 ["description" :content]))) (letvar635219 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar635219 ["vpcId" :content]))) (letvar635219 "groupSet") (clojure.core/assoc :groups (deser-group-identifier-list (clojure.core/get-in letvar635219 ["groupSet" :content]))) (letvar635219 "privateIpAddressesSet") (clojure.core/assoc :private-ip-addresses (deser-network-interface-private-ip-address-list (clojure.core/get-in letvar635219 ["privateIpAddressesSet" :content]))) (letvar635219 "association") (clojure.core/assoc :association (deser-network-interface-association (clojure.core/get-in letvar635219 ["association" :content]))) (letvar635219 "requesterId") (clojure.core/assoc :requester-id (deser-string (clojure.core/get-in letvar635219 ["requesterId" :content]))) (letvar635219 "privateIpAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar635219 ["privateIpAddress" :content]))))))

(clojure.core/defn- deser-launch-template-name [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-snapshot [input] (clojure.core/let [letvar635332 {"progress" (portkey.aws/search-for-tag input "progress" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "kmsKeyId" (portkey.aws/search-for-tag input "kmsKeyId" :flattened? nil :xmlAttribute? nil), "encrypted" (portkey.aws/search-for-tag input "encrypted" :flattened? nil :xmlAttribute? nil), "startTime" (portkey.aws/search-for-tag input "startTime" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "dataEncryptionKeyId" (portkey.aws/search-for-tag input "dataEncryptionKeyId" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil), "volumeId" (portkey.aws/search-for-tag input "volumeId" :flattened? nil :xmlAttribute? nil), "snapshotId" (portkey.aws/search-for-tag input "snapshotId" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "volumeSize" (portkey.aws/search-for-tag input "volumeSize" :flattened? nil :xmlAttribute? nil), "ownerAlias" (portkey.aws/search-for-tag input "ownerAlias" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar635332 "startTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar635332 ["startTime" :content]))) (letvar635332 "statusMessage") (clojure.core/assoc :state-message (deser-string (clojure.core/get-in letvar635332 ["statusMessage" :content]))) (letvar635332 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar635332 ["ownerId" :content]))) (letvar635332 "encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar635332 ["encrypted" :content]))) (letvar635332 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar635332 ["tagSet" :content]))) (letvar635332 "ownerAlias") (clojure.core/assoc :owner-alias (deser-string (clojure.core/get-in letvar635332 ["ownerAlias" :content]))) (letvar635332 "progress") (clojure.core/assoc :progress (deser-string (clojure.core/get-in letvar635332 ["progress" :content]))) (letvar635332 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar635332 ["description" :content]))) (letvar635332 "dataEncryptionKeyId") (clojure.core/assoc :data-encryption-key-id (deser-string (clojure.core/get-in letvar635332 ["dataEncryptionKeyId" :content]))) (letvar635332 "kmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar635332 ["kmsKeyId" :content]))) (letvar635332 "volumeId") (clojure.core/assoc :volume-id (deser-string (clojure.core/get-in letvar635332 ["volumeId" :content]))) (letvar635332 "status") (clojure.core/assoc :state (deser-snapshot-state (clojure.core/get-in letvar635332 ["status" :content]))) (letvar635332 "volumeSize") (clojure.core/assoc :volume-size (deser-integer (clojure.core/get-in letvar635332 ["volumeSize" :content]))) (letvar635332 "snapshotId") (clojure.core/assoc :snapshot-id (deser-string (clojure.core/get-in letvar635332 ["snapshotId" :content]))))))

(clojure.core/defn- deser-resource-type [input] (clojure.core/get {"vpn-gateway" :vpngateway, "subnet" :subnet, "transit-gateway" :transitgateway, "vpc" :vpc, "elastic-ip" :elasticip, "dedicated-host" :dedicatedhost, "spot-instances-request" :spotinstancesrequest, "route-table" :routetable, "image" :image, "natgateway" :natgateway, "transit-gateway-route-table" :transitgatewayroutetable, "snapshot" :snapshot, "vpn-connection" :vpnconnection, "internet-gateway" :internetgateway, "reserved-instances" :reservedinstances, "instance" :instance, "fleet" :fleet, "network-interface" :networkinterface, "security-group" :securitygroup, "volume" :volume, "dhcp-options" :dhcpoptions, "vpc-peering-connection" :vpcpeeringconnection, "customer-gateway" :customergateway, "fpga-image" :fpgaimage, "network-acl" :networkacl, "client-vpn-endpoint" :clientvpnendpoint, "launch-template" :launchtemplate, "transit-gateway-attachment" :transitgatewayattachment} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-instance-status-event [input] (clojure.core/let [letvar635445 {"instanceEventId" (portkey.aws/search-for-tag input "instanceEventId" :flattened? nil :xmlAttribute? nil), "code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "notAfter" (portkey.aws/search-for-tag input "notAfter" :flattened? nil :xmlAttribute? nil), "notBefore" (portkey.aws/search-for-tag input "notBefore" :flattened? nil :xmlAttribute? nil), "notBeforeDeadline" (portkey.aws/search-for-tag input "notBeforeDeadline" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar635445 "instanceEventId") (clojure.core/assoc :instance-event-id (deser-instance-event-id (clojure.core/get-in letvar635445 ["instanceEventId" :content]))) (letvar635445 "code") (clojure.core/assoc :code (deser-event-code (clojure.core/get-in letvar635445 ["code" :content]))) (letvar635445 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar635445 ["description" :content]))) (letvar635445 "notAfter") (clojure.core/assoc :not-after (deser-date-time (clojure.core/get-in letvar635445 ["notAfter" :content]))) (letvar635445 "notBefore") (clojure.core/assoc :not-before (deser-date-time (clojure.core/get-in letvar635445 ["notBefore" :content]))) (letvar635445 "notBeforeDeadline") (clojure.core/assoc :not-before-deadline (deser-date-time (clojure.core/get-in letvar635445 ["notBeforeDeadline" :content]))))))

(clojure.core/defn- deser-vpc-peering-connection-options-description [input] (clojure.core/let [letvar635553 {"allowDnsResolutionFromRemoteVpc" (portkey.aws/search-for-tag input "allowDnsResolutionFromRemoteVpc" :flattened? nil :xmlAttribute? nil), "allowEgressFromLocalClassicLinkToRemoteVpc" (portkey.aws/search-for-tag input "allowEgressFromLocalClassicLinkToRemoteVpc" :flattened? nil :xmlAttribute? nil), "allowEgressFromLocalVpcToRemoteClassicLink" (portkey.aws/search-for-tag input "allowEgressFromLocalVpcToRemoteClassicLink" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar635553 "allowDnsResolutionFromRemoteVpc") (clojure.core/assoc :allow-dns-resolution-from-remote-vpc (deser-boolean (clojure.core/get-in letvar635553 ["allowDnsResolutionFromRemoteVpc" :content]))) (letvar635553 "allowEgressFromLocalClassicLinkToRemoteVpc") (clojure.core/assoc :allow-egress-from-local-classic-link-to-remote-vpc (deser-boolean (clojure.core/get-in letvar635553 ["allowEgressFromLocalClassicLinkToRemoteVpc" :content]))) (letvar635553 "allowEgressFromLocalVpcToRemoteClassicLink") (clojure.core/assoc :allow-egress-from-local-vpc-to-remote-classic-link (deser-boolean (clojure.core/get-in letvar635553 ["allowEgressFromLocalVpcToRemoteClassicLink" :content]))))))

(clojure.core/defn- deser-transit-gateway-options [input] (clojure.core/let [letvar635661 {"amazonSideAsn" (portkey.aws/search-for-tag input "amazonSideAsn" :flattened? nil :xmlAttribute? nil), "autoAcceptSharedAttachments" (portkey.aws/search-for-tag input "autoAcceptSharedAttachments" :flattened? nil :xmlAttribute? nil), "defaultRouteTableAssociation" (portkey.aws/search-for-tag input "defaultRouteTableAssociation" :flattened? nil :xmlAttribute? nil), "associationDefaultRouteTableId" (portkey.aws/search-for-tag input "associationDefaultRouteTableId" :flattened? nil :xmlAttribute? nil), "defaultRouteTablePropagation" (portkey.aws/search-for-tag input "defaultRouteTablePropagation" :flattened? nil :xmlAttribute? nil), "propagationDefaultRouteTableId" (portkey.aws/search-for-tag input "propagationDefaultRouteTableId" :flattened? nil :xmlAttribute? nil), "vpnEcmpSupport" (portkey.aws/search-for-tag input "vpnEcmpSupport" :flattened? nil :xmlAttribute? nil), "dnsSupport" (portkey.aws/search-for-tag input "dnsSupport" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar635661 "amazonSideAsn") (clojure.core/assoc :amazon-side-asn (deser-long (clojure.core/get-in letvar635661 ["amazonSideAsn" :content]))) (letvar635661 "autoAcceptSharedAttachments") (clojure.core/assoc :auto-accept-shared-attachments (deser-auto-accept-shared-attachments-value (clojure.core/get-in letvar635661 ["autoAcceptSharedAttachments" :content]))) (letvar635661 "defaultRouteTableAssociation") (clojure.core/assoc :default-route-table-association (deser-default-route-table-association-value (clojure.core/get-in letvar635661 ["defaultRouteTableAssociation" :content]))) (letvar635661 "associationDefaultRouteTableId") (clojure.core/assoc :association-default-route-table-id (deser-string (clojure.core/get-in letvar635661 ["associationDefaultRouteTableId" :content]))) (letvar635661 "defaultRouteTablePropagation") (clojure.core/assoc :default-route-table-propagation (deser-default-route-table-propagation-value (clojure.core/get-in letvar635661 ["defaultRouteTablePropagation" :content]))) (letvar635661 "propagationDefaultRouteTableId") (clojure.core/assoc :propagation-default-route-table-id (deser-string (clojure.core/get-in letvar635661 ["propagationDefaultRouteTableId" :content]))) (letvar635661 "vpnEcmpSupport") (clojure.core/assoc :vpn-ecmp-support (deser-vpn-ecmp-support-value (clojure.core/get-in letvar635661 ["vpnEcmpSupport" :content]))) (letvar635661 "dnsSupport") (clojure.core/assoc :dns-support (deser-dns-support-value (clojure.core/get-in letvar635661 ["dnsSupport" :content]))))))

(clojure.core/defn- deser-volume-status-name [input] (clojure.core/get {"io-enabled" :ioenabled, "io-performance" :ioperformance} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-internet-gateway [input] (clojure.core/let [letvar635774 {"attachmentSet" (portkey.aws/search-for-tag input "attachmentSet" :flattened? nil :xmlAttribute? nil), "internetGatewayId" (portkey.aws/search-for-tag input "internetGatewayId" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar635774 "attachmentSet") (clojure.core/assoc :attachments (deser-internet-gateway-attachment-list (clojure.core/get-in letvar635774 ["attachmentSet" :content]))) (letvar635774 "internetGatewayId") (clojure.core/assoc :internet-gateway-id (deser-string (clojure.core/get-in letvar635774 ["internetGatewayId" :content]))) (letvar635774 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar635774 ["ownerId" :content]))) (letvar635774 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar635774 ["tagSet" :content]))))))

(clojure.core/defn- deser-vpc [input] (clojure.core/let [letvar635882 {"tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "ipv6CidrBlockAssociationSet" (portkey.aws/search-for-tag input "ipv6CidrBlockAssociationSet" :flattened? nil :xmlAttribute? nil), "cidrBlockAssociationSet" (portkey.aws/search-for-tag input "cidrBlockAssociationSet" :flattened? nil :xmlAttribute? nil), "instanceTenancy" (portkey.aws/search-for-tag input "instanceTenancy" :flattened? nil :xmlAttribute? nil), "cidrBlock" (portkey.aws/search-for-tag input "cidrBlock" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "dhcpOptionsId" (portkey.aws/search-for-tag input "dhcpOptionsId" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil), "isDefault" (portkey.aws/search-for-tag input "isDefault" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar635882 "cidrBlockAssociationSet") (clojure.core/assoc :cidr-block-association-set (deser-vpc-cidr-block-association-set (clojure.core/get-in letvar635882 ["cidrBlockAssociationSet" :content]))) (letvar635882 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar635882 ["ownerId" :content]))) (letvar635882 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar635882 ["tagSet" :content]))) (letvar635882 "cidrBlock") (clojure.core/assoc :cidr-block (deser-string (clojure.core/get-in letvar635882 ["cidrBlock" :content]))) (letvar635882 "instanceTenancy") (clojure.core/assoc :instance-tenancy (deser-tenancy (clojure.core/get-in letvar635882 ["instanceTenancy" :content]))) (letvar635882 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar635882 ["vpcId" :content]))) (letvar635882 "state") (clojure.core/assoc :state (deser-vpc-state (clojure.core/get-in letvar635882 ["state" :content]))) (letvar635882 "dhcpOptionsId") (clojure.core/assoc :dhcp-options-id (deser-string (clojure.core/get-in letvar635882 ["dhcpOptionsId" :content]))) (letvar635882 "isDefault") (clojure.core/assoc :is-default (deser-boolean (clojure.core/get-in letvar635882 ["isDefault" :content]))) (letvar635882 "ipv6CidrBlockAssociationSet") (clojure.core/assoc :ipv-6-cidr-block-association-set (deser-vpc-ipv-6-cidr-block-association-set (clojure.core/get-in letvar635882 ["ipv6CidrBlockAssociationSet" :content]))))))

(clojure.core/defn- deser-ipv-6-address-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-transit-gateway-route-state [input] (clojure.core/get {"pending" :pending, "active" :active, "blackhole" :blackhole, "deleting" :deleting, "deleted" :deleted} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-network-interface-permission-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-network-interface-permission coll))) input))

(clojure.core/defn- deser-batch-state [input] (clojure.core/get {"submitted" :submitted, "active" :active, "cancelled" :cancelled, "failed" :failed, "cancelled_running" :cancelled-running, "cancelled_terminating" :cancelled-terminating, "modifying" :modifying} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-fleet-on-demand-allocation-strategy [input] (clojure.core/get {"lowest-price" :lowestprice, "prioritized" :prioritized} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-reservation-value [input] (clojure.core/let [letvar636039 {"hourlyPrice" (portkey.aws/search-for-tag input "hourlyPrice" :flattened? nil :xmlAttribute? nil), "remainingTotalValue" (portkey.aws/search-for-tag input "remainingTotalValue" :flattened? nil :xmlAttribute? nil), "remainingUpfrontValue" (portkey.aws/search-for-tag input "remainingUpfrontValue" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar636039 "hourlyPrice") (clojure.core/assoc :hourly-price (deser-string (clojure.core/get-in letvar636039 ["hourlyPrice" :content]))) (letvar636039 "remainingTotalValue") (clojure.core/assoc :remaining-total-value (deser-string (clojure.core/get-in letvar636039 ["remainingTotalValue" :content]))) (letvar636039 "remainingUpfrontValue") (clojure.core/assoc :remaining-upfront-value (deser-string (clojure.core/get-in letvar636039 ["remainingUpfrontValue" :content]))))))

(clojure.core/defn- deser-host-instance [input] (clojure.core/let [letvar636147 {"instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar636147 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar636147 ["instanceId" :content]))) (letvar636147 "instanceType") (clojure.core/assoc :instance-type (deser-string (clojure.core/get-in letvar636147 ["instanceType" :content]))))))

(clojure.core/defn- deser-launch-template-cpu-options [input] (clojure.core/let [letvar636255 {"coreCount" (portkey.aws/search-for-tag input "coreCount" :flattened? nil :xmlAttribute? nil), "threadsPerCore" (portkey.aws/search-for-tag input "threadsPerCore" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar636255 "coreCount") (clojure.core/assoc :core-count (deser-integer (clojure.core/get-in letvar636255 ["coreCount" :content]))) (letvar636255 "threadsPerCore") (clojure.core/assoc :threads-per-core (deser-integer (clojure.core/get-in letvar636255 ["threadsPerCore" :content]))))))

(clojure.core/defn- deser-currency-code-values [input] (clojure.core/get {"USD" :usd} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-import-image-task [input] (clojure.core/let [letvar636368 {"architecture" (portkey.aws/search-for-tag input "architecture" :flattened? nil :xmlAttribute? nil), "progress" (portkey.aws/search-for-tag input "progress" :flattened? nil :xmlAttribute? nil), "snapshotDetailSet" (portkey.aws/search-for-tag input "snapshotDetailSet" :flattened? nil :xmlAttribute? nil), "kmsKeyId" (portkey.aws/search-for-tag input "kmsKeyId" :flattened? nil :xmlAttribute? nil), "licenseType" (portkey.aws/search-for-tag input "licenseType" :flattened? nil :xmlAttribute? nil), "encrypted" (portkey.aws/search-for-tag input "encrypted" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "imageId" (portkey.aws/search-for-tag input "imageId" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil), "importTaskId" (portkey.aws/search-for-tag input "importTaskId" :flattened? nil :xmlAttribute? nil), "hypervisor" (portkey.aws/search-for-tag input "hypervisor" :flattened? nil :xmlAttribute? nil), "platform" (portkey.aws/search-for-tag input "platform" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar636368 "platform") (clojure.core/assoc :platform (deser-string (clojure.core/get-in letvar636368 ["platform" :content]))) (letvar636368 "importTaskId") (clojure.core/assoc :import-task-id (deser-string (clojure.core/get-in letvar636368 ["importTaskId" :content]))) (letvar636368 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar636368 ["imageId" :content]))) (letvar636368 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar636368 ["statusMessage" :content]))) (letvar636368 "encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar636368 ["encrypted" :content]))) (letvar636368 "status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar636368 ["status" :content]))) (letvar636368 "progress") (clojure.core/assoc :progress (deser-string (clojure.core/get-in letvar636368 ["progress" :content]))) (letvar636368 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar636368 ["description" :content]))) (letvar636368 "snapshotDetailSet") (clojure.core/assoc :snapshot-details (deser-snapshot-detail-list (clojure.core/get-in letvar636368 ["snapshotDetailSet" :content]))) (letvar636368 "kmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar636368 ["kmsKeyId" :content]))) (letvar636368 "hypervisor") (clojure.core/assoc :hypervisor (deser-string (clojure.core/get-in letvar636368 ["hypervisor" :content]))) (letvar636368 "architecture") (clojure.core/assoc :architecture (deser-string (clojure.core/get-in letvar636368 ["architecture" :content]))) (letvar636368 "licenseType") (clojure.core/assoc :license-type (deser-string (clojure.core/get-in letvar636368 ["licenseType" :content]))))))

(clojure.core/defn- deser-load-permission [input] (clojure.core/let [letvar636476 {"userId" (portkey.aws/search-for-tag input "userId" :flattened? nil :xmlAttribute? nil), "group" (portkey.aws/search-for-tag input "group" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar636476 "userId") (clojure.core/assoc :user-id (deser-string (clojure.core/get-in letvar636476 ["userId" :content]))) (letvar636476 "group") (clojure.core/assoc :group (deser-permission-group (clojure.core/get-in letvar636476 ["group" :content]))))))

(clojure.core/defn- deser-volume-status-details-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-volume-status-details coll))) input))

(clojure.core/defn- deser-byoip-cidr-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-byoip-cidr coll))) input))

(clojure.core/defn- deser-fleet-launch-template-overrides-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-fleet-launch-template-overrides coll))) input))

(clojure.core/defn- deser-summary-status [input] (clojure.core/get {"ok" :ok, "impaired" :impaired, "insufficient-data" :insufficientdata, "not-applicable" :notapplicable, "initializing" :initializing} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-fleet-launch-template-overrides [input] (clojure.core/let [letvar636640 {"instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "maxPrice" (portkey.aws/search-for-tag input "maxPrice" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "weightedCapacity" (portkey.aws/search-for-tag input "weightedCapacity" :flattened? nil :xmlAttribute? nil), "priority" (portkey.aws/search-for-tag input "priority" :flattened? nil :xmlAttribute? nil), "placement" (portkey.aws/search-for-tag input "placement" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar636640 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar636640 ["instanceType" :content]))) (letvar636640 "maxPrice") (clojure.core/assoc :max-price (deser-string (clojure.core/get-in letvar636640 ["maxPrice" :content]))) (letvar636640 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar636640 ["subnetId" :content]))) (letvar636640 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar636640 ["availabilityZone" :content]))) (letvar636640 "weightedCapacity") (clojure.core/assoc :weighted-capacity (deser-double (clojure.core/get-in letvar636640 ["weightedCapacity" :content]))) (letvar636640 "priority") (clojure.core/assoc :priority (deser-double (clojure.core/get-in letvar636640 ["priority" :content]))) (letvar636640 "placement") (clojure.core/assoc :placement (deser-placement-response (clojure.core/get-in letvar636640 ["placement" :content]))))))

(clojure.core/defn- deser-instance-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance coll))) input))

(clojure.core/defn- deser-launch-template-elastic-inference-accelerator-response-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-launch-template-elastic-inference-accelerator-response coll))) input))

(clojure.core/defn- deser-volume-type [input] (clojure.core/get {"standard" :standard, "io1" :io-1, "gp2" :gp-2, "sc1" :sc-1, "st1" :st-1} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-capacity-reservation-state [input] (clojure.core/get {"active" :active, "expired" :expired, "cancelled" :cancelled, "pending" :pending, "failed" :failed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-client-vpn-route-status-code [input] (clojure.core/get {"creating" :creating, "active" :active, "failed" :failed, "deleting" :deleting} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-customer-gateway [input] (clojure.core/let [letvar636797 {"bgpAsn" (portkey.aws/search-for-tag input "bgpAsn" :flattened? nil :xmlAttribute? nil), "customerGatewayId" (portkey.aws/search-for-tag input "customerGatewayId" :flattened? nil :xmlAttribute? nil), "ipAddress" (portkey.aws/search-for-tag input "ipAddress" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar636797 "bgpAsn") (clojure.core/assoc :bgp-asn (deser-string (clojure.core/get-in letvar636797 ["bgpAsn" :content]))) (letvar636797 "customerGatewayId") (clojure.core/assoc :customer-gateway-id (deser-string (clojure.core/get-in letvar636797 ["customerGatewayId" :content]))) (letvar636797 "ipAddress") (clojure.core/assoc :ip-address (deser-string (clojure.core/get-in letvar636797 ["ipAddress" :content]))) (letvar636797 "state") (clojure.core/assoc :state (deser-string (clojure.core/get-in letvar636797 ["state" :content]))) (letvar636797 "type") (clojure.core/assoc :type (deser-string (clojure.core/get-in letvar636797 ["type" :content]))) (letvar636797 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar636797 ["tagSet" :content]))))))

(clojure.core/defn- deser-network-interface-permission [input] (clojure.core/let [letvar636905 {"networkInterfacePermissionId" (portkey.aws/search-for-tag input "networkInterfacePermissionId" :flattened? nil :xmlAttribute? nil), "networkInterfaceId" (portkey.aws/search-for-tag input "networkInterfaceId" :flattened? nil :xmlAttribute? nil), "awsAccountId" (portkey.aws/search-for-tag input "awsAccountId" :flattened? nil :xmlAttribute? nil), "awsService" (portkey.aws/search-for-tag input "awsService" :flattened? nil :xmlAttribute? nil), "permission" (portkey.aws/search-for-tag input "permission" :flattened? nil :xmlAttribute? nil), "permissionState" (portkey.aws/search-for-tag input "permissionState" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar636905 "networkInterfacePermissionId") (clojure.core/assoc :network-interface-permission-id (deser-string (clojure.core/get-in letvar636905 ["networkInterfacePermissionId" :content]))) (letvar636905 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar636905 ["networkInterfaceId" :content]))) (letvar636905 "awsAccountId") (clojure.core/assoc :aws-account-id (deser-string (clojure.core/get-in letvar636905 ["awsAccountId" :content]))) (letvar636905 "awsService") (clojure.core/assoc :aws-service (deser-string (clojure.core/get-in letvar636905 ["awsService" :content]))) (letvar636905 "permission") (clojure.core/assoc :permission (deser-interface-permission-type (clojure.core/get-in letvar636905 ["permission" :content]))) (letvar636905 "permissionState") (clojure.core/assoc :permission-state (deser-network-interface-permission-state (clojure.core/get-in letvar636905 ["permissionState" :content]))))))

(clojure.core/defn- deser-response-host-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-transit-gateway-route-table-association [input] (clojure.core/let [letvar637030 {"transitGatewayAttachmentId" (portkey.aws/search-for-tag input "transitGatewayAttachmentId" :flattened? nil :xmlAttribute? nil), "resourceId" (portkey.aws/search-for-tag input "resourceId" :flattened? nil :xmlAttribute? nil), "resourceType" (portkey.aws/search-for-tag input "resourceType" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar637030 "transitGatewayAttachmentId") (clojure.core/assoc :transit-gateway-attachment-id (deser-string (clojure.core/get-in letvar637030 ["transitGatewayAttachmentId" :content]))) (letvar637030 "resourceId") (clojure.core/assoc :resource-id (deser-string (clojure.core/get-in letvar637030 ["resourceId" :content]))) (letvar637030 "resourceType") (clojure.core/assoc :resource-type (deser-transit-gateway-attachment-resource-type (clojure.core/get-in letvar637030 ["resourceType" :content]))) (letvar637030 "state") (clojure.core/assoc :state (deser-transit-gateway-association-state (clojure.core/get-in letvar637030 ["state" :content]))))))

(clojure.core/defn- deser-vpn-ecmp-support-value [input] (clojure.core/get {"enable" :enable, "disable" :disable} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-vpc-cidr-block-association [input] (clojure.core/let [letvar637143 {"associationId" (portkey.aws/search-for-tag input "associationId" :flattened? nil :xmlAttribute? nil), "cidrBlock" (portkey.aws/search-for-tag input "cidrBlock" :flattened? nil :xmlAttribute? nil), "cidrBlockState" (portkey.aws/search-for-tag input "cidrBlockState" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar637143 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar637143 ["associationId" :content]))) (letvar637143 "cidrBlock") (clojure.core/assoc :cidr-block (deser-string (clojure.core/get-in letvar637143 ["cidrBlock" :content]))) (letvar637143 "cidrBlockState") (clojure.core/assoc :cidr-block-state (deser-vpc-cidr-block-state (clojure.core/get-in letvar637143 ["cidrBlockState" :content]))))))

(clojure.core/defn- deser-launch-template-instance-network-interface-specification [input] (clojure.core/let [letvar637251 {"associatePublicIpAddress" (portkey.aws/search-for-tag input "associatePublicIpAddress" :flattened? nil :xmlAttribute? nil), "groupSet" (portkey.aws/search-for-tag input "groupSet" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "privateIpAddressesSet" (portkey.aws/search-for-tag input "privateIpAddressesSet" :flattened? nil :xmlAttribute? nil), "privateIpAddress" (portkey.aws/search-for-tag input "privateIpAddress" :flattened? nil :xmlAttribute? nil), "secondaryPrivateIpAddressCount" (portkey.aws/search-for-tag input "secondaryPrivateIpAddressCount" :flattened? nil :xmlAttribute? nil), "deleteOnTermination" (portkey.aws/search-for-tag input "deleteOnTermination" :flattened? nil :xmlAttribute? nil), "ipv6AddressesSet" (portkey.aws/search-for-tag input "ipv6AddressesSet" :flattened? nil :xmlAttribute? nil), "deviceIndex" (portkey.aws/search-for-tag input "deviceIndex" :flattened? nil :xmlAttribute? nil), "ipv6AddressCount" (portkey.aws/search-for-tag input "ipv6AddressCount" :flattened? nil :xmlAttribute? nil), "networkInterfaceId" (portkey.aws/search-for-tag input "networkInterfaceId" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar637251 "associatePublicIpAddress") (clojure.core/assoc :associate-public-ip-address (deser-boolean (clojure.core/get-in letvar637251 ["associatePublicIpAddress" :content]))) (letvar637251 "ipv6AddressesSet") (clojure.core/assoc :ipv-6-addresses (deser-instance-ipv-6-address-list (clojure.core/get-in letvar637251 ["ipv6AddressesSet" :content]))) (letvar637251 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar637251 ["subnetId" :content]))) (letvar637251 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar637251 ["networkInterfaceId" :content]))) (letvar637251 "deviceIndex") (clojure.core/assoc :device-index (deser-integer (clojure.core/get-in letvar637251 ["deviceIndex" :content]))) (letvar637251 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar637251 ["description" :content]))) (letvar637251 "groupSet") (clojure.core/assoc :groups (deser-group-id-string-list (clojure.core/get-in letvar637251 ["groupSet" :content]))) (letvar637251 "deleteOnTermination") (clojure.core/assoc :delete-on-termination (deser-boolean (clojure.core/get-in letvar637251 ["deleteOnTermination" :content]))) (letvar637251 "privateIpAddressesSet") (clojure.core/assoc :private-ip-addresses (deser-private-ip-address-specification-list (clojure.core/get-in letvar637251 ["privateIpAddressesSet" :content]))) (letvar637251 "secondaryPrivateIpAddressCount") (clojure.core/assoc :secondary-private-ip-address-count (deser-integer (clojure.core/get-in letvar637251 ["secondaryPrivateIpAddressCount" :content]))) (letvar637251 "privateIpAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar637251 ["privateIpAddress" :content]))) (letvar637251 "ipv6AddressCount") (clojure.core/assoc :ipv-6-address-count (deser-integer (clojure.core/get-in letvar637251 ["ipv6AddressCount" :content]))))))

(clojure.core/defn- deser-host-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-host coll))) input))

(clojure.core/defn- deser-stale-security-group-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-stale-security-group coll))) input))

(clojure.core/defn- deser-elastic-gpu-specification-response-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-elastic-gpu-specification-response coll))) input))

(clojure.core/defn- deser-classic-load-balancers-config [input] (clojure.core/let [letvar637410 {"classicLoadBalancers" (portkey.aws/search-for-tag input "classicLoadBalancers" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar637410 "classicLoadBalancers") (clojure.core/assoc :classic-load-balancers (deser-classic-load-balancers (clojure.core/get-in letvar637410 ["classicLoadBalancers" :content]))))))

(clojure.core/defn- deser-volume-status-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-volume-status-item coll))) input))

(clojure.core/defn- deser-export-task [input] (clojure.core/let [letvar637535 {"description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "exportTaskId" (portkey.aws/search-for-tag input "exportTaskId" :flattened? nil :xmlAttribute? nil), "exportToS3" (portkey.aws/search-for-tag input "exportToS3" :flattened? nil :xmlAttribute? nil), "instanceExport" (portkey.aws/search-for-tag input "instanceExport" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar637535 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar637535 ["description" :content]))) (letvar637535 "exportTaskId") (clojure.core/assoc :export-task-id (deser-string (clojure.core/get-in letvar637535 ["exportTaskId" :content]))) (letvar637535 "exportToS3") (clojure.core/assoc :export-to-s-3-task (deser-export-to-s-3-task (clojure.core/get-in letvar637535 ["exportToS3" :content]))) (letvar637535 "instanceExport") (clojure.core/assoc :instance-export-details (deser-instance-export-details (clojure.core/get-in letvar637535 ["instanceExport" :content]))) (letvar637535 "state") (clojure.core/assoc :state (deser-export-task-state (clojure.core/get-in letvar637535 ["state" :content]))) (letvar637535 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar637535 ["statusMessage" :content]))))))

(clojure.core/defn- deser-transit-gateway-association [input] (clojure.core/let [letvar637643 {"transitGatewayRouteTableId" (portkey.aws/search-for-tag input "transitGatewayRouteTableId" :flattened? nil :xmlAttribute? nil), "transitGatewayAttachmentId" (portkey.aws/search-for-tag input "transitGatewayAttachmentId" :flattened? nil :xmlAttribute? nil), "resourceId" (portkey.aws/search-for-tag input "resourceId" :flattened? nil :xmlAttribute? nil), "resourceType" (portkey.aws/search-for-tag input "resourceType" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar637643 "transitGatewayRouteTableId") (clojure.core/assoc :transit-gateway-route-table-id (deser-string (clojure.core/get-in letvar637643 ["transitGatewayRouteTableId" :content]))) (letvar637643 "transitGatewayAttachmentId") (clojure.core/assoc :transit-gateway-attachment-id (deser-string (clojure.core/get-in letvar637643 ["transitGatewayAttachmentId" :content]))) (letvar637643 "resourceId") (clojure.core/assoc :resource-id (deser-string (clojure.core/get-in letvar637643 ["resourceId" :content]))) (letvar637643 "resourceType") (clojure.core/assoc :resource-type (deser-transit-gateway-attachment-resource-type (clojure.core/get-in letvar637643 ["resourceType" :content]))) (letvar637643 "state") (clojure.core/assoc :state (deser-transit-gateway-association-state (clojure.core/get-in letvar637643 ["state" :content]))))))

(clojure.core/defn- deser-transit-gateway-state [input] (clojure.core/get {"pending" :pending, "available" :available, "modifying" :modifying, "deleting" :deleting, "deleted" :deleted} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-dns-support-value [input] (clojure.core/get {"enable" :enable, "disable" :disable} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-network-interface-private-ip-address [input] (clojure.core/let [letvar637761 {"association" (portkey.aws/search-for-tag input "association" :flattened? nil :xmlAttribute? nil), "primary" (portkey.aws/search-for-tag input "primary" :flattened? nil :xmlAttribute? nil), "privateDnsName" (portkey.aws/search-for-tag input "privateDnsName" :flattened? nil :xmlAttribute? nil), "privateIpAddress" (portkey.aws/search-for-tag input "privateIpAddress" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar637761 "association") (clojure.core/assoc :association (deser-network-interface-association (clojure.core/get-in letvar637761 ["association" :content]))) (letvar637761 "primary") (clojure.core/assoc :primary (deser-boolean (clojure.core/get-in letvar637761 ["primary" :content]))) (letvar637761 "privateDnsName") (clojure.core/assoc :private-dns-name (deser-string (clojure.core/get-in letvar637761 ["privateDnsName" :content]))) (letvar637761 "privateIpAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar637761 ["privateIpAddress" :content]))))))

(clojure.core/defn- deser-transit-gateway-propagation [input] (clojure.core/let [letvar637869 {"transitGatewayAttachmentId" (portkey.aws/search-for-tag input "transitGatewayAttachmentId" :flattened? nil :xmlAttribute? nil), "resourceId" (portkey.aws/search-for-tag input "resourceId" :flattened? nil :xmlAttribute? nil), "resourceType" (portkey.aws/search-for-tag input "resourceType" :flattened? nil :xmlAttribute? nil), "transitGatewayRouteTableId" (portkey.aws/search-for-tag input "transitGatewayRouteTableId" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar637869 "transitGatewayAttachmentId") (clojure.core/assoc :transit-gateway-attachment-id (deser-string (clojure.core/get-in letvar637869 ["transitGatewayAttachmentId" :content]))) (letvar637869 "resourceId") (clojure.core/assoc :resource-id (deser-string (clojure.core/get-in letvar637869 ["resourceId" :content]))) (letvar637869 "resourceType") (clojure.core/assoc :resource-type (deser-transit-gateway-attachment-resource-type (clojure.core/get-in letvar637869 ["resourceType" :content]))) (letvar637869 "transitGatewayRouteTableId") (clojure.core/assoc :transit-gateway-route-table-id (deser-string (clojure.core/get-in letvar637869 ["transitGatewayRouteTableId" :content]))) (letvar637869 "state") (clojure.core/assoc :state (deser-transit-gateway-propagation-state (clojure.core/get-in letvar637869 ["state" :content]))))))

(clojure.core/defn- deser-placement-group-state [input] (clojure.core/get {"pending" :pending, "available" :available, "deleting" :deleting, "deleted" :deleted} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-long [input] (java.lang.Long. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-describe-fleet-error [input] (clojure.core/let [letvar637984 {"launchTemplateAndOverrides" (portkey.aws/search-for-tag input "launchTemplateAndOverrides" :flattened? nil :xmlAttribute? nil), "lifecycle" (portkey.aws/search-for-tag input "lifecycle" :flattened? nil :xmlAttribute? nil), "errorCode" (portkey.aws/search-for-tag input "errorCode" :flattened? nil :xmlAttribute? nil), "errorMessage" (portkey.aws/search-for-tag input "errorMessage" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar637984 "launchTemplateAndOverrides") (clojure.core/assoc :launch-template-and-overrides (deser-launch-template-and-overrides-response (clojure.core/get-in letvar637984 ["launchTemplateAndOverrides" :content]))) (letvar637984 "lifecycle") (clojure.core/assoc :lifecycle (deser-instance-lifecycle (clojure.core/get-in letvar637984 ["lifecycle" :content]))) (letvar637984 "errorCode") (clojure.core/assoc :error-code (deser-string (clojure.core/get-in letvar637984 ["errorCode" :content]))) (letvar637984 "errorMessage") (clojure.core/assoc :error-message (deser-string (clojure.core/get-in letvar637984 ["errorMessage" :content]))))))

(clojure.core/defn- deser-volume-status-actions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-volume-status-action coll))) input))

(clojure.core/defn- deser-vpn-static-route-source [input] (clojure.core/get {"Static" :static} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-host-offering-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-host-offering coll))) input))

(clojure.core/defn- deser-vpc-endpoint-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-endpoint coll))) input))

(clojure.core/defn- deser-scheduled-instance-recurrence [input] (clojure.core/let [letvar638148 {"frequency" (portkey.aws/search-for-tag input "frequency" :flattened? nil :xmlAttribute? nil), "interval" (portkey.aws/search-for-tag input "interval" :flattened? nil :xmlAttribute? nil), "occurrenceDaySet" (portkey.aws/search-for-tag input "occurrenceDaySet" :flattened? nil :xmlAttribute? nil), "occurrenceRelativeToEnd" (portkey.aws/search-for-tag input "occurrenceRelativeToEnd" :flattened? nil :xmlAttribute? nil), "occurrenceUnit" (portkey.aws/search-for-tag input "occurrenceUnit" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar638148 "frequency") (clojure.core/assoc :frequency (deser-string (clojure.core/get-in letvar638148 ["frequency" :content]))) (letvar638148 "interval") (clojure.core/assoc :interval (deser-integer (clojure.core/get-in letvar638148 ["interval" :content]))) (letvar638148 "occurrenceDaySet") (clojure.core/assoc :occurrence-day-set (deser-occurrence-day-set (clojure.core/get-in letvar638148 ["occurrenceDaySet" :content]))) (letvar638148 "occurrenceRelativeToEnd") (clojure.core/assoc :occurrence-relative-to-end (deser-boolean (clojure.core/get-in letvar638148 ["occurrenceRelativeToEnd" :content]))) (letvar638148 "occurrenceUnit") (clojure.core/assoc :occurrence-unit (deser-string (clojure.core/get-in letvar638148 ["occurrenceUnit" :content]))))))

(clojure.core/defn- deser-allowed-principal [input] (clojure.core/let [letvar638256 {"principalType" (portkey.aws/search-for-tag input "principalType" :flattened? nil :xmlAttribute? nil), "principal" (portkey.aws/search-for-tag input "principal" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar638256 "principalType") (clojure.core/assoc :principal-type (deser-principal-type (clojure.core/get-in letvar638256 ["principalType" :content]))) (letvar638256 "principal") (clojure.core/assoc :principal (deser-string (clojure.core/get-in letvar638256 ["principal" :content]))))))

(clojure.core/defn- deser-unsuccessful-instance-credit-specification-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-unsuccessful-instance-credit-specification-item coll))) input))

(clojure.core/defn- deser-instance-state [input] (clojure.core/let [letvar638381 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "name" (portkey.aws/search-for-tag input "name" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar638381 "code") (clojure.core/assoc :code (deser-integer (clojure.core/get-in letvar638381 ["code" :content]))) (letvar638381 "name") (clojure.core/assoc :name (deser-instance-state-name (clojure.core/get-in letvar638381 ["name" :content]))))))

(clojure.core/defn- deser-volume-status-item [input] (clojure.core/let [letvar638489 {"actionsSet" (portkey.aws/search-for-tag input "actionsSet" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "eventsSet" (portkey.aws/search-for-tag input "eventsSet" :flattened? nil :xmlAttribute? nil), "volumeId" (portkey.aws/search-for-tag input "volumeId" :flattened? nil :xmlAttribute? nil), "volumeStatus" (portkey.aws/search-for-tag input "volumeStatus" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar638489 "actionsSet") (clojure.core/assoc :actions (deser-volume-status-actions-list (clojure.core/get-in letvar638489 ["actionsSet" :content]))) (letvar638489 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar638489 ["availabilityZone" :content]))) (letvar638489 "eventsSet") (clojure.core/assoc :events (deser-volume-status-events-list (clojure.core/get-in letvar638489 ["eventsSet" :content]))) (letvar638489 "volumeId") (clojure.core/assoc :volume-id (deser-string (clojure.core/get-in letvar638489 ["volumeId" :content]))) (letvar638489 "volumeStatus") (clojure.core/assoc :volume-status (deser-volume-status-info (clojure.core/get-in letvar638489 ["volumeStatus" :content]))))))

(clojure.core/defn- deser-spot-instance-state [input] (clojure.core/get {"open" :open, "active" :active, "closed" :closed, "cancelled" :cancelled, "failed" :failed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-capacity-reservation [input] (clojure.core/let [letvar638602 {"endDateType" (portkey.aws/search-for-tag input "endDateType" :flattened? nil :xmlAttribute? nil), "createDate" (portkey.aws/search-for-tag input "createDate" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "instancePlatform" (portkey.aws/search-for-tag input "instancePlatform" :flattened? nil :xmlAttribute? nil), "tenancy" (portkey.aws/search-for-tag input "tenancy" :flattened? nil :xmlAttribute? nil), "instanceMatchCriteria" (portkey.aws/search-for-tag input "instanceMatchCriteria" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "availableInstanceCount" (portkey.aws/search-for-tag input "availableInstanceCount" :flattened? nil :xmlAttribute? nil), "ebsOptimized" (portkey.aws/search-for-tag input "ebsOptimized" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "totalInstanceCount" (portkey.aws/search-for-tag input "totalInstanceCount" :flattened? nil :xmlAttribute? nil), "capacityReservationId" (portkey.aws/search-for-tag input "capacityReservationId" :flattened? nil :xmlAttribute? nil), "endDate" (portkey.aws/search-for-tag input "endDate" :flattened? nil :xmlAttribute? nil), "ephemeralStorage" (portkey.aws/search-for-tag input "ephemeralStorage" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar638602 "totalInstanceCount") (clojure.core/assoc :total-instance-count (deser-integer (clojure.core/get-in letvar638602 ["totalInstanceCount" :content]))) (letvar638602 "capacityReservationId") (clojure.core/assoc :capacity-reservation-id (deser-string (clojure.core/get-in letvar638602 ["capacityReservationId" :content]))) (letvar638602 "endDate") (clojure.core/assoc :end-date (deser-date-time (clojure.core/get-in letvar638602 ["endDate" :content]))) (letvar638602 "tenancy") (clojure.core/assoc :tenancy (deser-capacity-reservation-tenancy (clojure.core/get-in letvar638602 ["tenancy" :content]))) (letvar638602 "ebsOptimized") (clojure.core/assoc :ebs-optimized (deser-boolean (clojure.core/get-in letvar638602 ["ebsOptimized" :content]))) (letvar638602 "createDate") (clojure.core/assoc :create-date (deser-date-time (clojure.core/get-in letvar638602 ["createDate" :content]))) (letvar638602 "instanceType") (clojure.core/assoc :instance-type (deser-string (clojure.core/get-in letvar638602 ["instanceType" :content]))) (letvar638602 "endDateType") (clojure.core/assoc :end-date-type (deser-end-date-type (clojure.core/get-in letvar638602 ["endDateType" :content]))) (letvar638602 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar638602 ["tagSet" :content]))) (letvar638602 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar638602 ["availabilityZone" :content]))) (letvar638602 "ephemeralStorage") (clojure.core/assoc :ephemeral-storage (deser-boolean (clojure.core/get-in letvar638602 ["ephemeralStorage" :content]))) (letvar638602 "instanceMatchCriteria") (clojure.core/assoc :instance-match-criteria (deser-instance-match-criteria (clojure.core/get-in letvar638602 ["instanceMatchCriteria" :content]))) (letvar638602 "instancePlatform") (clojure.core/assoc :instance-platform (deser-capacity-reservation-instance-platform (clojure.core/get-in letvar638602 ["instancePlatform" :content]))) (letvar638602 "availableInstanceCount") (clojure.core/assoc :available-instance-count (deser-integer (clojure.core/get-in letvar638602 ["availableInstanceCount" :content]))) (letvar638602 "state") (clojure.core/assoc :state (deser-capacity-reservation-state (clojure.core/get-in letvar638602 ["state" :content]))))))

(clojure.core/defn- deser-instance-state-name [input] (clojure.core/get {"pending" :pending, "running" :running, "shutting-down" :shuttingdown, "terminated" :terminated, "stopping" :stopping, "stopped" :stopped} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-availability-zone-message [input] (clojure.core/let [letvar638715 {"message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar638715 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar638715 ["message" :content]))))))

(clojure.core/defn- deser-launch-template-version-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-launch-template-version coll))) input))

(clojure.core/defn- deser-version-description [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-elastic-inference-accelerator-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-elastic-inference-accelerator-association coll))) input))

(clojure.core/defn- deser-host-reservation-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-host-reservation coll))) input))

(clojure.core/defn- deser-unsuccessful-item-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-unsuccessful-item coll))) input))

(clojure.core/defn- deser-virtualization-type [input] (clojure.core/get {"hvm" :hvm, "paravirtual" :paravirtual} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-launch-template-elastic-inference-accelerator-response [input] (clojure.core/let [letvar638901 {"type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar638901 "type") (clojure.core/assoc :type (deser-string (clojure.core/get-in letvar638901 ["type" :content]))))))

(clojure.core/defn- deser-reserved-instances-id [input] (clojure.core/let [letvar639009 {"reservedInstancesId" (portkey.aws/search-for-tag input "reservedInstancesId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar639009 "reservedInstancesId") (clojure.core/assoc :reserved-instances-id (deser-string (clojure.core/get-in letvar639009 ["reservedInstancesId" :content]))))))

(clojure.core/defn- deser-instance-credit-specification-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-credit-specification coll))) input))

(clojure.core/defn- deser-default-target-capacity-type [input] (clojure.core/get {"spot" :spot, "on-demand" :ondemand} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-instance-network-interface-specification-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-network-interface-specification coll))) input))

(clojure.core/defn- deser-conversion-task [input] (clojure.core/let [letvar639156 {"conversionTaskId" (portkey.aws/search-for-tag input "conversionTaskId" :flattened? nil :xmlAttribute? nil), "expirationTime" (portkey.aws/search-for-tag input "expirationTime" :flattened? nil :xmlAttribute? nil), "importInstance" (portkey.aws/search-for-tag input "importInstance" :flattened? nil :xmlAttribute? nil), "importVolume" (portkey.aws/search-for-tag input "importVolume" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar639156 "conversionTaskId") (clojure.core/assoc :conversion-task-id (deser-string (clojure.core/get-in letvar639156 ["conversionTaskId" :content]))) (letvar639156 "expirationTime") (clojure.core/assoc :expiration-time (deser-string (clojure.core/get-in letvar639156 ["expirationTime" :content]))) (letvar639156 "importInstance") (clojure.core/assoc :import-instance (deser-import-instance-task-details (clojure.core/get-in letvar639156 ["importInstance" :content]))) (letvar639156 "importVolume") (clojure.core/assoc :import-volume (deser-import-volume-task-details (clojure.core/get-in letvar639156 ["importVolume" :content]))) (letvar639156 "state") (clojure.core/assoc :state (deser-conversion-task-state (clojure.core/get-in letvar639156 ["state" :content]))) (letvar639156 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar639156 ["statusMessage" :content]))) (letvar639156 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar639156 ["tagSet" :content]))))))

(clojure.core/defn- deser-successful-instance-credit-specification-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-successful-instance-credit-specification-item coll))) input))

(clojure.core/defn- deser-bundle-task-error [input] (clojure.core/let [letvar639281 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar639281 "code") (clojure.core/assoc :code (deser-string (clojure.core/get-in letvar639281 ["code" :content]))) (letvar639281 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar639281 ["message" :content]))))))

(clojure.core/defn- deser-dhcp-configuration [input] (clojure.core/let [letvar639389 {"key" (portkey.aws/search-for-tag input "key" :flattened? nil :xmlAttribute? nil), "valueSet" (portkey.aws/search-for-tag input "valueSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar639389 "key") (clojure.core/assoc :key (deser-string (clojure.core/get-in letvar639389 ["key" :content]))) (letvar639389 "valueSet") (clojure.core/assoc :values (deser-dhcp-configuration-value-list (clojure.core/get-in letvar639389 ["valueSet" :content]))))))

(clojure.core/defn- deser-block-device-mapping [input] (clojure.core/let [letvar639497 {"deviceName" (portkey.aws/search-for-tag input "deviceName" :flattened? nil :xmlAttribute? nil), "virtualName" (portkey.aws/search-for-tag input "virtualName" :flattened? nil :xmlAttribute? nil), "ebs" (portkey.aws/search-for-tag input "ebs" :flattened? nil :xmlAttribute? nil), "noDevice" (portkey.aws/search-for-tag input "noDevice" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar639497 "deviceName") (clojure.core/assoc :device-name (deser-string (clojure.core/get-in letvar639497 ["deviceName" :content]))) (letvar639497 "virtualName") (clojure.core/assoc :virtual-name (deser-string (clojure.core/get-in letvar639497 ["virtualName" :content]))) (letvar639497 "ebs") (clojure.core/assoc :ebs (deser-ebs-block-device (clojure.core/get-in letvar639497 ["ebs" :content]))) (letvar639497 "noDevice") (clojure.core/assoc :no-device (deser-string (clojure.core/get-in letvar639497 ["noDevice" :content]))))))

(clojure.core/defn- deser-state [input] (clojure.core/get {"PendingAcceptance" :pending-acceptance, "Pending" :pending, "Available" :available, "Deleting" :deleting, "Deleted" :deleted, "Rejected" :rejected, "Failed" :failed, "Expired" :expired} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-export-to-s-3-task [input] (clojure.core/let [letvar639610 {"containerFormat" (portkey.aws/search-for-tag input "containerFormat" :flattened? nil :xmlAttribute? nil), "diskImageFormat" (portkey.aws/search-for-tag input "diskImageFormat" :flattened? nil :xmlAttribute? nil), "s3Bucket" (portkey.aws/search-for-tag input "s3Bucket" :flattened? nil :xmlAttribute? nil), "s3Key" (portkey.aws/search-for-tag input "s3Key" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar639610 "containerFormat") (clojure.core/assoc :container-format (deser-container-format (clojure.core/get-in letvar639610 ["containerFormat" :content]))) (letvar639610 "diskImageFormat") (clojure.core/assoc :disk-image-format (deser-disk-image-format (clojure.core/get-in letvar639610 ["diskImageFormat" :content]))) (letvar639610 "s3Bucket") (clojure.core/assoc :s-3-bucket (deser-string (clojure.core/get-in letvar639610 ["s3Bucket" :content]))) (letvar639610 "s3Key") (clojure.core/assoc :s-3-key (deser-string (clojure.core/get-in letvar639610 ["s3Key" :content]))))))

(clojure.core/defn- deser-network-acl-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-network-acl coll))) input))

(clojure.core/defn- deser-target-network-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-network coll))) input))

(clojure.core/defn- deser-public-ipv-4-pool [input] (clojure.core/let [letvar639752 {"poolId" (portkey.aws/search-for-tag input "poolId" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "poolAddressRangeSet" (portkey.aws/search-for-tag input "poolAddressRangeSet" :flattened? nil :xmlAttribute? nil), "totalAddressCount" (portkey.aws/search-for-tag input "totalAddressCount" :flattened? nil :xmlAttribute? nil), "totalAvailableAddressCount" (portkey.aws/search-for-tag input "totalAvailableAddressCount" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar639752 "poolId") (clojure.core/assoc :pool-id (deser-string (clojure.core/get-in letvar639752 ["poolId" :content]))) (letvar639752 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar639752 ["description" :content]))) (letvar639752 "poolAddressRangeSet") (clojure.core/assoc :pool-address-ranges (deser-public-ipv-4-pool-range-set (clojure.core/get-in letvar639752 ["poolAddressRangeSet" :content]))) (letvar639752 "totalAddressCount") (clojure.core/assoc :total-address-count (deser-integer (clojure.core/get-in letvar639752 ["totalAddressCount" :content]))) (letvar639752 "totalAvailableAddressCount") (clojure.core/assoc :total-available-address-count (deser-integer (clojure.core/get-in letvar639752 ["totalAvailableAddressCount" :content]))))))

(clojure.core/defn- deser-cpu-options [input] (clojure.core/let [letvar639860 {"coreCount" (portkey.aws/search-for-tag input "coreCount" :flattened? nil :xmlAttribute? nil), "threadsPerCore" (portkey.aws/search-for-tag input "threadsPerCore" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar639860 "coreCount") (clojure.core/assoc :core-count (deser-integer (clojure.core/get-in letvar639860 ["coreCount" :content]))) (letvar639860 "threadsPerCore") (clojure.core/assoc :threads-per-core (deser-integer (clojure.core/get-in letvar639860 ["threadsPerCore" :content]))))))

(clojure.core/defn- deser-tag [input] (clojure.core/let [letvar639968 {"key" (portkey.aws/search-for-tag input "key" :flattened? nil :xmlAttribute? nil), "value" (portkey.aws/search-for-tag input "value" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar639968 "key") (clojure.core/assoc :key (deser-string (clojure.core/get-in letvar639968 ["key" :content]))) (letvar639968 "value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar639968 ["value" :content]))))))

(clojure.core/defn- deser-client-vpn-connection [input] (clojure.core/let [letvar640076 {"connectionId" (portkey.aws/search-for-tag input "connectionId" :flattened? nil :xmlAttribute? nil), "egressPackets" (portkey.aws/search-for-tag input "egressPackets" :flattened? nil :xmlAttribute? nil), "username" (portkey.aws/search-for-tag input "username" :flattened? nil :xmlAttribute? nil), "ingressBytes" (portkey.aws/search-for-tag input "ingressBytes" :flattened? nil :xmlAttribute? nil), "commonName" (portkey.aws/search-for-tag input "commonName" :flattened? nil :xmlAttribute? nil), "timestamp" (portkey.aws/search-for-tag input "timestamp" :flattened? nil :xmlAttribute? nil), "clientVpnEndpointId" (portkey.aws/search-for-tag input "clientVpnEndpointId" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "clientIp" (portkey.aws/search-for-tag input "clientIp" :flattened? nil :xmlAttribute? nil), "ingressPackets" (portkey.aws/search-for-tag input "ingressPackets" :flattened? nil :xmlAttribute? nil), "egressBytes" (portkey.aws/search-for-tag input "egressBytes" :flattened? nil :xmlAttribute? nil), "connectionEndTime" (portkey.aws/search-for-tag input "connectionEndTime" :flattened? nil :xmlAttribute? nil), "connectionEstablishedTime" (portkey.aws/search-for-tag input "connectionEstablishedTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar640076 "username") (clojure.core/assoc :username (deser-string (clojure.core/get-in letvar640076 ["username" :content]))) (letvar640076 "connectionId") (clojure.core/assoc :connection-id (deser-string (clojure.core/get-in letvar640076 ["connectionId" :content]))) (letvar640076 "egressBytes") (clojure.core/assoc :egress-bytes (deser-string (clojure.core/get-in letvar640076 ["egressBytes" :content]))) (letvar640076 "egressPackets") (clojure.core/assoc :egress-packets (deser-string (clojure.core/get-in letvar640076 ["egressPackets" :content]))) (letvar640076 "status") (clojure.core/assoc :status (deser-client-vpn-connection-status (clojure.core/get-in letvar640076 ["status" :content]))) (letvar640076 "ingressBytes") (clojure.core/assoc :ingress-bytes (deser-string (clojure.core/get-in letvar640076 ["ingressBytes" :content]))) (letvar640076 "commonName") (clojure.core/assoc :common-name (deser-string (clojure.core/get-in letvar640076 ["commonName" :content]))) (letvar640076 "connectionEndTime") (clojure.core/assoc :connection-end-time (deser-string (clojure.core/get-in letvar640076 ["connectionEndTime" :content]))) (letvar640076 "ingressPackets") (clojure.core/assoc :ingress-packets (deser-string (clojure.core/get-in letvar640076 ["ingressPackets" :content]))) (letvar640076 "connectionEstablishedTime") (clojure.core/assoc :connection-established-time (deser-string (clojure.core/get-in letvar640076 ["connectionEstablishedTime" :content]))) (letvar640076 "clientIp") (clojure.core/assoc :client-ip (deser-string (clojure.core/get-in letvar640076 ["clientIp" :content]))) (letvar640076 "timestamp") (clojure.core/assoc :timestamp (deser-string (clojure.core/get-in letvar640076 ["timestamp" :content]))) (letvar640076 "clientVpnEndpointId") (clojure.core/assoc :client-vpn-endpoint-id (deser-string (clojure.core/get-in letvar640076 ["clientVpnEndpointId" :content]))))))

(clojure.core/defn- deser-recurring-charge-frequency [input] (clojure.core/get {"Hourly" :hourly} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-spot-fleet-tag-specification [input] (clojure.core/let [letvar640189 {"resourceType" (portkey.aws/search-for-tag input "resourceType" :flattened? nil :xmlAttribute? nil), "tag" (portkey.aws/search-for-tag input "tag" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar640189 "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (clojure.core/get-in letvar640189 ["resourceType" :content]))) (letvar640189 "tag") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar640189 ["tag" :content]))))))

(clojure.core/defn- deser-platform-values [input] (clojure.core/get {"Windows" :windows} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-cancel-spot-fleet-requests-success-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cancel-spot-fleet-requests-success-item coll))) input))

(clojure.core/defn- deser-product-code [input] (clojure.core/let [letvar640319 {"productCode" (portkey.aws/search-for-tag input "productCode" :flattened? nil :xmlAttribute? nil), "type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar640319 "productCode") (clojure.core/assoc :product-code-id (deser-string (clojure.core/get-in letvar640319 ["productCode" :content]))) (letvar640319 "type") (clojure.core/assoc :product-code-type (deser-product-code-values (clojure.core/get-in letvar640319 ["type" :content]))))))

(clojure.core/defn- deser-client-vpn-authentication-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-client-vpn-authentication coll))) input))

(clojure.core/defn- deser-port-range [input] (clojure.core/let [letvar640444 {"from" (portkey.aws/search-for-tag input "from" :flattened? nil :xmlAttribute? nil), "to" (portkey.aws/search-for-tag input "to" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar640444 "from") (clojure.core/assoc :from (deser-integer (clojure.core/get-in letvar640444 ["from" :content]))) (letvar640444 "to") (clojure.core/assoc :to (deser-integer (clojure.core/get-in letvar640444 ["to" :content]))))))

(clojure.core/defn- deser-vpc-state [input] (clojure.core/get {"pending" :pending, "available" :available} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-attachment-status [input] (clojure.core/get {"attaching" :attaching, "attached" :attached, "detaching" :detaching, "detached" :detached} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-peering-connection-options [input] (clojure.core/let [letvar640562 {"allowDnsResolutionFromRemoteVpc" (portkey.aws/search-for-tag input "allowDnsResolutionFromRemoteVpc" :flattened? nil :xmlAttribute? nil), "allowEgressFromLocalClassicLinkToRemoteVpc" (portkey.aws/search-for-tag input "allowEgressFromLocalClassicLinkToRemoteVpc" :flattened? nil :xmlAttribute? nil), "allowEgressFromLocalVpcToRemoteClassicLink" (portkey.aws/search-for-tag input "allowEgressFromLocalVpcToRemoteClassicLink" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar640562 "allowDnsResolutionFromRemoteVpc") (clojure.core/assoc :allow-dns-resolution-from-remote-vpc (deser-boolean (clojure.core/get-in letvar640562 ["allowDnsResolutionFromRemoteVpc" :content]))) (letvar640562 "allowEgressFromLocalClassicLinkToRemoteVpc") (clojure.core/assoc :allow-egress-from-local-classic-link-to-remote-vpc (deser-boolean (clojure.core/get-in letvar640562 ["allowEgressFromLocalClassicLinkToRemoteVpc" :content]))) (letvar640562 "allowEgressFromLocalVpcToRemoteClassicLink") (clojure.core/assoc :allow-egress-from-local-vpc-to-remote-classic-link (deser-boolean (clojure.core/get-in letvar640562 ["allowEgressFromLocalVpcToRemoteClassicLink" :content]))))))

(clojure.core/defn- deser-launch-templates-monitoring [input] (clojure.core/let [letvar640670 {"enabled" (portkey.aws/search-for-tag input "enabled" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar640670 "enabled") (clojure.core/assoc :enabled (deser-boolean (clojure.core/get-in letvar640670 ["enabled" :content]))))))

(clojure.core/defn- deser-dns-entry-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-dns-entry coll))) input))

(clojure.core/defn- deser-launch-template-version [input] (clojure.core/let [letvar640795 {"launchTemplateId" (portkey.aws/search-for-tag input "launchTemplateId" :flattened? nil :xmlAttribute? nil), "launchTemplateName" (portkey.aws/search-for-tag input "launchTemplateName" :flattened? nil :xmlAttribute? nil), "versionNumber" (portkey.aws/search-for-tag input "versionNumber" :flattened? nil :xmlAttribute? nil), "versionDescription" (portkey.aws/search-for-tag input "versionDescription" :flattened? nil :xmlAttribute? nil), "createTime" (portkey.aws/search-for-tag input "createTime" :flattened? nil :xmlAttribute? nil), "createdBy" (portkey.aws/search-for-tag input "createdBy" :flattened? nil :xmlAttribute? nil), "defaultVersion" (portkey.aws/search-for-tag input "defaultVersion" :flattened? nil :xmlAttribute? nil), "launchTemplateData" (portkey.aws/search-for-tag input "launchTemplateData" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar640795 "launchTemplateId") (clojure.core/assoc :launch-template-id (deser-string (clojure.core/get-in letvar640795 ["launchTemplateId" :content]))) (letvar640795 "launchTemplateName") (clojure.core/assoc :launch-template-name (deser-launch-template-name (clojure.core/get-in letvar640795 ["launchTemplateName" :content]))) (letvar640795 "versionNumber") (clojure.core/assoc :version-number (deser-long (clojure.core/get-in letvar640795 ["versionNumber" :content]))) (letvar640795 "versionDescription") (clojure.core/assoc :version-description (deser-version-description (clojure.core/get-in letvar640795 ["versionDescription" :content]))) (letvar640795 "createTime") (clojure.core/assoc :create-time (deser-date-time (clojure.core/get-in letvar640795 ["createTime" :content]))) (letvar640795 "createdBy") (clojure.core/assoc :created-by (deser-string (clojure.core/get-in letvar640795 ["createdBy" :content]))) (letvar640795 "defaultVersion") (clojure.core/assoc :default-version (deser-boolean (clojure.core/get-in letvar640795 ["defaultVersion" :content]))) (letvar640795 "launchTemplateData") (clojure.core/assoc :launch-template-data (deser-response-launch-template-data (clojure.core/get-in letvar640795 ["launchTemplateData" :content]))))))

(clojure.core/defn- deser-vpc-attachment [input] (clojure.core/let [letvar640903 {"state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar640903 "state") (clojure.core/assoc :state (deser-attachment-status (clojure.core/get-in letvar640903 ["state" :content]))) (letvar640903 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar640903 ["vpcId" :content]))))))

(clojure.core/defn- deser-instance-status [input] (clojure.core/let [letvar641011 {"availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "eventsSet" (portkey.aws/search-for-tag input "eventsSet" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "instanceState" (portkey.aws/search-for-tag input "instanceState" :flattened? nil :xmlAttribute? nil), "instanceStatus" (portkey.aws/search-for-tag input "instanceStatus" :flattened? nil :xmlAttribute? nil), "systemStatus" (portkey.aws/search-for-tag input "systemStatus" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar641011 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar641011 ["availabilityZone" :content]))) (letvar641011 "eventsSet") (clojure.core/assoc :events (deser-instance-status-event-list (clojure.core/get-in letvar641011 ["eventsSet" :content]))) (letvar641011 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar641011 ["instanceId" :content]))) (letvar641011 "instanceState") (clojure.core/assoc :instance-state (deser-instance-state (clojure.core/get-in letvar641011 ["instanceState" :content]))) (letvar641011 "instanceStatus") (clojure.core/assoc :instance-status (deser-instance-status-summary (clojure.core/get-in letvar641011 ["instanceStatus" :content]))) (letvar641011 "systemStatus") (clojure.core/assoc :system-status (deser-instance-status-summary (clojure.core/get-in letvar641011 ["systemStatus" :content]))))))

(clojure.core/defn- deser-spot-fleet-launch-specification [input] (clojure.core/let [letvar641119 {"groupSet" (portkey.aws/search-for-tag input "groupSet" :flattened? nil :xmlAttribute? nil), "ramdiskId" (portkey.aws/search-for-tag input "ramdiskId" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "addressingType" (portkey.aws/search-for-tag input "addressingType" :flattened? nil :xmlAttribute? nil), "blockDeviceMapping" (portkey.aws/search-for-tag input "blockDeviceMapping" :flattened? nil :xmlAttribute? nil), "keyName" (portkey.aws/search-for-tag input "keyName" :flattened? nil :xmlAttribute? nil), "placement" (portkey.aws/search-for-tag input "placement" :flattened? nil :xmlAttribute? nil), "monitoring" (portkey.aws/search-for-tag input "monitoring" :flattened? nil :xmlAttribute? nil), "tagSpecificationSet" (portkey.aws/search-for-tag input "tagSpecificationSet" :flattened? nil :xmlAttribute? nil), "iamInstanceProfile" (portkey.aws/search-for-tag input "iamInstanceProfile" :flattened? nil :xmlAttribute? nil), "spotPrice" (portkey.aws/search-for-tag input "spotPrice" :flattened? nil :xmlAttribute? nil), "userData" (portkey.aws/search-for-tag input "userData" :flattened? nil :xmlAttribute? nil), "imageId" (portkey.aws/search-for-tag input "imageId" :flattened? nil :xmlAttribute? nil), "ebsOptimized" (portkey.aws/search-for-tag input "ebsOptimized" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "weightedCapacity" (portkey.aws/search-for-tag input "weightedCapacity" :flattened? nil :xmlAttribute? nil), "kernelId" (portkey.aws/search-for-tag input "kernelId" :flattened? nil :xmlAttribute? nil), "networkInterfaceSet" (portkey.aws/search-for-tag input "networkInterfaceSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar641119 "tagSpecificationSet") (clojure.core/assoc :tag-specifications (deser-spot-fleet-tag-specification-list (clojure.core/get-in letvar641119 ["tagSpecificationSet" :content]))) (letvar641119 "kernelId") (clojure.core/assoc :kernel-id (deser-string (clojure.core/get-in letvar641119 ["kernelId" :content]))) (letvar641119 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar641119 ["imageId" :content]))) (letvar641119 "placement") (clojure.core/assoc :placement (deser-spot-placement (clojure.core/get-in letvar641119 ["placement" :content]))) (letvar641119 "addressingType") (clojure.core/assoc :addressing-type (deser-string (clojure.core/get-in letvar641119 ["addressingType" :content]))) (letvar641119 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar641119 ["subnetId" :content]))) (letvar641119 "groupSet") (clojure.core/assoc :security-groups (deser-group-identifier-list (clojure.core/get-in letvar641119 ["groupSet" :content]))) (letvar641119 "ebsOptimized") (clojure.core/assoc :ebs-optimized (deser-boolean (clojure.core/get-in letvar641119 ["ebsOptimized" :content]))) (letvar641119 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar641119 ["instanceType" :content]))) (letvar641119 "keyName") (clojure.core/assoc :key-name (deser-string (clojure.core/get-in letvar641119 ["keyName" :content]))) (letvar641119 "spotPrice") (clojure.core/assoc :spot-price (deser-string (clojure.core/get-in letvar641119 ["spotPrice" :content]))) (letvar641119 "monitoring") (clojure.core/assoc :monitoring (deser-spot-fleet-monitoring (clojure.core/get-in letvar641119 ["monitoring" :content]))) (letvar641119 "weightedCapacity") (clojure.core/assoc :weighted-capacity (deser-double (clojure.core/get-in letvar641119 ["weightedCapacity" :content]))) (letvar641119 "blockDeviceMapping") (clojure.core/assoc :block-device-mappings (deser-block-device-mapping-list (clojure.core/get-in letvar641119 ["blockDeviceMapping" :content]))) (letvar641119 "ramdiskId") (clojure.core/assoc :ramdisk-id (deser-string (clojure.core/get-in letvar641119 ["ramdiskId" :content]))) (letvar641119 "userData") (clojure.core/assoc :user-data (deser-string (clojure.core/get-in letvar641119 ["userData" :content]))) (letvar641119 "iamInstanceProfile") (clojure.core/assoc :iam-instance-profile (deser-iam-instance-profile-specification (clojure.core/get-in letvar641119 ["iamInstanceProfile" :content]))) (letvar641119 "networkInterfaceSet") (clojure.core/assoc :network-interfaces (deser-instance-network-interface-specification-list (clojure.core/get-in letvar641119 ["networkInterfaceSet" :content]))))))

(clojure.core/defn- deser-ipv-6-cidr-block-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ipv-6-cidr-block coll))) input))

(clojure.core/defn- deser-ip-range [input] (clojure.core/let [letvar641244 {"cidrIp" (portkey.aws/search-for-tag input "cidrIp" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar641244 "cidrIp") (clojure.core/assoc :cidr-ip (deser-string (clojure.core/get-in letvar641244 ["cidrIp" :content]))) (letvar641244 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar641244 ["description" :content]))))))

(clojure.core/defn- deser-cidr-block-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cidr-block coll))) input))

(clojure.core/defn- deser-stale-security-group [input] (clojure.core/let [letvar641369 {"description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "groupId" (portkey.aws/search-for-tag input "groupId" :flattened? nil :xmlAttribute? nil), "groupName" (portkey.aws/search-for-tag input "groupName" :flattened? nil :xmlAttribute? nil), "staleIpPermissions" (portkey.aws/search-for-tag input "staleIpPermissions" :flattened? nil :xmlAttribute? nil), "staleIpPermissionsEgress" (portkey.aws/search-for-tag input "staleIpPermissionsEgress" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar641369 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar641369 ["description" :content]))) (letvar641369 "groupId") (clojure.core/assoc :group-id (deser-string (clojure.core/get-in letvar641369 ["groupId" :content]))) (letvar641369 "groupName") (clojure.core/assoc :group-name (deser-string (clojure.core/get-in letvar641369 ["groupName" :content]))) (letvar641369 "staleIpPermissions") (clojure.core/assoc :stale-ip-permissions (deser-stale-ip-permission-set (clojure.core/get-in letvar641369 ["staleIpPermissions" :content]))) (letvar641369 "staleIpPermissionsEgress") (clojure.core/assoc :stale-ip-permissions-egress (deser-stale-ip-permission-set (clojure.core/get-in letvar641369 ["staleIpPermissionsEgress" :content]))) (letvar641369 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar641369 ["vpcId" :content]))))))

(clojure.core/defn- deser-import-snapshot-task [input] (clojure.core/let [letvar641477 {"description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "importTaskId" (portkey.aws/search-for-tag input "importTaskId" :flattened? nil :xmlAttribute? nil), "snapshotTaskDetail" (portkey.aws/search-for-tag input "snapshotTaskDetail" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar641477 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar641477 ["description" :content]))) (letvar641477 "importTaskId") (clojure.core/assoc :import-task-id (deser-string (clojure.core/get-in letvar641477 ["importTaskId" :content]))) (letvar641477 "snapshotTaskDetail") (clojure.core/assoc :snapshot-task-detail (deser-snapshot-task-detail (clojure.core/get-in letvar641477 ["snapshotTaskDetail" :content]))))))

(clojure.core/defn- deser-elastic-gpu-specification-response [input] (clojure.core/let [letvar641585 {"type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar641585 "type") (clojure.core/assoc :type (deser-string (clojure.core/get-in letvar641585 ["type" :content]))))))

(clojure.core/defn- deser-container-format [input] (clojure.core/get {"ova" :ova} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-network-interface-ipv-6-addresses-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-network-interface-ipv-6-address coll))) input))

(clojure.core/defn- deser-vpc-peering-connection-state-reason [input] (clojure.core/let [letvar641715 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar641715 "code") (clojure.core/assoc :code (deser-vpc-peering-connection-state-reason-code (clojure.core/get-in letvar641715 ["code" :content]))) (letvar641715 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar641715 ["message" :content]))))))

(clojure.core/defn- deser-market-type [input] (clojure.core/get {"spot" :spot} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-instance [input] (clojure.core/let [letvar641828 {"groupSet" (portkey.aws/search-for-tag input "groupSet" :flattened? nil :xmlAttribute? nil), "ramdiskId" (portkey.aws/search-for-tag input "ramdiskId" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "productCodes" (portkey.aws/search-for-tag input "productCodes" :flattened? nil :xmlAttribute? nil), "architecture" (portkey.aws/search-for-tag input "architecture" :flattened? nil :xmlAttribute? nil), "stateReason" (portkey.aws/search-for-tag input "stateReason" :flattened? nil :xmlAttribute? nil), "privateIpAddress" (portkey.aws/search-for-tag input "privateIpAddress" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "clientToken" (portkey.aws/search-for-tag input "clientToken" :flattened? nil :xmlAttribute? nil), "blockDeviceMapping" (portkey.aws/search-for-tag input "blockDeviceMapping" :flattened? nil :xmlAttribute? nil), "keyName" (portkey.aws/search-for-tag input "keyName" :flattened? nil :xmlAttribute? nil), "cpuOptions" (portkey.aws/search-for-tag input "cpuOptions" :flattened? nil :xmlAttribute? nil), "spotInstanceRequestId" (portkey.aws/search-for-tag input "spotInstanceRequestId" :flattened? nil :xmlAttribute? nil), "instanceLifecycle" (portkey.aws/search-for-tag input "instanceLifecycle" :flattened? nil :xmlAttribute? nil), "elasticInferenceAcceleratorAssociationSet" (portkey.aws/search-for-tag input "elasticInferenceAcceleratorAssociationSet" :flattened? nil :xmlAttribute? nil), "placement" (portkey.aws/search-for-tag input "placement" :flattened? nil :xmlAttribute? nil), "licenseSet" (portkey.aws/search-for-tag input "licenseSet" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "privateDnsName" (portkey.aws/search-for-tag input "privateDnsName" :flattened? nil :xmlAttribute? nil), "monitoring" (portkey.aws/search-for-tag input "monitoring" :flattened? nil :xmlAttribute? nil), "iamInstanceProfile" (portkey.aws/search-for-tag input "iamInstanceProfile" :flattened? nil :xmlAttribute? nil), "sourceDestCheck" (portkey.aws/search-for-tag input "sourceDestCheck" :flattened? nil :xmlAttribute? nil), "virtualizationType" (portkey.aws/search-for-tag input "virtualizationType" :flattened? nil :xmlAttribute? nil), "launchTime" (portkey.aws/search-for-tag input "launchTime" :flattened? nil :xmlAttribute? nil), "imageId" (portkey.aws/search-for-tag input "imageId" :flattened? nil :xmlAttribute? nil), "rootDeviceType" (portkey.aws/search-for-tag input "rootDeviceType" :flattened? nil :xmlAttribute? nil), "ebsOptimized" (portkey.aws/search-for-tag input "ebsOptimized" :flattened? nil :xmlAttribute? nil), "amiLaunchIndex" (portkey.aws/search-for-tag input "amiLaunchIndex" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "capacityReservationSpecification" (portkey.aws/search-for-tag input "capacityReservationSpecification" :flattened? nil :xmlAttribute? nil), "kernelId" (portkey.aws/search-for-tag input "kernelId" :flattened? nil :xmlAttribute? nil), "reason" (portkey.aws/search-for-tag input "reason" :flattened? nil :xmlAttribute? nil), "enaSupport" (portkey.aws/search-for-tag input "enaSupport" :flattened? nil :xmlAttribute? nil), "instanceState" (portkey.aws/search-for-tag input "instanceState" :flattened? nil :xmlAttribute? nil), "networkInterfaceSet" (portkey.aws/search-for-tag input "networkInterfaceSet" :flattened? nil :xmlAttribute? nil), "rootDeviceName" (portkey.aws/search-for-tag input "rootDeviceName" :flattened? nil :xmlAttribute? nil), "hibernationOptions" (portkey.aws/search-for-tag input "hibernationOptions" :flattened? nil :xmlAttribute? nil), "hypervisor" (portkey.aws/search-for-tag input "hypervisor" :flattened? nil :xmlAttribute? nil), "capacityReservationId" (portkey.aws/search-for-tag input "capacityReservationId" :flattened? nil :xmlAttribute? nil), "platform" (portkey.aws/search-for-tag input "platform" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "dnsName" (portkey.aws/search-for-tag input "dnsName" :flattened? nil :xmlAttribute? nil), "ipAddress" (portkey.aws/search-for-tag input "ipAddress" :flattened? nil :xmlAttribute? nil), "elasticGpuAssociationSet" (portkey.aws/search-for-tag input "elasticGpuAssociationSet" :flattened? nil :xmlAttribute? nil), "sriovNetSupport" (portkey.aws/search-for-tag input "sriovNetSupport" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar641828 "dnsName") (clojure.core/assoc :public-dns-name (deser-string (clojure.core/get-in letvar641828 ["dnsName" :content]))) (letvar641828 "kernelId") (clojure.core/assoc :kernel-id (deser-string (clojure.core/get-in letvar641828 ["kernelId" :content]))) (letvar641828 "spotInstanceRequestId") (clojure.core/assoc :spot-instance-request-id (deser-string (clojure.core/get-in letvar641828 ["spotInstanceRequestId" :content]))) (letvar641828 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar641828 ["instanceId" :content]))) (letvar641828 "instanceLifecycle") (clojure.core/assoc :instance-lifecycle (deser-instance-lifecycle-type (clojure.core/get-in letvar641828 ["instanceLifecycle" :content]))) (letvar641828 "platform") (clojure.core/assoc :platform (deser-platform-values (clojure.core/get-in letvar641828 ["platform" :content]))) (letvar641828 "capacityReservationId") (clojure.core/assoc :capacity-reservation-id (deser-string (clojure.core/get-in letvar641828 ["capacityReservationId" :content]))) (letvar641828 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar641828 ["imageId" :content]))) (letvar641828 "placement") (clojure.core/assoc :placement (deser-placement (clojure.core/get-in letvar641828 ["placement" :content]))) (letvar641828 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar641828 ["subnetId" :content]))) (letvar641828 "rootDeviceType") (clojure.core/assoc :root-device-type (deser-device-type (clojure.core/get-in letvar641828 ["rootDeviceType" :content]))) (letvar641828 "groupSet") (clojure.core/assoc :security-groups (deser-group-identifier-list (clojure.core/get-in letvar641828 ["groupSet" :content]))) (letvar641828 "ebsOptimized") (clojure.core/assoc :ebs-optimized (deser-boolean (clojure.core/get-in letvar641828 ["ebsOptimized" :content]))) (letvar641828 "instanceType") (clojure.core/assoc :instance-type (deser-instance-type (clojure.core/get-in letvar641828 ["instanceType" :content]))) (letvar641828 "sriovNetSupport") (clojure.core/assoc :sriov-net-support (deser-string (clojure.core/get-in letvar641828 ["sriovNetSupport" :content]))) (letvar641828 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar641828 ["tagSet" :content]))) (letvar641828 "elasticInferenceAcceleratorAssociationSet") (clojure.core/assoc :elastic-inference-accelerator-associations (deser-elastic-inference-accelerator-association-list (clojure.core/get-in letvar641828 ["elasticInferenceAcceleratorAssociationSet" :content]))) (letvar641828 "sourceDestCheck") (clojure.core/assoc :source-dest-check (deser-boolean (clojure.core/get-in letvar641828 ["sourceDestCheck" :content]))) (letvar641828 "keyName") (clojure.core/assoc :key-name (deser-string (clojure.core/get-in letvar641828 ["keyName" :content]))) (letvar641828 "elasticGpuAssociationSet") (clojure.core/assoc :elastic-gpu-associations (deser-elastic-gpu-association-list (clojure.core/get-in letvar641828 ["elasticGpuAssociationSet" :content]))) (letvar641828 "privateDnsName") (clojure.core/assoc :private-dns-name (deser-string (clojure.core/get-in letvar641828 ["privateDnsName" :content]))) (letvar641828 "hibernationOptions") (clojure.core/assoc :hibernation-options (deser-hibernation-options (clojure.core/get-in letvar641828 ["hibernationOptions" :content]))) (letvar641828 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar641828 ["vpcId" :content]))) (letvar641828 "monitoring") (clojure.core/assoc :monitoring (deser-monitoring (clojure.core/get-in letvar641828 ["monitoring" :content]))) (letvar641828 "licenseSet") (clojure.core/assoc :licenses (deser-license-list (clojure.core/get-in letvar641828 ["licenseSet" :content]))) (letvar641828 "blockDeviceMapping") (clojure.core/assoc :block-device-mappings (deser-instance-block-device-mapping-list (clojure.core/get-in letvar641828 ["blockDeviceMapping" :content]))) (letvar641828 "hypervisor") (clojure.core/assoc :hypervisor (deser-hypervisor-type (clojure.core/get-in letvar641828 ["hypervisor" :content]))) (letvar641828 "architecture") (clojure.core/assoc :architecture (deser-architecture-values (clojure.core/get-in letvar641828 ["architecture" :content]))) (letvar641828 "virtualizationType") (clojure.core/assoc :virtualization-type (deser-virtualization-type (clojure.core/get-in letvar641828 ["virtualizationType" :content]))) (letvar641828 "capacityReservationSpecification") (clojure.core/assoc :capacity-reservation-specification (deser-capacity-reservation-specification-response (clojure.core/get-in letvar641828 ["capacityReservationSpecification" :content]))) (letvar641828 "productCodes") (clojure.core/assoc :product-codes (deser-product-code-list (clojure.core/get-in letvar641828 ["productCodes" :content]))) (letvar641828 "instanceState") (clojure.core/assoc :state (deser-instance-state (clojure.core/get-in letvar641828 ["instanceState" :content]))) (letvar641828 "cpuOptions") (clojure.core/assoc :cpu-options (deser-cpu-options (clojure.core/get-in letvar641828 ["cpuOptions" :content]))) (letvar641828 "rootDeviceName") (clojure.core/assoc :root-device-name (deser-string (clojure.core/get-in letvar641828 ["rootDeviceName" :content]))) (letvar641828 "ramdiskId") (clojure.core/assoc :ramdisk-id (deser-string (clojure.core/get-in letvar641828 ["ramdiskId" :content]))) (letvar641828 "launchTime") (clojure.core/assoc :launch-time (deser-date-time (clojure.core/get-in letvar641828 ["launchTime" :content]))) (letvar641828 "ipAddress") (clojure.core/assoc :public-ip-address (deser-string (clojure.core/get-in letvar641828 ["ipAddress" :content]))) (letvar641828 "stateReason") (clojure.core/assoc :state-reason (deser-state-reason (clojure.core/get-in letvar641828 ["stateReason" :content]))) (letvar641828 "iamInstanceProfile") (clojure.core/assoc :iam-instance-profile (deser-iam-instance-profile (clojure.core/get-in letvar641828 ["iamInstanceProfile" :content]))) (letvar641828 "amiLaunchIndex") (clojure.core/assoc :ami-launch-index (deser-integer (clojure.core/get-in letvar641828 ["amiLaunchIndex" :content]))) (letvar641828 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar641828 ["clientToken" :content]))) (letvar641828 "reason") (clojure.core/assoc :state-transition-reason (deser-string (clojure.core/get-in letvar641828 ["reason" :content]))) (letvar641828 "privateIpAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar641828 ["privateIpAddress" :content]))) (letvar641828 "networkInterfaceSet") (clojure.core/assoc :network-interfaces (deser-instance-network-interface-list (clojure.core/get-in letvar641828 ["networkInterfaceSet" :content]))) (letvar641828 "enaSupport") (clojure.core/assoc :ena-support (deser-boolean (clojure.core/get-in letvar641828 ["enaSupport" :content]))))))

(clojure.core/defn- deser-nat-gateway-state [input] (clojure.core/get {"pending" :pending, "failed" :failed, "available" :available, "deleting" :deleting, "deleted" :deleted} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-block-device-mapping-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-block-device-mapping coll))) input))

(clojure.core/defn- deser-blob [input] input)

(clojure.core/defn- deser-describe-fleets-instances-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-describe-fleets-instances coll))) input))

(clojure.core/defn- deser-delete-fleet-error-item [input] (clojure.core/let [letvar641977 {"error" (portkey.aws/search-for-tag input "error" :flattened? nil :xmlAttribute? nil), "fleetId" (portkey.aws/search-for-tag input "fleetId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar641977 "error") (clojure.core/assoc :error (deser-delete-fleet-error (clojure.core/get-in letvar641977 ["error" :content]))) (letvar641977 "fleetId") (clojure.core/assoc :fleet-id (deser-fleet-identifier (clojure.core/get-in letvar641977 ["fleetId" :content]))))))

(clojure.core/defn- deser-instance-block-device-mapping-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-block-device-mapping coll))) input))

(clojure.core/defn- deser-security-group-reference [input] (clojure.core/let [letvar642102 {"groupId" (portkey.aws/search-for-tag input "groupId" :flattened? nil :xmlAttribute? nil), "referencingVpcId" (portkey.aws/search-for-tag input "referencingVpcId" :flattened? nil :xmlAttribute? nil), "vpcPeeringConnectionId" (portkey.aws/search-for-tag input "vpcPeeringConnectionId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar642102 "groupId") (clojure.core/assoc :group-id (deser-string (clojure.core/get-in letvar642102 ["groupId" :content]))) (letvar642102 "referencingVpcId") (clojure.core/assoc :referencing-vpc-id (deser-string (clojure.core/get-in letvar642102 ["referencingVpcId" :content]))) (letvar642102 "vpcPeeringConnectionId") (clojure.core/assoc :vpc-peering-connection-id (deser-string (clojure.core/get-in letvar642102 ["vpcPeeringConnectionId" :content]))))))

(clojure.core/defn- deser-classic-link-dns-support-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-classic-link-dns-support coll))) input))

(clojure.core/defn- deser-gateway-type [input] (clojure.core/get {"ipsec.1" :ipsec-1} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-image [input] (clojure.core/let [letvar642232 {"creationDate" (portkey.aws/search-for-tag input "creationDate" :flattened? nil :xmlAttribute? nil), "ramdiskId" (portkey.aws/search-for-tag input "ramdiskId" :flattened? nil :xmlAttribute? nil), "productCodes" (portkey.aws/search-for-tag input "productCodes" :flattened? nil :xmlAttribute? nil), "architecture" (portkey.aws/search-for-tag input "architecture" :flattened? nil :xmlAttribute? nil), "stateReason" (portkey.aws/search-for-tag input "stateReason" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "blockDeviceMapping" (portkey.aws/search-for-tag input "blockDeviceMapping" :flattened? nil :xmlAttribute? nil), "imageLocation" (portkey.aws/search-for-tag input "imageLocation" :flattened? nil :xmlAttribute? nil), "name" (portkey.aws/search-for-tag input "name" :flattened? nil :xmlAttribute? nil), "imageOwnerId" (portkey.aws/search-for-tag input "imageOwnerId" :flattened? nil :xmlAttribute? nil), "virtualizationType" (portkey.aws/search-for-tag input "virtualizationType" :flattened? nil :xmlAttribute? nil), "imageId" (portkey.aws/search-for-tag input "imageId" :flattened? nil :xmlAttribute? nil), "imageState" (portkey.aws/search-for-tag input "imageState" :flattened? nil :xmlAttribute? nil), "rootDeviceType" (portkey.aws/search-for-tag input "rootDeviceType" :flattened? nil :xmlAttribute? nil), "imageType" (portkey.aws/search-for-tag input "imageType" :flattened? nil :xmlAttribute? nil), "imageOwnerAlias" (portkey.aws/search-for-tag input "imageOwnerAlias" :flattened? nil :xmlAttribute? nil), "kernelId" (portkey.aws/search-for-tag input "kernelId" :flattened? nil :xmlAttribute? nil), "enaSupport" (portkey.aws/search-for-tag input "enaSupport" :flattened? nil :xmlAttribute? nil), "rootDeviceName" (portkey.aws/search-for-tag input "rootDeviceName" :flattened? nil :xmlAttribute? nil), "hypervisor" (portkey.aws/search-for-tag input "hypervisor" :flattened? nil :xmlAttribute? nil), "isPublic" (portkey.aws/search-for-tag input "isPublic" :flattened? nil :xmlAttribute? nil), "platform" (portkey.aws/search-for-tag input "platform" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "sriovNetSupport" (portkey.aws/search-for-tag input "sriovNetSupport" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar642232 "kernelId") (clojure.core/assoc :kernel-id (deser-string (clojure.core/get-in letvar642232 ["kernelId" :content]))) (letvar642232 "platform") (clojure.core/assoc :platform (deser-platform-values (clojure.core/get-in letvar642232 ["platform" :content]))) (letvar642232 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar642232 ["imageId" :content]))) (letvar642232 "rootDeviceType") (clojure.core/assoc :root-device-type (deser-device-type (clojure.core/get-in letvar642232 ["rootDeviceType" :content]))) (letvar642232 "imageOwnerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar642232 ["imageOwnerId" :content]))) (letvar642232 "sriovNetSupport") (clojure.core/assoc :sriov-net-support (deser-string (clojure.core/get-in letvar642232 ["sriovNetSupport" :content]))) (letvar642232 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar642232 ["tagSet" :content]))) (letvar642232 "isPublic") (clojure.core/assoc :public (deser-boolean (clojure.core/get-in letvar642232 ["isPublic" :content]))) (letvar642232 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar642232 ["description" :content]))) (letvar642232 "blockDeviceMapping") (clojure.core/assoc :block-device-mappings (deser-block-device-mapping-list (clojure.core/get-in letvar642232 ["blockDeviceMapping" :content]))) (letvar642232 "hypervisor") (clojure.core/assoc :hypervisor (deser-hypervisor-type (clojure.core/get-in letvar642232 ["hypervisor" :content]))) (letvar642232 "architecture") (clojure.core/assoc :architecture (deser-architecture-values (clojure.core/get-in letvar642232 ["architecture" :content]))) (letvar642232 "imageOwnerAlias") (clojure.core/assoc :image-owner-alias (deser-string (clojure.core/get-in letvar642232 ["imageOwnerAlias" :content]))) (letvar642232 "creationDate") (clojure.core/assoc :creation-date (deser-string (clojure.core/get-in letvar642232 ["creationDate" :content]))) (letvar642232 "virtualizationType") (clojure.core/assoc :virtualization-type (deser-virtualization-type (clojure.core/get-in letvar642232 ["virtualizationType" :content]))) (letvar642232 "productCodes") (clojure.core/assoc :product-codes (deser-product-code-list (clojure.core/get-in letvar642232 ["productCodes" :content]))) (letvar642232 "imageLocation") (clojure.core/assoc :image-location (deser-string (clojure.core/get-in letvar642232 ["imageLocation" :content]))) (letvar642232 "imageState") (clojure.core/assoc :state (deser-image-state (clojure.core/get-in letvar642232 ["imageState" :content]))) (letvar642232 "imageType") (clojure.core/assoc :image-type (deser-image-type-values (clojure.core/get-in letvar642232 ["imageType" :content]))) (letvar642232 "rootDeviceName") (clojure.core/assoc :root-device-name (deser-string (clojure.core/get-in letvar642232 ["rootDeviceName" :content]))) (letvar642232 "ramdiskId") (clojure.core/assoc :ramdisk-id (deser-string (clojure.core/get-in letvar642232 ["ramdiskId" :content]))) (letvar642232 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar642232 ["name" :content]))) (letvar642232 "stateReason") (clojure.core/assoc :state-reason (deser-state-reason (clojure.core/get-in letvar642232 ["stateReason" :content]))) (letvar642232 "enaSupport") (clojure.core/assoc :ena-support (deser-boolean (clojure.core/get-in letvar642232 ["enaSupport" :content]))))))

(clojure.core/defn- deser-transport-protocol [input] (clojure.core/get {"tcp" :tcp, "udp" :udp} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-ip-range-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ip-range coll))) input))

(clojure.core/defn- deser-image-type-values [input] (clojure.core/get {"machine" :machine, "kernel" :kernel, "ramdisk" :ramdisk} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-classic-link-instance [input] (clojure.core/let [letvar642367 {"groupSet" (portkey.aws/search-for-tag input "groupSet" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar642367 "groupSet") (clojure.core/assoc :groups (deser-group-identifier-list (clojure.core/get-in letvar642367 ["groupSet" :content]))) (letvar642367 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar642367 ["instanceId" :content]))) (letvar642367 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar642367 ["tagSet" :content]))) (letvar642367 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar642367 ["vpcId" :content]))))))

(clojure.core/defn- deser-certificate-authentication [input] (clojure.core/let [letvar642475 {"clientRootCertificateChain" (portkey.aws/search-for-tag input "clientRootCertificateChain" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar642475 "clientRootCertificateChain") (clojure.core/assoc :client-root-certificate-chain (deser-string (clojure.core/get-in letvar642475 ["clientRootCertificateChain" :content]))))))

(clojure.core/defn- deser-classic-load-balancers [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-classic-load-balancer coll))) input))

(clojure.core/defn- deser-transit-gateway-route-attachment [input] (clojure.core/let [letvar642600 {"resourceId" (portkey.aws/search-for-tag input "resourceId" :flattened? nil :xmlAttribute? nil), "transitGatewayAttachmentId" (portkey.aws/search-for-tag input "transitGatewayAttachmentId" :flattened? nil :xmlAttribute? nil), "resourceType" (portkey.aws/search-for-tag input "resourceType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar642600 "resourceId") (clojure.core/assoc :resource-id (deser-string (clojure.core/get-in letvar642600 ["resourceId" :content]))) (letvar642600 "transitGatewayAttachmentId") (clojure.core/assoc :transit-gateway-attachment-id (deser-string (clojure.core/get-in letvar642600 ["transitGatewayAttachmentId" :content]))) (letvar642600 "resourceType") (clojure.core/assoc :resource-type (deser-transit-gateway-attachment-resource-type (clojure.core/get-in letvar642600 ["resourceType" :content]))))))

(clojure.core/defn- deser-security-group-identifier [input] (clojure.core/let [letvar642708 {"groupId" (portkey.aws/search-for-tag input "groupId" :flattened? nil :xmlAttribute? nil), "groupName" (portkey.aws/search-for-tag input "groupName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar642708 "groupId") (clojure.core/assoc :group-id (deser-string (clojure.core/get-in letvar642708 ["groupId" :content]))) (letvar642708 "groupName") (clojure.core/assoc :group-name (deser-string (clojure.core/get-in letvar642708 ["groupName" :content]))))))

(clojure.core/defn- deser-transit-gateway-attachment-propagation [input] (clojure.core/let [letvar642816 {"transitGatewayRouteTableId" (portkey.aws/search-for-tag input "transitGatewayRouteTableId" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar642816 "transitGatewayRouteTableId") (clojure.core/assoc :transit-gateway-route-table-id (deser-string (clojure.core/get-in letvar642816 ["transitGatewayRouteTableId" :content]))) (letvar642816 "state") (clojure.core/assoc :state (deser-transit-gateway-propagation-state (clojure.core/get-in letvar642816 ["state" :content]))))))

(clojure.core/defn- deser-cancel-spot-fleet-requests-error-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cancel-spot-fleet-requests-error-item coll))) input))

(clojure.core/defn- deser-reserved-instances-modification-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-instances-modification coll))) input))

(clojure.core/defn- deser-network-acl-entry-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-network-acl-entry coll))) input))

(clojure.core/defn- deser-network-interface-private-ip-address-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-network-interface-private-ip-address coll))) input))

(clojure.core/defn- deser-target-group [input] (clojure.core/let [letvar642992 {"arn" (portkey.aws/search-for-tag input "arn" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar642992 "arn") (clojure.core/assoc :arn (deser-string (clojure.core/get-in letvar642992 ["arn" :content]))))))

(clojure.core/defn- deser-instance-event-id [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-conversion-task-state [input] (clojure.core/get {"active" :active, "cancelling" :cancelling, "cancelled" :cancelled, "completed" :completed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-transit-gateway-route-table-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-transit-gateway-route-table-association coll))) input))

(clojure.core/defn- deser-offering-class-type [input] (clojure.core/get {"standard" :standard, "convertible" :convertible} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-launch-template-error-code [input] (clojure.core/get {"launchTemplateIdDoesNotExist" :launch-template-id-does-not-exist, "launchTemplateIdMalformed" :launch-template-id-malformed, "launchTemplateNameDoesNotExist" :launch-template-name-does-not-exist, "launchTemplateNameMalformed" :launch-template-name-malformed, "launchTemplateVersionDoesNotExist" :launch-template-version-does-not-exist, "unexpectedError" :unexpected-error} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-nat-gateway-address-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-nat-gateway-address coll))) input))

(clojure.core/defn- deser-transit-gateway-route-table-propagation-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-transit-gateway-route-table-propagation coll))) input))

(clojure.core/defn- deser-reserved-instances-modification [input] (clojure.core/let [letvar643171 {"updateDate" (portkey.aws/search-for-tag input "updateDate" :flattened? nil :xmlAttribute? nil), "createDate" (portkey.aws/search-for-tag input "createDate" :flattened? nil :xmlAttribute? nil), "clientToken" (portkey.aws/search-for-tag input "clientToken" :flattened? nil :xmlAttribute? nil), "effectiveDate" (portkey.aws/search-for-tag input "effectiveDate" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "statusMessage" (portkey.aws/search-for-tag input "statusMessage" :flattened? nil :xmlAttribute? nil), "reservedInstancesSet" (portkey.aws/search-for-tag input "reservedInstancesSet" :flattened? nil :xmlAttribute? nil), "modificationResultSet" (portkey.aws/search-for-tag input "modificationResultSet" :flattened? nil :xmlAttribute? nil), "reservedInstancesModificationId" (portkey.aws/search-for-tag input "reservedInstancesModificationId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar643171 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar643171 ["statusMessage" :content]))) (letvar643171 "createDate") (clojure.core/assoc :create-date (deser-date-time (clojure.core/get-in letvar643171 ["createDate" :content]))) (letvar643171 "reservedInstancesModificationId") (clojure.core/assoc :reserved-instances-modification-id (deser-string (clojure.core/get-in letvar643171 ["reservedInstancesModificationId" :content]))) (letvar643171 "status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar643171 ["status" :content]))) (letvar643171 "modificationResultSet") (clojure.core/assoc :modification-results (deser-reserved-instances-modification-result-list (clojure.core/get-in letvar643171 ["modificationResultSet" :content]))) (letvar643171 "reservedInstancesSet") (clojure.core/assoc :reserved-instances-ids (deser-reserved-intances-ids (clojure.core/get-in letvar643171 ["reservedInstancesSet" :content]))) (letvar643171 "updateDate") (clojure.core/assoc :update-date (deser-date-time (clojure.core/get-in letvar643171 ["updateDate" :content]))) (letvar643171 "effectiveDate") (clojure.core/assoc :effective-date (deser-date-time (clojure.core/get-in letvar643171 ["effectiveDate" :content]))) (letvar643171 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar643171 ["clientToken" :content]))))))

(clojure.core/defn- deser-listing-status [input] (clojure.core/get {"active" :active, "pending" :pending, "cancelled" :cancelled, "closed" :closed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-launch-template-overrides-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-launch-template-overrides coll))) input))

(clojure.core/defn- deser-classic-link-instance-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-classic-link-instance coll))) input))

(clojure.core/defn- deser-import-image-task-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-import-image-task coll))) input))

(clojure.core/defn- deser-capacity-reservation-preference [input] (clojure.core/get {"open" :open, "none" :none} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-route-table-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-route-table-association coll))) input))

(clojure.core/defn- deser-iam-instance-profile-association-state [input] (clojure.core/get {"associating" :associating, "associated" :associated, "disassociating" :disassociating, "disassociated" :disassociated} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-service-configuration [input] (clojure.core/let [letvar643362 {"serviceType" (portkey.aws/search-for-tag input "serviceType" :flattened? nil :xmlAttribute? nil), "privateDnsName" (portkey.aws/search-for-tag input "privateDnsName" :flattened? nil :xmlAttribute? nil), "acceptanceRequired" (portkey.aws/search-for-tag input "acceptanceRequired" :flattened? nil :xmlAttribute? nil), "availabilityZoneSet" (portkey.aws/search-for-tag input "availabilityZoneSet" :flattened? nil :xmlAttribute? nil), "serviceName" (portkey.aws/search-for-tag input "serviceName" :flattened? nil :xmlAttribute? nil), "serviceId" (portkey.aws/search-for-tag input "serviceId" :flattened? nil :xmlAttribute? nil), "networkLoadBalancerArnSet" (portkey.aws/search-for-tag input "networkLoadBalancerArnSet" :flattened? nil :xmlAttribute? nil), "serviceState" (portkey.aws/search-for-tag input "serviceState" :flattened? nil :xmlAttribute? nil), "baseEndpointDnsNameSet" (portkey.aws/search-for-tag input "baseEndpointDnsNameSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar643362 "acceptanceRequired") (clojure.core/assoc :acceptance-required (deser-boolean (clojure.core/get-in letvar643362 ["acceptanceRequired" :content]))) (letvar643362 "serviceType") (clojure.core/assoc :service-type (deser-service-type-detail-set (clojure.core/get-in letvar643362 ["serviceType" :content]))) (letvar643362 "serviceState") (clojure.core/assoc :service-state (deser-service-state (clojure.core/get-in letvar643362 ["serviceState" :content]))) (letvar643362 "privateDnsName") (clojure.core/assoc :private-dns-name (deser-string (clojure.core/get-in letvar643362 ["privateDnsName" :content]))) (letvar643362 "serviceId") (clojure.core/assoc :service-id (deser-string (clojure.core/get-in letvar643362 ["serviceId" :content]))) (letvar643362 "baseEndpointDnsNameSet") (clojure.core/assoc :base-endpoint-dns-names (deser-value-string-list (clojure.core/get-in letvar643362 ["baseEndpointDnsNameSet" :content]))) (letvar643362 "networkLoadBalancerArnSet") (clojure.core/assoc :network-load-balancer-arns (deser-value-string-list (clojure.core/get-in letvar643362 ["networkLoadBalancerArnSet" :content]))) (letvar643362 "serviceName") (clojure.core/assoc :service-name (deser-string (clojure.core/get-in letvar643362 ["serviceName" :content]))) (letvar643362 "availabilityZoneSet") (clojure.core/assoc :availability-zones (deser-value-string-list (clojure.core/get-in letvar643362 ["availabilityZoneSet" :content]))))))

(clojure.core/defn- deser-offering-type-values [input] (clojure.core/get {"Heavy Utilization" :heavy-utilization, "Medium Utilization" :medium-utilization, "Light Utilization" :light-utilization, "No Upfront" :no-upfront, "Partial Upfront" :partial-upfront, "All Upfront" :all-upfront} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-float [input] (java.lang.Float. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-network-acl [input] (clojure.core/let [letvar643477 {"associationSet" (portkey.aws/search-for-tag input "associationSet" :flattened? nil :xmlAttribute? nil), "entrySet" (portkey.aws/search-for-tag input "entrySet" :flattened? nil :xmlAttribute? nil), "default" (portkey.aws/search-for-tag input "default" :flattened? nil :xmlAttribute? nil), "networkAclId" (portkey.aws/search-for-tag input "networkAclId" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "ownerId" (portkey.aws/search-for-tag input "ownerId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar643477 "associationSet") (clojure.core/assoc :associations (deser-network-acl-association-list (clojure.core/get-in letvar643477 ["associationSet" :content]))) (letvar643477 "entrySet") (clojure.core/assoc :entries (deser-network-acl-entry-list (clojure.core/get-in letvar643477 ["entrySet" :content]))) (letvar643477 "default") (clojure.core/assoc :is-default (deser-boolean (clojure.core/get-in letvar643477 ["default" :content]))) (letvar643477 "networkAclId") (clojure.core/assoc :network-acl-id (deser-string (clojure.core/get-in letvar643477 ["networkAclId" :content]))) (letvar643477 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar643477 ["tagSet" :content]))) (letvar643477 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar643477 ["vpcId" :content]))) (letvar643477 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar643477 ["ownerId" :content]))))))

(clojure.core/defn- deser-target-capacity-specification [input] (clojure.core/let [letvar643585 {"totalTargetCapacity" (portkey.aws/search-for-tag input "totalTargetCapacity" :flattened? nil :xmlAttribute? nil), "onDemandTargetCapacity" (portkey.aws/search-for-tag input "onDemandTargetCapacity" :flattened? nil :xmlAttribute? nil), "spotTargetCapacity" (portkey.aws/search-for-tag input "spotTargetCapacity" :flattened? nil :xmlAttribute? nil), "defaultTargetCapacityType" (portkey.aws/search-for-tag input "defaultTargetCapacityType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar643585 "totalTargetCapacity") (clojure.core/assoc :total-target-capacity (deser-integer (clojure.core/get-in letvar643585 ["totalTargetCapacity" :content]))) (letvar643585 "onDemandTargetCapacity") (clojure.core/assoc :on-demand-target-capacity (deser-integer (clojure.core/get-in letvar643585 ["onDemandTargetCapacity" :content]))) (letvar643585 "spotTargetCapacity") (clojure.core/assoc :spot-target-capacity (deser-integer (clojure.core/get-in letvar643585 ["spotTargetCapacity" :content]))) (letvar643585 "defaultTargetCapacityType") (clojure.core/assoc :default-target-capacity-type (deser-default-target-capacity-type (clojure.core/get-in letvar643585 ["defaultTargetCapacityType" :content]))))))

(clojure.core/defn- deser-delete-launch-template-versions-response-error-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-delete-launch-template-versions-response-error-item coll))) input))

(clojure.core/defn- deser-unsuccessful-instance-credit-specification-item-error [input] (clojure.core/let [letvar643710 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar643710 "code") (clojure.core/assoc :code (deser-unsuccessful-instance-credit-specification-error-code (clojure.core/get-in letvar643710 ["code" :content]))) (letvar643710 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar643710 ["message" :content]))))))

(clojure.core/defn- deser-volume-attachment [input] (clojure.core/let [letvar643818 {"attachTime" (portkey.aws/search-for-tag input "attachTime" :flattened? nil :xmlAttribute? nil), "device" (portkey.aws/search-for-tag input "device" :flattened? nil :xmlAttribute? nil), "instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "status" (portkey.aws/search-for-tag input "status" :flattened? nil :xmlAttribute? nil), "volumeId" (portkey.aws/search-for-tag input "volumeId" :flattened? nil :xmlAttribute? nil), "deleteOnTermination" (portkey.aws/search-for-tag input "deleteOnTermination" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar643818 "attachTime") (clojure.core/assoc :attach-time (deser-date-time (clojure.core/get-in letvar643818 ["attachTime" :content]))) (letvar643818 "device") (clojure.core/assoc :device (deser-string (clojure.core/get-in letvar643818 ["device" :content]))) (letvar643818 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar643818 ["instanceId" :content]))) (letvar643818 "status") (clojure.core/assoc :state (deser-volume-attachment-state (clojure.core/get-in letvar643818 ["status" :content]))) (letvar643818 "volumeId") (clojure.core/assoc :volume-id (deser-string (clojure.core/get-in letvar643818 ["volumeId" :content]))) (letvar643818 "deleteOnTermination") (clojure.core/assoc :delete-on-termination (deser-boolean (clojure.core/get-in letvar643818 ["deleteOnTermination" :content]))))))

(clojure.core/defn- deser-route-table-association [input] (clojure.core/let [letvar643926 {"main" (portkey.aws/search-for-tag input "main" :flattened? nil :xmlAttribute? nil), "routeTableAssociationId" (portkey.aws/search-for-tag input "routeTableAssociationId" :flattened? nil :xmlAttribute? nil), "routeTableId" (portkey.aws/search-for-tag input "routeTableId" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar643926 "main") (clojure.core/assoc :main (deser-boolean (clojure.core/get-in letvar643926 ["main" :content]))) (letvar643926 "routeTableAssociationId") (clojure.core/assoc :route-table-association-id (deser-string (clojure.core/get-in letvar643926 ["routeTableAssociationId" :content]))) (letvar643926 "routeTableId") (clojure.core/assoc :route-table-id (deser-string (clojure.core/get-in letvar643926 ["routeTableId" :content]))) (letvar643926 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar643926 ["subnetId" :content]))))))

(clojure.core/defn- deser-subnet-ipv-6-cidr-block-association [input] (clojure.core/let [letvar644034 {"associationId" (portkey.aws/search-for-tag input "associationId" :flattened? nil :xmlAttribute? nil), "ipv6CidrBlock" (portkey.aws/search-for-tag input "ipv6CidrBlock" :flattened? nil :xmlAttribute? nil), "ipv6CidrBlockState" (portkey.aws/search-for-tag input "ipv6CidrBlockState" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar644034 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar644034 ["associationId" :content]))) (letvar644034 "ipv6CidrBlock") (clojure.core/assoc :ipv-6-cidr-block (deser-string (clojure.core/get-in letvar644034 ["ipv6CidrBlock" :content]))) (letvar644034 "ipv6CidrBlockState") (clojure.core/assoc :ipv-6-cidr-block-state (deser-subnet-cidr-block-state (clojure.core/get-in letvar644034 ["ipv6CidrBlockState" :content]))))))

(clojure.core/defn- deser-public-ipv-4-pool-range [input] (clojure.core/let [letvar644142 {"firstAddress" (portkey.aws/search-for-tag input "firstAddress" :flattened? nil :xmlAttribute? nil), "lastAddress" (portkey.aws/search-for-tag input "lastAddress" :flattened? nil :xmlAttribute? nil), "addressCount" (portkey.aws/search-for-tag input "addressCount" :flattened? nil :xmlAttribute? nil), "availableAddressCount" (portkey.aws/search-for-tag input "availableAddressCount" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar644142 "firstAddress") (clojure.core/assoc :first-address (deser-string (clojure.core/get-in letvar644142 ["firstAddress" :content]))) (letvar644142 "lastAddress") (clojure.core/assoc :last-address (deser-string (clojure.core/get-in letvar644142 ["lastAddress" :content]))) (letvar644142 "addressCount") (clojure.core/assoc :address-count (deser-integer (clojure.core/get-in letvar644142 ["addressCount" :content]))) (letvar644142 "availableAddressCount") (clojure.core/assoc :available-address-count (deser-integer (clojure.core/get-in letvar644142 ["availableAddressCount" :content]))))))

(clojure.core/defn- deser-principal-id-format [input] (clojure.core/let [letvar644250 {"arn" (portkey.aws/search-for-tag input "arn" :flattened? nil :xmlAttribute? nil), "statusSet" (portkey.aws/search-for-tag input "statusSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar644250 "arn") (clojure.core/assoc :arn (deser-string (clojure.core/get-in letvar644250 ["arn" :content]))) (letvar644250 "statusSet") (clojure.core/assoc :statuses (deser-id-format-list (clojure.core/get-in letvar644250 ["statusSet" :content]))))))

(clojure.core/defn- deser-vpn-connection [input] (clojure.core/let [letvar644358 {"vpnGatewayId" (portkey.aws/search-for-tag input "vpnGatewayId" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "customerGatewayId" (portkey.aws/search-for-tag input "customerGatewayId" :flattened? nil :xmlAttribute? nil), "transitGatewayId" (portkey.aws/search-for-tag input "transitGatewayId" :flattened? nil :xmlAttribute? nil), "vgwTelemetry" (portkey.aws/search-for-tag input "vgwTelemetry" :flattened? nil :xmlAttribute? nil), "customerGatewayConfiguration" (portkey.aws/search-for-tag input "customerGatewayConfiguration" :flattened? nil :xmlAttribute? nil), "type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil), "vpnConnectionId" (portkey.aws/search-for-tag input "vpnConnectionId" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "category" (portkey.aws/search-for-tag input "category" :flattened? nil :xmlAttribute? nil), "options" (portkey.aws/search-for-tag input "options" :flattened? nil :xmlAttribute? nil), "routes" (portkey.aws/search-for-tag input "routes" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar644358 "transitGatewayId") (clojure.core/assoc :transit-gateway-id (deser-string (clojure.core/get-in letvar644358 ["transitGatewayId" :content]))) (letvar644358 "type") (clojure.core/assoc :type (deser-gateway-type (clojure.core/get-in letvar644358 ["type" :content]))) (letvar644358 "category") (clojure.core/assoc :category (deser-string (clojure.core/get-in letvar644358 ["category" :content]))) (letvar644358 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar644358 ["tagSet" :content]))) (letvar644358 "routes") (clojure.core/assoc :routes (deser-vpn-static-route-list (clojure.core/get-in letvar644358 ["routes" :content]))) (letvar644358 "customerGatewayId") (clojure.core/assoc :customer-gateway-id (deser-string (clojure.core/get-in letvar644358 ["customerGatewayId" :content]))) (letvar644358 "vpnGatewayId") (clojure.core/assoc :vpn-gateway-id (deser-string (clojure.core/get-in letvar644358 ["vpnGatewayId" :content]))) (letvar644358 "vgwTelemetry") (clojure.core/assoc :vgw-telemetry (deser-vgw-telemetry-list (clojure.core/get-in letvar644358 ["vgwTelemetry" :content]))) (letvar644358 "vpnConnectionId") (clojure.core/assoc :vpn-connection-id (deser-string (clojure.core/get-in letvar644358 ["vpnConnectionId" :content]))) (letvar644358 "state") (clojure.core/assoc :state (deser-vpn-state (clojure.core/get-in letvar644358 ["state" :content]))) (letvar644358 "options") (clojure.core/assoc :options (deser-vpn-connection-options (clojure.core/get-in letvar644358 ["options" :content]))) (letvar644358 "customerGatewayConfiguration") (clojure.core/assoc :customer-gateway-configuration (deser-string (clojure.core/get-in letvar644358 ["customerGatewayConfiguration" :content]))))))

(clojure.core/defn- deser-region [input] (clojure.core/let [letvar644466 {"regionEndpoint" (portkey.aws/search-for-tag input "regionEndpoint" :flattened? nil :xmlAttribute? nil), "regionName" (portkey.aws/search-for-tag input "regionName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar644466 "regionEndpoint") (clojure.core/assoc :endpoint (deser-string (clojure.core/get-in letvar644466 ["regionEndpoint" :content]))) (letvar644466 "regionName") (clojure.core/assoc :region-name (deser-string (clojure.core/get-in letvar644466 ["regionName" :content]))))))

(clojure.core/defn- deser-fpga-image-state [input] (clojure.core/let [letvar644574 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar644574 "code") (clojure.core/assoc :code (deser-fpga-image-state-code (clojure.core/get-in letvar644574 ["code" :content]))) (letvar644574 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar644574 ["message" :content]))))))

(clojure.core/defn- deser-state-reason [input] (clojure.core/let [letvar644682 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar644682 "code") (clojure.core/assoc :code (deser-string (clojure.core/get-in letvar644682 ["code" :content]))) (letvar644682 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar644682 ["message" :content]))))))

(clojure.core/defn- deser-elastic-gpu-state [input] (clojure.core/get {"ATTACHED" :attached} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-iam-instance-profile [input] (clojure.core/let [letvar644795 {"arn" (portkey.aws/search-for-tag input "arn" :flattened? nil :xmlAttribute? nil), "id" (portkey.aws/search-for-tag input "id" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar644795 "arn") (clojure.core/assoc :arn (deser-string (clojure.core/get-in letvar644795 ["arn" :content]))) (letvar644795 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar644795 ["id" :content]))))))

(clojure.core/defn- deser-scheduled-instance-availability [input] (clojure.core/let [letvar644903 {"firstSlotStartTime" (portkey.aws/search-for-tag input "firstSlotStartTime" :flattened? nil :xmlAttribute? nil), "maxTermDurationInDays" (portkey.aws/search-for-tag input "maxTermDurationInDays" :flattened? nil :xmlAttribute? nil), "networkPlatform" (portkey.aws/search-for-tag input "networkPlatform" :flattened? nil :xmlAttribute? nil), "hourlyPrice" (portkey.aws/search-for-tag input "hourlyPrice" :flattened? nil :xmlAttribute? nil), "purchaseToken" (portkey.aws/search-for-tag input "purchaseToken" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "recurrence" (portkey.aws/search-for-tag input "recurrence" :flattened? nil :xmlAttribute? nil), "availableInstanceCount" (portkey.aws/search-for-tag input "availableInstanceCount" :flattened? nil :xmlAttribute? nil), "totalScheduledInstanceHours" (portkey.aws/search-for-tag input "totalScheduledInstanceHours" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "slotDurationInHours" (portkey.aws/search-for-tag input "slotDurationInHours" :flattened? nil :xmlAttribute? nil), "minTermDurationInDays" (portkey.aws/search-for-tag input "minTermDurationInDays" :flattened? nil :xmlAttribute? nil), "platform" (portkey.aws/search-for-tag input "platform" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar644903 "maxTermDurationInDays") (clojure.core/assoc :max-term-duration-in-days (deser-integer (clojure.core/get-in letvar644903 ["maxTermDurationInDays" :content]))) (letvar644903 "platform") (clojure.core/assoc :platform (deser-string (clojure.core/get-in letvar644903 ["platform" :content]))) (letvar644903 "networkPlatform") (clojure.core/assoc :network-platform (deser-string (clojure.core/get-in letvar644903 ["networkPlatform" :content]))) (letvar644903 "recurrence") (clojure.core/assoc :recurrence (deser-scheduled-instance-recurrence (clojure.core/get-in letvar644903 ["recurrence" :content]))) (letvar644903 "instanceType") (clojure.core/assoc :instance-type (deser-string (clojure.core/get-in letvar644903 ["instanceType" :content]))) (letvar644903 "totalScheduledInstanceHours") (clojure.core/assoc :total-scheduled-instance-hours (deser-integer (clojure.core/get-in letvar644903 ["totalScheduledInstanceHours" :content]))) (letvar644903 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar644903 ["availabilityZone" :content]))) (letvar644903 "hourlyPrice") (clojure.core/assoc :hourly-price (deser-string (clojure.core/get-in letvar644903 ["hourlyPrice" :content]))) (letvar644903 "purchaseToken") (clojure.core/assoc :purchase-token (deser-string (clojure.core/get-in letvar644903 ["purchaseToken" :content]))) (letvar644903 "slotDurationInHours") (clojure.core/assoc :slot-duration-in-hours (deser-integer (clojure.core/get-in letvar644903 ["slotDurationInHours" :content]))) (letvar644903 "firstSlotStartTime") (clojure.core/assoc :first-slot-start-time (deser-date-time (clojure.core/get-in letvar644903 ["firstSlotStartTime" :content]))) (letvar644903 "availableInstanceCount") (clojure.core/assoc :available-instance-count (deser-integer (clojure.core/get-in letvar644903 ["availableInstanceCount" :content]))) (letvar644903 "minTermDurationInDays") (clojure.core/assoc :min-term-duration-in-days (deser-integer (clojure.core/get-in letvar644903 ["minTermDurationInDays" :content]))))))

(clojure.core/defn- deser-active-instance [input] (clojure.core/let [letvar645011 {"instanceId" (portkey.aws/search-for-tag input "instanceId" :flattened? nil :xmlAttribute? nil), "instanceType" (portkey.aws/search-for-tag input "instanceType" :flattened? nil :xmlAttribute? nil), "spotInstanceRequestId" (portkey.aws/search-for-tag input "spotInstanceRequestId" :flattened? nil :xmlAttribute? nil), "instanceHealth" (portkey.aws/search-for-tag input "instanceHealth" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar645011 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar645011 ["instanceId" :content]))) (letvar645011 "instanceType") (clojure.core/assoc :instance-type (deser-string (clojure.core/get-in letvar645011 ["instanceType" :content]))) (letvar645011 "spotInstanceRequestId") (clojure.core/assoc :spot-instance-request-id (deser-string (clojure.core/get-in letvar645011 ["spotInstanceRequestId" :content]))) (letvar645011 "instanceHealth") (clojure.core/assoc :instance-health (deser-instance-health-status (clojure.core/get-in letvar645011 ["instanceHealth" :content]))))))

(clojure.core/defn- deser-fleet-excess-capacity-termination-policy [input] (clojure.core/get {"no-termination" :notermination, "termination" :termination} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-subnet-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-subnet coll))) input))

(clojure.core/defn- deser-account-attribute-value [input] (clojure.core/let [letvar645141 {"attributeValue" (portkey.aws/search-for-tag input "attributeValue" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar645141 "attributeValue") (clojure.core/assoc :attribute-value (deser-string (clojure.core/get-in letvar645141 ["attributeValue" :content]))))))

(clojure.core/defn- deser-vpc-peering-connection-state-reason-code [input] (clojure.core/get {"expired" :expired, "deleting" :deleting, "failed" :failed, "initiating-request" :initiatingrequest, "provisioning" :provisioning, "deleted" :deleted, "pending-acceptance" :pendingacceptance, "active" :active, "rejected" :rejected} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-launch-permission [input] (clojure.core/let [letvar645254 {"group" (portkey.aws/search-for-tag input "group" :flattened? nil :xmlAttribute? nil), "userId" (portkey.aws/search-for-tag input "userId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar645254 "group") (clojure.core/assoc :group (deser-permission-group (clojure.core/get-in letvar645254 ["group" :content]))) (letvar645254 "userId") (clojure.core/assoc :user-id (deser-string (clojure.core/get-in letvar645254 ["userId" :content]))))))

(clojure.core/defn- deser-elastic-gpu-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-elastic-gpus coll))) input))

(clojure.core/defn- deser-internet-gateway-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-internet-gateway coll))) input))

(clojure.core/defn- deser-delete-fleet-error [input] (clojure.core/let [letvar645396 {"code" (portkey.aws/search-for-tag input "code" :flattened? nil :xmlAttribute? nil), "message" (portkey.aws/search-for-tag input "message" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar645396 "code") (clojure.core/assoc :code (deser-delete-fleet-error-code (clojure.core/get-in letvar645396 ["code" :content]))) (letvar645396 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar645396 ["message" :content]))))))

(clojure.core/defn- deser-account-attribute [input] (clojure.core/let [letvar645504 {"attributeName" (portkey.aws/search-for-tag input "attributeName" :flattened? nil :xmlAttribute? nil), "attributeValueSet" (portkey.aws/search-for-tag input "attributeValueSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar645504 "attributeName") (clojure.core/assoc :attribute-name (deser-string (clojure.core/get-in letvar645504 ["attributeName" :content]))) (letvar645504 "attributeValueSet") (clojure.core/assoc :attribute-values (deser-account-attribute-value-list (clojure.core/get-in letvar645504 ["attributeValueSet" :content]))))))

(clojure.core/defn- deser-history-record-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-history-record-entry coll))) input))

(clojure.core/defn- deser-launch-template-instance-market-options [input] (clojure.core/let [letvar645629 {"marketType" (portkey.aws/search-for-tag input "marketType" :flattened? nil :xmlAttribute? nil), "spotOptions" (portkey.aws/search-for-tag input "spotOptions" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar645629 "marketType") (clojure.core/assoc :market-type (deser-market-type (clojure.core/get-in letvar645629 ["marketType" :content]))) (letvar645629 "spotOptions") (clojure.core/assoc :spot-options (deser-launch-template-spot-market-options (clojure.core/get-in letvar645629 ["spotOptions" :content]))))))

(clojure.core/defn- deser-ipv-6-range [input] (clojure.core/let [letvar645737 {"cidrIpv6" (portkey.aws/search-for-tag input "cidrIpv6" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar645737 "cidrIpv6") (clojure.core/assoc :cidr-ipv-6 (deser-string (clojure.core/get-in letvar645737 ["cidrIpv6" :content]))) (letvar645737 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar645737 ["description" :content]))))))

(clojure.core/defn- deser-host [input] (clojure.core/let [letvar645845 {"availableCapacity" (portkey.aws/search-for-tag input "availableCapacity" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil), "clientToken" (portkey.aws/search-for-tag input "clientToken" :flattened? nil :xmlAttribute? nil), "hostReservationId" (portkey.aws/search-for-tag input "hostReservationId" :flattened? nil :xmlAttribute? nil), "allocationTime" (portkey.aws/search-for-tag input "allocationTime" :flattened? nil :xmlAttribute? nil), "hostProperties" (portkey.aws/search-for-tag input "hostProperties" :flattened? nil :xmlAttribute? nil), "hostId" (portkey.aws/search-for-tag input "hostId" :flattened? nil :xmlAttribute? nil), "releaseTime" (portkey.aws/search-for-tag input "releaseTime" :flattened? nil :xmlAttribute? nil), "availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "instances" (portkey.aws/search-for-tag input "instances" :flattened? nil :xmlAttribute? nil), "autoPlacement" (portkey.aws/search-for-tag input "autoPlacement" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar645845 "releaseTime") (clojure.core/assoc :release-time (deser-date-time (clojure.core/get-in letvar645845 ["releaseTime" :content]))) (letvar645845 "hostProperties") (clojure.core/assoc :host-properties (deser-host-properties (clojure.core/get-in letvar645845 ["hostProperties" :content]))) (letvar645845 "hostId") (clojure.core/assoc :host-id (deser-string (clojure.core/get-in letvar645845 ["hostId" :content]))) (letvar645845 "availableCapacity") (clojure.core/assoc :available-capacity (deser-available-capacity (clojure.core/get-in letvar645845 ["availableCapacity" :content]))) (letvar645845 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar645845 ["tagSet" :content]))) (letvar645845 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar645845 ["availabilityZone" :content]))) (letvar645845 "autoPlacement") (clojure.core/assoc :auto-placement (deser-auto-placement (clojure.core/get-in letvar645845 ["autoPlacement" :content]))) (letvar645845 "hostReservationId") (clojure.core/assoc :host-reservation-id (deser-string (clojure.core/get-in letvar645845 ["hostReservationId" :content]))) (letvar645845 "state") (clojure.core/assoc :state (deser-allocation-state (clojure.core/get-in letvar645845 ["state" :content]))) (letvar645845 "allocationTime") (clojure.core/assoc :allocation-time (deser-date-time (clojure.core/get-in letvar645845 ["allocationTime" :content]))) (letvar645845 "instances") (clojure.core/assoc :instances (deser-host-instance-list (clojure.core/get-in letvar645845 ["instances" :content]))) (letvar645845 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar645845 ["clientToken" :content]))))))

(clojure.core/defn- deser-egress-only-internet-gateway-id [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-transit-gateway-propagation-state [input] (clojure.core/get {"enabling" :enabling, "enabled" :enabled, "disabling" :disabling, "disabled" :disabled} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-activity-status [input] (clojure.core/get {"error" :error, "pending_fulfillment" :pending-fulfillment, "pending_termination" :pending-termination, "fulfilled" :fulfilled} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-placement-group [input] (clojure.core/let [letvar645968 {"groupName" (portkey.aws/search-for-tag input "groupName" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "strategy" (portkey.aws/search-for-tag input "strategy" :flattened? nil :xmlAttribute? nil), "partitionCount" (portkey.aws/search-for-tag input "partitionCount" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar645968 "groupName") (clojure.core/assoc :group-name (deser-string (clojure.core/get-in letvar645968 ["groupName" :content]))) (letvar645968 "state") (clojure.core/assoc :state (deser-placement-group-state (clojure.core/get-in letvar645968 ["state" :content]))) (letvar645968 "strategy") (clojure.core/assoc :strategy (deser-placement-strategy (clojure.core/get-in letvar645968 ["strategy" :content]))) (letvar645968 "partitionCount") (clojure.core/assoc :partition-count (deser-integer (clojure.core/get-in letvar645968 ["partitionCount" :content]))))))

(clojure.core/defn- deser-reserved-instance-reservation-value [input] (clojure.core/let [letvar646076 {"reservationValue" (portkey.aws/search-for-tag input "reservationValue" :flattened? nil :xmlAttribute? nil), "reservedInstanceId" (portkey.aws/search-for-tag input "reservedInstanceId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar646076 "reservationValue") (clojure.core/assoc :reservation-value (deser-reservation-value (clojure.core/get-in letvar646076 ["reservationValue" :content]))) (letvar646076 "reservedInstanceId") (clojure.core/assoc :reserved-instance-id (deser-string (clojure.core/get-in letvar646076 ["reservedInstanceId" :content]))))))

(clojure.core/defn- deser-private-ip-address-specification [input] (clojure.core/let [letvar646184 {"primary" (portkey.aws/search-for-tag input "primary" :flattened? nil :xmlAttribute? nil), "privateIpAddress" (portkey.aws/search-for-tag input "privateIpAddress" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar646184 "primary") (clojure.core/assoc :primary (deser-boolean (clojure.core/get-in letvar646184 ["primary" :content]))) (letvar646184 "privateIpAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar646184 ["privateIpAddress" :content]))))))

(clojure.core/defn- deser-reservation-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reservation coll))) input))

(clojure.core/defn- deser-delete-fleet-error-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-delete-fleet-error-item coll))) input))

(clojure.core/defn- deser-vpc-ipv-6-cidr-block-association-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-ipv-6-cidr-block-association coll))) input))

(clojure.core/defn- deser-volume-modification-state [input] (clojure.core/get {"modifying" :modifying, "optimizing" :optimizing, "completed" :completed, "failed" :failed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-directory-service-authentication [input] (clojure.core/let [letvar646348 {"directoryId" (portkey.aws/search-for-tag input "directoryId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar646348 "directoryId") (clojure.core/assoc :directory-id (deser-string (clojure.core/get-in letvar646348 ["directoryId" :content]))))))

(clojure.core/defn- deser-user-id-group-pair [input] (clojure.core/let [letvar646456 {"description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil), "groupId" (portkey.aws/search-for-tag input "groupId" :flattened? nil :xmlAttribute? nil), "groupName" (portkey.aws/search-for-tag input "groupName" :flattened? nil :xmlAttribute? nil), "peeringStatus" (portkey.aws/search-for-tag input "peeringStatus" :flattened? nil :xmlAttribute? nil), "userId" (portkey.aws/search-for-tag input "userId" :flattened? nil :xmlAttribute? nil), "vpcId" (portkey.aws/search-for-tag input "vpcId" :flattened? nil :xmlAttribute? nil), "vpcPeeringConnectionId" (portkey.aws/search-for-tag input "vpcPeeringConnectionId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar646456 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar646456 ["description" :content]))) (letvar646456 "groupId") (clojure.core/assoc :group-id (deser-string (clojure.core/get-in letvar646456 ["groupId" :content]))) (letvar646456 "groupName") (clojure.core/assoc :group-name (deser-string (clojure.core/get-in letvar646456 ["groupName" :content]))) (letvar646456 "peeringStatus") (clojure.core/assoc :peering-status (deser-string (clojure.core/get-in letvar646456 ["peeringStatus" :content]))) (letvar646456 "userId") (clojure.core/assoc :user-id (deser-string (clojure.core/get-in letvar646456 ["userId" :content]))) (letvar646456 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar646456 ["vpcId" :content]))) (letvar646456 "vpcPeeringConnectionId") (clojure.core/assoc :vpc-peering-connection-id (deser-string (clojure.core/get-in letvar646456 ["vpcPeeringConnectionId" :content]))))))

(clojure.core/defn- deser-host-reservation [input] (clojure.core/let [letvar646564 {"hostReservationId" (portkey.aws/search-for-tag input "hostReservationId" :flattened? nil :xmlAttribute? nil), "hostIdSet" (portkey.aws/search-for-tag input "hostIdSet" :flattened? nil :xmlAttribute? nil), "count" (portkey.aws/search-for-tag input "count" :flattened? nil :xmlAttribute? nil), "hourlyPrice" (portkey.aws/search-for-tag input "hourlyPrice" :flattened? nil :xmlAttribute? nil), "start" (portkey.aws/search-for-tag input "start" :flattened? nil :xmlAttribute? nil), "currencyCode" (portkey.aws/search-for-tag input "currencyCode" :flattened? nil :xmlAttribute? nil), "duration" (portkey.aws/search-for-tag input "duration" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "paymentOption" (portkey.aws/search-for-tag input "paymentOption" :flattened? nil :xmlAttribute? nil), "offeringId" (portkey.aws/search-for-tag input "offeringId" :flattened? nil :xmlAttribute? nil), "upfrontPrice" (portkey.aws/search-for-tag input "upfrontPrice" :flattened? nil :xmlAttribute? nil), "instanceFamily" (portkey.aws/search-for-tag input "instanceFamily" :flattened? nil :xmlAttribute? nil), "end" (portkey.aws/search-for-tag input "end" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar646564 "currencyCode") (clojure.core/assoc :currency-code (deser-currency-code-values (clojure.core/get-in letvar646564 ["currencyCode" :content]))) (letvar646564 "upfrontPrice") (clojure.core/assoc :upfront-price (deser-string (clojure.core/get-in letvar646564 ["upfrontPrice" :content]))) (letvar646564 "hostIdSet") (clojure.core/assoc :host-id-set (deser-response-host-id-set (clojure.core/get-in letvar646564 ["hostIdSet" :content]))) (letvar646564 "start") (clojure.core/assoc :start (deser-date-time (clojure.core/get-in letvar646564 ["start" :content]))) (letvar646564 "end") (clojure.core/assoc :end (deser-date-time (clojure.core/get-in letvar646564 ["end" :content]))) (letvar646564 "count") (clojure.core/assoc :count (deser-integer (clojure.core/get-in letvar646564 ["count" :content]))) (letvar646564 "paymentOption") (clojure.core/assoc :payment-option (deser-payment-option (clojure.core/get-in letvar646564 ["paymentOption" :content]))) (letvar646564 "hourlyPrice") (clojure.core/assoc :hourly-price (deser-string (clojure.core/get-in letvar646564 ["hourlyPrice" :content]))) (letvar646564 "offeringId") (clojure.core/assoc :offering-id (deser-string (clojure.core/get-in letvar646564 ["offeringId" :content]))) (letvar646564 "duration") (clojure.core/assoc :duration (deser-integer (clojure.core/get-in letvar646564 ["duration" :content]))) (letvar646564 "instanceFamily") (clojure.core/assoc :instance-family (deser-string (clojure.core/get-in letvar646564 ["instanceFamily" :content]))) (letvar646564 "hostReservationId") (clojure.core/assoc :host-reservation-id (deser-string (clojure.core/get-in letvar646564 ["hostReservationId" :content]))) (letvar646564 "state") (clojure.core/assoc :state (deser-reservation-state (clojure.core/get-in letvar646564 ["state" :content]))))))

(clojure.core/defn- deser-capacity-reservation-tenancy [input] (clojure.core/get {"default" :default, "dedicated" :dedicated} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-telemetry-status [input] (clojure.core/get {"UP" :up, "DOWN" :down} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-create-fleet-errors-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-create-fleet-error coll))) input))

(clojure.core/defn- deser-delete-fleet-error-code [input] (clojure.core/get {"fleetIdDoesNotExist" :fleet-id-does-not-exist, "fleetIdMalformed" :fleet-id-malformed, "fleetNotInDeletableState" :fleet-not-in-deletable-state, "unexpectedError" :unexpected-error} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-vpn-gateway [input] (clojure.core/let [letvar646704 {"availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "state" (portkey.aws/search-for-tag input "state" :flattened? nil :xmlAttribute? nil), "type" (portkey.aws/search-for-tag input "type" :flattened? nil :xmlAttribute? nil), "attachments" (portkey.aws/search-for-tag input "attachments" :flattened? nil :xmlAttribute? nil), "vpnGatewayId" (portkey.aws/search-for-tag input "vpnGatewayId" :flattened? nil :xmlAttribute? nil), "amazonSideAsn" (portkey.aws/search-for-tag input "amazonSideAsn" :flattened? nil :xmlAttribute? nil), "tagSet" (portkey.aws/search-for-tag input "tagSet" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar646704 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar646704 ["availabilityZone" :content]))) (letvar646704 "state") (clojure.core/assoc :state (deser-vpn-state (clojure.core/get-in letvar646704 ["state" :content]))) (letvar646704 "type") (clojure.core/assoc :type (deser-gateway-type (clojure.core/get-in letvar646704 ["type" :content]))) (letvar646704 "attachments") (clojure.core/assoc :vpc-attachments (deser-vpc-attachment-list (clojure.core/get-in letvar646704 ["attachments" :content]))) (letvar646704 "vpnGatewayId") (clojure.core/assoc :vpn-gateway-id (deser-string (clojure.core/get-in letvar646704 ["vpnGatewayId" :content]))) (letvar646704 "amazonSideAsn") (clojure.core/assoc :amazon-side-asn (deser-long (clojure.core/get-in letvar646704 ["amazonSideAsn" :content]))) (letvar646704 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar646704 ["tagSet" :content]))))))

(clojure.core/defn- deser-network-interface-association [input] (clojure.core/let [letvar646812 {"allocationId" (portkey.aws/search-for-tag input "allocationId" :flattened? nil :xmlAttribute? nil), "associationId" (portkey.aws/search-for-tag input "associationId" :flattened? nil :xmlAttribute? nil), "ipOwnerId" (portkey.aws/search-for-tag input "ipOwnerId" :flattened? nil :xmlAttribute? nil), "publicDnsName" (portkey.aws/search-for-tag input "publicDnsName" :flattened? nil :xmlAttribute? nil), "publicIp" (portkey.aws/search-for-tag input "publicIp" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar646812 "allocationId") (clojure.core/assoc :allocation-id (deser-string (clojure.core/get-in letvar646812 ["allocationId" :content]))) (letvar646812 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar646812 ["associationId" :content]))) (letvar646812 "ipOwnerId") (clojure.core/assoc :ip-owner-id (deser-string (clojure.core/get-in letvar646812 ["ipOwnerId" :content]))) (letvar646812 "publicDnsName") (clojure.core/assoc :public-dns-name (deser-string (clojure.core/get-in letvar646812 ["publicDnsName" :content]))) (letvar646812 "publicIp") (clojure.core/assoc :public-ip (deser-string (clojure.core/get-in letvar646812 ["publicIp" :content]))))))

(clojure.core/defn- deser-launch-template-placement [input] (clojure.core/let [letvar646920 {"availabilityZone" (portkey.aws/search-for-tag input "availabilityZone" :flattened? nil :xmlAttribute? nil), "affinity" (portkey.aws/search-for-tag input "affinity" :flattened? nil :xmlAttribute? nil), "groupName" (portkey.aws/search-for-tag input "groupName" :flattened? nil :xmlAttribute? nil), "hostId" (portkey.aws/search-for-tag input "hostId" :flattened? nil :xmlAttribute? nil), "tenancy" (portkey.aws/search-for-tag input "tenancy" :flattened? nil :xmlAttribute? nil), "spreadDomain" (portkey.aws/search-for-tag input "spreadDomain" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar646920 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar646920 ["availabilityZone" :content]))) (letvar646920 "affinity") (clojure.core/assoc :affinity (deser-string (clojure.core/get-in letvar646920 ["affinity" :content]))) (letvar646920 "groupName") (clojure.core/assoc :group-name (deser-string (clojure.core/get-in letvar646920 ["groupName" :content]))) (letvar646920 "hostId") (clojure.core/assoc :host-id (deser-string (clojure.core/get-in letvar646920 ["hostId" :content]))) (letvar646920 "tenancy") (clojure.core/assoc :tenancy (deser-tenancy (clojure.core/get-in letvar646920 ["tenancy" :content]))) (letvar646920 "spreadDomain") (clojure.core/assoc :spread-domain (deser-string (clojure.core/get-in letvar646920 ["spreadDomain" :content]))))))

(clojure.core/defn- deser-placement-response [input] (clojure.core/let [letvar647028 {"groupName" (portkey.aws/search-for-tag input "groupName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar647028 "groupName") (clojure.core/assoc :group-name (deser-string (clojure.core/get-in letvar647028 ["groupName" :content]))))))

(clojure.core/defn- deser-date-time [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-shutdown-behavior [input] (clojure.core/get {"stop" :stop, "terminate" :terminate} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-egress-only-internet-gateway [input] (clojure.core/let [letvar647143 {"attachmentSet" (portkey.aws/search-for-tag input "attachmentSet" :flattened? nil :xmlAttribute? nil), "egressOnlyInternetGatewayId" (portkey.aws/search-for-tag input "egressOnlyInternetGatewayId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar647143 "attachmentSet") (clojure.core/assoc :attachments (deser-internet-gateway-attachment-list (clojure.core/get-in letvar647143 ["attachmentSet" :content]))) (letvar647143 "egressOnlyInternetGatewayId") (clojure.core/assoc :egress-only-internet-gateway-id (deser-egress-only-internet-gateway-id (clojure.core/get-in letvar647143 ["egressOnlyInternetGatewayId" :content]))))))

(clojure.core/defn- deser-boolean [input] (clojure.core/when-let [boolstr__21591__auto__ (portkey.aws/unbox-xml-primitive-value input)] (clojure.core/cond (clojure.core/= "true" boolstr__21591__auto__) true (clojure.core/= "false" boolstr__21591__auto__) false)))

(clojure.core/defn- deser-instance-network-interface-specification [input] (clojure.core/let [letvar647253 {"associatePublicIpAddress" (portkey.aws/search-for-tag input "associatePublicIpAddress" :flattened? nil :xmlAttribute? nil), "subnetId" (portkey.aws/search-for-tag input "subnetId" :flattened? nil :xmlAttribute? nil), "privateIpAddressesSet" (portkey.aws/search-for-tag input "privateIpAddressesSet" :flattened? nil :xmlAttribute? nil), "privateIpAddress" (portkey.aws/search-for-tag input "privateIpAddress" :flattened? nil :xmlAttribute? nil), "secondaryPrivateIpAddressCount" (portkey.aws/search-for-tag input "secondaryPrivateIpAddressCount" :flattened? nil :xmlAttribute? nil), "deleteOnTermination" (portkey.aws/search-for-tag input "deleteOnTermination" :flattened? nil :xmlAttribute? nil), "ipv6AddressesSet" (portkey.aws/search-for-tag input "ipv6AddressesSet" :flattened? nil :xmlAttribute? nil), "SecurityGroupId" (portkey.aws/search-for-tag input "SecurityGroupId" :flattened? nil :xmlAttribute? nil), "deviceIndex" (portkey.aws/search-for-tag input "deviceIndex" :flattened? nil :xmlAttribute? nil), "ipv6AddressCount" (portkey.aws/search-for-tag input "ipv6AddressCount" :flattened? nil :xmlAttribute? nil), "networkInterfaceId" (portkey.aws/search-for-tag input "networkInterfaceId" :flattened? nil :xmlAttribute? nil), "description" (portkey.aws/search-for-tag input "description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar647253 "associatePublicIpAddress") (clojure.core/assoc :associate-public-ip-address (deser-boolean (clojure.core/get-in letvar647253 ["associatePublicIpAddress" :content]))) (letvar647253 "ipv6AddressesSet") (clojure.core/assoc :ipv-6-addresses (deser-instance-ipv-6-address-list (clojure.core/get-in letvar647253 ["ipv6AddressesSet" :content]))) (letvar647253 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar647253 ["subnetId" :content]))) (letvar647253 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar647253 ["networkInterfaceId" :content]))) (letvar647253 "deviceIndex") (clojure.core/assoc :device-index (deser-integer (clojure.core/get-in letvar647253 ["deviceIndex" :content]))) (letvar647253 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar647253 ["description" :content]))) (letvar647253 "SecurityGroupId") (clojure.core/assoc :groups (deser-security-group-id-string-list (clojure.core/get-in letvar647253 ["SecurityGroupId" :content]))) (letvar647253 "deleteOnTermination") (clojure.core/assoc :delete-on-termination (deser-boolean (clojure.core/get-in letvar647253 ["deleteOnTermination" :content]))) (letvar647253 "privateIpAddressesSet") (clojure.core/assoc :private-ip-addresses (deser-private-ip-address-specification-list (clojure.core/get-in letvar647253 ["privateIpAddressesSet" :content]))) (letvar647253 "secondaryPrivateIpAddressCount") (clojure.core/assoc :secondary-private-ip-address-count (deser-integer (clojure.core/get-in letvar647253 ["secondaryPrivateIpAddressCount" :content]))) (letvar647253 "privateIpAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar647253 ["privateIpAddress" :content]))) (letvar647253 "ipv6AddressCount") (clojure.core/assoc :ipv-6-address-count (deser-integer (clojure.core/get-in letvar647253 ["ipv6AddressCount" :content]))))))

(clojure.core/defn- deser-client-vpn-security-group-id-set [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-reservation-state [input] (clojure.core/get {"payment-pending" :paymentpending, "payment-failed" :paymentfailed, "active" :active, "retired" :retired} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-available-instance-capacity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-capacity coll))) input))

(clojure.core/defn- deser-snapshot-state [input] (clojure.core/get {"pending" :pending, "completed" :completed, "error" :error} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-vpn-gateway-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpn-gateway coll))) input))

(clojure.core/defn- response-modify-spot-fleet-request-response ([input] (response-modify-spot-fleet-request-response nil input)) ([resultWrapper647316 input] (clojure.core/let [rawinput647315 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647317 {"return" (portkey.aws/search-for-tag rawinput647315 "return" :flattened? nil :result-wrapper resultWrapper647316)}] (clojure.core/cond-> {} (letvar647317 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647317 ["return" :content])))))))

(clojure.core/defn- response-revoke-client-vpn-ingress-result ([input] (response-revoke-client-vpn-ingress-result nil input)) ([resultWrapper647319 input] (clojure.core/let [rawinput647318 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647320 {"status" (portkey.aws/search-for-tag rawinput647318 "status" :flattened? nil :result-wrapper resultWrapper647319)}] (clojure.core/cond-> {} (letvar647320 "status") (clojure.core/assoc :status (deser-client-vpn-authorization-rule-status (clojure.core/get-in letvar647320 ["status" :content])))))))

(clojure.core/defn- response-get-console-screenshot-result ([input] (response-get-console-screenshot-result nil input)) ([resultWrapper647322 input] (clojure.core/let [rawinput647321 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647323 {"imageData" (portkey.aws/search-for-tag rawinput647321 "imageData" :flattened? nil :result-wrapper resultWrapper647322), "instanceId" (portkey.aws/search-for-tag rawinput647321 "instanceId" :flattened? nil :result-wrapper resultWrapper647322)}] (clojure.core/cond-> {} (letvar647323 "imageData") (clojure.core/assoc :image-data (deser-string (clojure.core/get-in letvar647323 ["imageData" :content]))) (letvar647323 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar647323 ["instanceId" :content])))))))

(clojure.core/defn- response-describe-egress-only-internet-gateways-result ([input] (response-describe-egress-only-internet-gateways-result nil input)) ([resultWrapper647325 input] (clojure.core/let [rawinput647324 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647326 {"egressOnlyInternetGatewaySet" (portkey.aws/search-for-tag rawinput647324 "egressOnlyInternetGatewaySet" :flattened? nil :result-wrapper resultWrapper647325), "nextToken" (portkey.aws/search-for-tag rawinput647324 "nextToken" :flattened? nil :result-wrapper resultWrapper647325)}] (clojure.core/cond-> {} (letvar647326 "egressOnlyInternetGatewaySet") (clojure.core/assoc :egress-only-internet-gateways (deser-egress-only-internet-gateway-list (clojure.core/get-in letvar647326 ["egressOnlyInternetGatewaySet" :content]))) (letvar647326 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647326 ["nextToken" :content])))))))

(clojure.core/defn- response-delete-transit-gateway-route-table-result ([input] (response-delete-transit-gateway-route-table-result nil input)) ([resultWrapper647328 input] (clojure.core/let [rawinput647327 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647329 {"transitGatewayRouteTable" (portkey.aws/search-for-tag rawinput647327 "transitGatewayRouteTable" :flattened? nil :result-wrapper resultWrapper647328)}] (clojure.core/cond-> {} (letvar647329 "transitGatewayRouteTable") (clojure.core/assoc :transit-gateway-route-table (deser-transit-gateway-route-table (clojure.core/get-in letvar647329 ["transitGatewayRouteTable" :content])))))))

(clojure.core/defn- response-describe-aggregate-id-format-result ([input] (response-describe-aggregate-id-format-result nil input)) ([resultWrapper647331 input] (clojure.core/let [rawinput647330 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647332 {"useLongIdsAggregated" (portkey.aws/search-for-tag rawinput647330 "useLongIdsAggregated" :flattened? nil :result-wrapper resultWrapper647331), "statusSet" (portkey.aws/search-for-tag rawinput647330 "statusSet" :flattened? nil :result-wrapper resultWrapper647331)}] (clojure.core/cond-> {} (letvar647332 "useLongIdsAggregated") (clojure.core/assoc :use-long-ids-aggregated (deser-boolean (clojure.core/get-in letvar647332 ["useLongIdsAggregated" :content]))) (letvar647332 "statusSet") (clojure.core/assoc :statuses (deser-id-format-list (clojure.core/get-in letvar647332 ["statusSet" :content])))))))

(clojure.core/defn- response-create-internet-gateway-result ([input] (response-create-internet-gateway-result nil input)) ([resultWrapper647334 input] (clojure.core/let [rawinput647333 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647335 {"internetGateway" (portkey.aws/search-for-tag rawinput647333 "internetGateway" :flattened? nil :result-wrapper resultWrapper647334)}] (clojure.core/cond-> {} (letvar647335 "internetGateway") (clojure.core/assoc :internet-gateway (deser-internet-gateway (clojure.core/get-in letvar647335 ["internetGateway" :content])))))))

(clojure.core/defn- response-describe-host-reservations-result ([input] (response-describe-host-reservations-result nil input)) ([resultWrapper647337 input] (clojure.core/let [rawinput647336 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647338 {"hostReservationSet" (portkey.aws/search-for-tag rawinput647336 "hostReservationSet" :flattened? nil :result-wrapper resultWrapper647337), "nextToken" (portkey.aws/search-for-tag rawinput647336 "nextToken" :flattened? nil :result-wrapper resultWrapper647337)}] (clojure.core/cond-> {} (letvar647338 "hostReservationSet") (clojure.core/assoc :host-reservation-set (deser-host-reservation-set (clojure.core/get-in letvar647338 ["hostReservationSet" :content]))) (letvar647338 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647338 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-vpc-peering-connections-result ([input] (response-describe-vpc-peering-connections-result nil input)) ([resultWrapper647340 input] (clojure.core/let [rawinput647339 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647341 {"vpcPeeringConnectionSet" (portkey.aws/search-for-tag rawinput647339 "vpcPeeringConnectionSet" :flattened? nil :result-wrapper resultWrapper647340), "nextToken" (portkey.aws/search-for-tag rawinput647339 "nextToken" :flattened? nil :result-wrapper resultWrapper647340)}] (clojure.core/cond-> {} (letvar647341 "vpcPeeringConnectionSet") (clojure.core/assoc :vpc-peering-connections (deser-vpc-peering-connection-list (clojure.core/get-in letvar647341 ["vpcPeeringConnectionSet" :content]))) (letvar647341 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647341 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-client-vpn-authorization-rules-result ([input] (response-describe-client-vpn-authorization-rules-result nil input)) ([resultWrapper647343 input] (clojure.core/let [rawinput647342 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647344 {"authorizationRule" (portkey.aws/search-for-tag rawinput647342 "authorizationRule" :flattened? nil :result-wrapper resultWrapper647343), "nextToken" (portkey.aws/search-for-tag rawinput647342 "nextToken" :flattened? nil :result-wrapper resultWrapper647343)}] (clojure.core/cond-> {} (letvar647344 "authorizationRule") (clojure.core/assoc :authorization-rules (deser-authorization-rule-set (clojure.core/get-in letvar647344 ["authorizationRule" :content]))) (letvar647344 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar647344 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-fleet-instances-result ([input] (response-describe-fleet-instances-result nil input)) ([resultWrapper647346 input] (clojure.core/let [rawinput647345 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647347 {"activeInstanceSet" (portkey.aws/search-for-tag rawinput647345 "activeInstanceSet" :flattened? nil :result-wrapper resultWrapper647346), "nextToken" (portkey.aws/search-for-tag rawinput647345 "nextToken" :flattened? nil :result-wrapper resultWrapper647346), "fleetId" (portkey.aws/search-for-tag rawinput647345 "fleetId" :flattened? nil :result-wrapper resultWrapper647346)}] (clojure.core/cond-> {} (letvar647347 "activeInstanceSet") (clojure.core/assoc :active-instances (deser-active-instance-set (clojure.core/get-in letvar647347 ["activeInstanceSet" :content]))) (letvar647347 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647347 ["nextToken" :content]))) (letvar647347 "fleetId") (clojure.core/assoc :fleet-id (deser-fleet-identifier (clojure.core/get-in letvar647347 ["fleetId" :content])))))))

(clojure.core/defn- response-run-scheduled-instances-result ([input] (response-run-scheduled-instances-result nil input)) ([resultWrapper647349 input] (clojure.core/let [rawinput647348 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647350 {"instanceIdSet" (portkey.aws/search-for-tag rawinput647348 "instanceIdSet" :flattened? nil :result-wrapper resultWrapper647349)}] (clojure.core/cond-> {} (letvar647350 "instanceIdSet") (clojure.core/assoc :instance-id-set (deser-instance-id-set (clojure.core/get-in letvar647350 ["instanceIdSet" :content])))))))

(clojure.core/defn- response-copy-fpga-image-result ([input] (response-copy-fpga-image-result nil input)) ([resultWrapper647352 input] (clojure.core/let [rawinput647351 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647353 {"fpgaImageId" (portkey.aws/search-for-tag rawinput647351 "fpgaImageId" :flattened? nil :result-wrapper resultWrapper647352)}] (clojure.core/cond-> {} (letvar647353 "fpgaImageId") (clojure.core/assoc :fpga-image-id (deser-string (clojure.core/get-in letvar647353 ["fpgaImageId" :content])))))))

(clojure.core/defn- response-create-image-result ([input] (response-create-image-result nil input)) ([resultWrapper647355 input] (clojure.core/let [rawinput647354 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647356 {"imageId" (portkey.aws/search-for-tag rawinput647354 "imageId" :flattened? nil :result-wrapper resultWrapper647355)}] (clojure.core/cond-> {} (letvar647356 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar647356 ["imageId" :content])))))))

(clojure.core/defn- response-describe-principal-id-format-result ([input] (response-describe-principal-id-format-result nil input)) ([resultWrapper647358 input] (clojure.core/let [rawinput647357 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647359 {"principalSet" (portkey.aws/search-for-tag rawinput647357 "principalSet" :flattened? nil :result-wrapper resultWrapper647358), "nextToken" (portkey.aws/search-for-tag rawinput647357 "nextToken" :flattened? nil :result-wrapper resultWrapper647358)}] (clojure.core/cond-> {} (letvar647359 "principalSet") (clojure.core/assoc :principals (deser-principal-id-format-list (clojure.core/get-in letvar647359 ["principalSet" :content]))) (letvar647359 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647359 ["nextToken" :content])))))))

(clojure.core/defn- response-create-transit-gateway-vpc-attachment-result ([input] (response-create-transit-gateway-vpc-attachment-result nil input)) ([resultWrapper647361 input] (clojure.core/let [rawinput647360 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647362 {"transitGatewayVpcAttachment" (portkey.aws/search-for-tag rawinput647360 "transitGatewayVpcAttachment" :flattened? nil :result-wrapper resultWrapper647361)}] (clojure.core/cond-> {} (letvar647362 "transitGatewayVpcAttachment") (clojure.core/assoc :transit-gateway-vpc-attachment (deser-transit-gateway-vpc-attachment (clojure.core/get-in letvar647362 ["transitGatewayVpcAttachment" :content])))))))

(clojure.core/defn- response-disable-transit-gateway-route-table-propagation-result ([input] (response-disable-transit-gateway-route-table-propagation-result nil input)) ([resultWrapper647364 input] (clojure.core/let [rawinput647363 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647365 {"propagation" (portkey.aws/search-for-tag rawinput647363 "propagation" :flattened? nil :result-wrapper resultWrapper647364)}] (clojure.core/cond-> {} (letvar647365 "propagation") (clojure.core/assoc :propagation (deser-transit-gateway-propagation (clojure.core/get-in letvar647365 ["propagation" :content])))))))

(clojure.core/defn- response-withdraw-byoip-cidr-result ([input] (response-withdraw-byoip-cidr-result nil input)) ([resultWrapper647367 input] (clojure.core/let [rawinput647366 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647368 {"byoipCidr" (portkey.aws/search-for-tag rawinput647366 "byoipCidr" :flattened? nil :result-wrapper resultWrapper647367)}] (clojure.core/cond-> {} (letvar647368 "byoipCidr") (clojure.core/assoc :byoip-cidr (deser-byoip-cidr (clojure.core/get-in letvar647368 ["byoipCidr" :content])))))))

(clojure.core/defn- response-terminate-client-vpn-connections-result ([input] (response-terminate-client-vpn-connections-result nil input)) ([resultWrapper647370 input] (clojure.core/let [rawinput647369 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647371 {"clientVpnEndpointId" (portkey.aws/search-for-tag rawinput647369 "clientVpnEndpointId" :flattened? nil :result-wrapper resultWrapper647370), "username" (portkey.aws/search-for-tag rawinput647369 "username" :flattened? nil :result-wrapper resultWrapper647370), "connectionStatuses" (portkey.aws/search-for-tag rawinput647369 "connectionStatuses" :flattened? nil :result-wrapper resultWrapper647370)}] (clojure.core/cond-> {} (letvar647371 "clientVpnEndpointId") (clojure.core/assoc :client-vpn-endpoint-id (deser-string (clojure.core/get-in letvar647371 ["clientVpnEndpointId" :content]))) (letvar647371 "username") (clojure.core/assoc :username (deser-string (clojure.core/get-in letvar647371 ["username" :content]))) (letvar647371 "connectionStatuses") (clojure.core/assoc :connection-statuses (deser-terminate-connection-status-set (clojure.core/get-in letvar647371 ["connectionStatuses" :content])))))))

(clojure.core/defn- response-replace-iam-instance-profile-association-result ([input] (response-replace-iam-instance-profile-association-result nil input)) ([resultWrapper647373 input] (clojure.core/let [rawinput647372 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647374 {"iamInstanceProfileAssociation" (portkey.aws/search-for-tag rawinput647372 "iamInstanceProfileAssociation" :flattened? nil :result-wrapper resultWrapper647373)}] (clojure.core/cond-> {} (letvar647374 "iamInstanceProfileAssociation") (clojure.core/assoc :iam-instance-profile-association (deser-iam-instance-profile-association (clojure.core/get-in letvar647374 ["iamInstanceProfileAssociation" :content])))))))

(clojure.core/defn- response-create-egress-only-internet-gateway-result ([input] (response-create-egress-only-internet-gateway-result nil input)) ([resultWrapper647376 input] (clojure.core/let [rawinput647375 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647377 {"clientToken" (portkey.aws/search-for-tag rawinput647375 "clientToken" :flattened? nil :result-wrapper resultWrapper647376), "egressOnlyInternetGateway" (portkey.aws/search-for-tag rawinput647375 "egressOnlyInternetGateway" :flattened? nil :result-wrapper resultWrapper647376)}] (clojure.core/cond-> {} (letvar647377 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar647377 ["clientToken" :content]))) (letvar647377 "egressOnlyInternetGateway") (clojure.core/assoc :egress-only-internet-gateway (deser-egress-only-internet-gateway (clojure.core/get-in letvar647377 ["egressOnlyInternetGateway" :content])))))))

(clojure.core/defn- response-export-transit-gateway-routes-result ([input] (response-export-transit-gateway-routes-result nil input)) ([resultWrapper647379 input] (clojure.core/let [rawinput647378 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647380 {"s3Location" (portkey.aws/search-for-tag rawinput647378 "s3Location" :flattened? nil :result-wrapper resultWrapper647379)}] (clojure.core/cond-> {} (letvar647380 "s3Location") (clojure.core/assoc :s-3-location (deser-string (clojure.core/get-in letvar647380 ["s3Location" :content])))))))

(clojure.core/defn- response-create-vpn-gateway-result ([input] (response-create-vpn-gateway-result nil input)) ([resultWrapper647382 input] (clojure.core/let [rawinput647381 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647383 {"vpnGateway" (portkey.aws/search-for-tag rawinput647381 "vpnGateway" :flattened? nil :result-wrapper resultWrapper647382)}] (clojure.core/cond-> {} (letvar647383 "vpnGateway") (clojure.core/assoc :vpn-gateway (deser-vpn-gateway (clojure.core/get-in letvar647383 ["vpnGateway" :content])))))))

(clojure.core/defn- response-create-subnet-result ([input] (response-create-subnet-result nil input)) ([resultWrapper647385 input] (clojure.core/let [rawinput647384 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647386 {"subnet" (portkey.aws/search-for-tag rawinput647384 "subnet" :flattened? nil :result-wrapper resultWrapper647385)}] (clojure.core/cond-> {} (letvar647386 "subnet") (clojure.core/assoc :subnet (deser-subnet (clojure.core/get-in letvar647386 ["subnet" :content])))))))

(clojure.core/defn- response-disassociate-subnet-cidr-block-result ([input] (response-disassociate-subnet-cidr-block-result nil input)) ([resultWrapper647388 input] (clojure.core/let [rawinput647387 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647389 {"ipv6CidrBlockAssociation" (portkey.aws/search-for-tag rawinput647387 "ipv6CidrBlockAssociation" :flattened? nil :result-wrapper resultWrapper647388), "subnetId" (portkey.aws/search-for-tag rawinput647387 "subnetId" :flattened? nil :result-wrapper resultWrapper647388)}] (clojure.core/cond-> {} (letvar647389 "ipv6CidrBlockAssociation") (clojure.core/assoc :ipv-6-cidr-block-association (deser-subnet-ipv-6-cidr-block-association (clojure.core/get-in letvar647389 ["ipv6CidrBlockAssociation" :content]))) (letvar647389 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar647389 ["subnetId" :content])))))))

(clojure.core/defn- response-describe-stale-security-groups-result ([input] (response-describe-stale-security-groups-result nil input)) ([resultWrapper647391 input] (clojure.core/let [rawinput647390 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647392 {"nextToken" (portkey.aws/search-for-tag rawinput647390 "nextToken" :flattened? nil :result-wrapper resultWrapper647391), "staleSecurityGroupSet" (portkey.aws/search-for-tag rawinput647390 "staleSecurityGroupSet" :flattened? nil :result-wrapper resultWrapper647391)}] (clojure.core/cond-> {} (letvar647392 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647392 ["nextToken" :content]))) (letvar647392 "staleSecurityGroupSet") (clojure.core/assoc :stale-security-group-set (deser-stale-security-group-set (clojure.core/get-in letvar647392 ["staleSecurityGroupSet" :content])))))))

(clojure.core/defn- response-describe-vpc-endpoint-service-configurations-result ([input] (response-describe-vpc-endpoint-service-configurations-result nil input)) ([resultWrapper647394 input] (clojure.core/let [rawinput647393 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647395 {"serviceConfigurationSet" (portkey.aws/search-for-tag rawinput647393 "serviceConfigurationSet" :flattened? nil :result-wrapper resultWrapper647394), "nextToken" (portkey.aws/search-for-tag rawinput647393 "nextToken" :flattened? nil :result-wrapper resultWrapper647394)}] (clojure.core/cond-> {} (letvar647395 "serviceConfigurationSet") (clojure.core/assoc :service-configurations (deser-service-configuration-set (clojure.core/get-in letvar647395 ["serviceConfigurationSet" :content]))) (letvar647395 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647395 ["nextToken" :content])))))))

(clojure.core/defn- response-get-reserved-instances-exchange-quote-result ([input] (response-get-reserved-instances-exchange-quote-result nil input)) ([resultWrapper647397 input] (clojure.core/let [rawinput647396 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647398 {"reservedInstanceValueSet" (portkey.aws/search-for-tag rawinput647396 "reservedInstanceValueSet" :flattened? nil :result-wrapper resultWrapper647397), "targetConfigurationValueSet" (portkey.aws/search-for-tag rawinput647396 "targetConfigurationValueSet" :flattened? nil :result-wrapper resultWrapper647397), "paymentDue" (portkey.aws/search-for-tag rawinput647396 "paymentDue" :flattened? nil :result-wrapper resultWrapper647397), "validationFailureReason" (portkey.aws/search-for-tag rawinput647396 "validationFailureReason" :flattened? nil :result-wrapper resultWrapper647397), "targetConfigurationValueRollup" (portkey.aws/search-for-tag rawinput647396 "targetConfigurationValueRollup" :flattened? nil :result-wrapper resultWrapper647397), "outputReservedInstancesWillExpireAt" (portkey.aws/search-for-tag rawinput647396 "outputReservedInstancesWillExpireAt" :flattened? nil :result-wrapper resultWrapper647397), "currencyCode" (portkey.aws/search-for-tag rawinput647396 "currencyCode" :flattened? nil :result-wrapper resultWrapper647397), "reservedInstanceValueRollup" (portkey.aws/search-for-tag rawinput647396 "reservedInstanceValueRollup" :flattened? nil :result-wrapper resultWrapper647397), "isValidExchange" (portkey.aws/search-for-tag rawinput647396 "isValidExchange" :flattened? nil :result-wrapper resultWrapper647397)}] (clojure.core/cond-> {} (letvar647398 "reservedInstanceValueSet") (clojure.core/assoc :reserved-instance-value-set (deser-reserved-instance-reservation-value-set (clojure.core/get-in letvar647398 ["reservedInstanceValueSet" :content]))) (letvar647398 "currencyCode") (clojure.core/assoc :currency-code (deser-string (clojure.core/get-in letvar647398 ["currencyCode" :content]))) (letvar647398 "targetConfigurationValueSet") (clojure.core/assoc :target-configuration-value-set (deser-target-reservation-value-set (clojure.core/get-in letvar647398 ["targetConfigurationValueSet" :content]))) (letvar647398 "validationFailureReason") (clojure.core/assoc :validation-failure-reason (deser-string (clojure.core/get-in letvar647398 ["validationFailureReason" :content]))) (letvar647398 "outputReservedInstancesWillExpireAt") (clojure.core/assoc :output-reserved-instances-will-expire-at (deser-date-time (clojure.core/get-in letvar647398 ["outputReservedInstancesWillExpireAt" :content]))) (letvar647398 "paymentDue") (clojure.core/assoc :payment-due (deser-string (clojure.core/get-in letvar647398 ["paymentDue" :content]))) (letvar647398 "isValidExchange") (clojure.core/assoc :is-valid-exchange (deser-boolean (clojure.core/get-in letvar647398 ["isValidExchange" :content]))) (letvar647398 "reservedInstanceValueRollup") (clojure.core/assoc :reserved-instance-value-rollup (deser-reservation-value (clojure.core/get-in letvar647398 ["reservedInstanceValueRollup" :content]))) (letvar647398 "targetConfigurationValueRollup") (clojure.core/assoc :target-configuration-value-rollup (deser-reservation-value (clojure.core/get-in letvar647398 ["targetConfigurationValueRollup" :content])))))))

(clojure.core/defn- response-confirm-product-instance-result ([input] (response-confirm-product-instance-result nil input)) ([resultWrapper647400 input] (clojure.core/let [rawinput647399 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647401 {"ownerId" (portkey.aws/search-for-tag rawinput647399 "ownerId" :flattened? nil :result-wrapper resultWrapper647400), "return" (portkey.aws/search-for-tag rawinput647399 "return" :flattened? nil :result-wrapper resultWrapper647400)}] (clojure.core/cond-> {} (letvar647401 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar647401 ["ownerId" :content]))) (letvar647401 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647401 ["return" :content])))))))

(clojure.core/defn- response-describe-reserved-instances-offerings-result ([input] (response-describe-reserved-instances-offerings-result nil input)) ([resultWrapper647403 input] (clojure.core/let [rawinput647402 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647404 {"reservedInstancesOfferingsSet" (portkey.aws/search-for-tag rawinput647402 "reservedInstancesOfferingsSet" :flattened? nil :result-wrapper resultWrapper647403), "nextToken" (portkey.aws/search-for-tag rawinput647402 "nextToken" :flattened? nil :result-wrapper resultWrapper647403)}] (clojure.core/cond-> {} (letvar647404 "reservedInstancesOfferingsSet") (clojure.core/assoc :reserved-instances-offerings (deser-reserved-instances-offering-list (clojure.core/get-in letvar647404 ["reservedInstancesOfferingsSet" :content]))) (letvar647404 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647404 ["nextToken" :content])))))))

(clojure.core/defn- response-get-launch-template-data-result ([input] (response-get-launch-template-data-result nil input)) ([resultWrapper647406 input] (clojure.core/let [rawinput647405 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647407 {"launchTemplateData" (portkey.aws/search-for-tag rawinput647405 "launchTemplateData" :flattened? nil :result-wrapper resultWrapper647406)}] (clojure.core/cond-> {} (letvar647407 "launchTemplateData") (clojure.core/assoc :launch-template-data (deser-response-launch-template-data (clojure.core/get-in letvar647407 ["launchTemplateData" :content])))))))

(clojure.core/defn- response-modify-reserved-instances-result ([input] (response-modify-reserved-instances-result nil input)) ([resultWrapper647409 input] (clojure.core/let [rawinput647408 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647410 {"reservedInstancesModificationId" (portkey.aws/search-for-tag rawinput647408 "reservedInstancesModificationId" :flattened? nil :result-wrapper resultWrapper647409)}] (clojure.core/cond-> {} (letvar647410 "reservedInstancesModificationId") (clojure.core/assoc :reserved-instances-modification-id (deser-string (clojure.core/get-in letvar647410 ["reservedInstancesModificationId" :content])))))))

(clojure.core/defn- response-cancel-capacity-reservation-result ([input] (response-cancel-capacity-reservation-result nil input)) ([resultWrapper647412 input] (clojure.core/let [rawinput647411 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647413 {"return" (portkey.aws/search-for-tag rawinput647411 "return" :flattened? nil :result-wrapper resultWrapper647412)}] (clojure.core/cond-> {} (letvar647413 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647413 ["return" :content])))))))

(clojure.core/defn- response-create-transit-gateway-result ([input] (response-create-transit-gateway-result nil input)) ([resultWrapper647415 input] (clojure.core/let [rawinput647414 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647416 {"transitGateway" (portkey.aws/search-for-tag rawinput647414 "transitGateway" :flattened? nil :result-wrapper resultWrapper647415)}] (clojure.core/cond-> {} (letvar647416 "transitGateway") (clojure.core/assoc :transit-gateway (deser-transit-gateway (clojure.core/get-in letvar647416 ["transitGateway" :content])))))))

(clojure.core/defn- response-describe-vpc-classic-link-result ([input] (response-describe-vpc-classic-link-result nil input)) ([resultWrapper647418 input] (clojure.core/let [rawinput647417 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647419 {"vpcSet" (portkey.aws/search-for-tag rawinput647417 "vpcSet" :flattened? nil :result-wrapper resultWrapper647418)}] (clojure.core/cond-> {} (letvar647419 "vpcSet") (clojure.core/assoc :vpcs (deser-vpc-classic-link-list (clojure.core/get-in letvar647419 ["vpcSet" :content])))))))

(clojure.core/defn- response-create-dhcp-options-result ([input] (response-create-dhcp-options-result nil input)) ([resultWrapper647421 input] (clojure.core/let [rawinput647420 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647422 {"dhcpOptions" (portkey.aws/search-for-tag rawinput647420 "dhcpOptions" :flattened? nil :result-wrapper resultWrapper647421)}] (clojure.core/cond-> {} (letvar647422 "dhcpOptions") (clojure.core/assoc :dhcp-options (deser-dhcp-options (clojure.core/get-in letvar647422 ["dhcpOptions" :content])))))))

(clojure.core/defn- response-volume ([input] (response-volume nil input)) ([resultWrapper647424 input] (clojure.core/let [rawinput647423 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647425 {"tagSet" (portkey.aws/search-for-tag rawinput647423 "tagSet" :flattened? nil :result-wrapper resultWrapper647424), "kmsKeyId" (portkey.aws/search-for-tag rawinput647423 "kmsKeyId" :flattened? nil :result-wrapper resultWrapper647424), "createTime" (portkey.aws/search-for-tag rawinput647423 "createTime" :flattened? nil :result-wrapper resultWrapper647424), "encrypted" (portkey.aws/search-for-tag rawinput647423 "encrypted" :flattened? nil :result-wrapper resultWrapper647424), "attachmentSet" (portkey.aws/search-for-tag rawinput647423 "attachmentSet" :flattened? nil :result-wrapper resultWrapper647424), "iops" (portkey.aws/search-for-tag rawinput647423 "iops" :flattened? nil :result-wrapper resultWrapper647424), "status" (portkey.aws/search-for-tag rawinput647423 "status" :flattened? nil :result-wrapper resultWrapper647424), "availabilityZone" (portkey.aws/search-for-tag rawinput647423 "availabilityZone" :flattened? nil :result-wrapper resultWrapper647424), "volumeType" (portkey.aws/search-for-tag rawinput647423 "volumeType" :flattened? nil :result-wrapper resultWrapper647424), "volumeId" (portkey.aws/search-for-tag rawinput647423 "volumeId" :flattened? nil :result-wrapper resultWrapper647424), "size" (portkey.aws/search-for-tag rawinput647423 "size" :flattened? nil :result-wrapper resultWrapper647424), "snapshotId" (portkey.aws/search-for-tag rawinput647423 "snapshotId" :flattened? nil :result-wrapper resultWrapper647424)}] (clojure.core/cond-> {} (letvar647425 "encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar647425 ["encrypted" :content]))) (letvar647425 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar647425 ["tagSet" :content]))) (letvar647425 "attachmentSet") (clojure.core/assoc :attachments (deser-volume-attachment-list (clojure.core/get-in letvar647425 ["attachmentSet" :content]))) (letvar647425 "availabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar647425 ["availabilityZone" :content]))) (letvar647425 "kmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar647425 ["kmsKeyId" :content]))) (letvar647425 "size") (clojure.core/assoc :size (deser-integer (clojure.core/get-in letvar647425 ["size" :content]))) (letvar647425 "iops") (clojure.core/assoc :iops (deser-integer (clojure.core/get-in letvar647425 ["iops" :content]))) (letvar647425 "volumeType") (clojure.core/assoc :volume-type (deser-volume-type (clojure.core/get-in letvar647425 ["volumeType" :content]))) (letvar647425 "volumeId") (clojure.core/assoc :volume-id (deser-string (clojure.core/get-in letvar647425 ["volumeId" :content]))) (letvar647425 "createTime") (clojure.core/assoc :create-time (deser-date-time (clojure.core/get-in letvar647425 ["createTime" :content]))) (letvar647425 "status") (clojure.core/assoc :state (deser-volume-state (clojure.core/get-in letvar647425 ["status" :content]))) (letvar647425 "snapshotId") (clojure.core/assoc :snapshot-id (deser-string (clojure.core/get-in letvar647425 ["snapshotId" :content])))))))

(clojure.core/defn- response-assign-ipv-6-addresses-result ([input] (response-assign-ipv-6-addresses-result nil input)) ([resultWrapper647427 input] (clojure.core/let [rawinput647426 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647428 {"assignedIpv6Addresses" (portkey.aws/search-for-tag rawinput647426 "assignedIpv6Addresses" :flattened? nil :result-wrapper resultWrapper647427), "networkInterfaceId" (portkey.aws/search-for-tag rawinput647426 "networkInterfaceId" :flattened? nil :result-wrapper resultWrapper647427)}] (clojure.core/cond-> {} (letvar647428 "assignedIpv6Addresses") (clojure.core/assoc :assigned-ipv-6-addresses (deser-ipv-6-address-list (clojure.core/get-in letvar647428 ["assignedIpv6Addresses" :content]))) (letvar647428 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar647428 ["networkInterfaceId" :content])))))))

(clojure.core/defn- response-modify-volume-result ([input] (response-modify-volume-result nil input)) ([resultWrapper647430 input] (clojure.core/let [rawinput647429 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647431 {"volumeModification" (portkey.aws/search-for-tag rawinput647429 "volumeModification" :flattened? nil :result-wrapper resultWrapper647430)}] (clojure.core/cond-> {} (letvar647431 "volumeModification") (clojure.core/assoc :volume-modification (deser-volume-modification (clojure.core/get-in letvar647431 ["volumeModification" :content])))))))

(clojure.core/defn- response-describe-volumes-result ([input] (response-describe-volumes-result nil input)) ([resultWrapper647433 input] (clojure.core/let [rawinput647432 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647434 {"volumeSet" (portkey.aws/search-for-tag rawinput647432 "volumeSet" :flattened? nil :result-wrapper resultWrapper647433), "nextToken" (portkey.aws/search-for-tag rawinput647432 "nextToken" :flattened? nil :result-wrapper resultWrapper647433)}] (clojure.core/cond-> {} (letvar647434 "volumeSet") (clojure.core/assoc :volumes (deser-volume-list (clojure.core/get-in letvar647434 ["volumeSet" :content]))) (letvar647434 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647434 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-conversion-tasks-result ([input] (response-describe-conversion-tasks-result nil input)) ([resultWrapper647436 input] (clojure.core/let [rawinput647435 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647437 {"conversionTasks" (portkey.aws/search-for-tag rawinput647435 "conversionTasks" :flattened? nil :result-wrapper resultWrapper647436)}] (clojure.core/cond-> {} (letvar647437 "conversionTasks") (clojure.core/assoc :conversion-tasks (deser-describe-conversion-task-list (clojure.core/get-in letvar647437 ["conversionTasks" :content])))))))

(clojure.core/defn- response-describe-reserved-instances-listings-result ([input] (response-describe-reserved-instances-listings-result nil input)) ([resultWrapper647439 input] (clojure.core/let [rawinput647438 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647440 {"reservedInstancesListingsSet" (portkey.aws/search-for-tag rawinput647438 "reservedInstancesListingsSet" :flattened? nil :result-wrapper resultWrapper647439)}] (clojure.core/cond-> {} (letvar647440 "reservedInstancesListingsSet") (clojure.core/assoc :reserved-instances-listings (deser-reserved-instances-listing-list (clojure.core/get-in letvar647440 ["reservedInstancesListingsSet" :content])))))))

(clojure.core/defn- response-authorize-client-vpn-ingress-result ([input] (response-authorize-client-vpn-ingress-result nil input)) ([resultWrapper647442 input] (clojure.core/let [rawinput647441 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647443 {"status" (portkey.aws/search-for-tag rawinput647441 "status" :flattened? nil :result-wrapper resultWrapper647442)}] (clojure.core/cond-> {} (letvar647443 "status") (clojure.core/assoc :status (deser-client-vpn-authorization-rule-status (clojure.core/get-in letvar647443 ["status" :content])))))))

(clojure.core/defn- response-create-reserved-instances-listing-result ([input] (response-create-reserved-instances-listing-result nil input)) ([resultWrapper647445 input] (clojure.core/let [rawinput647444 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647446 {"reservedInstancesListingsSet" (portkey.aws/search-for-tag rawinput647444 "reservedInstancesListingsSet" :flattened? nil :result-wrapper resultWrapper647445)}] (clojure.core/cond-> {} (letvar647446 "reservedInstancesListingsSet") (clojure.core/assoc :reserved-instances-listings (deser-reserved-instances-listing-list (clojure.core/get-in letvar647446 ["reservedInstancesListingsSet" :content])))))))

(clojure.core/defn- response-describe-import-image-tasks-result ([input] (response-describe-import-image-tasks-result nil input)) ([resultWrapper647448 input] (clojure.core/let [rawinput647447 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647449 {"importImageTaskSet" (portkey.aws/search-for-tag rawinput647447 "importImageTaskSet" :flattened? nil :result-wrapper resultWrapper647448), "nextToken" (portkey.aws/search-for-tag rawinput647447 "nextToken" :flattened? nil :result-wrapper resultWrapper647448)}] (clojure.core/cond-> {} (letvar647449 "importImageTaskSet") (clojure.core/assoc :import-image-tasks (deser-import-image-task-list (clojure.core/get-in letvar647449 ["importImageTaskSet" :content]))) (letvar647449 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647449 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-client-vpn-endpoints-result ([input] (response-describe-client-vpn-endpoints-result nil input)) ([resultWrapper647451 input] (clojure.core/let [rawinput647450 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647452 {"clientVpnEndpoint" (portkey.aws/search-for-tag rawinput647450 "clientVpnEndpoint" :flattened? nil :result-wrapper resultWrapper647451), "nextToken" (portkey.aws/search-for-tag rawinput647450 "nextToken" :flattened? nil :result-wrapper resultWrapper647451)}] (clojure.core/cond-> {} (letvar647452 "clientVpnEndpoint") (clojure.core/assoc :client-vpn-endpoints (deser-endpoint-set (clojure.core/get-in letvar647452 ["clientVpnEndpoint" :content]))) (letvar647452 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar647452 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-fleets-result ([input] (response-describe-fleets-result nil input)) ([resultWrapper647454 input] (clojure.core/let [rawinput647453 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647455 {"nextToken" (portkey.aws/search-for-tag rawinput647453 "nextToken" :flattened? nil :result-wrapper resultWrapper647454), "fleetSet" (portkey.aws/search-for-tag rawinput647453 "fleetSet" :flattened? nil :result-wrapper resultWrapper647454)}] (clojure.core/cond-> {} (letvar647455 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647455 ["nextToken" :content]))) (letvar647455 "fleetSet") (clojure.core/assoc :fleets (deser-fleet-set (clojure.core/get-in letvar647455 ["fleetSet" :content])))))))

(clojure.core/defn- response-describe-instance-status-result ([input] (response-describe-instance-status-result nil input)) ([resultWrapper647457 input] (clojure.core/let [rawinput647456 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647458 {"instanceStatusSet" (portkey.aws/search-for-tag rawinput647456 "instanceStatusSet" :flattened? nil :result-wrapper resultWrapper647457), "nextToken" (portkey.aws/search-for-tag rawinput647456 "nextToken" :flattened? nil :result-wrapper resultWrapper647457)}] (clojure.core/cond-> {} (letvar647458 "instanceStatusSet") (clojure.core/assoc :instance-statuses (deser-instance-status-list (clojure.core/get-in letvar647458 ["instanceStatusSet" :content]))) (letvar647458 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647458 ["nextToken" :content])))))))

(clojure.core/defn- response-create-network-interface-result ([input] (response-create-network-interface-result nil input)) ([resultWrapper647460 input] (clojure.core/let [rawinput647459 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647461 {"networkInterface" (portkey.aws/search-for-tag rawinput647459 "networkInterface" :flattened? nil :result-wrapper resultWrapper647460)}] (clojure.core/cond-> {} (letvar647461 "networkInterface") (clojure.core/assoc :network-interface (deser-network-interface (clojure.core/get-in letvar647461 ["networkInterface" :content])))))))

(clojure.core/defn- response-describe-network-interface-attribute-result ([input] (response-describe-network-interface-attribute-result nil input)) ([resultWrapper647463 input] (clojure.core/let [rawinput647462 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647464 {"attachment" (portkey.aws/search-for-tag rawinput647462 "attachment" :flattened? nil :result-wrapper resultWrapper647463), "description" (portkey.aws/search-for-tag rawinput647462 "description" :flattened? nil :result-wrapper resultWrapper647463), "groupSet" (portkey.aws/search-for-tag rawinput647462 "groupSet" :flattened? nil :result-wrapper resultWrapper647463), "networkInterfaceId" (portkey.aws/search-for-tag rawinput647462 "networkInterfaceId" :flattened? nil :result-wrapper resultWrapper647463), "sourceDestCheck" (portkey.aws/search-for-tag rawinput647462 "sourceDestCheck" :flattened? nil :result-wrapper resultWrapper647463)}] (clojure.core/cond-> {} (letvar647464 "attachment") (clojure.core/assoc :attachment (deser-network-interface-attachment (clojure.core/get-in letvar647464 ["attachment" :content]))) (letvar647464 "description") (clojure.core/assoc :description (deser-attribute-value (clojure.core/get-in letvar647464 ["description" :content]))) (letvar647464 "groupSet") (clojure.core/assoc :groups (deser-group-identifier-list (clojure.core/get-in letvar647464 ["groupSet" :content]))) (letvar647464 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar647464 ["networkInterfaceId" :content]))) (letvar647464 "sourceDestCheck") (clojure.core/assoc :source-dest-check (deser-attribute-boolean-value (clojure.core/get-in letvar647464 ["sourceDestCheck" :content])))))))

(clojure.core/defn- response-attach-network-interface-result ([input] (response-attach-network-interface-result nil input)) ([resultWrapper647466 input] (clojure.core/let [rawinput647465 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647467 {"attachmentId" (portkey.aws/search-for-tag rawinput647465 "attachmentId" :flattened? nil :result-wrapper resultWrapper647466)}] (clojure.core/cond-> {} (letvar647467 "attachmentId") (clojure.core/assoc :attachment-id (deser-string (clojure.core/get-in letvar647467 ["attachmentId" :content])))))))

(clojure.core/defn- response-describe-vpc-endpoint-service-permissions-result ([input] (response-describe-vpc-endpoint-service-permissions-result nil input)) ([resultWrapper647469 input] (clojure.core/let [rawinput647468 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647470 {"allowedPrincipals" (portkey.aws/search-for-tag rawinput647468 "allowedPrincipals" :flattened? nil :result-wrapper resultWrapper647469), "nextToken" (portkey.aws/search-for-tag rawinput647468 "nextToken" :flattened? nil :result-wrapper resultWrapper647469)}] (clojure.core/cond-> {} (letvar647470 "allowedPrincipals") (clojure.core/assoc :allowed-principals (deser-allowed-principal-set (clojure.core/get-in letvar647470 ["allowedPrincipals" :content]))) (letvar647470 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647470 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-instance-credit-specifications-result ([input] (response-describe-instance-credit-specifications-result nil input)) ([resultWrapper647472 input] (clojure.core/let [rawinput647471 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647473 {"instanceCreditSpecificationSet" (portkey.aws/search-for-tag rawinput647471 "instanceCreditSpecificationSet" :flattened? nil :result-wrapper resultWrapper647472), "nextToken" (portkey.aws/search-for-tag rawinput647471 "nextToken" :flattened? nil :result-wrapper resultWrapper647472)}] (clojure.core/cond-> {} (letvar647473 "instanceCreditSpecificationSet") (clojure.core/assoc :instance-credit-specifications (deser-instance-credit-specification-list (clojure.core/get-in letvar647473 ["instanceCreditSpecificationSet" :content]))) (letvar647473 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647473 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-network-interfaces-result ([input] (response-describe-network-interfaces-result nil input)) ([resultWrapper647475 input] (clojure.core/let [rawinput647474 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647476 {"networkInterfaceSet" (portkey.aws/search-for-tag rawinput647474 "networkInterfaceSet" :flattened? nil :result-wrapper resultWrapper647475), "nextToken" (portkey.aws/search-for-tag rawinput647474 "nextToken" :flattened? nil :result-wrapper resultWrapper647475)}] (clojure.core/cond-> {} (letvar647476 "networkInterfaceSet") (clojure.core/assoc :network-interfaces (deser-network-interface-list (clojure.core/get-in letvar647476 ["networkInterfaceSet" :content]))) (letvar647476 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647476 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-network-interface-permissions-result ([input] (response-describe-network-interface-permissions-result nil input)) ([resultWrapper647478 input] (clojure.core/let [rawinput647477 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647479 {"networkInterfacePermissions" (portkey.aws/search-for-tag rawinput647477 "networkInterfacePermissions" :flattened? nil :result-wrapper resultWrapper647478), "nextToken" (portkey.aws/search-for-tag rawinput647477 "nextToken" :flattened? nil :result-wrapper resultWrapper647478)}] (clojure.core/cond-> {} (letvar647479 "networkInterfacePermissions") (clojure.core/assoc :network-interface-permissions (deser-network-interface-permission-list (clojure.core/get-in letvar647479 ["networkInterfacePermissions" :content]))) (letvar647479 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647479 ["nextToken" :content])))))))

(clojure.core/defn- response-create-default-subnet-result ([input] (response-create-default-subnet-result nil input)) ([resultWrapper647481 input] (clojure.core/let [rawinput647480 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647482 {"subnet" (portkey.aws/search-for-tag rawinput647480 "subnet" :flattened? nil :result-wrapper resultWrapper647481)}] (clojure.core/cond-> {} (letvar647482 "subnet") (clojure.core/assoc :subnet (deser-subnet (clojure.core/get-in letvar647482 ["subnet" :content])))))))

(clojure.core/defn- response-modify-transit-gateway-vpc-attachment-result ([input] (response-modify-transit-gateway-vpc-attachment-result nil input)) ([resultWrapper647484 input] (clojure.core/let [rawinput647483 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647485 {"transitGatewayVpcAttachment" (portkey.aws/search-for-tag rawinput647483 "transitGatewayVpcAttachment" :flattened? nil :result-wrapper resultWrapper647484)}] (clojure.core/cond-> {} (letvar647485 "transitGatewayVpcAttachment") (clojure.core/assoc :transit-gateway-vpc-attachment (deser-transit-gateway-vpc-attachment (clojure.core/get-in letvar647485 ["transitGatewayVpcAttachment" :content])))))))

(clojure.core/defn- response-delete-client-vpn-endpoint-result ([input] (response-delete-client-vpn-endpoint-result nil input)) ([resultWrapper647487 input] (clojure.core/let [rawinput647486 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647488 {"status" (portkey.aws/search-for-tag rawinput647486 "status" :flattened? nil :result-wrapper resultWrapper647487)}] (clojure.core/cond-> {} (letvar647488 "status") (clojure.core/assoc :status (deser-client-vpn-endpoint-status (clojure.core/get-in letvar647488 ["status" :content])))))))

(clojure.core/defn- response-describe-volume-attribute-result ([input] (response-describe-volume-attribute-result nil input)) ([resultWrapper647490 input] (clojure.core/let [rawinput647489 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647491 {"autoEnableIO" (portkey.aws/search-for-tag rawinput647489 "autoEnableIO" :flattened? nil :result-wrapper resultWrapper647490), "productCodes" (portkey.aws/search-for-tag rawinput647489 "productCodes" :flattened? nil :result-wrapper resultWrapper647490), "volumeId" (portkey.aws/search-for-tag rawinput647489 "volumeId" :flattened? nil :result-wrapper resultWrapper647490)}] (clojure.core/cond-> {} (letvar647491 "autoEnableIO") (clojure.core/assoc :auto-enable-io (deser-attribute-boolean-value (clojure.core/get-in letvar647491 ["autoEnableIO" :content]))) (letvar647491 "productCodes") (clojure.core/assoc :product-codes (deser-product-code-list (clojure.core/get-in letvar647491 ["productCodes" :content]))) (letvar647491 "volumeId") (clojure.core/assoc :volume-id (deser-string (clojure.core/get-in letvar647491 ["volumeId" :content])))))))

(clojure.core/defn- response-associate-client-vpn-target-network-result ([input] (response-associate-client-vpn-target-network-result nil input)) ([resultWrapper647493 input] (clojure.core/let [rawinput647492 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647494 {"associationId" (portkey.aws/search-for-tag rawinput647492 "associationId" :flattened? nil :result-wrapper resultWrapper647493), "status" (portkey.aws/search-for-tag rawinput647492 "status" :flattened? nil :result-wrapper resultWrapper647493)}] (clojure.core/cond-> {} (letvar647494 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar647494 ["associationId" :content]))) (letvar647494 "status") (clojure.core/assoc :status (deser-association-status (clojure.core/get-in letvar647494 ["status" :content])))))))

(clojure.core/defn- response-enable-transit-gateway-route-table-propagation-result ([input] (response-enable-transit-gateway-route-table-propagation-result nil input)) ([resultWrapper647496 input] (clojure.core/let [rawinput647495 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647497 {"propagation" (portkey.aws/search-for-tag rawinput647495 "propagation" :flattened? nil :result-wrapper resultWrapper647496)}] (clojure.core/cond-> {} (letvar647497 "propagation") (clojure.core/assoc :propagation (deser-transit-gateway-propagation (clojure.core/get-in letvar647497 ["propagation" :content])))))))

(clojure.core/defn- response-describe-reserved-instances-modifications-result ([input] (response-describe-reserved-instances-modifications-result nil input)) ([resultWrapper647499 input] (clojure.core/let [rawinput647498 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647500 {"nextToken" (portkey.aws/search-for-tag rawinput647498 "nextToken" :flattened? nil :result-wrapper resultWrapper647499), "reservedInstancesModificationsSet" (portkey.aws/search-for-tag rawinput647498 "reservedInstancesModificationsSet" :flattened? nil :result-wrapper resultWrapper647499)}] (clojure.core/cond-> {} (letvar647500 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647500 ["nextToken" :content]))) (letvar647500 "reservedInstancesModificationsSet") (clojure.core/assoc :reserved-instances-modifications (deser-reserved-instances-modification-list (clojure.core/get-in letvar647500 ["reservedInstancesModificationsSet" :content])))))))

(clojure.core/defn- response-cancel-bundle-task-result ([input] (response-cancel-bundle-task-result nil input)) ([resultWrapper647502 input] (clojure.core/let [rawinput647501 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647503 {"bundleInstanceTask" (portkey.aws/search-for-tag rawinput647501 "bundleInstanceTask" :flattened? nil :result-wrapper resultWrapper647502)}] (clojure.core/cond-> {} (letvar647503 "bundleInstanceTask") (clojure.core/assoc :bundle-task (deser-bundle-task (clojure.core/get-in letvar647503 ["bundleInstanceTask" :content])))))))

(clojure.core/defn- response-get-host-reservation-purchase-preview-result ([input] (response-get-host-reservation-purchase-preview-result nil input)) ([resultWrapper647505 input] (clojure.core/let [rawinput647504 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647506 {"currencyCode" (portkey.aws/search-for-tag rawinput647504 "currencyCode" :flattened? nil :result-wrapper resultWrapper647505), "purchase" (portkey.aws/search-for-tag rawinput647504 "purchase" :flattened? nil :result-wrapper resultWrapper647505), "totalHourlyPrice" (portkey.aws/search-for-tag rawinput647504 "totalHourlyPrice" :flattened? nil :result-wrapper resultWrapper647505), "totalUpfrontPrice" (portkey.aws/search-for-tag rawinput647504 "totalUpfrontPrice" :flattened? nil :result-wrapper resultWrapper647505)}] (clojure.core/cond-> {} (letvar647506 "currencyCode") (clojure.core/assoc :currency-code (deser-currency-code-values (clojure.core/get-in letvar647506 ["currencyCode" :content]))) (letvar647506 "purchase") (clojure.core/assoc :purchase (deser-purchase-set (clojure.core/get-in letvar647506 ["purchase" :content]))) (letvar647506 "totalHourlyPrice") (clojure.core/assoc :total-hourly-price (deser-string (clojure.core/get-in letvar647506 ["totalHourlyPrice" :content]))) (letvar647506 "totalUpfrontPrice") (clojure.core/assoc :total-upfront-price (deser-string (clojure.core/get-in letvar647506 ["totalUpfrontPrice" :content])))))))

(clojure.core/defn- response-describe-availability-zones-result ([input] (response-describe-availability-zones-result nil input)) ([resultWrapper647508 input] (clojure.core/let [rawinput647507 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647509 {"availabilityZoneInfo" (portkey.aws/search-for-tag rawinput647507 "availabilityZoneInfo" :flattened? nil :result-wrapper resultWrapper647508)}] (clojure.core/cond-> {} (letvar647509 "availabilityZoneInfo") (clojure.core/assoc :availability-zones (deser-availability-zone-list (clojure.core/get-in letvar647509 ["availabilityZoneInfo" :content])))))))

(clojure.core/defn- response-delete-client-vpn-route-result ([input] (response-delete-client-vpn-route-result nil input)) ([resultWrapper647511 input] (clojure.core/let [rawinput647510 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647512 {"status" (portkey.aws/search-for-tag rawinput647510 "status" :flattened? nil :result-wrapper resultWrapper647511)}] (clojure.core/cond-> {} (letvar647512 "status") (clojure.core/assoc :status (deser-client-vpn-route-status (clojure.core/get-in letvar647512 ["status" :content])))))))

(clojure.core/defn- response-cancel-reserved-instances-listing-result ([input] (response-cancel-reserved-instances-listing-result nil input)) ([resultWrapper647514 input] (clojure.core/let [rawinput647513 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647515 {"reservedInstancesListingsSet" (portkey.aws/search-for-tag rawinput647513 "reservedInstancesListingsSet" :flattened? nil :result-wrapper resultWrapper647514)}] (clojure.core/cond-> {} (letvar647515 "reservedInstancesListingsSet") (clojure.core/assoc :reserved-instances-listings (deser-reserved-instances-listing-list (clojure.core/get-in letvar647515 ["reservedInstancesListingsSet" :content])))))))

(clojure.core/defn- response-restore-address-to-classic-result ([input] (response-restore-address-to-classic-result nil input)) ([resultWrapper647517 input] (clojure.core/let [rawinput647516 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647518 {"publicIp" (portkey.aws/search-for-tag rawinput647516 "publicIp" :flattened? nil :result-wrapper resultWrapper647517), "status" (portkey.aws/search-for-tag rawinput647516 "status" :flattened? nil :result-wrapper resultWrapper647517)}] (clojure.core/cond-> {} (letvar647518 "publicIp") (clojure.core/assoc :public-ip (deser-string (clojure.core/get-in letvar647518 ["publicIp" :content]))) (letvar647518 "status") (clojure.core/assoc :status (deser-status (clojure.core/get-in letvar647518 ["status" :content])))))))

(clojure.core/defn- response-describe-network-acls-result ([input] (response-describe-network-acls-result nil input)) ([resultWrapper647520 input] (clojure.core/let [rawinput647519 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647521 {"networkAclSet" (portkey.aws/search-for-tag rawinput647519 "networkAclSet" :flattened? nil :result-wrapper resultWrapper647520), "nextToken" (portkey.aws/search-for-tag rawinput647519 "nextToken" :flattened? nil :result-wrapper resultWrapper647520)}] (clojure.core/cond-> {} (letvar647521 "networkAclSet") (clojure.core/assoc :network-acls (deser-network-acl-list (clojure.core/get-in letvar647521 ["networkAclSet" :content]))) (letvar647521 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647521 ["nextToken" :content])))))))

(clojure.core/defn- response-cancel-import-task-result ([input] (response-cancel-import-task-result nil input)) ([resultWrapper647523 input] (clojure.core/let [rawinput647522 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647524 {"importTaskId" (portkey.aws/search-for-tag rawinput647522 "importTaskId" :flattened? nil :result-wrapper resultWrapper647523), "previousState" (portkey.aws/search-for-tag rawinput647522 "previousState" :flattened? nil :result-wrapper resultWrapper647523), "state" (portkey.aws/search-for-tag rawinput647522 "state" :flattened? nil :result-wrapper resultWrapper647523)}] (clojure.core/cond-> {} (letvar647524 "importTaskId") (clojure.core/assoc :import-task-id (deser-string (clojure.core/get-in letvar647524 ["importTaskId" :content]))) (letvar647524 "previousState") (clojure.core/assoc :previous-state (deser-string (clojure.core/get-in letvar647524 ["previousState" :content]))) (letvar647524 "state") (clojure.core/assoc :state (deser-string (clojure.core/get-in letvar647524 ["state" :content])))))))

(clojure.core/defn- response-register-image-result ([input] (response-register-image-result nil input)) ([resultWrapper647526 input] (clojure.core/let [rawinput647525 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647527 {"imageId" (portkey.aws/search-for-tag rawinput647525 "imageId" :flattened? nil :result-wrapper resultWrapper647526)}] (clojure.core/cond-> {} (letvar647527 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar647527 ["imageId" :content])))))))

(clojure.core/defn- response-describe-fpga-image-attribute-result ([input] (response-describe-fpga-image-attribute-result nil input)) ([resultWrapper647529 input] (clojure.core/let [rawinput647528 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647530 {"fpgaImageAttribute" (portkey.aws/search-for-tag rawinput647528 "fpgaImageAttribute" :flattened? nil :result-wrapper resultWrapper647529)}] (clojure.core/cond-> {} (letvar647530 "fpgaImageAttribute") (clojure.core/assoc :fpga-image-attribute (deser-fpga-image-attribute (clojure.core/get-in letvar647530 ["fpgaImageAttribute" :content])))))))

(clojure.core/defn- response-describe-client-vpn-target-networks-result ([input] (response-describe-client-vpn-target-networks-result nil input)) ([resultWrapper647532 input] (clojure.core/let [rawinput647531 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647533 {"clientVpnTargetNetworks" (portkey.aws/search-for-tag rawinput647531 "clientVpnTargetNetworks" :flattened? nil :result-wrapper resultWrapper647532), "nextToken" (portkey.aws/search-for-tag rawinput647531 "nextToken" :flattened? nil :result-wrapper resultWrapper647532)}] (clojure.core/cond-> {} (letvar647533 "clientVpnTargetNetworks") (clojure.core/assoc :client-vpn-target-networks (deser-target-network-set (clojure.core/get-in letvar647533 ["clientVpnTargetNetworks" :content]))) (letvar647533 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar647533 ["nextToken" :content])))))))

(clojure.core/defn- response-import-image-result ([input] (response-import-image-result nil input)) ([resultWrapper647535 input] (clojure.core/let [rawinput647534 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647536 {"architecture" (portkey.aws/search-for-tag rawinput647534 "architecture" :flattened? nil :result-wrapper resultWrapper647535), "progress" (portkey.aws/search-for-tag rawinput647534 "progress" :flattened? nil :result-wrapper resultWrapper647535), "snapshotDetailSet" (portkey.aws/search-for-tag rawinput647534 "snapshotDetailSet" :flattened? nil :result-wrapper resultWrapper647535), "kmsKeyId" (portkey.aws/search-for-tag rawinput647534 "kmsKeyId" :flattened? nil :result-wrapper resultWrapper647535), "licenseType" (portkey.aws/search-for-tag rawinput647534 "licenseType" :flattened? nil :result-wrapper resultWrapper647535), "encrypted" (portkey.aws/search-for-tag rawinput647534 "encrypted" :flattened? nil :result-wrapper resultWrapper647535), "status" (portkey.aws/search-for-tag rawinput647534 "status" :flattened? nil :result-wrapper resultWrapper647535), "imageId" (portkey.aws/search-for-tag rawinput647534 "imageId" :flattened? nil :result-wrapper resultWrapper647535), "statusMessage" (portkey.aws/search-for-tag rawinput647534 "statusMessage" :flattened? nil :result-wrapper resultWrapper647535), "importTaskId" (portkey.aws/search-for-tag rawinput647534 "importTaskId" :flattened? nil :result-wrapper resultWrapper647535), "hypervisor" (portkey.aws/search-for-tag rawinput647534 "hypervisor" :flattened? nil :result-wrapper resultWrapper647535), "platform" (portkey.aws/search-for-tag rawinput647534 "platform" :flattened? nil :result-wrapper resultWrapper647535), "description" (portkey.aws/search-for-tag rawinput647534 "description" :flattened? nil :result-wrapper resultWrapper647535)}] (clojure.core/cond-> {} (letvar647536 "platform") (clojure.core/assoc :platform (deser-string (clojure.core/get-in letvar647536 ["platform" :content]))) (letvar647536 "importTaskId") (clojure.core/assoc :import-task-id (deser-string (clojure.core/get-in letvar647536 ["importTaskId" :content]))) (letvar647536 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar647536 ["imageId" :content]))) (letvar647536 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar647536 ["statusMessage" :content]))) (letvar647536 "encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar647536 ["encrypted" :content]))) (letvar647536 "status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar647536 ["status" :content]))) (letvar647536 "progress") (clojure.core/assoc :progress (deser-string (clojure.core/get-in letvar647536 ["progress" :content]))) (letvar647536 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar647536 ["description" :content]))) (letvar647536 "snapshotDetailSet") (clojure.core/assoc :snapshot-details (deser-snapshot-detail-list (clojure.core/get-in letvar647536 ["snapshotDetailSet" :content]))) (letvar647536 "kmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar647536 ["kmsKeyId" :content]))) (letvar647536 "hypervisor") (clojure.core/assoc :hypervisor (deser-string (clojure.core/get-in letvar647536 ["hypervisor" :content]))) (letvar647536 "architecture") (clojure.core/assoc :architecture (deser-string (clojure.core/get-in letvar647536 ["architecture" :content]))) (letvar647536 "licenseType") (clojure.core/assoc :license-type (deser-string (clojure.core/get-in letvar647536 ["licenseType" :content])))))))

(clojure.core/defn- response-describe-launch-templates-result ([input] (response-describe-launch-templates-result nil input)) ([resultWrapper647538 input] (clojure.core/let [rawinput647537 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647539 {"launchTemplates" (portkey.aws/search-for-tag rawinput647537 "launchTemplates" :flattened? nil :result-wrapper resultWrapper647538), "nextToken" (portkey.aws/search-for-tag rawinput647537 "nextToken" :flattened? nil :result-wrapper resultWrapper647538)}] (clojure.core/cond-> {} (letvar647539 "launchTemplates") (clojure.core/assoc :launch-templates (deser-launch-template-set (clojure.core/get-in letvar647539 ["launchTemplates" :content]))) (letvar647539 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647539 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-client-vpn-connections-result ([input] (response-describe-client-vpn-connections-result nil input)) ([resultWrapper647541 input] (clojure.core/let [rawinput647540 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647542 {"connections" (portkey.aws/search-for-tag rawinput647540 "connections" :flattened? nil :result-wrapper resultWrapper647541), "nextToken" (portkey.aws/search-for-tag rawinput647540 "nextToken" :flattened? nil :result-wrapper resultWrapper647541)}] (clojure.core/cond-> {} (letvar647542 "connections") (clojure.core/assoc :connections (deser-client-vpn-connection-set (clojure.core/get-in letvar647542 ["connections" :content]))) (letvar647542 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar647542 ["nextToken" :content])))))))

(clojure.core/defn- response-associate-subnet-cidr-block-result ([input] (response-associate-subnet-cidr-block-result nil input)) ([resultWrapper647544 input] (clojure.core/let [rawinput647543 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647545 {"ipv6CidrBlockAssociation" (portkey.aws/search-for-tag rawinput647543 "ipv6CidrBlockAssociation" :flattened? nil :result-wrapper resultWrapper647544), "subnetId" (portkey.aws/search-for-tag rawinput647543 "subnetId" :flattened? nil :result-wrapper resultWrapper647544)}] (clojure.core/cond-> {} (letvar647545 "ipv6CidrBlockAssociation") (clojure.core/assoc :ipv-6-cidr-block-association (deser-subnet-ipv-6-cidr-block-association (clojure.core/get-in letvar647545 ["ipv6CidrBlockAssociation" :content]))) (letvar647545 "subnetId") (clojure.core/assoc :subnet-id (deser-string (clojure.core/get-in letvar647545 ["subnetId" :content])))))))

(clojure.core/defn- response-describe-vpc-endpoint-connections-result ([input] (response-describe-vpc-endpoint-connections-result nil input)) ([resultWrapper647547 input] (clojure.core/let [rawinput647546 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647548 {"vpcEndpointConnectionSet" (portkey.aws/search-for-tag rawinput647546 "vpcEndpointConnectionSet" :flattened? nil :result-wrapper resultWrapper647547), "nextToken" (portkey.aws/search-for-tag rawinput647546 "nextToken" :flattened? nil :result-wrapper resultWrapper647547)}] (clojure.core/cond-> {} (letvar647548 "vpcEndpointConnectionSet") (clojure.core/assoc :vpc-endpoint-connections (deser-vpc-endpoint-connection-set (clojure.core/get-in letvar647548 ["vpcEndpointConnectionSet" :content]))) (letvar647548 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647548 ["nextToken" :content])))))))

(clojure.core/defn- response-monitor-instances-result ([input] (response-monitor-instances-result nil input)) ([resultWrapper647550 input] (clojure.core/let [rawinput647549 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647551 {"instancesSet" (portkey.aws/search-for-tag rawinput647549 "instancesSet" :flattened? nil :result-wrapper resultWrapper647550)}] (clojure.core/cond-> {} (letvar647551 "instancesSet") (clojure.core/assoc :instance-monitorings (deser-instance-monitoring-list (clojure.core/get-in letvar647551 ["instancesSet" :content])))))))

(clojure.core/defn- response-create-vpc-endpoint-result ([input] (response-create-vpc-endpoint-result nil input)) ([resultWrapper647553 input] (clojure.core/let [rawinput647552 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647554 {"vpcEndpoint" (portkey.aws/search-for-tag rawinput647552 "vpcEndpoint" :flattened? nil :result-wrapper resultWrapper647553), "clientToken" (portkey.aws/search-for-tag rawinput647552 "clientToken" :flattened? nil :result-wrapper resultWrapper647553)}] (clojure.core/cond-> {} (letvar647554 "vpcEndpoint") (clojure.core/assoc :vpc-endpoint (deser-vpc-endpoint (clojure.core/get-in letvar647554 ["vpcEndpoint" :content]))) (letvar647554 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar647554 ["clientToken" :content])))))))

(clojure.core/defn- response-import-key-pair-result ([input] (response-import-key-pair-result nil input)) ([resultWrapper647556 input] (clojure.core/let [rawinput647555 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647557 {"keyFingerprint" (portkey.aws/search-for-tag rawinput647555 "keyFingerprint" :flattened? nil :result-wrapper resultWrapper647556), "keyName" (portkey.aws/search-for-tag rawinput647555 "keyName" :flattened? nil :result-wrapper resultWrapper647556)}] (clojure.core/cond-> {} (letvar647557 "keyFingerprint") (clojure.core/assoc :key-fingerprint (deser-string (clojure.core/get-in letvar647557 ["keyFingerprint" :content]))) (letvar647557 "keyName") (clojure.core/assoc :key-name (deser-string (clojure.core/get-in letvar647557 ["keyName" :content])))))))

(clojure.core/defn- response-create-network-acl-result ([input] (response-create-network-acl-result nil input)) ([resultWrapper647559 input] (clojure.core/let [rawinput647558 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647560 {"networkAcl" (portkey.aws/search-for-tag rawinput647558 "networkAcl" :flattened? nil :result-wrapper resultWrapper647559)}] (clojure.core/cond-> {} (letvar647560 "networkAcl") (clojure.core/assoc :network-acl (deser-network-acl (clojure.core/get-in letvar647560 ["networkAcl" :content])))))))

(clojure.core/defn- response-describe-vpc-endpoint-connection-notifications-result ([input] (response-describe-vpc-endpoint-connection-notifications-result nil input)) ([resultWrapper647562 input] (clojure.core/let [rawinput647561 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647563 {"connectionNotificationSet" (portkey.aws/search-for-tag rawinput647561 "connectionNotificationSet" :flattened? nil :result-wrapper resultWrapper647562), "nextToken" (portkey.aws/search-for-tag rawinput647561 "nextToken" :flattened? nil :result-wrapper resultWrapper647562)}] (clojure.core/cond-> {} (letvar647563 "connectionNotificationSet") (clojure.core/assoc :connection-notification-set (deser-connection-notification-set (clojure.core/get-in letvar647563 ["connectionNotificationSet" :content]))) (letvar647563 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647563 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-iam-instance-profile-associations-result ([input] (response-describe-iam-instance-profile-associations-result nil input)) ([resultWrapper647565 input] (clojure.core/let [rawinput647564 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647566 {"iamInstanceProfileAssociationSet" (portkey.aws/search-for-tag rawinput647564 "iamInstanceProfileAssociationSet" :flattened? nil :result-wrapper resultWrapper647565), "nextToken" (portkey.aws/search-for-tag rawinput647564 "nextToken" :flattened? nil :result-wrapper resultWrapper647565)}] (clojure.core/cond-> {} (letvar647566 "iamInstanceProfileAssociationSet") (clojure.core/assoc :iam-instance-profile-associations (deser-iam-instance-profile-association-set (clojure.core/get-in letvar647566 ["iamInstanceProfileAssociationSet" :content]))) (letvar647566 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar647566 ["nextToken" :content])))))))

(clojure.core/defn- response-create-route-result ([input] (response-create-route-result nil input)) ([resultWrapper647568 input] (clojure.core/let [rawinput647567 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647569 {"return" (portkey.aws/search-for-tag rawinput647567 "return" :flattened? nil :result-wrapper resultWrapper647568)}] (clojure.core/cond-> {} (letvar647569 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647569 ["return" :content])))))))

(clojure.core/defn- response-disassociate-client-vpn-target-network-result ([input] (response-disassociate-client-vpn-target-network-result nil input)) ([resultWrapper647571 input] (clojure.core/let [rawinput647570 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647572 {"associationId" (portkey.aws/search-for-tag rawinput647570 "associationId" :flattened? nil :result-wrapper resultWrapper647571), "status" (portkey.aws/search-for-tag rawinput647570 "status" :flattened? nil :result-wrapper resultWrapper647571)}] (clojure.core/cond-> {} (letvar647572 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar647572 ["associationId" :content]))) (letvar647572 "status") (clojure.core/assoc :status (deser-association-status (clojure.core/get-in letvar647572 ["status" :content])))))))

(clojure.core/defn- response-create-route-table-result ([input] (response-create-route-table-result nil input)) ([resultWrapper647574 input] (clojure.core/let [rawinput647573 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647575 {"routeTable" (portkey.aws/search-for-tag rawinput647573 "routeTable" :flattened? nil :result-wrapper resultWrapper647574)}] (clojure.core/cond-> {} (letvar647575 "routeTable") (clojure.core/assoc :route-table (deser-route-table (clojure.core/get-in letvar647575 ["routeTable" :content])))))))

(clojure.core/defn- response-describe-volume-status-result ([input] (response-describe-volume-status-result nil input)) ([resultWrapper647577 input] (clojure.core/let [rawinput647576 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647578 {"nextToken" (portkey.aws/search-for-tag rawinput647576 "nextToken" :flattened? nil :result-wrapper resultWrapper647577), "volumeStatusSet" (portkey.aws/search-for-tag rawinput647576 "volumeStatusSet" :flattened? nil :result-wrapper resultWrapper647577)}] (clojure.core/cond-> {} (letvar647578 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647578 ["nextToken" :content]))) (letvar647578 "volumeStatusSet") (clojure.core/assoc :volume-statuses (deser-volume-status-list (clojure.core/get-in letvar647578 ["volumeStatusSet" :content])))))))

(clojure.core/defn- response-describe-route-tables-result ([input] (response-describe-route-tables-result nil input)) ([resultWrapper647580 input] (clojure.core/let [rawinput647579 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647581 {"routeTableSet" (portkey.aws/search-for-tag rawinput647579 "routeTableSet" :flattened? nil :result-wrapper resultWrapper647580), "nextToken" (portkey.aws/search-for-tag rawinput647579 "nextToken" :flattened? nil :result-wrapper resultWrapper647580)}] (clojure.core/cond-> {} (letvar647581 "routeTableSet") (clojure.core/assoc :route-tables (deser-route-table-list (clojure.core/get-in letvar647581 ["routeTableSet" :content]))) (letvar647581 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647581 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-export-tasks-result ([input] (response-describe-export-tasks-result nil input)) ([resultWrapper647583 input] (clojure.core/let [rawinput647582 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647584 {"exportTaskSet" (portkey.aws/search-for-tag rawinput647582 "exportTaskSet" :flattened? nil :result-wrapper resultWrapper647583)}] (clojure.core/cond-> {} (letvar647584 "exportTaskSet") (clojure.core/assoc :export-tasks (deser-export-task-list (clojure.core/get-in letvar647584 ["exportTaskSet" :content])))))))

(clojure.core/defn- response-accept-transit-gateway-vpc-attachment-result ([input] (response-accept-transit-gateway-vpc-attachment-result nil input)) ([resultWrapper647586 input] (clojure.core/let [rawinput647585 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647587 {"transitGatewayVpcAttachment" (portkey.aws/search-for-tag rawinput647585 "transitGatewayVpcAttachment" :flattened? nil :result-wrapper resultWrapper647586)}] (clojure.core/cond-> {} (letvar647587 "transitGatewayVpcAttachment") (clojure.core/assoc :transit-gateway-vpc-attachment (deser-transit-gateway-vpc-attachment (clojure.core/get-in letvar647587 ["transitGatewayVpcAttachment" :content])))))))

(clojure.core/defn- response-reservation ([input] (response-reservation nil input)) ([resultWrapper647589 input] (clojure.core/let [rawinput647588 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647590 {"groupSet" (portkey.aws/search-for-tag rawinput647588 "groupSet" :flattened? nil :result-wrapper resultWrapper647589), "instancesSet" (portkey.aws/search-for-tag rawinput647588 "instancesSet" :flattened? nil :result-wrapper resultWrapper647589), "ownerId" (portkey.aws/search-for-tag rawinput647588 "ownerId" :flattened? nil :result-wrapper resultWrapper647589), "requesterId" (portkey.aws/search-for-tag rawinput647588 "requesterId" :flattened? nil :result-wrapper resultWrapper647589), "reservationId" (portkey.aws/search-for-tag rawinput647588 "reservationId" :flattened? nil :result-wrapper resultWrapper647589)}] (clojure.core/cond-> {} (letvar647590 "groupSet") (clojure.core/assoc :groups (deser-group-identifier-list (clojure.core/get-in letvar647590 ["groupSet" :content]))) (letvar647590 "instancesSet") (clojure.core/assoc :instances (deser-instance-list (clojure.core/get-in letvar647590 ["instancesSet" :content]))) (letvar647590 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar647590 ["ownerId" :content]))) (letvar647590 "requesterId") (clojure.core/assoc :requester-id (deser-string (clojure.core/get-in letvar647590 ["requesterId" :content]))) (letvar647590 "reservationId") (clojure.core/assoc :reservation-id (deser-string (clojure.core/get-in letvar647590 ["reservationId" :content])))))))

(clojure.core/defn- response-delete-transit-gateway-result ([input] (response-delete-transit-gateway-result nil input)) ([resultWrapper647592 input] (clojure.core/let [rawinput647591 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647593 {"transitGateway" (portkey.aws/search-for-tag rawinput647591 "transitGateway" :flattened? nil :result-wrapper resultWrapper647592)}] (clojure.core/cond-> {} (letvar647593 "transitGateway") (clojure.core/assoc :transit-gateway (deser-transit-gateway (clojure.core/get-in letvar647593 ["transitGateway" :content])))))))

(clojure.core/defn- response-replace-network-acl-association-result ([input] (response-replace-network-acl-association-result nil input)) ([resultWrapper647595 input] (clojure.core/let [rawinput647594 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647596 {"newAssociationId" (portkey.aws/search-for-tag rawinput647594 "newAssociationId" :flattened? nil :result-wrapper resultWrapper647595)}] (clojure.core/cond-> {} (letvar647596 "newAssociationId") (clojure.core/assoc :new-association-id (deser-string (clojure.core/get-in letvar647596 ["newAssociationId" :content])))))))

(clojure.core/defn- response-import-client-vpn-client-certificate-revocation-list-result ([input] (response-import-client-vpn-client-certificate-revocation-list-result nil input)) ([resultWrapper647598 input] (clojure.core/let [rawinput647597 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647599 {"return" (portkey.aws/search-for-tag rawinput647597 "return" :flattened? nil :result-wrapper resultWrapper647598)}] (clojure.core/cond-> {} (letvar647599 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647599 ["return" :content])))))))

(clojure.core/defn- response-import-snapshot-result ([input] (response-import-snapshot-result nil input)) ([resultWrapper647601 input] (clojure.core/let [rawinput647600 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647602 {"description" (portkey.aws/search-for-tag rawinput647600 "description" :flattened? nil :result-wrapper resultWrapper647601), "importTaskId" (portkey.aws/search-for-tag rawinput647600 "importTaskId" :flattened? nil :result-wrapper resultWrapper647601), "snapshotTaskDetail" (portkey.aws/search-for-tag rawinput647600 "snapshotTaskDetail" :flattened? nil :result-wrapper resultWrapper647601)}] (clojure.core/cond-> {} (letvar647602 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar647602 ["description" :content]))) (letvar647602 "importTaskId") (clojure.core/assoc :import-task-id (deser-string (clojure.core/get-in letvar647602 ["importTaskId" :content]))) (letvar647602 "snapshotTaskDetail") (clojure.core/assoc :snapshot-task-detail (deser-snapshot-task-detail (clojure.core/get-in letvar647602 ["snapshotTaskDetail" :content])))))))

(clojure.core/defn- response-modify-client-vpn-endpoint-result ([input] (response-modify-client-vpn-endpoint-result nil input)) ([resultWrapper647604 input] (clojure.core/let [rawinput647603 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647605 {"return" (portkey.aws/search-for-tag rawinput647603 "return" :flattened? nil :result-wrapper resultWrapper647604)}] (clojure.core/cond-> {} (letvar647605 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647605 ["return" :content])))))))

(clojure.core/defn- response-create-client-vpn-route-result ([input] (response-create-client-vpn-route-result nil input)) ([resultWrapper647607 input] (clojure.core/let [rawinput647606 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647608 {"status" (portkey.aws/search-for-tag rawinput647606 "status" :flattened? nil :result-wrapper resultWrapper647607)}] (clojure.core/cond-> {} (letvar647608 "status") (clojure.core/assoc :status (deser-client-vpn-route-status (clojure.core/get-in letvar647608 ["status" :content])))))))

(clojure.core/defn- response-disable-vpc-classic-link-result ([input] (response-disable-vpc-classic-link-result nil input)) ([resultWrapper647610 input] (clojure.core/let [rawinput647609 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647611 {"return" (portkey.aws/search-for-tag rawinput647609 "return" :flattened? nil :result-wrapper resultWrapper647610)}] (clojure.core/cond-> {} (letvar647611 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647611 ["return" :content])))))))

(clojure.core/defn- response-describe-transit-gateway-attachments-result ([input] (response-describe-transit-gateway-attachments-result nil input)) ([resultWrapper647613 input] (clojure.core/let [rawinput647612 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647614 {"transitGatewayAttachments" (portkey.aws/search-for-tag rawinput647612 "transitGatewayAttachments" :flattened? nil :result-wrapper resultWrapper647613), "nextToken" (portkey.aws/search-for-tag rawinput647612 "nextToken" :flattened? nil :result-wrapper resultWrapper647613)}] (clojure.core/cond-> {} (letvar647614 "transitGatewayAttachments") (clojure.core/assoc :transit-gateway-attachments (deser-transit-gateway-attachment-list (clojure.core/get-in letvar647614 ["transitGatewayAttachments" :content]))) (letvar647614 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647614 ["nextToken" :content])))))))

(clojure.core/defn- response-update-security-group-rule-descriptions-egress-result ([input] (response-update-security-group-rule-descriptions-egress-result nil input)) ([resultWrapper647616 input] (clojure.core/let [rawinput647615 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647617 {"return" (portkey.aws/search-for-tag rawinput647615 "return" :flattened? nil :result-wrapper resultWrapper647616)}] (clojure.core/cond-> {} (letvar647617 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647617 ["return" :content])))))))

(clojure.core/defn- response-create-default-vpc-result ([input] (response-create-default-vpc-result nil input)) ([resultWrapper647619 input] (clojure.core/let [rawinput647618 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647620 {"vpc" (portkey.aws/search-for-tag rawinput647618 "vpc" :flattened? nil :result-wrapper resultWrapper647619)}] (clojure.core/cond-> {} (letvar647620 "vpc") (clojure.core/assoc :vpc (deser-vpc (clojure.core/get-in letvar647620 ["vpc" :content])))))))

(clojure.core/defn- response-modify-instance-credit-specification-result ([input] (response-modify-instance-credit-specification-result nil input)) ([resultWrapper647622 input] (clojure.core/let [rawinput647621 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647623 {"successfulInstanceCreditSpecificationSet" (portkey.aws/search-for-tag rawinput647621 "successfulInstanceCreditSpecificationSet" :flattened? nil :result-wrapper resultWrapper647622), "unsuccessfulInstanceCreditSpecificationSet" (portkey.aws/search-for-tag rawinput647621 "unsuccessfulInstanceCreditSpecificationSet" :flattened? nil :result-wrapper resultWrapper647622)}] (clojure.core/cond-> {} (letvar647623 "successfulInstanceCreditSpecificationSet") (clojure.core/assoc :successful-instance-credit-specifications (deser-successful-instance-credit-specification-set (clojure.core/get-in letvar647623 ["successfulInstanceCreditSpecificationSet" :content]))) (letvar647623 "unsuccessfulInstanceCreditSpecificationSet") (clojure.core/assoc :unsuccessful-instance-credit-specifications (deser-unsuccessful-instance-credit-specification-set (clojure.core/get-in letvar647623 ["unsuccessfulInstanceCreditSpecificationSet" :content])))))))

(clojure.core/defn- response-reset-fpga-image-attribute-result ([input] (response-reset-fpga-image-attribute-result nil input)) ([resultWrapper647625 input] (clojure.core/let [rawinput647624 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647626 {"return" (portkey.aws/search-for-tag rawinput647624 "return" :flattened? nil :result-wrapper resultWrapper647625)}] (clojure.core/cond-> {} (letvar647626 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647626 ["return" :content])))))))

(clojure.core/defn- response-release-hosts-result ([input] (response-release-hosts-result nil input)) ([resultWrapper647628 input] (clojure.core/let [rawinput647627 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647629 {"successful" (portkey.aws/search-for-tag rawinput647627 "successful" :flattened? nil :result-wrapper resultWrapper647628), "unsuccessful" (portkey.aws/search-for-tag rawinput647627 "unsuccessful" :flattened? nil :result-wrapper resultWrapper647628)}] (clojure.core/cond-> {} (letvar647629 "successful") (clojure.core/assoc :successful (deser-response-host-id-list (clojure.core/get-in letvar647629 ["successful" :content]))) (letvar647629 "unsuccessful") (clojure.core/assoc :unsuccessful (deser-unsuccessful-item-list (clojure.core/get-in letvar647629 ["unsuccessful" :content])))))))

(clojure.core/defn- response-deprovision-byoip-cidr-result ([input] (response-deprovision-byoip-cidr-result nil input)) ([resultWrapper647631 input] (clojure.core/let [rawinput647630 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647632 {"byoipCidr" (portkey.aws/search-for-tag rawinput647630 "byoipCidr" :flattened? nil :result-wrapper resultWrapper647631)}] (clojure.core/cond-> {} (letvar647632 "byoipCidr") (clojure.core/assoc :byoip-cidr (deser-byoip-cidr (clojure.core/get-in letvar647632 ["byoipCidr" :content])))))))

(clojure.core/defn- response-disable-vpc-classic-link-dns-support-result ([input] (response-disable-vpc-classic-link-dns-support-result nil input)) ([resultWrapper647634 input] (clojure.core/let [rawinput647633 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647635 {"return" (portkey.aws/search-for-tag rawinput647633 "return" :flattened? nil :result-wrapper resultWrapper647634)}] (clojure.core/cond-> {} (letvar647635 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647635 ["return" :content])))))))

(clojure.core/defn- response-describe-tags-result ([input] (response-describe-tags-result nil input)) ([resultWrapper647637 input] (clojure.core/let [rawinput647636 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647638 {"nextToken" (portkey.aws/search-for-tag rawinput647636 "nextToken" :flattened? nil :result-wrapper resultWrapper647637), "tagSet" (portkey.aws/search-for-tag rawinput647636 "tagSet" :flattened? nil :result-wrapper resultWrapper647637)}] (clojure.core/cond-> {} (letvar647638 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647638 ["nextToken" :content]))) (letvar647638 "tagSet") (clojure.core/assoc :tags (deser-tag-description-list (clojure.core/get-in letvar647638 ["tagSet" :content])))))))

(clojure.core/defn- response-describe-moving-addresses-result ([input] (response-describe-moving-addresses-result nil input)) ([resultWrapper647640 input] (clojure.core/let [rawinput647639 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647641 {"movingAddressStatusSet" (portkey.aws/search-for-tag rawinput647639 "movingAddressStatusSet" :flattened? nil :result-wrapper resultWrapper647640), "nextToken" (portkey.aws/search-for-tag rawinput647639 "nextToken" :flattened? nil :result-wrapper resultWrapper647640)}] (clojure.core/cond-> {} (letvar647641 "movingAddressStatusSet") (clojure.core/assoc :moving-address-statuses (deser-moving-address-status-set (clojure.core/get-in letvar647641 ["movingAddressStatusSet" :content]))) (letvar647641 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647641 ["nextToken" :content])))))))

(clojure.core/defn- response-create-capacity-reservation-result ([input] (response-create-capacity-reservation-result nil input)) ([resultWrapper647643 input] (clojure.core/let [rawinput647642 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647644 {"capacityReservation" (portkey.aws/search-for-tag rawinput647642 "capacityReservation" :flattened? nil :result-wrapper resultWrapper647643)}] (clojure.core/cond-> {} (letvar647644 "capacityReservation") (clojure.core/assoc :capacity-reservation (deser-capacity-reservation (clojure.core/get-in letvar647644 ["capacityReservation" :content])))))))

(clojure.core/defn- response-reject-vpc-endpoint-connections-result ([input] (response-reject-vpc-endpoint-connections-result nil input)) ([resultWrapper647646 input] (clojure.core/let [rawinput647645 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647647 {"unsuccessful" (portkey.aws/search-for-tag rawinput647645 "unsuccessful" :flattened? nil :result-wrapper resultWrapper647646)}] (clojure.core/cond-> {} (letvar647647 "unsuccessful") (clojure.core/assoc :unsuccessful (deser-unsuccessful-item-set (clojure.core/get-in letvar647647 ["unsuccessful" :content])))))))

(clojure.core/defn- response-create-vpc-endpoint-connection-notification-result ([input] (response-create-vpc-endpoint-connection-notification-result nil input)) ([resultWrapper647649 input] (clojure.core/let [rawinput647648 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647650 {"connectionNotification" (portkey.aws/search-for-tag rawinput647648 "connectionNotification" :flattened? nil :result-wrapper resultWrapper647649), "clientToken" (portkey.aws/search-for-tag rawinput647648 "clientToken" :flattened? nil :result-wrapper resultWrapper647649)}] (clojure.core/cond-> {} (letvar647650 "connectionNotification") (clojure.core/assoc :connection-notification (deser-connection-notification (clojure.core/get-in letvar647650 ["connectionNotification" :content]))) (letvar647650 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar647650 ["clientToken" :content])))))))

(clojure.core/defn- response-describe-images-result ([input] (response-describe-images-result nil input)) ([resultWrapper647652 input] (clojure.core/let [rawinput647651 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647653 {"imagesSet" (portkey.aws/search-for-tag rawinput647651 "imagesSet" :flattened? nil :result-wrapper resultWrapper647652)}] (clojure.core/cond-> {} (letvar647653 "imagesSet") (clojure.core/assoc :images (deser-image-list (clojure.core/get-in letvar647653 ["imagesSet" :content])))))))

(clojure.core/defn- response-create-flow-logs-result ([input] (response-create-flow-logs-result nil input)) ([resultWrapper647655 input] (clojure.core/let [rawinput647654 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647656 {"clientToken" (portkey.aws/search-for-tag rawinput647654 "clientToken" :flattened? nil :result-wrapper resultWrapper647655), "flowLogIdSet" (portkey.aws/search-for-tag rawinput647654 "flowLogIdSet" :flattened? nil :result-wrapper resultWrapper647655), "unsuccessful" (portkey.aws/search-for-tag rawinput647654 "unsuccessful" :flattened? nil :result-wrapper resultWrapper647655)}] (clojure.core/cond-> {} (letvar647656 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar647656 ["clientToken" :content]))) (letvar647656 "flowLogIdSet") (clojure.core/assoc :flow-log-ids (deser-value-string-list (clojure.core/get-in letvar647656 ["flowLogIdSet" :content]))) (letvar647656 "unsuccessful") (clojure.core/assoc :unsuccessful (deser-unsuccessful-item-set (clojure.core/get-in letvar647656 ["unsuccessful" :content])))))))

(clojure.core/defn- response-delete-launch-template-versions-result ([input] (response-delete-launch-template-versions-result nil input)) ([resultWrapper647658 input] (clojure.core/let [rawinput647657 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647659 {"successfullyDeletedLaunchTemplateVersionSet" (portkey.aws/search-for-tag rawinput647657 "successfullyDeletedLaunchTemplateVersionSet" :flattened? nil :result-wrapper resultWrapper647658), "unsuccessfullyDeletedLaunchTemplateVersionSet" (portkey.aws/search-for-tag rawinput647657 "unsuccessfullyDeletedLaunchTemplateVersionSet" :flattened? nil :result-wrapper resultWrapper647658)}] (clojure.core/cond-> {} (letvar647659 "successfullyDeletedLaunchTemplateVersionSet") (clojure.core/assoc :successfully-deleted-launch-template-versions (deser-delete-launch-template-versions-response-success-set (clojure.core/get-in letvar647659 ["successfullyDeletedLaunchTemplateVersionSet" :content]))) (letvar647659 "unsuccessfullyDeletedLaunchTemplateVersionSet") (clojure.core/assoc :unsuccessfully-deleted-launch-template-versions (deser-delete-launch-template-versions-response-error-set (clojure.core/get-in letvar647659 ["unsuccessfullyDeletedLaunchTemplateVersionSet" :content])))))))

(clojure.core/defn- response-create-transit-gateway-route-result ([input] (response-create-transit-gateway-route-result nil input)) ([resultWrapper647661 input] (clojure.core/let [rawinput647660 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647662 {"route" (portkey.aws/search-for-tag rawinput647660 "route" :flattened? nil :result-wrapper resultWrapper647661)}] (clojure.core/cond-> {} (letvar647662 "route") (clojure.core/assoc :route (deser-transit-gateway-route (clojure.core/get-in letvar647662 ["route" :content])))))))

(clojure.core/defn- response-describe-spot-instance-requests-result ([input] (response-describe-spot-instance-requests-result nil input)) ([resultWrapper647664 input] (clojure.core/let [rawinput647663 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647665 {"spotInstanceRequestSet" (portkey.aws/search-for-tag rawinput647663 "spotInstanceRequestSet" :flattened? nil :result-wrapper resultWrapper647664), "nextToken" (portkey.aws/search-for-tag rawinput647663 "nextToken" :flattened? nil :result-wrapper resultWrapper647664)}] (clojure.core/cond-> {} (letvar647665 "spotInstanceRequestSet") (clojure.core/assoc :spot-instance-requests (deser-spot-instance-request-list (clojure.core/get-in letvar647665 ["spotInstanceRequestSet" :content]))) (letvar647665 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647665 ["nextToken" :content])))))))

(clojure.core/defn- response-create-customer-gateway-result ([input] (response-create-customer-gateway-result nil input)) ([resultWrapper647667 input] (clojure.core/let [rawinput647666 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647668 {"customerGateway" (portkey.aws/search-for-tag rawinput647666 "customerGateway" :flattened? nil :result-wrapper resultWrapper647667)}] (clojure.core/cond-> {} (letvar647668 "customerGateway") (clojure.core/assoc :customer-gateway (deser-customer-gateway (clojure.core/get-in letvar647668 ["customerGateway" :content])))))))

(clojure.core/defn- response-describe-hosts-result ([input] (response-describe-hosts-result nil input)) ([resultWrapper647670 input] (clojure.core/let [rawinput647669 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647671 {"hostSet" (portkey.aws/search-for-tag rawinput647669 "hostSet" :flattened? nil :result-wrapper resultWrapper647670), "nextToken" (portkey.aws/search-for-tag rawinput647669 "nextToken" :flattened? nil :result-wrapper resultWrapper647670)}] (clojure.core/cond-> {} (letvar647671 "hostSet") (clojure.core/assoc :hosts (deser-host-list (clojure.core/get-in letvar647671 ["hostSet" :content]))) (letvar647671 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647671 ["nextToken" :content])))))))

(clojure.core/defn- response-get-transit-gateway-attachment-propagations-result ([input] (response-get-transit-gateway-attachment-propagations-result nil input)) ([resultWrapper647673 input] (clojure.core/let [rawinput647672 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647674 {"transitGatewayAttachmentPropagations" (portkey.aws/search-for-tag rawinput647672 "transitGatewayAttachmentPropagations" :flattened? nil :result-wrapper resultWrapper647673), "nextToken" (portkey.aws/search-for-tag rawinput647672 "nextToken" :flattened? nil :result-wrapper resultWrapper647673)}] (clojure.core/cond-> {} (letvar647674 "transitGatewayAttachmentPropagations") (clojure.core/assoc :transit-gateway-attachment-propagations (deser-transit-gateway-attachment-propagation-list (clojure.core/get-in letvar647674 ["transitGatewayAttachmentPropagations" :content]))) (letvar647674 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647674 ["nextToken" :content])))))))

(clojure.core/defn- response-enable-vpc-classic-link-dns-support-result ([input] (response-enable-vpc-classic-link-dns-support-result nil input)) ([resultWrapper647676 input] (clojure.core/let [rawinput647675 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647677 {"return" (portkey.aws/search-for-tag rawinput647675 "return" :flattened? nil :result-wrapper resultWrapper647676)}] (clojure.core/cond-> {} (letvar647677 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647677 ["return" :content])))))))

(clojure.core/defn- response-search-transit-gateway-routes-result ([input] (response-search-transit-gateway-routes-result nil input)) ([resultWrapper647679 input] (clojure.core/let [rawinput647678 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647680 {"routeSet" (portkey.aws/search-for-tag rawinput647678 "routeSet" :flattened? nil :result-wrapper resultWrapper647679), "additionalRoutesAvailable" (portkey.aws/search-for-tag rawinput647678 "additionalRoutesAvailable" :flattened? nil :result-wrapper resultWrapper647679)}] (clojure.core/cond-> {} (letvar647680 "routeSet") (clojure.core/assoc :routes (deser-transit-gateway-route-list (clojure.core/get-in letvar647680 ["routeSet" :content]))) (letvar647680 "additionalRoutesAvailable") (clojure.core/assoc :additional-routes-available (deser-boolean (clojure.core/get-in letvar647680 ["additionalRoutesAvailable" :content])))))))

(clojure.core/defn- response-describe-launch-template-versions-result ([input] (response-describe-launch-template-versions-result nil input)) ([resultWrapper647682 input] (clojure.core/let [rawinput647681 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647683 {"launchTemplateVersionSet" (portkey.aws/search-for-tag rawinput647681 "launchTemplateVersionSet" :flattened? nil :result-wrapper resultWrapper647682), "nextToken" (portkey.aws/search-for-tag rawinput647681 "nextToken" :flattened? nil :result-wrapper resultWrapper647682)}] (clojure.core/cond-> {} (letvar647683 "launchTemplateVersionSet") (clojure.core/assoc :launch-template-versions (deser-launch-template-version-set (clojure.core/get-in letvar647683 ["launchTemplateVersionSet" :content]))) (letvar647683 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647683 ["nextToken" :content])))))))

(clojure.core/defn- response-create-launch-template-result ([input] (response-create-launch-template-result nil input)) ([resultWrapper647685 input] (clojure.core/let [rawinput647684 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647686 {"launchTemplate" (portkey.aws/search-for-tag rawinput647684 "launchTemplate" :flattened? nil :result-wrapper resultWrapper647685)}] (clojure.core/cond-> {} (letvar647686 "launchTemplate") (clojure.core/assoc :launch-template (deser-launch-template (clojure.core/get-in letvar647686 ["launchTemplate" :content])))))))

(clojure.core/defn- response-create-client-vpn-endpoint-result ([input] (response-create-client-vpn-endpoint-result nil input)) ([resultWrapper647688 input] (clojure.core/let [rawinput647687 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647689 {"clientVpnEndpointId" (portkey.aws/search-for-tag rawinput647687 "clientVpnEndpointId" :flattened? nil :result-wrapper resultWrapper647688), "status" (portkey.aws/search-for-tag rawinput647687 "status" :flattened? nil :result-wrapper resultWrapper647688), "dnsName" (portkey.aws/search-for-tag rawinput647687 "dnsName" :flattened? nil :result-wrapper resultWrapper647688)}] (clojure.core/cond-> {} (letvar647689 "clientVpnEndpointId") (clojure.core/assoc :client-vpn-endpoint-id (deser-string (clojure.core/get-in letvar647689 ["clientVpnEndpointId" :content]))) (letvar647689 "status") (clojure.core/assoc :status (deser-client-vpn-endpoint-status (clojure.core/get-in letvar647689 ["status" :content]))) (letvar647689 "dnsName") (clojure.core/assoc :dns-name (deser-string (clojure.core/get-in letvar647689 ["dnsName" :content])))))))

(clojure.core/defn- response-describe-volumes-modifications-result ([input] (response-describe-volumes-modifications-result nil input)) ([resultWrapper647691 input] (clojure.core/let [rawinput647690 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647692 {"volumeModificationSet" (portkey.aws/search-for-tag rawinput647690 "volumeModificationSet" :flattened? nil :result-wrapper resultWrapper647691), "nextToken" (portkey.aws/search-for-tag rawinput647690 "nextToken" :flattened? nil :result-wrapper resultWrapper647691)}] (clojure.core/cond-> {} (letvar647692 "volumeModificationSet") (clojure.core/assoc :volumes-modifications (deser-volume-modification-list (clojure.core/get-in letvar647692 ["volumeModificationSet" :content]))) (letvar647692 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647692 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-public-ipv-4-pools-result ([input] (response-describe-public-ipv-4-pools-result nil input)) ([resultWrapper647694 input] (clojure.core/let [rawinput647693 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647695 {"publicIpv4PoolSet" (portkey.aws/search-for-tag rawinput647693 "publicIpv4PoolSet" :flattened? nil :result-wrapper resultWrapper647694), "nextToken" (portkey.aws/search-for-tag rawinput647693 "nextToken" :flattened? nil :result-wrapper resultWrapper647694)}] (clojure.core/cond-> {} (letvar647695 "publicIpv4PoolSet") (clojure.core/assoc :public-ipv-4-pools (deser-public-ipv-4-pool-set (clojure.core/get-in letvar647695 ["publicIpv4PoolSet" :content]))) (letvar647695 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647695 ["nextToken" :content])))))))

(clojure.core/defn- response-stop-instances-result ([input] (response-stop-instances-result nil input)) ([resultWrapper647697 input] (clojure.core/let [rawinput647696 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647698 {"instancesSet" (portkey.aws/search-for-tag rawinput647696 "instancesSet" :flattened? nil :result-wrapper resultWrapper647697)}] (clojure.core/cond-> {} (letvar647698 "instancesSet") (clojure.core/assoc :stopping-instances (deser-instance-state-change-list (clojure.core/get-in letvar647698 ["instancesSet" :content])))))))

(clojure.core/defn- response-describe-vpc-endpoints-result ([input] (response-describe-vpc-endpoints-result nil input)) ([resultWrapper647700 input] (clojure.core/let [rawinput647699 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647701 {"vpcEndpointSet" (portkey.aws/search-for-tag rawinput647699 "vpcEndpointSet" :flattened? nil :result-wrapper resultWrapper647700), "nextToken" (portkey.aws/search-for-tag rawinput647699 "nextToken" :flattened? nil :result-wrapper resultWrapper647700)}] (clojure.core/cond-> {} (letvar647701 "vpcEndpointSet") (clojure.core/assoc :vpc-endpoints (deser-vpc-endpoint-set (clojure.core/get-in letvar647701 ["vpcEndpointSet" :content]))) (letvar647701 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647701 ["nextToken" :content])))))))

(clojure.core/defn- response-purchase-scheduled-instances-result ([input] (response-purchase-scheduled-instances-result nil input)) ([resultWrapper647703 input] (clojure.core/let [rawinput647702 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647704 {"scheduledInstanceSet" (portkey.aws/search-for-tag rawinput647702 "scheduledInstanceSet" :flattened? nil :result-wrapper resultWrapper647703)}] (clojure.core/cond-> {} (letvar647704 "scheduledInstanceSet") (clojure.core/assoc :scheduled-instance-set (deser-purchased-scheduled-instance-set (clojure.core/get-in letvar647704 ["scheduledInstanceSet" :content])))))))

(clojure.core/defn- response-describe-addresses-result ([input] (response-describe-addresses-result nil input)) ([resultWrapper647706 input] (clojure.core/let [rawinput647705 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647707 {"addressesSet" (portkey.aws/search-for-tag rawinput647705 "addressesSet" :flattened? nil :result-wrapper resultWrapper647706)}] (clojure.core/cond-> {} (letvar647707 "addressesSet") (clojure.core/assoc :addresses (deser-address-list (clojure.core/get-in letvar647707 ["addressesSet" :content])))))))

(clojure.core/defn- response-purchase-host-reservation-result ([input] (response-purchase-host-reservation-result nil input)) ([resultWrapper647709 input] (clojure.core/let [rawinput647708 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647710 {"clientToken" (portkey.aws/search-for-tag rawinput647708 "clientToken" :flattened? nil :result-wrapper resultWrapper647709), "currencyCode" (portkey.aws/search-for-tag rawinput647708 "currencyCode" :flattened? nil :result-wrapper resultWrapper647709), "purchase" (portkey.aws/search-for-tag rawinput647708 "purchase" :flattened? nil :result-wrapper resultWrapper647709), "totalHourlyPrice" (portkey.aws/search-for-tag rawinput647708 "totalHourlyPrice" :flattened? nil :result-wrapper resultWrapper647709), "totalUpfrontPrice" (portkey.aws/search-for-tag rawinput647708 "totalUpfrontPrice" :flattened? nil :result-wrapper resultWrapper647709)}] (clojure.core/cond-> {} (letvar647710 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar647710 ["clientToken" :content]))) (letvar647710 "currencyCode") (clojure.core/assoc :currency-code (deser-currency-code-values (clojure.core/get-in letvar647710 ["currencyCode" :content]))) (letvar647710 "purchase") (clojure.core/assoc :purchase (deser-purchase-set (clojure.core/get-in letvar647710 ["purchase" :content]))) (letvar647710 "totalHourlyPrice") (clojure.core/assoc :total-hourly-price (deser-string (clojure.core/get-in letvar647710 ["totalHourlyPrice" :content]))) (letvar647710 "totalUpfrontPrice") (clojure.core/assoc :total-upfront-price (deser-string (clojure.core/get-in letvar647710 ["totalUpfrontPrice" :content])))))))

(clojure.core/defn- response-describe-prefix-lists-result ([input] (response-describe-prefix-lists-result nil input)) ([resultWrapper647712 input] (clojure.core/let [rawinput647711 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647713 {"nextToken" (portkey.aws/search-for-tag rawinput647711 "nextToken" :flattened? nil :result-wrapper resultWrapper647712), "prefixListSet" (portkey.aws/search-for-tag rawinput647711 "prefixListSet" :flattened? nil :result-wrapper resultWrapper647712)}] (clojure.core/cond-> {} (letvar647713 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647713 ["nextToken" :content]))) (letvar647713 "prefixListSet") (clojure.core/assoc :prefix-lists (deser-prefix-list-set (clojure.core/get-in letvar647713 ["prefixListSet" :content])))))))

(clojure.core/defn- response-describe-identity-id-format-result ([input] (response-describe-identity-id-format-result nil input)) ([resultWrapper647715 input] (clojure.core/let [rawinput647714 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647716 {"statusSet" (portkey.aws/search-for-tag rawinput647714 "statusSet" :flattened? nil :result-wrapper resultWrapper647715)}] (clojure.core/cond-> {} (letvar647716 "statusSet") (clojure.core/assoc :statuses (deser-id-format-list (clojure.core/get-in letvar647716 ["statusSet" :content])))))))

(clojure.core/defn- response-describe-spot-datafeed-subscription-result ([input] (response-describe-spot-datafeed-subscription-result nil input)) ([resultWrapper647718 input] (clojure.core/let [rawinput647717 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647719 {"spotDatafeedSubscription" (portkey.aws/search-for-tag rawinput647717 "spotDatafeedSubscription" :flattened? nil :result-wrapper resultWrapper647718)}] (clojure.core/cond-> {} (letvar647719 "spotDatafeedSubscription") (clojure.core/assoc :spot-datafeed-subscription (deser-spot-datafeed-subscription (clojure.core/get-in letvar647719 ["spotDatafeedSubscription" :content])))))))

(clojure.core/defn- response-import-instance-result ([input] (response-import-instance-result nil input)) ([resultWrapper647721 input] (clojure.core/let [rawinput647720 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647722 {"conversionTask" (portkey.aws/search-for-tag rawinput647720 "conversionTask" :flattened? nil :result-wrapper resultWrapper647721)}] (clojure.core/cond-> {} (letvar647722 "conversionTask") (clojure.core/assoc :conversion-task (deser-conversion-task (clojure.core/get-in letvar647722 ["conversionTask" :content])))))))

(clojure.core/defn- response-describe-transit-gateway-vpc-attachments-result ([input] (response-describe-transit-gateway-vpc-attachments-result nil input)) ([resultWrapper647724 input] (clojure.core/let [rawinput647723 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647725 {"transitGatewayVpcAttachments" (portkey.aws/search-for-tag rawinput647723 "transitGatewayVpcAttachments" :flattened? nil :result-wrapper resultWrapper647724), "nextToken" (portkey.aws/search-for-tag rawinput647723 "nextToken" :flattened? nil :result-wrapper resultWrapper647724)}] (clojure.core/cond-> {} (letvar647725 "transitGatewayVpcAttachments") (clojure.core/assoc :transit-gateway-vpc-attachments (deser-transit-gateway-vpc-attachment-list (clojure.core/get-in letvar647725 ["transitGatewayVpcAttachments" :content]))) (letvar647725 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647725 ["nextToken" :content])))))))

(clojure.core/defn- response-create-transit-gateway-route-table-result ([input] (response-create-transit-gateway-route-table-result nil input)) ([resultWrapper647727 input] (clojure.core/let [rawinput647726 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647728 {"transitGatewayRouteTable" (portkey.aws/search-for-tag rawinput647726 "transitGatewayRouteTable" :flattened? nil :result-wrapper resultWrapper647727)}] (clojure.core/cond-> {} (letvar647728 "transitGatewayRouteTable") (clojure.core/assoc :transit-gateway-route-table (deser-transit-gateway-route-table (clojure.core/get-in letvar647728 ["transitGatewayRouteTable" :content])))))))

(clojure.core/defn- response-associate-vpc-cidr-block-result ([input] (response-associate-vpc-cidr-block-result nil input)) ([resultWrapper647730 input] (clojure.core/let [rawinput647729 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647731 {"ipv6CidrBlockAssociation" (portkey.aws/search-for-tag rawinput647729 "ipv6CidrBlockAssociation" :flattened? nil :result-wrapper resultWrapper647730), "cidrBlockAssociation" (portkey.aws/search-for-tag rawinput647729 "cidrBlockAssociation" :flattened? nil :result-wrapper resultWrapper647730), "vpcId" (portkey.aws/search-for-tag rawinput647729 "vpcId" :flattened? nil :result-wrapper resultWrapper647730)}] (clojure.core/cond-> {} (letvar647731 "ipv6CidrBlockAssociation") (clojure.core/assoc :ipv-6-cidr-block-association (deser-vpc-ipv-6-cidr-block-association (clojure.core/get-in letvar647731 ["ipv6CidrBlockAssociation" :content]))) (letvar647731 "cidrBlockAssociation") (clojure.core/assoc :cidr-block-association (deser-vpc-cidr-block-association (clojure.core/get-in letvar647731 ["cidrBlockAssociation" :content]))) (letvar647731 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar647731 ["vpcId" :content])))))))

(clojure.core/defn- response-describe-key-pairs-result ([input] (response-describe-key-pairs-result nil input)) ([resultWrapper647733 input] (clojure.core/let [rawinput647732 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647734 {"keySet" (portkey.aws/search-for-tag rawinput647732 "keySet" :flattened? nil :result-wrapper resultWrapper647733)}] (clojure.core/cond-> {} (letvar647734 "keySet") (clojure.core/assoc :key-pairs (deser-key-pair-list (clojure.core/get-in letvar647734 ["keySet" :content])))))))

(clojure.core/defn- response-describe-internet-gateways-result ([input] (response-describe-internet-gateways-result nil input)) ([resultWrapper647736 input] (clojure.core/let [rawinput647735 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647737 {"internetGatewaySet" (portkey.aws/search-for-tag rawinput647735 "internetGatewaySet" :flattened? nil :result-wrapper resultWrapper647736), "nextToken" (portkey.aws/search-for-tag rawinput647735 "nextToken" :flattened? nil :result-wrapper resultWrapper647736)}] (clojure.core/cond-> {} (letvar647737 "internetGatewaySet") (clojure.core/assoc :internet-gateways (deser-internet-gateway-list (clojure.core/get-in letvar647737 ["internetGatewaySet" :content]))) (letvar647737 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647737 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-vpc-classic-link-dns-support-result ([input] (response-describe-vpc-classic-link-dns-support-result nil input)) ([resultWrapper647739 input] (clojure.core/let [rawinput647738 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647740 {"nextToken" (portkey.aws/search-for-tag rawinput647738 "nextToken" :flattened? nil :result-wrapper resultWrapper647739), "vpcs" (portkey.aws/search-for-tag rawinput647738 "vpcs" :flattened? nil :result-wrapper resultWrapper647739)}] (clojure.core/cond-> {} (letvar647740 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar647740 ["nextToken" :content]))) (letvar647740 "vpcs") (clojure.core/assoc :vpcs (deser-classic-link-dns-support-list (clojure.core/get-in letvar647740 ["vpcs" :content])))))))

(clojure.core/defn- response-describe-id-format-result ([input] (response-describe-id-format-result nil input)) ([resultWrapper647742 input] (clojure.core/let [rawinput647741 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647743 {"statusSet" (portkey.aws/search-for-tag rawinput647741 "statusSet" :flattened? nil :result-wrapper resultWrapper647742)}] (clojure.core/cond-> {} (letvar647743 "statusSet") (clojure.core/assoc :statuses (deser-id-format-list (clojure.core/get-in letvar647743 ["statusSet" :content])))))))

(clojure.core/defn- response-describe-snapshot-attribute-result ([input] (response-describe-snapshot-attribute-result nil input)) ([resultWrapper647745 input] (clojure.core/let [rawinput647744 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647746 {"createVolumePermission" (portkey.aws/search-for-tag rawinput647744 "createVolumePermission" :flattened? nil :result-wrapper resultWrapper647745), "productCodes" (portkey.aws/search-for-tag rawinput647744 "productCodes" :flattened? nil :result-wrapper resultWrapper647745), "snapshotId" (portkey.aws/search-for-tag rawinput647744 "snapshotId" :flattened? nil :result-wrapper resultWrapper647745)}] (clojure.core/cond-> {} (letvar647746 "createVolumePermission") (clojure.core/assoc :create-volume-permissions (deser-create-volume-permission-list (clojure.core/get-in letvar647746 ["createVolumePermission" :content]))) (letvar647746 "productCodes") (clojure.core/assoc :product-codes (deser-product-code-list (clojure.core/get-in letvar647746 ["productCodes" :content]))) (letvar647746 "snapshotId") (clojure.core/assoc :snapshot-id (deser-string (clojure.core/get-in letvar647746 ["snapshotId" :content])))))))

(clojure.core/defn- response-create-launch-template-version-result ([input] (response-create-launch-template-version-result nil input)) ([resultWrapper647748 input] (clojure.core/let [rawinput647747 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647749 {"launchTemplateVersion" (portkey.aws/search-for-tag rawinput647747 "launchTemplateVersion" :flattened? nil :result-wrapper resultWrapper647748)}] (clojure.core/cond-> {} (letvar647749 "launchTemplateVersion") (clojure.core/assoc :launch-template-version (deser-launch-template-version (clojure.core/get-in letvar647749 ["launchTemplateVersion" :content])))))))

(clojure.core/defn- response-get-console-output-result ([input] (response-get-console-output-result nil input)) ([resultWrapper647751 input] (clojure.core/let [rawinput647750 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647752 {"instanceId" (portkey.aws/search-for-tag rawinput647750 "instanceId" :flattened? nil :result-wrapper resultWrapper647751), "output" (portkey.aws/search-for-tag rawinput647750 "output" :flattened? nil :result-wrapper resultWrapper647751), "timestamp" (portkey.aws/search-for-tag rawinput647750 "timestamp" :flattened? nil :result-wrapper resultWrapper647751)}] (clojure.core/cond-> {} (letvar647752 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar647752 ["instanceId" :content]))) (letvar647752 "output") (clojure.core/assoc :output (deser-string (clojure.core/get-in letvar647752 ["output" :content]))) (letvar647752 "timestamp") (clojure.core/assoc :timestamp (deser-date-time (clojure.core/get-in letvar647752 ["timestamp" :content])))))))

(clojure.core/defn- response-describe-placement-groups-result ([input] (response-describe-placement-groups-result nil input)) ([resultWrapper647754 input] (clojure.core/let [rawinput647753 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647755 {"placementGroupSet" (portkey.aws/search-for-tag rawinput647753 "placementGroupSet" :flattened? nil :result-wrapper resultWrapper647754)}] (clojure.core/cond-> {} (letvar647755 "placementGroupSet") (clojure.core/assoc :placement-groups (deser-placement-group-list (clojure.core/get-in letvar647755 ["placementGroupSet" :content])))))))

(clojure.core/defn- response-create-vpc-peering-connection-result ([input] (response-create-vpc-peering-connection-result nil input)) ([resultWrapper647757 input] (clojure.core/let [rawinput647756 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647758 {"vpcPeeringConnection" (portkey.aws/search-for-tag rawinput647756 "vpcPeeringConnection" :flattened? nil :result-wrapper resultWrapper647757)}] (clojure.core/cond-> {} (letvar647758 "vpcPeeringConnection") (clojure.core/assoc :vpc-peering-connection (deser-vpc-peering-connection (clojure.core/get-in letvar647758 ["vpcPeeringConnection" :content])))))))

(clojure.core/defn- response-modify-hosts-result ([input] (response-modify-hosts-result nil input)) ([resultWrapper647760 input] (clojure.core/let [rawinput647759 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647761 {"successful" (portkey.aws/search-for-tag rawinput647759 "successful" :flattened? nil :result-wrapper resultWrapper647760), "unsuccessful" (portkey.aws/search-for-tag rawinput647759 "unsuccessful" :flattened? nil :result-wrapper resultWrapper647760)}] (clojure.core/cond-> {} (letvar647761 "successful") (clojure.core/assoc :successful (deser-response-host-id-list (clojure.core/get-in letvar647761 ["successful" :content]))) (letvar647761 "unsuccessful") (clojure.core/assoc :unsuccessful (deser-unsuccessful-item-list (clojure.core/get-in letvar647761 ["unsuccessful" :content])))))))

(clojure.core/defn- response-create-vpn-connection-result ([input] (response-create-vpn-connection-result nil input)) ([resultWrapper647763 input] (clojure.core/let [rawinput647762 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647764 {"vpnConnection" (portkey.aws/search-for-tag rawinput647762 "vpnConnection" :flattened? nil :result-wrapper resultWrapper647763)}] (clojure.core/cond-> {} (letvar647764 "vpnConnection") (clojure.core/assoc :vpn-connection (deser-vpn-connection (clojure.core/get-in letvar647764 ["vpnConnection" :content])))))))

(clojure.core/defn- response-describe-customer-gateways-result ([input] (response-describe-customer-gateways-result nil input)) ([resultWrapper647766 input] (clojure.core/let [rawinput647765 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647767 {"customerGatewaySet" (portkey.aws/search-for-tag rawinput647765 "customerGatewaySet" :flattened? nil :result-wrapper resultWrapper647766)}] (clojure.core/cond-> {} (letvar647767 "customerGatewaySet") (clojure.core/assoc :customer-gateways (deser-customer-gateway-list (clojure.core/get-in letvar647767 ["customerGatewaySet" :content])))))))

(clojure.core/defn- response-describe-account-attributes-result ([input] (response-describe-account-attributes-result nil input)) ([resultWrapper647769 input] (clojure.core/let [rawinput647768 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647770 {"accountAttributeSet" (portkey.aws/search-for-tag rawinput647768 "accountAttributeSet" :flattened? nil :result-wrapper resultWrapper647769)}] (clojure.core/cond-> {} (letvar647770 "accountAttributeSet") (clojure.core/assoc :account-attributes (deser-account-attribute-list (clojure.core/get-in letvar647770 ["accountAttributeSet" :content])))))))

(clojure.core/defn- response-describe-scheduled-instances-result ([input] (response-describe-scheduled-instances-result nil input)) ([resultWrapper647772 input] (clojure.core/let [rawinput647771 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647773 {"nextToken" (portkey.aws/search-for-tag rawinput647771 "nextToken" :flattened? nil :result-wrapper resultWrapper647772), "scheduledInstanceSet" (portkey.aws/search-for-tag rawinput647771 "scheduledInstanceSet" :flattened? nil :result-wrapper resultWrapper647772)}] (clojure.core/cond-> {} (letvar647773 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647773 ["nextToken" :content]))) (letvar647773 "scheduledInstanceSet") (clojure.core/assoc :scheduled-instance-set (deser-scheduled-instance-set (clojure.core/get-in letvar647773 ["scheduledInstanceSet" :content])))))))

(clojure.core/defn- response-modify-vpc-endpoint-connection-notification-result ([input] (response-modify-vpc-endpoint-connection-notification-result nil input)) ([resultWrapper647775 input] (clojure.core/let [rawinput647774 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647776 {"return" (portkey.aws/search-for-tag rawinput647774 "return" :flattened? nil :result-wrapper resultWrapper647775)}] (clojure.core/cond-> {} (letvar647776 "return") (clojure.core/assoc :return-value (deser-boolean (clojure.core/get-in letvar647776 ["return" :content])))))))

(clojure.core/defn- response-replace-transit-gateway-route-result ([input] (response-replace-transit-gateway-route-result nil input)) ([resultWrapper647778 input] (clojure.core/let [rawinput647777 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647779 {"route" (portkey.aws/search-for-tag rawinput647777 "route" :flattened? nil :result-wrapper resultWrapper647778)}] (clojure.core/cond-> {} (letvar647779 "route") (clojure.core/assoc :route (deser-transit-gateway-route (clojure.core/get-in letvar647779 ["route" :content])))))))

(clojure.core/defn- response-purchase-reserved-instances-offering-result ([input] (response-purchase-reserved-instances-offering-result nil input)) ([resultWrapper647781 input] (clojure.core/let [rawinput647780 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647782 {"reservedInstancesId" (portkey.aws/search-for-tag rawinput647780 "reservedInstancesId" :flattened? nil :result-wrapper resultWrapper647781)}] (clojure.core/cond-> {} (letvar647782 "reservedInstancesId") (clojure.core/assoc :reserved-instances-id (deser-string (clojure.core/get-in letvar647782 ["reservedInstancesId" :content])))))))

(clojure.core/defn- response-disassociate-vpc-cidr-block-result ([input] (response-disassociate-vpc-cidr-block-result nil input)) ([resultWrapper647784 input] (clojure.core/let [rawinput647783 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647785 {"ipv6CidrBlockAssociation" (portkey.aws/search-for-tag rawinput647783 "ipv6CidrBlockAssociation" :flattened? nil :result-wrapper resultWrapper647784), "cidrBlockAssociation" (portkey.aws/search-for-tag rawinput647783 "cidrBlockAssociation" :flattened? nil :result-wrapper resultWrapper647784), "vpcId" (portkey.aws/search-for-tag rawinput647783 "vpcId" :flattened? nil :result-wrapper resultWrapper647784)}] (clojure.core/cond-> {} (letvar647785 "ipv6CidrBlockAssociation") (clojure.core/assoc :ipv-6-cidr-block-association (deser-vpc-ipv-6-cidr-block-association (clojure.core/get-in letvar647785 ["ipv6CidrBlockAssociation" :content]))) (letvar647785 "cidrBlockAssociation") (clojure.core/assoc :cidr-block-association (deser-vpc-cidr-block-association (clojure.core/get-in letvar647785 ["cidrBlockAssociation" :content]))) (letvar647785 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar647785 ["vpcId" :content])))))))

(clojure.core/defn- response-request-spot-instances-result ([input] (response-request-spot-instances-result nil input)) ([resultWrapper647787 input] (clojure.core/let [rawinput647786 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647788 {"spotInstanceRequestSet" (portkey.aws/search-for-tag rawinput647786 "spotInstanceRequestSet" :flattened? nil :result-wrapper resultWrapper647787)}] (clojure.core/cond-> {} (letvar647788 "spotInstanceRequestSet") (clojure.core/assoc :spot-instance-requests (deser-spot-instance-request-list (clojure.core/get-in letvar647788 ["spotInstanceRequestSet" :content])))))))

(clojure.core/defn- response-describe-vpc-endpoint-services-result ([input] (response-describe-vpc-endpoint-services-result nil input)) ([resultWrapper647790 input] (clojure.core/let [rawinput647789 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647791 {"serviceNameSet" (portkey.aws/search-for-tag rawinput647789 "serviceNameSet" :flattened? nil :result-wrapper resultWrapper647790), "serviceDetailSet" (portkey.aws/search-for-tag rawinput647789 "serviceDetailSet" :flattened? nil :result-wrapper resultWrapper647790), "nextToken" (portkey.aws/search-for-tag rawinput647789 "nextToken" :flattened? nil :result-wrapper resultWrapper647790)}] (clojure.core/cond-> {} (letvar647791 "serviceNameSet") (clojure.core/assoc :service-names (deser-value-string-list (clojure.core/get-in letvar647791 ["serviceNameSet" :content]))) (letvar647791 "serviceDetailSet") (clojure.core/assoc :service-details (deser-service-detail-set (clojure.core/get-in letvar647791 ["serviceDetailSet" :content]))) (letvar647791 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647791 ["nextToken" :content])))))))

(clojure.core/defn- response-modify-instance-placement-result ([input] (response-modify-instance-placement-result nil input)) ([resultWrapper647793 input] (clojure.core/let [rawinput647792 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647794 {"return" (portkey.aws/search-for-tag rawinput647792 "return" :flattened? nil :result-wrapper resultWrapper647793)}] (clojure.core/cond-> {} (letvar647794 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647794 ["return" :content])))))))

(clojure.core/defn- response-get-transit-gateway-route-table-associations-result ([input] (response-get-transit-gateway-route-table-associations-result nil input)) ([resultWrapper647796 input] (clojure.core/let [rawinput647795 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647797 {"associations" (portkey.aws/search-for-tag rawinput647795 "associations" :flattened? nil :result-wrapper resultWrapper647796), "nextToken" (portkey.aws/search-for-tag rawinput647795 "nextToken" :flattened? nil :result-wrapper resultWrapper647796)}] (clojure.core/cond-> {} (letvar647797 "associations") (clojure.core/assoc :associations (deser-transit-gateway-route-table-association-list (clojure.core/get-in letvar647797 ["associations" :content]))) (letvar647797 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647797 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-vpc-attribute-result ([input] (response-describe-vpc-attribute-result nil input)) ([resultWrapper647799 input] (clojure.core/let [rawinput647798 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647800 {"vpcId" (portkey.aws/search-for-tag rawinput647798 "vpcId" :flattened? nil :result-wrapper resultWrapper647799), "enableDnsHostnames" (portkey.aws/search-for-tag rawinput647798 "enableDnsHostnames" :flattened? nil :result-wrapper resultWrapper647799), "enableDnsSupport" (portkey.aws/search-for-tag rawinput647798 "enableDnsSupport" :flattened? nil :result-wrapper resultWrapper647799)}] (clojure.core/cond-> {} (letvar647800 "vpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar647800 ["vpcId" :content]))) (letvar647800 "enableDnsHostnames") (clojure.core/assoc :enable-dns-hostnames (deser-attribute-boolean-value (clojure.core/get-in letvar647800 ["enableDnsHostnames" :content]))) (letvar647800 "enableDnsSupport") (clojure.core/assoc :enable-dns-support (deser-attribute-boolean-value (clojure.core/get-in letvar647800 ["enableDnsSupport" :content])))))))

(clojure.core/defn- response-describe-flow-logs-result ([input] (response-describe-flow-logs-result nil input)) ([resultWrapper647802 input] (clojure.core/let [rawinput647801 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647803 {"flowLogSet" (portkey.aws/search-for-tag rawinput647801 "flowLogSet" :flattened? nil :result-wrapper resultWrapper647802), "nextToken" (portkey.aws/search-for-tag rawinput647801 "nextToken" :flattened? nil :result-wrapper resultWrapper647802)}] (clojure.core/cond-> {} (letvar647803 "flowLogSet") (clojure.core/assoc :flow-logs (deser-flow-log-set (clojure.core/get-in letvar647803 ["flowLogSet" :content]))) (letvar647803 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647803 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-scheduled-instance-availability-result ([input] (response-describe-scheduled-instance-availability-result nil input)) ([resultWrapper647805 input] (clojure.core/let [rawinput647804 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647806 {"nextToken" (portkey.aws/search-for-tag rawinput647804 "nextToken" :flattened? nil :result-wrapper resultWrapper647805), "scheduledInstanceAvailabilitySet" (portkey.aws/search-for-tag rawinput647804 "scheduledInstanceAvailabilitySet" :flattened? nil :result-wrapper resultWrapper647805)}] (clojure.core/cond-> {} (letvar647806 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647806 ["nextToken" :content]))) (letvar647806 "scheduledInstanceAvailabilitySet") (clojure.core/assoc :scheduled-instance-availability-set (deser-scheduled-instance-availability-set (clojure.core/get-in letvar647806 ["scheduledInstanceAvailabilitySet" :content])))))))

(clojure.core/defn- response-create-vpc-result ([input] (response-create-vpc-result nil input)) ([resultWrapper647808 input] (clojure.core/let [rawinput647807 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647809 {"vpc" (portkey.aws/search-for-tag rawinput647807 "vpc" :flattened? nil :result-wrapper resultWrapper647808)}] (clojure.core/cond-> {} (letvar647809 "vpc") (clojure.core/assoc :vpc (deser-vpc (clojure.core/get-in letvar647809 ["vpc" :content])))))))

(clojure.core/defn- response-allocate-address-result ([input] (response-allocate-address-result nil input)) ([resultWrapper647811 input] (clojure.core/let [rawinput647810 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647812 {"publicIp" (portkey.aws/search-for-tag rawinput647810 "publicIp" :flattened? nil :result-wrapper resultWrapper647811), "allocationId" (portkey.aws/search-for-tag rawinput647810 "allocationId" :flattened? nil :result-wrapper resultWrapper647811), "publicIpv4Pool" (portkey.aws/search-for-tag rawinput647810 "publicIpv4Pool" :flattened? nil :result-wrapper resultWrapper647811), "domain" (portkey.aws/search-for-tag rawinput647810 "domain" :flattened? nil :result-wrapper resultWrapper647811)}] (clojure.core/cond-> {} (letvar647812 "publicIp") (clojure.core/assoc :public-ip (deser-string (clojure.core/get-in letvar647812 ["publicIp" :content]))) (letvar647812 "allocationId") (clojure.core/assoc :allocation-id (deser-string (clojure.core/get-in letvar647812 ["allocationId" :content]))) (letvar647812 "publicIpv4Pool") (clojure.core/assoc :public-ipv-4-pool (deser-string (clojure.core/get-in letvar647812 ["publicIpv4Pool" :content]))) (letvar647812 "domain") (clojure.core/assoc :domain (deser-domain-type (clojure.core/get-in letvar647812 ["domain" :content])))))))

(clojure.core/defn- response-delete-egress-only-internet-gateway-result ([input] (response-delete-egress-only-internet-gateway-result nil input)) ([resultWrapper647814 input] (clojure.core/let [rawinput647813 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647815 {"returnCode" (portkey.aws/search-for-tag rawinput647813 "returnCode" :flattened? nil :result-wrapper resultWrapper647814)}] (clojure.core/cond-> {} (letvar647815 "returnCode") (clojure.core/assoc :return-code (deser-boolean (clojure.core/get-in letvar647815 ["returnCode" :content])))))))

(clojure.core/defn- response-move-address-to-vpc-result ([input] (response-move-address-to-vpc-result nil input)) ([resultWrapper647817 input] (clojure.core/let [rawinput647816 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647818 {"allocationId" (portkey.aws/search-for-tag rawinput647816 "allocationId" :flattened? nil :result-wrapper resultWrapper647817), "status" (portkey.aws/search-for-tag rawinput647816 "status" :flattened? nil :result-wrapper resultWrapper647817)}] (clojure.core/cond-> {} (letvar647818 "allocationId") (clojure.core/assoc :allocation-id (deser-string (clojure.core/get-in letvar647818 ["allocationId" :content]))) (letvar647818 "status") (clojure.core/assoc :status (deser-status (clojure.core/get-in letvar647818 ["status" :content])))))))

(clojure.core/defn- response-describe-bundle-tasks-result ([input] (response-describe-bundle-tasks-result nil input)) ([resultWrapper647820 input] (clojure.core/let [rawinput647819 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647821 {"bundleInstanceTasksSet" (portkey.aws/search-for-tag rawinput647819 "bundleInstanceTasksSet" :flattened? nil :result-wrapper resultWrapper647820)}] (clojure.core/cond-> {} (letvar647821 "bundleInstanceTasksSet") (clojure.core/assoc :bundle-tasks (deser-bundle-task-list (clojure.core/get-in letvar647821 ["bundleInstanceTasksSet" :content])))))))

(clojure.core/defn- response-describe-snapshots-result ([input] (response-describe-snapshots-result nil input)) ([resultWrapper647823 input] (clojure.core/let [rawinput647822 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647824 {"snapshotSet" (portkey.aws/search-for-tag rawinput647822 "snapshotSet" :flattened? nil :result-wrapper resultWrapper647823), "nextToken" (portkey.aws/search-for-tag rawinput647822 "nextToken" :flattened? nil :result-wrapper resultWrapper647823)}] (clojure.core/cond-> {} (letvar647824 "snapshotSet") (clojure.core/assoc :snapshots (deser-snapshot-list (clojure.core/get-in letvar647824 ["snapshotSet" :content]))) (letvar647824 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647824 ["nextToken" :content])))))))

(clojure.core/defn- response-disassociate-transit-gateway-route-table-result ([input] (response-disassociate-transit-gateway-route-table-result nil input)) ([resultWrapper647826 input] (clojure.core/let [rawinput647825 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647827 {"association" (portkey.aws/search-for-tag rawinput647825 "association" :flattened? nil :result-wrapper resultWrapper647826)}] (clojure.core/cond-> {} (letvar647827 "association") (clojure.core/assoc :association (deser-transit-gateway-association (clojure.core/get-in letvar647827 ["association" :content])))))))

(clojure.core/defn- response-describe-transit-gateways-result ([input] (response-describe-transit-gateways-result nil input)) ([resultWrapper647829 input] (clojure.core/let [rawinput647828 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647830 {"transitGatewaySet" (portkey.aws/search-for-tag rawinput647828 "transitGatewaySet" :flattened? nil :result-wrapper resultWrapper647829), "nextToken" (portkey.aws/search-for-tag rawinput647828 "nextToken" :flattened? nil :result-wrapper resultWrapper647829)}] (clojure.core/cond-> {} (letvar647830 "transitGatewaySet") (clojure.core/assoc :transit-gateways (deser-transit-gateway-list (clojure.core/get-in letvar647830 ["transitGatewaySet" :content]))) (letvar647830 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647830 ["nextToken" :content])))))))

(clojure.core/defn- response-delete-network-interface-permission-result ([input] (response-delete-network-interface-permission-result nil input)) ([resultWrapper647832 input] (clojure.core/let [rawinput647831 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647833 {"return" (portkey.aws/search-for-tag rawinput647831 "return" :flattened? nil :result-wrapper resultWrapper647832)}] (clojure.core/cond-> {} (letvar647833 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647833 ["return" :content])))))))

(clojure.core/defn- response-create-fpga-image-result ([input] (response-create-fpga-image-result nil input)) ([resultWrapper647835 input] (clojure.core/let [rawinput647834 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647836 {"fpgaImageId" (portkey.aws/search-for-tag rawinput647834 "fpgaImageId" :flattened? nil :result-wrapper resultWrapper647835), "fpgaImageGlobalId" (portkey.aws/search-for-tag rawinput647834 "fpgaImageGlobalId" :flattened? nil :result-wrapper resultWrapper647835)}] (clojure.core/cond-> {} (letvar647836 "fpgaImageId") (clojure.core/assoc :fpga-image-id (deser-string (clojure.core/get-in letvar647836 ["fpgaImageId" :content]))) (letvar647836 "fpgaImageGlobalId") (clojure.core/assoc :fpga-image-global-id (deser-string (clojure.core/get-in letvar647836 ["fpgaImageGlobalId" :content])))))))

(clojure.core/defn- response-snapshot ([input] (response-snapshot nil input)) ([resultWrapper647838 input] (clojure.core/let [rawinput647837 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647839 {"progress" (portkey.aws/search-for-tag rawinput647837 "progress" :flattened? nil :result-wrapper resultWrapper647838), "tagSet" (portkey.aws/search-for-tag rawinput647837 "tagSet" :flattened? nil :result-wrapper resultWrapper647838), "kmsKeyId" (portkey.aws/search-for-tag rawinput647837 "kmsKeyId" :flattened? nil :result-wrapper resultWrapper647838), "encrypted" (portkey.aws/search-for-tag rawinput647837 "encrypted" :flattened? nil :result-wrapper resultWrapper647838), "startTime" (portkey.aws/search-for-tag rawinput647837 "startTime" :flattened? nil :result-wrapper resultWrapper647838), "status" (portkey.aws/search-for-tag rawinput647837 "status" :flattened? nil :result-wrapper resultWrapper647838), "dataEncryptionKeyId" (portkey.aws/search-for-tag rawinput647837 "dataEncryptionKeyId" :flattened? nil :result-wrapper resultWrapper647838), "statusMessage" (portkey.aws/search-for-tag rawinput647837 "statusMessage" :flattened? nil :result-wrapper resultWrapper647838), "volumeId" (portkey.aws/search-for-tag rawinput647837 "volumeId" :flattened? nil :result-wrapper resultWrapper647838), "snapshotId" (portkey.aws/search-for-tag rawinput647837 "snapshotId" :flattened? nil :result-wrapper resultWrapper647838), "ownerId" (portkey.aws/search-for-tag rawinput647837 "ownerId" :flattened? nil :result-wrapper resultWrapper647838), "volumeSize" (portkey.aws/search-for-tag rawinput647837 "volumeSize" :flattened? nil :result-wrapper resultWrapper647838), "ownerAlias" (portkey.aws/search-for-tag rawinput647837 "ownerAlias" :flattened? nil :result-wrapper resultWrapper647838), "description" (portkey.aws/search-for-tag rawinput647837 "description" :flattened? nil :result-wrapper resultWrapper647838)}] (clojure.core/cond-> {} (letvar647839 "startTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar647839 ["startTime" :content]))) (letvar647839 "statusMessage") (clojure.core/assoc :state-message (deser-string (clojure.core/get-in letvar647839 ["statusMessage" :content]))) (letvar647839 "ownerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar647839 ["ownerId" :content]))) (letvar647839 "encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar647839 ["encrypted" :content]))) (letvar647839 "tagSet") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar647839 ["tagSet" :content]))) (letvar647839 "ownerAlias") (clojure.core/assoc :owner-alias (deser-string (clojure.core/get-in letvar647839 ["ownerAlias" :content]))) (letvar647839 "progress") (clojure.core/assoc :progress (deser-string (clojure.core/get-in letvar647839 ["progress" :content]))) (letvar647839 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar647839 ["description" :content]))) (letvar647839 "dataEncryptionKeyId") (clojure.core/assoc :data-encryption-key-id (deser-string (clojure.core/get-in letvar647839 ["dataEncryptionKeyId" :content]))) (letvar647839 "kmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar647839 ["kmsKeyId" :content]))) (letvar647839 "volumeId") (clojure.core/assoc :volume-id (deser-string (clojure.core/get-in letvar647839 ["volumeId" :content]))) (letvar647839 "status") (clojure.core/assoc :state (deser-snapshot-state (clojure.core/get-in letvar647839 ["status" :content]))) (letvar647839 "volumeSize") (clojure.core/assoc :volume-size (deser-integer (clojure.core/get-in letvar647839 ["volumeSize" :content]))) (letvar647839 "snapshotId") (clojure.core/assoc :snapshot-id (deser-string (clojure.core/get-in letvar647839 ["snapshotId" :content])))))))

(clojure.core/defn- response-get-transit-gateway-route-table-propagations-result ([input] (response-get-transit-gateway-route-table-propagations-result nil input)) ([resultWrapper647841 input] (clojure.core/let [rawinput647840 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647842 {"transitGatewayRouteTablePropagations" (portkey.aws/search-for-tag rawinput647840 "transitGatewayRouteTablePropagations" :flattened? nil :result-wrapper resultWrapper647841), "nextToken" (portkey.aws/search-for-tag rawinput647840 "nextToken" :flattened? nil :result-wrapper resultWrapper647841)}] (clojure.core/cond-> {} (letvar647842 "transitGatewayRouteTablePropagations") (clojure.core/assoc :transit-gateway-route-table-propagations (deser-transit-gateway-route-table-propagation-list (clojure.core/get-in letvar647842 ["transitGatewayRouteTablePropagations" :content]))) (letvar647842 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647842 ["nextToken" :content])))))))

(clojure.core/defn- response-create-vpc-endpoint-service-configuration-result ([input] (response-create-vpc-endpoint-service-configuration-result nil input)) ([resultWrapper647844 input] (clojure.core/let [rawinput647843 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647845 {"serviceConfiguration" (portkey.aws/search-for-tag rawinput647843 "serviceConfiguration" :flattened? nil :result-wrapper resultWrapper647844), "clientToken" (portkey.aws/search-for-tag rawinput647843 "clientToken" :flattened? nil :result-wrapper resultWrapper647844)}] (clojure.core/cond-> {} (letvar647845 "serviceConfiguration") (clojure.core/assoc :service-configuration (deser-service-configuration (clojure.core/get-in letvar647845 ["serviceConfiguration" :content]))) (letvar647845 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar647845 ["clientToken" :content])))))))

(clojure.core/defn- response-describe-classic-link-instances-result ([input] (response-describe-classic-link-instances-result nil input)) ([resultWrapper647847 input] (clojure.core/let [rawinput647846 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647848 {"instancesSet" (portkey.aws/search-for-tag rawinput647846 "instancesSet" :flattened? nil :result-wrapper resultWrapper647847), "nextToken" (portkey.aws/search-for-tag rawinput647846 "nextToken" :flattened? nil :result-wrapper resultWrapper647847)}] (clojure.core/cond-> {} (letvar647848 "instancesSet") (clojure.core/assoc :instances (deser-classic-link-instance-list (clojure.core/get-in letvar647848 ["instancesSet" :content]))) (letvar647848 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647848 ["nextToken" :content])))))))

(clojure.core/defn- response-modify-vpc-tenancy-result ([input] (response-modify-vpc-tenancy-result nil input)) ([resultWrapper647850 input] (clojure.core/let [rawinput647849 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647851 {"return" (portkey.aws/search-for-tag rawinput647849 "return" :flattened? nil :result-wrapper resultWrapper647850)}] (clojure.core/cond-> {} (letvar647851 "return") (clojure.core/assoc :return-value (deser-boolean (clojure.core/get-in letvar647851 ["return" :content])))))))

(clojure.core/defn- response-describe-instances-result ([input] (response-describe-instances-result nil input)) ([resultWrapper647853 input] (clojure.core/let [rawinput647852 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647854 {"reservationSet" (portkey.aws/search-for-tag rawinput647852 "reservationSet" :flattened? nil :result-wrapper resultWrapper647853), "nextToken" (portkey.aws/search-for-tag rawinput647852 "nextToken" :flattened? nil :result-wrapper resultWrapper647853)}] (clojure.core/cond-> {} (letvar647854 "reservationSet") (clojure.core/assoc :reservations (deser-reservation-list (clojure.core/get-in letvar647854 ["reservationSet" :content]))) (letvar647854 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647854 ["nextToken" :content])))))))

(clojure.core/defn- response-unassign-ipv-6-addresses-result ([input] (response-unassign-ipv-6-addresses-result nil input)) ([resultWrapper647856 input] (clojure.core/let [rawinput647855 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647857 {"networkInterfaceId" (portkey.aws/search-for-tag rawinput647855 "networkInterfaceId" :flattened? nil :result-wrapper resultWrapper647856), "unassignedIpv6Addresses" (portkey.aws/search-for-tag rawinput647855 "unassignedIpv6Addresses" :flattened? nil :result-wrapper resultWrapper647856)}] (clojure.core/cond-> {} (letvar647857 "networkInterfaceId") (clojure.core/assoc :network-interface-id (deser-string (clojure.core/get-in letvar647857 ["networkInterfaceId" :content]))) (letvar647857 "unassignedIpv6Addresses") (clojure.core/assoc :unassigned-ipv-6-addresses (deser-ipv-6-address-list (clojure.core/get-in letvar647857 ["unassignedIpv6Addresses" :content])))))))

(clojure.core/defn- response-delete-flow-logs-result ([input] (response-delete-flow-logs-result nil input)) ([resultWrapper647859 input] (clojure.core/let [rawinput647858 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647860 {"unsuccessful" (portkey.aws/search-for-tag rawinput647858 "unsuccessful" :flattened? nil :result-wrapper resultWrapper647859)}] (clojure.core/cond-> {} (letvar647860 "unsuccessful") (clojure.core/assoc :unsuccessful (deser-unsuccessful-item-set (clojure.core/get-in letvar647860 ["unsuccessful" :content])))))))

(clojure.core/defn- response-request-spot-fleet-response ([input] (response-request-spot-fleet-response nil input)) ([resultWrapper647862 input] (clojure.core/let [rawinput647861 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647863 {"spotFleetRequestId" (portkey.aws/search-for-tag rawinput647861 "spotFleetRequestId" :flattened? nil :result-wrapper resultWrapper647862)}] (clojure.core/cond-> {} (letvar647863 "spotFleetRequestId") (clojure.core/assoc :spot-fleet-request-id (deser-string (clojure.core/get-in letvar647863 ["spotFleetRequestId" :content])))))))

(clojure.core/defn- response-describe-spot-fleet-requests-response ([input] (response-describe-spot-fleet-requests-response nil input)) ([resultWrapper647865 input] (clojure.core/let [rawinput647864 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647866 {"nextToken" (portkey.aws/search-for-tag rawinput647864 "nextToken" :flattened? nil :result-wrapper resultWrapper647865), "spotFleetRequestConfigSet" (portkey.aws/search-for-tag rawinput647864 "spotFleetRequestConfigSet" :flattened? nil :result-wrapper resultWrapper647865)}] (clojure.core/cond-> {} (letvar647866 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647866 ["nextToken" :content]))) (letvar647866 "spotFleetRequestConfigSet") (clojure.core/assoc :spot-fleet-request-configs (deser-spot-fleet-request-config-set (clojure.core/get-in letvar647866 ["spotFleetRequestConfigSet" :content])))))))

(clojure.core/defn- response-describe-vpn-connections-result ([input] (response-describe-vpn-connections-result nil input)) ([resultWrapper647868 input] (clojure.core/let [rawinput647867 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647869 {"vpnConnectionSet" (portkey.aws/search-for-tag rawinput647867 "vpnConnectionSet" :flattened? nil :result-wrapper resultWrapper647868)}] (clojure.core/cond-> {} (letvar647869 "vpnConnectionSet") (clojure.core/assoc :vpn-connections (deser-vpn-connection-list (clojure.core/get-in letvar647869 ["vpnConnectionSet" :content])))))))

(clojure.core/defn- response-copy-image-result ([input] (response-copy-image-result nil input)) ([resultWrapper647871 input] (clojure.core/let [rawinput647870 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647872 {"imageId" (portkey.aws/search-for-tag rawinput647870 "imageId" :flattened? nil :result-wrapper resultWrapper647871)}] (clojure.core/cond-> {} (letvar647872 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar647872 ["imageId" :content])))))))

(clojure.core/defn- response-export-client-vpn-client-certificate-revocation-list-result ([input] (response-export-client-vpn-client-certificate-revocation-list-result nil input)) ([resultWrapper647874 input] (clojure.core/let [rawinput647873 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647875 {"certificateRevocationList" (portkey.aws/search-for-tag rawinput647873 "certificateRevocationList" :flattened? nil :result-wrapper resultWrapper647874), "status" (portkey.aws/search-for-tag rawinput647873 "status" :flattened? nil :result-wrapper resultWrapper647874)}] (clojure.core/cond-> {} (letvar647875 "certificateRevocationList") (clojure.core/assoc :certificate-revocation-list (deser-string (clojure.core/get-in letvar647875 ["certificateRevocationList" :content]))) (letvar647875 "status") (clojure.core/assoc :status (deser-client-certificate-revocation-list-status (clojure.core/get-in letvar647875 ["status" :content])))))))

(clojure.core/defn- response-accept-vpc-peering-connection-result ([input] (response-accept-vpc-peering-connection-result nil input)) ([resultWrapper647877 input] (clojure.core/let [rawinput647876 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647878 {"vpcPeeringConnection" (portkey.aws/search-for-tag rawinput647876 "vpcPeeringConnection" :flattened? nil :result-wrapper resultWrapper647877)}] (clojure.core/cond-> {} (letvar647878 "vpcPeeringConnection") (clojure.core/assoc :vpc-peering-connection (deser-vpc-peering-connection (clojure.core/get-in letvar647878 ["vpcPeeringConnection" :content])))))))

(clojure.core/defn- response-terminate-instances-result ([input] (response-terminate-instances-result nil input)) ([resultWrapper647880 input] (clojure.core/let [rawinput647879 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647881 {"instancesSet" (portkey.aws/search-for-tag rawinput647879 "instancesSet" :flattened? nil :result-wrapper resultWrapper647880)}] (clojure.core/cond-> {} (letvar647881 "instancesSet") (clojure.core/assoc :terminating-instances (deser-instance-state-change-list (clojure.core/get-in letvar647881 ["instancesSet" :content])))))))

(clojure.core/defn- response-describe-vpcs-result ([input] (response-describe-vpcs-result nil input)) ([resultWrapper647883 input] (clojure.core/let [rawinput647882 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647884 {"vpcSet" (portkey.aws/search-for-tag rawinput647882 "vpcSet" :flattened? nil :result-wrapper resultWrapper647883), "nextToken" (portkey.aws/search-for-tag rawinput647882 "nextToken" :flattened? nil :result-wrapper resultWrapper647883)}] (clojure.core/cond-> {} (letvar647884 "vpcSet") (clojure.core/assoc :vpcs (deser-vpc-list (clojure.core/get-in letvar647884 ["vpcSet" :content]))) (letvar647884 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647884 ["nextToken" :content])))))))

(clojure.core/defn- response-delete-vpc-endpoints-result ([input] (response-delete-vpc-endpoints-result nil input)) ([resultWrapper647886 input] (clojure.core/let [rawinput647885 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647887 {"unsuccessful" (portkey.aws/search-for-tag rawinput647885 "unsuccessful" :flattened? nil :result-wrapper resultWrapper647886)}] (clojure.core/cond-> {} (letvar647887 "unsuccessful") (clojure.core/assoc :unsuccessful (deser-unsuccessful-item-set (clojure.core/get-in letvar647887 ["unsuccessful" :content])))))))

(clojure.core/defn- response-describe-spot-fleet-instances-response ([input] (response-describe-spot-fleet-instances-response nil input)) ([resultWrapper647889 input] (clojure.core/let [rawinput647888 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647890 {"activeInstanceSet" (portkey.aws/search-for-tag rawinput647888 "activeInstanceSet" :flattened? nil :result-wrapper resultWrapper647889), "nextToken" (portkey.aws/search-for-tag rawinput647888 "nextToken" :flattened? nil :result-wrapper resultWrapper647889), "spotFleetRequestId" (portkey.aws/search-for-tag rawinput647888 "spotFleetRequestId" :flattened? nil :result-wrapper resultWrapper647889)}] (clojure.core/cond-> {} (letvar647890 "activeInstanceSet") (clojure.core/assoc :active-instances (deser-active-instance-set (clojure.core/get-in letvar647890 ["activeInstanceSet" :content]))) (letvar647890 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647890 ["nextToken" :content]))) (letvar647890 "spotFleetRequestId") (clojure.core/assoc :spot-fleet-request-id (deser-string (clojure.core/get-in letvar647890 ["spotFleetRequestId" :content])))))))

(clojure.core/defn- response-describe-spot-price-history-result ([input] (response-describe-spot-price-history-result nil input)) ([resultWrapper647892 input] (clojure.core/let [rawinput647891 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647893 {"nextToken" (portkey.aws/search-for-tag rawinput647891 "nextToken" :flattened? nil :result-wrapper resultWrapper647892), "spotPriceHistorySet" (portkey.aws/search-for-tag rawinput647891 "spotPriceHistorySet" :flattened? nil :result-wrapper resultWrapper647892)}] (clojure.core/cond-> {} (letvar647893 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647893 ["nextToken" :content]))) (letvar647893 "spotPriceHistorySet") (clojure.core/assoc :spot-price-history (deser-spot-price-history-list (clojure.core/get-in letvar647893 ["spotPriceHistorySet" :content])))))))

(clojure.core/defn- response-copy-snapshot-result ([input] (response-copy-snapshot-result nil input)) ([resultWrapper647895 input] (clojure.core/let [rawinput647894 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647896 {"snapshotId" (portkey.aws/search-for-tag rawinput647894 "snapshotId" :flattened? nil :result-wrapper resultWrapper647895)}] (clojure.core/cond-> {} (letvar647896 "snapshotId") (clojure.core/assoc :snapshot-id (deser-string (clojure.core/get-in letvar647896 ["snapshotId" :content])))))))

(clojure.core/defn- response-attach-classic-link-vpc-result ([input] (response-attach-classic-link-vpc-result nil input)) ([resultWrapper647898 input] (clojure.core/let [rawinput647897 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647899 {"return" (portkey.aws/search-for-tag rawinput647897 "return" :flattened? nil :result-wrapper resultWrapper647898)}] (clojure.core/cond-> {} (letvar647899 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647899 ["return" :content])))))))

(clojure.core/defn- response-advertise-byoip-cidr-result ([input] (response-advertise-byoip-cidr-result nil input)) ([resultWrapper647901 input] (clojure.core/let [rawinput647900 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647902 {"byoipCidr" (portkey.aws/search-for-tag rawinput647900 "byoipCidr" :flattened? nil :result-wrapper resultWrapper647901)}] (clojure.core/cond-> {} (letvar647902 "byoipCidr") (clojure.core/assoc :byoip-cidr (deser-byoip-cidr (clojure.core/get-in letvar647902 ["byoipCidr" :content])))))))

(clojure.core/defn- response-update-security-group-rule-descriptions-ingress-result ([input] (response-update-security-group-rule-descriptions-ingress-result nil input)) ([resultWrapper647904 input] (clojure.core/let [rawinput647903 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647905 {"return" (portkey.aws/search-for-tag rawinput647903 "return" :flattened? nil :result-wrapper resultWrapper647904)}] (clojure.core/cond-> {} (letvar647905 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647905 ["return" :content])))))))

(clojure.core/defn- response-cancel-spot-fleet-requests-response ([input] (response-cancel-spot-fleet-requests-response nil input)) ([resultWrapper647907 input] (clojure.core/let [rawinput647906 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647908 {"successfulFleetRequestSet" (portkey.aws/search-for-tag rawinput647906 "successfulFleetRequestSet" :flattened? nil :result-wrapper resultWrapper647907), "unsuccessfulFleetRequestSet" (portkey.aws/search-for-tag rawinput647906 "unsuccessfulFleetRequestSet" :flattened? nil :result-wrapper resultWrapper647907)}] (clojure.core/cond-> {} (letvar647908 "successfulFleetRequestSet") (clojure.core/assoc :successful-fleet-requests (deser-cancel-spot-fleet-requests-success-set (clojure.core/get-in letvar647908 ["successfulFleetRequestSet" :content]))) (letvar647908 "unsuccessfulFleetRequestSet") (clojure.core/assoc :unsuccessful-fleet-requests (deser-cancel-spot-fleet-requests-error-set (clojure.core/get-in letvar647908 ["unsuccessfulFleetRequestSet" :content])))))))

(clojure.core/defn- response-apply-security-groups-to-client-vpn-target-network-result ([input] (response-apply-security-groups-to-client-vpn-target-network-result nil input)) ([resultWrapper647910 input] (clojure.core/let [rawinput647909 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647911 {"securityGroupIds" (portkey.aws/search-for-tag rawinput647909 "securityGroupIds" :flattened? nil :result-wrapper resultWrapper647910)}] (clojure.core/cond-> {} (letvar647911 "securityGroupIds") (clojure.core/assoc :security-group-ids (deser-client-vpn-security-group-id-set (clojure.core/get-in letvar647911 ["securityGroupIds" :content])))))))

(clojure.core/defn- response-delete-fleets-result ([input] (response-delete-fleets-result nil input)) ([resultWrapper647913 input] (clojure.core/let [rawinput647912 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647914 {"successfulFleetDeletionSet" (portkey.aws/search-for-tag rawinput647912 "successfulFleetDeletionSet" :flattened? nil :result-wrapper resultWrapper647913), "unsuccessfulFleetDeletionSet" (portkey.aws/search-for-tag rawinput647912 "unsuccessfulFleetDeletionSet" :flattened? nil :result-wrapper resultWrapper647913)}] (clojure.core/cond-> {} (letvar647914 "successfulFleetDeletionSet") (clojure.core/assoc :successful-fleet-deletions (deser-delete-fleet-success-set (clojure.core/get-in letvar647914 ["successfulFleetDeletionSet" :content]))) (letvar647914 "unsuccessfulFleetDeletionSet") (clojure.core/assoc :unsuccessful-fleet-deletions (deser-delete-fleet-error-set (clojure.core/get-in letvar647914 ["unsuccessfulFleetDeletionSet" :content])))))))

(clojure.core/defn- response-create-fleet-result ([input] (response-create-fleet-result nil input)) ([resultWrapper647916 input] (clojure.core/let [rawinput647915 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647917 {"fleetId" (portkey.aws/search-for-tag rawinput647915 "fleetId" :flattened? nil :result-wrapper resultWrapper647916), "errorSet" (portkey.aws/search-for-tag rawinput647915 "errorSet" :flattened? nil :result-wrapper resultWrapper647916), "fleetInstanceSet" (portkey.aws/search-for-tag rawinput647915 "fleetInstanceSet" :flattened? nil :result-wrapper resultWrapper647916)}] (clojure.core/cond-> {} (letvar647917 "fleetId") (clojure.core/assoc :fleet-id (deser-fleet-identifier (clojure.core/get-in letvar647917 ["fleetId" :content]))) (letvar647917 "errorSet") (clojure.core/assoc :errors (deser-create-fleet-errors-set (clojure.core/get-in letvar647917 ["errorSet" :content]))) (letvar647917 "fleetInstanceSet") (clojure.core/assoc :instances (deser-create-fleet-instances-set (clojure.core/get-in letvar647917 ["fleetInstanceSet" :content])))))))

(clojure.core/defn- response-delete-nat-gateway-result ([input] (response-delete-nat-gateway-result nil input)) ([resultWrapper647919 input] (clojure.core/let [rawinput647918 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647920 {"natGatewayId" (portkey.aws/search-for-tag rawinput647918 "natGatewayId" :flattened? nil :result-wrapper resultWrapper647919)}] (clojure.core/cond-> {} (letvar647920 "natGatewayId") (clojure.core/assoc :nat-gateway-id (deser-string (clojure.core/get-in letvar647920 ["natGatewayId" :content])))))))

(clojure.core/defn- response-allocate-hosts-result ([input] (response-allocate-hosts-result nil input)) ([resultWrapper647922 input] (clojure.core/let [rawinput647921 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647923 {"hostIdSet" (portkey.aws/search-for-tag rawinput647921 "hostIdSet" :flattened? nil :result-wrapper resultWrapper647922)}] (clojure.core/cond-> {} (letvar647923 "hostIdSet") (clojure.core/assoc :host-ids (deser-response-host-id-list (clojure.core/get-in letvar647923 ["hostIdSet" :content])))))))

(clojure.core/defn- response-instance-attribute ([input] (response-instance-attribute nil input)) ([resultWrapper647925 input] (clojure.core/let [rawinput647924 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647926 {"kernel" (portkey.aws/search-for-tag rawinput647924 "kernel" :flattened? nil :result-wrapper resultWrapper647925), "groupSet" (portkey.aws/search-for-tag rawinput647924 "groupSet" :flattened? nil :result-wrapper resultWrapper647925), "productCodes" (portkey.aws/search-for-tag rawinput647924 "productCodes" :flattened? nil :result-wrapper resultWrapper647925), "blockDeviceMapping" (portkey.aws/search-for-tag rawinput647924 "blockDeviceMapping" :flattened? nil :result-wrapper resultWrapper647925), "disableApiTermination" (portkey.aws/search-for-tag rawinput647924 "disableApiTermination" :flattened? nil :result-wrapper resultWrapper647925), "sourceDestCheck" (portkey.aws/search-for-tag rawinput647924 "sourceDestCheck" :flattened? nil :result-wrapper resultWrapper647925), "userData" (portkey.aws/search-for-tag rawinput647924 "userData" :flattened? nil :result-wrapper resultWrapper647925), "ebsOptimized" (portkey.aws/search-for-tag rawinput647924 "ebsOptimized" :flattened? nil :result-wrapper resultWrapper647925), "ramdisk" (portkey.aws/search-for-tag rawinput647924 "ramdisk" :flattened? nil :result-wrapper resultWrapper647925), "instanceType" (portkey.aws/search-for-tag rawinput647924 "instanceType" :flattened? nil :result-wrapper resultWrapper647925), "enaSupport" (portkey.aws/search-for-tag rawinput647924 "enaSupport" :flattened? nil :result-wrapper resultWrapper647925), "rootDeviceName" (portkey.aws/search-for-tag rawinput647924 "rootDeviceName" :flattened? nil :result-wrapper resultWrapper647925), "instanceInitiatedShutdownBehavior" (portkey.aws/search-for-tag rawinput647924 "instanceInitiatedShutdownBehavior" :flattened? nil :result-wrapper resultWrapper647925), "instanceId" (portkey.aws/search-for-tag rawinput647924 "instanceId" :flattened? nil :result-wrapper resultWrapper647925), "sriovNetSupport" (portkey.aws/search-for-tag rawinput647924 "sriovNetSupport" :flattened? nil :result-wrapper resultWrapper647925)}] (clojure.core/cond-> {} (letvar647926 "kernel") (clojure.core/assoc :kernel-id (deser-attribute-value (clojure.core/get-in letvar647926 ["kernel" :content]))) (letvar647926 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar647926 ["instanceId" :content]))) (letvar647926 "ebsOptimized") (clojure.core/assoc :ebs-optimized (deser-attribute-boolean-value (clojure.core/get-in letvar647926 ["ebsOptimized" :content]))) (letvar647926 "instanceType") (clojure.core/assoc :instance-type (deser-attribute-value (clojure.core/get-in letvar647926 ["instanceType" :content]))) (letvar647926 "sriovNetSupport") (clojure.core/assoc :sriov-net-support (deser-attribute-value (clojure.core/get-in letvar647926 ["sriovNetSupport" :content]))) (letvar647926 "sourceDestCheck") (clojure.core/assoc :source-dest-check (deser-attribute-boolean-value (clojure.core/get-in letvar647926 ["sourceDestCheck" :content]))) (letvar647926 "disableApiTermination") (clojure.core/assoc :disable-api-termination (deser-attribute-boolean-value (clojure.core/get-in letvar647926 ["disableApiTermination" :content]))) (letvar647926 "groupSet") (clojure.core/assoc :groups (deser-group-identifier-list (clojure.core/get-in letvar647926 ["groupSet" :content]))) (letvar647926 "blockDeviceMapping") (clojure.core/assoc :block-device-mappings (deser-instance-block-device-mapping-list (clojure.core/get-in letvar647926 ["blockDeviceMapping" :content]))) (letvar647926 "productCodes") (clojure.core/assoc :product-codes (deser-product-code-list (clojure.core/get-in letvar647926 ["productCodes" :content]))) (letvar647926 "rootDeviceName") (clojure.core/assoc :root-device-name (deser-attribute-value (clojure.core/get-in letvar647926 ["rootDeviceName" :content]))) (letvar647926 "ramdisk") (clojure.core/assoc :ramdisk-id (deser-attribute-value (clojure.core/get-in letvar647926 ["ramdisk" :content]))) (letvar647926 "userData") (clojure.core/assoc :user-data (deser-attribute-value (clojure.core/get-in letvar647926 ["userData" :content]))) (letvar647926 "instanceInitiatedShutdownBehavior") (clojure.core/assoc :instance-initiated-shutdown-behavior (deser-attribute-value (clojure.core/get-in letvar647926 ["instanceInitiatedShutdownBehavior" :content]))) (letvar647926 "enaSupport") (clojure.core/assoc :ena-support (deser-attribute-boolean-value (clojure.core/get-in letvar647926 ["enaSupport" :content])))))))

(clojure.core/defn- response-delete-transit-gateway-vpc-attachment-result ([input] (response-delete-transit-gateway-vpc-attachment-result nil input)) ([resultWrapper647928 input] (clojure.core/let [rawinput647927 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647929 {"transitGatewayVpcAttachment" (portkey.aws/search-for-tag rawinput647927 "transitGatewayVpcAttachment" :flattened? nil :result-wrapper resultWrapper647928)}] (clojure.core/cond-> {} (letvar647929 "transitGatewayVpcAttachment") (clojure.core/assoc :transit-gateway-vpc-attachment (deser-transit-gateway-vpc-attachment (clojure.core/get-in letvar647929 ["transitGatewayVpcAttachment" :content])))))))

(clojure.core/defn- response-modify-vpc-endpoint-result ([input] (response-modify-vpc-endpoint-result nil input)) ([resultWrapper647931 input] (clojure.core/let [rawinput647930 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647932 {"return" (portkey.aws/search-for-tag rawinput647930 "return" :flattened? nil :result-wrapper resultWrapper647931)}] (clojure.core/cond-> {} (letvar647932 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647932 ["return" :content])))))))

(clojure.core/defn- response-describe-fpga-images-result ([input] (response-describe-fpga-images-result nil input)) ([resultWrapper647934 input] (clojure.core/let [rawinput647933 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647935 {"fpgaImageSet" (portkey.aws/search-for-tag rawinput647933 "fpgaImageSet" :flattened? nil :result-wrapper resultWrapper647934), "nextToken" (portkey.aws/search-for-tag rawinput647933 "nextToken" :flattened? nil :result-wrapper resultWrapper647934)}] (clojure.core/cond-> {} (letvar647935 "fpgaImageSet") (clojure.core/assoc :fpga-images (deser-fpga-image-list (clojure.core/get-in letvar647935 ["fpgaImageSet" :content]))) (letvar647935 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar647935 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-fleet-history-result ([input] (response-describe-fleet-history-result nil input)) ([resultWrapper647937 input] (clojure.core/let [rawinput647936 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647938 {"historyRecordSet" (portkey.aws/search-for-tag rawinput647936 "historyRecordSet" :flattened? nil :result-wrapper resultWrapper647937), "lastEvaluatedTime" (portkey.aws/search-for-tag rawinput647936 "lastEvaluatedTime" :flattened? nil :result-wrapper resultWrapper647937), "nextToken" (portkey.aws/search-for-tag rawinput647936 "nextToken" :flattened? nil :result-wrapper resultWrapper647937), "fleetId" (portkey.aws/search-for-tag rawinput647936 "fleetId" :flattened? nil :result-wrapper resultWrapper647937), "startTime" (portkey.aws/search-for-tag rawinput647936 "startTime" :flattened? nil :result-wrapper resultWrapper647937)}] (clojure.core/cond-> {} (letvar647938 "historyRecordSet") (clojure.core/assoc :history-records (deser-history-record-set (clojure.core/get-in letvar647938 ["historyRecordSet" :content]))) (letvar647938 "lastEvaluatedTime") (clojure.core/assoc :last-evaluated-time (deser-date-time (clojure.core/get-in letvar647938 ["lastEvaluatedTime" :content]))) (letvar647938 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647938 ["nextToken" :content]))) (letvar647938 "fleetId") (clojure.core/assoc :fleet-id (deser-fleet-identifier (clojure.core/get-in letvar647938 ["fleetId" :content]))) (letvar647938 "startTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar647938 ["startTime" :content])))))))

(clojure.core/defn- response-modify-fpga-image-attribute-result ([input] (response-modify-fpga-image-attribute-result nil input)) ([resultWrapper647940 input] (clojure.core/let [rawinput647939 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647941 {"fpgaImageAttribute" (portkey.aws/search-for-tag rawinput647939 "fpgaImageAttribute" :flattened? nil :result-wrapper resultWrapper647940)}] (clojure.core/cond-> {} (letvar647941 "fpgaImageAttribute") (clojure.core/assoc :fpga-image-attribute (deser-fpga-image-attribute (clojure.core/get-in letvar647941 ["fpgaImageAttribute" :content])))))))

(clojure.core/defn- response-describe-transit-gateway-route-tables-result ([input] (response-describe-transit-gateway-route-tables-result nil input)) ([resultWrapper647943 input] (clojure.core/let [rawinput647942 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647944 {"transitGatewayRouteTables" (portkey.aws/search-for-tag rawinput647942 "transitGatewayRouteTables" :flattened? nil :result-wrapper resultWrapper647943), "nextToken" (portkey.aws/search-for-tag rawinput647942 "nextToken" :flattened? nil :result-wrapper resultWrapper647943)}] (clojure.core/cond-> {} (letvar647944 "transitGatewayRouteTables") (clojure.core/assoc :transit-gateway-route-tables (deser-transit-gateway-route-table-list (clojure.core/get-in letvar647944 ["transitGatewayRouteTables" :content]))) (letvar647944 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647944 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-client-vpn-routes-result ([input] (response-describe-client-vpn-routes-result nil input)) ([resultWrapper647946 input] (clojure.core/let [rawinput647945 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647947 {"routes" (portkey.aws/search-for-tag rawinput647945 "routes" :flattened? nil :result-wrapper resultWrapper647946), "nextToken" (portkey.aws/search-for-tag rawinput647945 "nextToken" :flattened? nil :result-wrapper resultWrapper647946)}] (clojure.core/cond-> {} (letvar647947 "routes") (clojure.core/assoc :routes (deser-client-vpn-route-set (clojure.core/get-in letvar647947 ["routes" :content]))) (letvar647947 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar647947 ["nextToken" :content])))))))

(clojure.core/defn- response-disassociate-iam-instance-profile-result ([input] (response-disassociate-iam-instance-profile-result nil input)) ([resultWrapper647949 input] (clojure.core/let [rawinput647948 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647950 {"iamInstanceProfileAssociation" (portkey.aws/search-for-tag rawinput647948 "iamInstanceProfileAssociation" :flattened? nil :result-wrapper resultWrapper647949)}] (clojure.core/cond-> {} (letvar647950 "iamInstanceProfileAssociation") (clojure.core/assoc :iam-instance-profile-association (deser-iam-instance-profile-association (clojure.core/get-in letvar647950 ["iamInstanceProfileAssociation" :content])))))))

(clojure.core/defn- response-key-pair ([input] (response-key-pair nil input)) ([resultWrapper647952 input] (clojure.core/let [rawinput647951 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647953 {"keyFingerprint" (portkey.aws/search-for-tag rawinput647951 "keyFingerprint" :flattened? nil :result-wrapper resultWrapper647952), "keyMaterial" (portkey.aws/search-for-tag rawinput647951 "keyMaterial" :flattened? nil :result-wrapper resultWrapper647952), "keyName" (portkey.aws/search-for-tag rawinput647951 "keyName" :flattened? nil :result-wrapper resultWrapper647952)}] (clojure.core/cond-> {} (letvar647953 "keyFingerprint") (clojure.core/assoc :key-fingerprint (deser-string (clojure.core/get-in letvar647953 ["keyFingerprint" :content]))) (letvar647953 "keyMaterial") (clojure.core/assoc :key-material (deser-string (clojure.core/get-in letvar647953 ["keyMaterial" :content]))) (letvar647953 "keyName") (clojure.core/assoc :key-name (deser-string (clojure.core/get-in letvar647953 ["keyName" :content])))))))

(clojure.core/defn- response-delete-vpc-endpoint-connection-notifications-result ([input] (response-delete-vpc-endpoint-connection-notifications-result nil input)) ([resultWrapper647955 input] (clojure.core/let [rawinput647954 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647956 {"unsuccessful" (portkey.aws/search-for-tag rawinput647954 "unsuccessful" :flattened? nil :result-wrapper resultWrapper647955)}] (clojure.core/cond-> {} (letvar647956 "unsuccessful") (clojure.core/assoc :unsuccessful (deser-unsuccessful-item-set (clojure.core/get-in letvar647956 ["unsuccessful" :content])))))))

(clojure.core/defn- response-accept-vpc-endpoint-connections-result ([input] (response-accept-vpc-endpoint-connections-result nil input)) ([resultWrapper647958 input] (clojure.core/let [rawinput647957 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647959 {"unsuccessful" (portkey.aws/search-for-tag rawinput647957 "unsuccessful" :flattened? nil :result-wrapper resultWrapper647958)}] (clojure.core/cond-> {} (letvar647959 "unsuccessful") (clojure.core/assoc :unsuccessful (deser-unsuccessful-item-set (clojure.core/get-in letvar647959 ["unsuccessful" :content])))))))

(clojure.core/defn- response-describe-subnets-result ([input] (response-describe-subnets-result nil input)) ([resultWrapper647961 input] (clojure.core/let [rawinput647960 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647962 {"subnetSet" (portkey.aws/search-for-tag rawinput647960 "subnetSet" :flattened? nil :result-wrapper resultWrapper647961)}] (clojure.core/cond-> {} (letvar647962 "subnetSet") (clojure.core/assoc :subnets (deser-subnet-list (clojure.core/get-in letvar647962 ["subnetSet" :content])))))))

(clojure.core/defn- response-associate-address-result ([input] (response-associate-address-result nil input)) ([resultWrapper647964 input] (clojure.core/let [rawinput647963 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647965 {"associationId" (portkey.aws/search-for-tag rawinput647963 "associationId" :flattened? nil :result-wrapper resultWrapper647964)}] (clojure.core/cond-> {} (letvar647965 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar647965 ["associationId" :content])))))))

(clojure.core/defn- response-create-instance-export-task-result ([input] (response-create-instance-export-task-result nil input)) ([resultWrapper647967 input] (clojure.core/let [rawinput647966 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647968 {"exportTask" (portkey.aws/search-for-tag rawinput647966 "exportTask" :flattened? nil :result-wrapper resultWrapper647967)}] (clojure.core/cond-> {} (letvar647968 "exportTask") (clojure.core/assoc :export-task (deser-export-task (clojure.core/get-in letvar647968 ["exportTask" :content])))))))

(clojure.core/defn- response-modify-vpc-peering-connection-options-result ([input] (response-modify-vpc-peering-connection-options-result nil input)) ([resultWrapper647970 input] (clojure.core/let [rawinput647969 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647971 {"accepterPeeringConnectionOptions" (portkey.aws/search-for-tag rawinput647969 "accepterPeeringConnectionOptions" :flattened? nil :result-wrapper resultWrapper647970), "requesterPeeringConnectionOptions" (portkey.aws/search-for-tag rawinput647969 "requesterPeeringConnectionOptions" :flattened? nil :result-wrapper resultWrapper647970)}] (clojure.core/cond-> {} (letvar647971 "accepterPeeringConnectionOptions") (clojure.core/assoc :accepter-peering-connection-options (deser-peering-connection-options (clojure.core/get-in letvar647971 ["accepterPeeringConnectionOptions" :content]))) (letvar647971 "requesterPeeringConnectionOptions") (clojure.core/assoc :requester-peering-connection-options (deser-peering-connection-options (clojure.core/get-in letvar647971 ["requesterPeeringConnectionOptions" :content])))))))

(clojure.core/defn- response-associate-route-table-result ([input] (response-associate-route-table-result nil input)) ([resultWrapper647973 input] (clojure.core/let [rawinput647972 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647974 {"associationId" (portkey.aws/search-for-tag rawinput647972 "associationId" :flattened? nil :result-wrapper resultWrapper647973)}] (clojure.core/cond-> {} (letvar647974 "associationId") (clojure.core/assoc :association-id (deser-string (clojure.core/get-in letvar647974 ["associationId" :content])))))))

(clojure.core/defn- response-modify-capacity-reservation-result ([input] (response-modify-capacity-reservation-result nil input)) ([resultWrapper647976 input] (clojure.core/let [rawinput647975 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647977 {"return" (portkey.aws/search-for-tag rawinput647975 "return" :flattened? nil :result-wrapper resultWrapper647976)}] (clojure.core/cond-> {} (letvar647977 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647977 ["return" :content])))))))

(clojure.core/defn- response-describe-byoip-cidrs-result ([input] (response-describe-byoip-cidrs-result nil input)) ([resultWrapper647979 input] (clojure.core/let [rawinput647978 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647980 {"byoipCidrSet" (portkey.aws/search-for-tag rawinput647978 "byoipCidrSet" :flattened? nil :result-wrapper resultWrapper647979), "nextToken" (portkey.aws/search-for-tag rawinput647978 "nextToken" :flattened? nil :result-wrapper resultWrapper647979)}] (clojure.core/cond-> {} (letvar647980 "byoipCidrSet") (clojure.core/assoc :byoip-cidrs (deser-byoip-cidr-set (clojure.core/get-in letvar647980 ["byoipCidrSet" :content]))) (letvar647980 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar647980 ["nextToken" :content])))))))

(clojure.core/defn- response-modify-fleet-result ([input] (response-modify-fleet-result nil input)) ([resultWrapper647982 input] (clojure.core/let [rawinput647981 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647983 {"return" (portkey.aws/search-for-tag rawinput647981 "return" :flattened? nil :result-wrapper resultWrapper647982)}] (clojure.core/cond-> {} (letvar647983 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647983 ["return" :content])))))))

(clojure.core/defn- response-associate-transit-gateway-route-table-result ([input] (response-associate-transit-gateway-route-table-result nil input)) ([resultWrapper647985 input] (clojure.core/let [rawinput647984 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647986 {"association" (portkey.aws/search-for-tag rawinput647984 "association" :flattened? nil :result-wrapper resultWrapper647985)}] (clojure.core/cond-> {} (letvar647986 "association") (clojure.core/assoc :association (deser-transit-gateway-association (clojure.core/get-in letvar647986 ["association" :content])))))))

(clojure.core/defn- response-modify-vpc-endpoint-service-permissions-result ([input] (response-modify-vpc-endpoint-service-permissions-result nil input)) ([resultWrapper647988 input] (clojure.core/let [rawinput647987 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647989 {"return" (portkey.aws/search-for-tag rawinput647987 "return" :flattened? nil :result-wrapper resultWrapper647988)}] (clojure.core/cond-> {} (letvar647989 "return") (clojure.core/assoc :return-value (deser-boolean (clojure.core/get-in letvar647989 ["return" :content])))))))

(clojure.core/defn- response-modify-vpc-endpoint-service-configuration-result ([input] (response-modify-vpc-endpoint-service-configuration-result nil input)) ([resultWrapper647991 input] (clojure.core/let [rawinput647990 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647992 {"return" (portkey.aws/search-for-tag rawinput647990 "return" :flattened? nil :result-wrapper resultWrapper647991)}] (clojure.core/cond-> {} (letvar647992 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar647992 ["return" :content])))))))

(clojure.core/defn- response-create-security-group-result ([input] (response-create-security-group-result nil input)) ([resultWrapper647994 input] (clojure.core/let [rawinput647993 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647995 {"groupId" (portkey.aws/search-for-tag rawinput647993 "groupId" :flattened? nil :result-wrapper resultWrapper647994)}] (clojure.core/cond-> {} (letvar647995 "groupId") (clojure.core/assoc :group-id (deser-string (clojure.core/get-in letvar647995 ["groupId" :content])))))))

(clojure.core/defn- response-get-password-data-result ([input] (response-get-password-data-result nil input)) ([resultWrapper647997 input] (clojure.core/let [rawinput647996 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar647998 {"instanceId" (portkey.aws/search-for-tag rawinput647996 "instanceId" :flattened? nil :result-wrapper resultWrapper647997), "passwordData" (portkey.aws/search-for-tag rawinput647996 "passwordData" :flattened? nil :result-wrapper resultWrapper647997), "timestamp" (portkey.aws/search-for-tag rawinput647996 "timestamp" :flattened? nil :result-wrapper resultWrapper647997)}] (clojure.core/cond-> {} (letvar647998 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar647998 ["instanceId" :content]))) (letvar647998 "passwordData") (clojure.core/assoc :password-data (deser-string (clojure.core/get-in letvar647998 ["passwordData" :content]))) (letvar647998 "timestamp") (clojure.core/assoc :timestamp (deser-date-time (clojure.core/get-in letvar647998 ["timestamp" :content])))))))

(clojure.core/defn- response-import-volume-result ([input] (response-import-volume-result nil input)) ([resultWrapper648000 input] (clojure.core/let [rawinput647999 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648001 {"conversionTask" (portkey.aws/search-for-tag rawinput647999 "conversionTask" :flattened? nil :result-wrapper resultWrapper648000)}] (clojure.core/cond-> {} (letvar648001 "conversionTask") (clojure.core/assoc :conversion-task (deser-conversion-task (clojure.core/get-in letvar648001 ["conversionTask" :content])))))))

(clojure.core/defn- response-describe-reserved-instances-result ([input] (response-describe-reserved-instances-result nil input)) ([resultWrapper648003 input] (clojure.core/let [rawinput648002 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648004 {"reservedInstancesSet" (portkey.aws/search-for-tag rawinput648002 "reservedInstancesSet" :flattened? nil :result-wrapper resultWrapper648003)}] (clojure.core/cond-> {} (letvar648004 "reservedInstancesSet") (clojure.core/assoc :reserved-instances (deser-reserved-instances-list (clojure.core/get-in letvar648004 ["reservedInstancesSet" :content])))))))

(clojure.core/defn- response-describe-nat-gateways-result ([input] (response-describe-nat-gateways-result nil input)) ([resultWrapper648006 input] (clojure.core/let [rawinput648005 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648007 {"natGatewaySet" (portkey.aws/search-for-tag rawinput648005 "natGatewaySet" :flattened? nil :result-wrapper resultWrapper648006), "nextToken" (portkey.aws/search-for-tag rawinput648005 "nextToken" :flattened? nil :result-wrapper resultWrapper648006)}] (clojure.core/cond-> {} (letvar648007 "natGatewaySet") (clojure.core/assoc :nat-gateways (deser-nat-gateway-list (clojure.core/get-in letvar648007 ["natGatewaySet" :content]))) (letvar648007 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar648007 ["nextToken" :content])))))))

(clojure.core/defn- response-accept-reserved-instances-exchange-quote-result ([input] (response-accept-reserved-instances-exchange-quote-result nil input)) ([resultWrapper648009 input] (clojure.core/let [rawinput648008 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648010 {"exchangeId" (portkey.aws/search-for-tag rawinput648008 "exchangeId" :flattened? nil :result-wrapper resultWrapper648009)}] (clojure.core/cond-> {} (letvar648010 "exchangeId") (clojure.core/assoc :exchange-id (deser-string (clojure.core/get-in letvar648010 ["exchangeId" :content])))))))

(clojure.core/defn- response-export-client-vpn-client-configuration-result ([input] (response-export-client-vpn-client-configuration-result nil input)) ([resultWrapper648012 input] (clojure.core/let [rawinput648011 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648013 {"clientConfiguration" (portkey.aws/search-for-tag rawinput648011 "clientConfiguration" :flattened? nil :result-wrapper resultWrapper648012)}] (clojure.core/cond-> {} (letvar648013 "clientConfiguration") (clojure.core/assoc :client-configuration (deser-string (clojure.core/get-in letvar648013 ["clientConfiguration" :content])))))))

(clojure.core/defn- response-describe-host-reservation-offerings-result ([input] (response-describe-host-reservation-offerings-result nil input)) ([resultWrapper648015 input] (clojure.core/let [rawinput648014 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648016 {"nextToken" (portkey.aws/search-for-tag rawinput648014 "nextToken" :flattened? nil :result-wrapper resultWrapper648015), "offeringSet" (portkey.aws/search-for-tag rawinput648014 "offeringSet" :flattened? nil :result-wrapper resultWrapper648015)}] (clojure.core/cond-> {} (letvar648016 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar648016 ["nextToken" :content]))) (letvar648016 "offeringSet") (clojure.core/assoc :offering-set (deser-host-offering-set (clojure.core/get-in letvar648016 ["offeringSet" :content])))))))

(clojure.core/defn- response-replace-route-table-association-result ([input] (response-replace-route-table-association-result nil input)) ([resultWrapper648018 input] (clojure.core/let [rawinput648017 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648019 {"newAssociationId" (portkey.aws/search-for-tag rawinput648017 "newAssociationId" :flattened? nil :result-wrapper resultWrapper648018)}] (clojure.core/cond-> {} (letvar648019 "newAssociationId") (clojure.core/assoc :new-association-id (deser-string (clojure.core/get-in letvar648019 ["newAssociationId" :content])))))))

(clojure.core/defn- response-modify-launch-template-result ([input] (response-modify-launch-template-result nil input)) ([resultWrapper648021 input] (clojure.core/let [rawinput648020 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648022 {"launchTemplate" (portkey.aws/search-for-tag rawinput648020 "launchTemplate" :flattened? nil :result-wrapper resultWrapper648021)}] (clojure.core/cond-> {} (letvar648022 "launchTemplate") (clojure.core/assoc :launch-template (deser-launch-template (clojure.core/get-in letvar648022 ["launchTemplate" :content])))))))

(clojure.core/defn- response-cancel-spot-instance-requests-result ([input] (response-cancel-spot-instance-requests-result nil input)) ([resultWrapper648024 input] (clojure.core/let [rawinput648023 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648025 {"spotInstanceRequestSet" (portkey.aws/search-for-tag rawinput648023 "spotInstanceRequestSet" :flattened? nil :result-wrapper resultWrapper648024)}] (clojure.core/cond-> {} (letvar648025 "spotInstanceRequestSet") (clojure.core/assoc :cancelled-spot-instance-requests (deser-cancelled-spot-instance-request-list (clojure.core/get-in letvar648025 ["spotInstanceRequestSet" :content])))))))

(clojure.core/defn- response-describe-import-snapshot-tasks-result ([input] (response-describe-import-snapshot-tasks-result nil input)) ([resultWrapper648027 input] (clojure.core/let [rawinput648026 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648028 {"importSnapshotTaskSet" (portkey.aws/search-for-tag rawinput648026 "importSnapshotTaskSet" :flattened? nil :result-wrapper resultWrapper648027), "nextToken" (portkey.aws/search-for-tag rawinput648026 "nextToken" :flattened? nil :result-wrapper resultWrapper648027)}] (clojure.core/cond-> {} (letvar648028 "importSnapshotTaskSet") (clojure.core/assoc :import-snapshot-tasks (deser-import-snapshot-task-list (clojure.core/get-in letvar648028 ["importSnapshotTaskSet" :content]))) (letvar648028 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar648028 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-dhcp-options-result ([input] (response-describe-dhcp-options-result nil input)) ([resultWrapper648030 input] (clojure.core/let [rawinput648029 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648031 {"dhcpOptionsSet" (portkey.aws/search-for-tag rawinput648029 "dhcpOptionsSet" :flattened? nil :result-wrapper resultWrapper648030)}] (clojure.core/cond-> {} (letvar648031 "dhcpOptionsSet") (clojure.core/assoc :dhcp-options (deser-dhcp-options-list (clojure.core/get-in letvar648031 ["dhcpOptionsSet" :content])))))))

(clojure.core/defn- response-create-nat-gateway-result ([input] (response-create-nat-gateway-result nil input)) ([resultWrapper648033 input] (clojure.core/let [rawinput648032 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648034 {"clientToken" (portkey.aws/search-for-tag rawinput648032 "clientToken" :flattened? nil :result-wrapper resultWrapper648033), "natGateway" (portkey.aws/search-for-tag rawinput648032 "natGateway" :flattened? nil :result-wrapper resultWrapper648033)}] (clojure.core/cond-> {} (letvar648034 "clientToken") (clojure.core/assoc :client-token (deser-string (clojure.core/get-in letvar648034 ["clientToken" :content]))) (letvar648034 "natGateway") (clojure.core/assoc :nat-gateway (deser-nat-gateway (clojure.core/get-in letvar648034 ["natGateway" :content])))))))

(clojure.core/defn- response-image-attribute ([input] (response-image-attribute nil input)) ([resultWrapper648036 input] (clojure.core/let [rawinput648035 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648037 {"blockDeviceMapping" (portkey.aws/search-for-tag rawinput648035 "blockDeviceMapping" :flattened? nil :result-wrapper resultWrapper648036), "imageId" (portkey.aws/search-for-tag rawinput648035 "imageId" :flattened? nil :result-wrapper resultWrapper648036), "launchPermission" (portkey.aws/search-for-tag rawinput648035 "launchPermission" :flattened? nil :result-wrapper resultWrapper648036), "productCodes" (portkey.aws/search-for-tag rawinput648035 "productCodes" :flattened? nil :result-wrapper resultWrapper648036), "description" (portkey.aws/search-for-tag rawinput648035 "description" :flattened? nil :result-wrapper resultWrapper648036), "kernel" (portkey.aws/search-for-tag rawinput648035 "kernel" :flattened? nil :result-wrapper resultWrapper648036), "ramdisk" (portkey.aws/search-for-tag rawinput648035 "ramdisk" :flattened? nil :result-wrapper resultWrapper648036), "sriovNetSupport" (portkey.aws/search-for-tag rawinput648035 "sriovNetSupport" :flattened? nil :result-wrapper resultWrapper648036)}] (clojure.core/cond-> {} (letvar648037 "blockDeviceMapping") (clojure.core/assoc :block-device-mappings (deser-block-device-mapping-list (clojure.core/get-in letvar648037 ["blockDeviceMapping" :content]))) (letvar648037 "imageId") (clojure.core/assoc :image-id (deser-string (clojure.core/get-in letvar648037 ["imageId" :content]))) (letvar648037 "launchPermission") (clojure.core/assoc :launch-permissions (deser-launch-permission-list (clojure.core/get-in letvar648037 ["launchPermission" :content]))) (letvar648037 "productCodes") (clojure.core/assoc :product-codes (deser-product-code-list (clojure.core/get-in letvar648037 ["productCodes" :content]))) (letvar648037 "description") (clojure.core/assoc :description (deser-attribute-value (clojure.core/get-in letvar648037 ["description" :content]))) (letvar648037 "kernel") (clojure.core/assoc :kernel-id (deser-attribute-value (clojure.core/get-in letvar648037 ["kernel" :content]))) (letvar648037 "ramdisk") (clojure.core/assoc :ramdisk-id (deser-attribute-value (clojure.core/get-in letvar648037 ["ramdisk" :content]))) (letvar648037 "sriovNetSupport") (clojure.core/assoc :sriov-net-support (deser-attribute-value (clojure.core/get-in letvar648037 ["sriovNetSupport" :content])))))))

(clojure.core/defn- response-reject-vpc-peering-connection-result ([input] (response-reject-vpc-peering-connection-result nil input)) ([resultWrapper648039 input] (clojure.core/let [rawinput648038 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648040 {"return" (portkey.aws/search-for-tag rawinput648038 "return" :flattened? nil :result-wrapper resultWrapper648039)}] (clojure.core/cond-> {} (letvar648040 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar648040 ["return" :content])))))))

(clojure.core/defn- response-create-network-interface-permission-result ([input] (response-create-network-interface-permission-result nil input)) ([resultWrapper648042 input] (clojure.core/let [rawinput648041 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648043 {"interfacePermission" (portkey.aws/search-for-tag rawinput648041 "interfacePermission" :flattened? nil :result-wrapper resultWrapper648042)}] (clojure.core/cond-> {} (letvar648043 "interfacePermission") (clojure.core/assoc :interface-permission (deser-network-interface-permission (clojure.core/get-in letvar648043 ["interfacePermission" :content])))))))

(clojure.core/defn- response-modify-instance-event-start-time-result ([input] (response-modify-instance-event-start-time-result nil input)) ([resultWrapper648045 input] (clojure.core/let [rawinput648044 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648046 {"event" (portkey.aws/search-for-tag rawinput648044 "event" :flattened? nil :result-wrapper resultWrapper648045)}] (clojure.core/cond-> {} (letvar648046 "event") (clojure.core/assoc :event (deser-instance-status-event (clojure.core/get-in letvar648046 ["event" :content])))))))

(clojure.core/defn- response-modify-instance-capacity-reservation-attributes-result ([input] (response-modify-instance-capacity-reservation-attributes-result nil input)) ([resultWrapper648048 input] (clojure.core/let [rawinput648047 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648049 {"return" (portkey.aws/search-for-tag rawinput648047 "return" :flattened? nil :result-wrapper resultWrapper648048)}] (clojure.core/cond-> {} (letvar648049 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar648049 ["return" :content])))))))

(clojure.core/defn- response-create-spot-datafeed-subscription-result ([input] (response-create-spot-datafeed-subscription-result nil input)) ([resultWrapper648051 input] (clojure.core/let [rawinput648050 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648052 {"spotDatafeedSubscription" (portkey.aws/search-for-tag rawinput648050 "spotDatafeedSubscription" :flattened? nil :result-wrapper resultWrapper648051)}] (clojure.core/cond-> {} (letvar648052 "spotDatafeedSubscription") (clojure.core/assoc :spot-datafeed-subscription (deser-spot-datafeed-subscription (clojure.core/get-in letvar648052 ["spotDatafeedSubscription" :content])))))))

(clojure.core/defn- response-bundle-instance-result ([input] (response-bundle-instance-result nil input)) ([resultWrapper648054 input] (clojure.core/let [rawinput648053 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648055 {"bundleInstanceTask" (portkey.aws/search-for-tag rawinput648053 "bundleInstanceTask" :flattened? nil :result-wrapper resultWrapper648054)}] (clojure.core/cond-> {} (letvar648055 "bundleInstanceTask") (clojure.core/assoc :bundle-task (deser-bundle-task (clojure.core/get-in letvar648055 ["bundleInstanceTask" :content])))))))

(clojure.core/defn- response-start-instances-result ([input] (response-start-instances-result nil input)) ([resultWrapper648057 input] (clojure.core/let [rawinput648056 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648058 {"instancesSet" (portkey.aws/search-for-tag rawinput648056 "instancesSet" :flattened? nil :result-wrapper resultWrapper648057)}] (clojure.core/cond-> {} (letvar648058 "instancesSet") (clojure.core/assoc :starting-instances (deser-instance-state-change-list (clojure.core/get-in letvar648058 ["instancesSet" :content])))))))

(clojure.core/defn- response-delete-transit-gateway-route-result ([input] (response-delete-transit-gateway-route-result nil input)) ([resultWrapper648060 input] (clojure.core/let [rawinput648059 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648061 {"route" (portkey.aws/search-for-tag rawinput648059 "route" :flattened? nil :result-wrapper resultWrapper648060)}] (clojure.core/cond-> {} (letvar648061 "route") (clojure.core/assoc :route (deser-transit-gateway-route (clojure.core/get-in letvar648061 ["route" :content])))))))

(clojure.core/defn- response-describe-elastic-gpus-result ([input] (response-describe-elastic-gpus-result nil input)) ([resultWrapper648063 input] (clojure.core/let [rawinput648062 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648064 {"elasticGpuSet" (portkey.aws/search-for-tag rawinput648062 "elasticGpuSet" :flattened? nil :result-wrapper resultWrapper648063), "maxResults" (portkey.aws/search-for-tag rawinput648062 "maxResults" :flattened? nil :result-wrapper resultWrapper648063), "nextToken" (portkey.aws/search-for-tag rawinput648062 "nextToken" :flattened? nil :result-wrapper resultWrapper648063)}] (clojure.core/cond-> {} (letvar648064 "elasticGpuSet") (clojure.core/assoc :elastic-gpu-set (deser-elastic-gpu-set (clojure.core/get-in letvar648064 ["elasticGpuSet" :content]))) (letvar648064 "maxResults") (clojure.core/assoc :max-results (deser-integer (clojure.core/get-in letvar648064 ["maxResults" :content]))) (letvar648064 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar648064 ["nextToken" :content])))))))

(clojure.core/defn- response-describe-vpn-gateways-result ([input] (response-describe-vpn-gateways-result nil input)) ([resultWrapper648066 input] (clojure.core/let [rawinput648065 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648067 {"vpnGatewaySet" (portkey.aws/search-for-tag rawinput648065 "vpnGatewaySet" :flattened? nil :result-wrapper resultWrapper648066)}] (clojure.core/cond-> {} (letvar648067 "vpnGatewaySet") (clojure.core/assoc :vpn-gateways (deser-vpn-gateway-list (clojure.core/get-in letvar648067 ["vpnGatewaySet" :content])))))))

(clojure.core/defn- response-volume-attachment ([input] (response-volume-attachment nil input)) ([resultWrapper648069 input] (clojure.core/let [rawinput648068 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648070 {"attachTime" (portkey.aws/search-for-tag rawinput648068 "attachTime" :flattened? nil :result-wrapper resultWrapper648069), "device" (portkey.aws/search-for-tag rawinput648068 "device" :flattened? nil :result-wrapper resultWrapper648069), "instanceId" (portkey.aws/search-for-tag rawinput648068 "instanceId" :flattened? nil :result-wrapper resultWrapper648069), "status" (portkey.aws/search-for-tag rawinput648068 "status" :flattened? nil :result-wrapper resultWrapper648069), "volumeId" (portkey.aws/search-for-tag rawinput648068 "volumeId" :flattened? nil :result-wrapper resultWrapper648069), "deleteOnTermination" (portkey.aws/search-for-tag rawinput648068 "deleteOnTermination" :flattened? nil :result-wrapper resultWrapper648069)}] (clojure.core/cond-> {} (letvar648070 "attachTime") (clojure.core/assoc :attach-time (deser-date-time (clojure.core/get-in letvar648070 ["attachTime" :content]))) (letvar648070 "device") (clojure.core/assoc :device (deser-string (clojure.core/get-in letvar648070 ["device" :content]))) (letvar648070 "instanceId") (clojure.core/assoc :instance-id (deser-string (clojure.core/get-in letvar648070 ["instanceId" :content]))) (letvar648070 "status") (clojure.core/assoc :state (deser-volume-attachment-state (clojure.core/get-in letvar648070 ["status" :content]))) (letvar648070 "volumeId") (clojure.core/assoc :volume-id (deser-string (clojure.core/get-in letvar648070 ["volumeId" :content]))) (letvar648070 "deleteOnTermination") (clojure.core/assoc :delete-on-termination (deser-boolean (clojure.core/get-in letvar648070 ["deleteOnTermination" :content])))))))

(clojure.core/defn- response-associate-iam-instance-profile-result ([input] (response-associate-iam-instance-profile-result nil input)) ([resultWrapper648072 input] (clojure.core/let [rawinput648071 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648073 {"iamInstanceProfileAssociation" (portkey.aws/search-for-tag rawinput648071 "iamInstanceProfileAssociation" :flattened? nil :result-wrapper resultWrapper648072)}] (clojure.core/cond-> {} (letvar648073 "iamInstanceProfileAssociation") (clojure.core/assoc :iam-instance-profile-association (deser-iam-instance-profile-association (clojure.core/get-in letvar648073 ["iamInstanceProfileAssociation" :content])))))))

(clojure.core/defn- response-describe-capacity-reservations-result ([input] (response-describe-capacity-reservations-result nil input)) ([resultWrapper648075 input] (clojure.core/let [rawinput648074 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648076 {"nextToken" (portkey.aws/search-for-tag rawinput648074 "nextToken" :flattened? nil :result-wrapper resultWrapper648075), "capacityReservationSet" (portkey.aws/search-for-tag rawinput648074 "capacityReservationSet" :flattened? nil :result-wrapper resultWrapper648075)}] (clojure.core/cond-> {} (letvar648076 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar648076 ["nextToken" :content]))) (letvar648076 "capacityReservationSet") (clojure.core/assoc :capacity-reservations (deser-capacity-reservation-set (clojure.core/get-in letvar648076 ["capacityReservationSet" :content])))))))

(clojure.core/defn- response-enable-vpc-classic-link-result ([input] (response-enable-vpc-classic-link-result nil input)) ([resultWrapper648078 input] (clojure.core/let [rawinput648077 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648079 {"return" (portkey.aws/search-for-tag rawinput648077 "return" :flattened? nil :result-wrapper resultWrapper648078)}] (clojure.core/cond-> {} (letvar648079 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar648079 ["return" :content])))))))

(clojure.core/defn- response-delete-launch-template-result ([input] (response-delete-launch-template-result nil input)) ([resultWrapper648081 input] (clojure.core/let [rawinput648080 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648082 {"launchTemplate" (portkey.aws/search-for-tag rawinput648080 "launchTemplate" :flattened? nil :result-wrapper resultWrapper648081)}] (clojure.core/cond-> {} (letvar648082 "launchTemplate") (clojure.core/assoc :launch-template (deser-launch-template (clojure.core/get-in letvar648082 ["launchTemplate" :content])))))))

(clojure.core/defn- response-describe-security-groups-result ([input] (response-describe-security-groups-result nil input)) ([resultWrapper648084 input] (clojure.core/let [rawinput648083 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648085 {"securityGroupInfo" (portkey.aws/search-for-tag rawinput648083 "securityGroupInfo" :flattened? nil :result-wrapper resultWrapper648084), "nextToken" (portkey.aws/search-for-tag rawinput648083 "nextToken" :flattened? nil :result-wrapper resultWrapper648084)}] (clojure.core/cond-> {} (letvar648085 "securityGroupInfo") (clojure.core/assoc :security-groups (deser-security-group-list (clojure.core/get-in letvar648085 ["securityGroupInfo" :content]))) (letvar648085 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar648085 ["nextToken" :content])))))))

(clojure.core/defn- response-reject-transit-gateway-vpc-attachment-result ([input] (response-reject-transit-gateway-vpc-attachment-result nil input)) ([resultWrapper648087 input] (clojure.core/let [rawinput648086 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648088 {"transitGatewayVpcAttachment" (portkey.aws/search-for-tag rawinput648086 "transitGatewayVpcAttachment" :flattened? nil :result-wrapper resultWrapper648087)}] (clojure.core/cond-> {} (letvar648088 "transitGatewayVpcAttachment") (clojure.core/assoc :transit-gateway-vpc-attachment (deser-transit-gateway-vpc-attachment (clojure.core/get-in letvar648088 ["transitGatewayVpcAttachment" :content])))))))

(clojure.core/defn- response-describe-security-group-references-result ([input] (response-describe-security-group-references-result nil input)) ([resultWrapper648090 input] (clojure.core/let [rawinput648089 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648091 {"securityGroupReferenceSet" (portkey.aws/search-for-tag rawinput648089 "securityGroupReferenceSet" :flattened? nil :result-wrapper resultWrapper648090)}] (clojure.core/cond-> {} (letvar648091 "securityGroupReferenceSet") (clojure.core/assoc :security-group-reference-set (deser-security-group-references (clojure.core/get-in letvar648091 ["securityGroupReferenceSet" :content])))))))

(clojure.core/defn- response-describe-regions-result ([input] (response-describe-regions-result nil input)) ([resultWrapper648093 input] (clojure.core/let [rawinput648092 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648094 {"regionInfo" (portkey.aws/search-for-tag rawinput648092 "regionInfo" :flattened? nil :result-wrapper resultWrapper648093)}] (clojure.core/cond-> {} (letvar648094 "regionInfo") (clojure.core/assoc :regions (deser-region-list (clojure.core/get-in letvar648094 ["regionInfo" :content])))))))

(clojure.core/defn- response-provision-byoip-cidr-result ([input] (response-provision-byoip-cidr-result nil input)) ([resultWrapper648096 input] (clojure.core/let [rawinput648095 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648097 {"byoipCidr" (portkey.aws/search-for-tag rawinput648095 "byoipCidr" :flattened? nil :result-wrapper resultWrapper648096)}] (clojure.core/cond-> {} (letvar648097 "byoipCidr") (clojure.core/assoc :byoip-cidr (deser-byoip-cidr (clojure.core/get-in letvar648097 ["byoipCidr" :content])))))))

(clojure.core/defn- response-detach-classic-link-vpc-result ([input] (response-detach-classic-link-vpc-result nil input)) ([resultWrapper648099 input] (clojure.core/let [rawinput648098 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648100 {"return" (portkey.aws/search-for-tag rawinput648098 "return" :flattened? nil :result-wrapper resultWrapper648099)}] (clojure.core/cond-> {} (letvar648100 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar648100 ["return" :content])))))))

(clojure.core/defn- response-delete-vpc-peering-connection-result ([input] (response-delete-vpc-peering-connection-result nil input)) ([resultWrapper648102 input] (clojure.core/let [rawinput648101 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648103 {"return" (portkey.aws/search-for-tag rawinput648101 "return" :flattened? nil :result-wrapper resultWrapper648102)}] (clojure.core/cond-> {} (letvar648103 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar648103 ["return" :content])))))))

(clojure.core/defn- response-delete-fpga-image-result ([input] (response-delete-fpga-image-result nil input)) ([resultWrapper648105 input] (clojure.core/let [rawinput648104 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648106 {"return" (portkey.aws/search-for-tag rawinput648104 "return" :flattened? nil :result-wrapper resultWrapper648105)}] (clojure.core/cond-> {} (letvar648106 "return") (clojure.core/assoc :return (deser-boolean (clojure.core/get-in letvar648106 ["return" :content])))))))

(clojure.core/defn- response-delete-vpc-endpoint-service-configurations-result ([input] (response-delete-vpc-endpoint-service-configurations-result nil input)) ([resultWrapper648108 input] (clojure.core/let [rawinput648107 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648109 {"unsuccessful" (portkey.aws/search-for-tag rawinput648107 "unsuccessful" :flattened? nil :result-wrapper resultWrapper648108)}] (clojure.core/cond-> {} (letvar648109 "unsuccessful") (clojure.core/assoc :unsuccessful (deser-unsuccessful-item-set (clojure.core/get-in letvar648109 ["unsuccessful" :content])))))))

(clojure.core/defn- response-unmonitor-instances-result ([input] (response-unmonitor-instances-result nil input)) ([resultWrapper648111 input] (clojure.core/let [rawinput648110 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648112 {"instancesSet" (portkey.aws/search-for-tag rawinput648110 "instancesSet" :flattened? nil :result-wrapper resultWrapper648111)}] (clojure.core/cond-> {} (letvar648112 "instancesSet") (clojure.core/assoc :instance-monitorings (deser-instance-monitoring-list (clojure.core/get-in letvar648112 ["instancesSet" :content])))))))

(clojure.core/defn- response-attach-vpn-gateway-result ([input] (response-attach-vpn-gateway-result nil input)) ([resultWrapper648114 input] (clojure.core/let [rawinput648113 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648115 {"attachment" (portkey.aws/search-for-tag rawinput648113 "attachment" :flattened? nil :result-wrapper resultWrapper648114)}] (clojure.core/cond-> {} (letvar648115 "attachment") (clojure.core/assoc :vpc-attachment (deser-vpc-attachment (clojure.core/get-in letvar648115 ["attachment" :content])))))))

(clojure.core/defn- response-describe-spot-fleet-request-history-response ([input] (response-describe-spot-fleet-request-history-response nil input)) ([resultWrapper648117 input] (clojure.core/let [rawinput648116 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar648118 {"historyRecordSet" (portkey.aws/search-for-tag rawinput648116 "historyRecordSet" :flattened? nil :result-wrapper resultWrapper648117), "lastEvaluatedTime" (portkey.aws/search-for-tag rawinput648116 "lastEvaluatedTime" :flattened? nil :result-wrapper resultWrapper648117), "nextToken" (portkey.aws/search-for-tag rawinput648116 "nextToken" :flattened? nil :result-wrapper resultWrapper648117), "spotFleetRequestId" (portkey.aws/search-for-tag rawinput648116 "spotFleetRequestId" :flattened? nil :result-wrapper resultWrapper648117), "startTime" (portkey.aws/search-for-tag rawinput648116 "startTime" :flattened? nil :result-wrapper resultWrapper648117)}] (clojure.core/cond-> {} (letvar648118 "historyRecordSet") (clojure.core/assoc :history-records (deser-history-records (clojure.core/get-in letvar648118 ["historyRecordSet" :content]))) (letvar648118 "lastEvaluatedTime") (clojure.core/assoc :last-evaluated-time (deser-date-time (clojure.core/get-in letvar648118 ["lastEvaluatedTime" :content]))) (letvar648118 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar648118 ["nextToken" :content]))) (letvar648118 "spotFleetRequestId") (clojure.core/assoc :spot-fleet-request-id (deser-string (clojure.core/get-in letvar648118 ["spotFleetRequestId" :content]))) (letvar648118 "startTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar648118 ["startTime" :content])))))))

(clojure.spec.alpha/def :portkey.aws.ec2/zone-name-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-instance-network-interface-specification-request-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-instance-network-interface-specification-request))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshots-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshots-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshots-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshots-request/owner-ids (clojure.spec.alpha/and :portkey.aws.ec2/owner-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshots-request/restorable-by-user-ids (clojure.spec.alpha/and :portkey.aws.ec2/restorable-by-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshots-request/snapshot-ids (clojure.spec.alpha/and :portkey.aws.ec2/snapshot-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshots-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-snapshots-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-snapshots-request/filters :portkey.aws.ec2.describe-snapshots-request/max-results :portkey.aws.ec2.describe-snapshots-request/next-token :portkey.aws.ec2.describe-snapshots-request/owner-ids :portkey.aws.ec2.describe-snapshots-request/restorable-by-user-ids :portkey.aws.ec2.describe-snapshots-request/snapshot-ids :portkey.aws.ec2.describe-snapshots-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment-options/dns-support (clojure.spec.alpha/and :portkey.aws.ec2/dns-support-value))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment-options/ipv-6-support (clojure.spec.alpha/and :portkey.aws.ec2/ipv-6-support-value))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-vpc-attachment-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-vpc-attachment-options/dns-support :portkey.aws.ec2.transit-gateway-vpc-attachment-options/ipv-6-support]))

(clojure.spec.alpha/def :portkey.aws.ec2/export-task-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/export-task))

(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-authorization-rule-status/code (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-authorization-rule-status-code))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-authorization-rule-status/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-authorization-rule-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-vpn-authorization-rule-status/code :portkey.aws.ec2.client-vpn-authorization-rule-status/message]))

(clojure.spec.alpha/def :portkey.aws.ec2/event-code #{:instancestop "instance-retirement" "instance-reboot" :instancereboot "instance-stop" "system-reboot" :instanceretirement :systemmaintenance :systemreboot "system-maintenance"})

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-license-configuration-request/license-configuration-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-license-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-license-configuration-request/license-configuration-arn]))

(clojure.spec.alpha/def :portkey.aws.ec2.flow-log/flow-log-status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.flow-log/resource-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.flow-log/deliver-logs-error-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.flow-log/deliver-logs-status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.flow-log/deliver-logs-permission-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.flow-log/flow-log-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.flow-log/log-group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.flow-log/creation-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.flow-log/log-destination (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/flow-log (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.flow-log/flow-log-status :portkey.aws.ec2/traffic-type :portkey.aws.ec2.flow-log/resource-id :portkey.aws.ec2.flow-log/deliver-logs-error-message :portkey.aws.ec2.flow-log/deliver-logs-status :portkey.aws.ec2.flow-log/deliver-logs-permission-arn :portkey.aws.ec2/log-destination-type :portkey.aws.ec2.flow-log/flow-log-id :portkey.aws.ec2.flow-log/log-group-name :portkey.aws.ec2.flow-log/creation-time :portkey.aws.ec2.flow-log/log-destination]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpc))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-spot-fleet-request-response/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-spot-fleet-request-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-spot-fleet-request-response/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-and-overrides-response/launch-template-specification (clojure.spec.alpha/and :portkey.aws.ec2/fleet-launch-template-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-and-overrides-response/overrides (clojure.spec.alpha/and :portkey.aws.ec2/fleet-launch-template-overrides))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-and-overrides-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-and-overrides-response/launch-template-specification :portkey.aws.ec2.launch-template-and-overrides-response/overrides]))

(clojure.spec.alpha/def :portkey.aws.ec2.history-record-entry/event-type (clojure.spec.alpha/and :portkey.aws.ec2/fleet-event-type))
(clojure.spec.alpha/def :portkey.aws.ec2.history-record-entry/timestamp (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/history-record-entry (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/event-information :portkey.aws.ec2.history-record-entry/event-type :portkey.aws.ec2.history-record-entry/timestamp]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-hibernation-options-request/configured (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-hibernation-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-hibernation-options-request/configured]))

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-monitoring/enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-monitoring (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instances-monitoring/enabled]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-requests-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-requests-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-requests-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-requests-request/spot-fleet-request-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-fleet-requests-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-spot-fleet-requests-request/dry-run :portkey.aws.ec2.describe-spot-fleet-requests-request/max-results :portkey.aws.ec2.describe-spot-fleet-requests-request/next-token :portkey.aws.ec2.describe-spot-fleet-requests-request/spot-fleet-request-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2/spot-allocation-strategy #{:diversified "lowest-price" "diversified" :lowestprice})

(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-action/code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-action/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-action/event-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-action/event-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-action (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.volume-status-action/code :portkey.aws.ec2.volume-status-action/description :portkey.aws.ec2.volume-status-action/event-id :portkey.aws.ec2.volume-status-action/event-type]))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment/transit-gateway-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment/resource-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment/resource-type (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-resource-type))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment/creation-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-state))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment/association (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-association))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment/resource-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-attachment (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-attachment/transit-gateway-id :portkey.aws.ec2.transit-gateway-attachment/tags :portkey.aws.ec2.transit-gateway-attachment/transit-gateway-owner-id :portkey.aws.ec2.transit-gateway-attachment/resource-id :portkey.aws.ec2.transit-gateway-attachment/transit-gateway-attachment-id :portkey.aws.ec2.transit-gateway-attachment/resource-type :portkey.aws.ec2.transit-gateway-attachment/creation-time :portkey.aws.ec2.transit-gateway-attachment/state :portkey.aws.ec2.transit-gateway-attachment/association :portkey.aws.ec2.transit-gateway-attachment/resource-owner-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/permission-group #{:all "all"})

(clojure.spec.alpha/def :portkey.aws.ec2.address/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.address/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.address/network-interface-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.address/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.address/allocation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.address/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.address/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.address/domain (clojure.spec.alpha/and :portkey.aws.ec2/domain-type))
(clojure.spec.alpha/def :portkey.aws.ec2.address/public-ipv-4-pool (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.address/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/address (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.address/public-ip :portkey.aws.ec2.address/instance-id :portkey.aws.ec2.address/network-interface-owner-id :portkey.aws.ec2.address/association-id :portkey.aws.ec2.address/allocation-id :portkey.aws.ec2.address/tags :portkey.aws.ec2.address/network-interface-id :portkey.aws.ec2.address/domain :portkey.aws.ec2.address/public-ipv-4-pool :portkey.aws.ec2.address/private-ip-address]))

(clojure.spec.alpha/def :portkey.aws.ec2.response-error/code (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-error-code))
(clojure.spec.alpha/def :portkey.aws.ec2.response-error/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/response-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.response-error/code :portkey.aws.ec2.response-error/message]))

(clojure.spec.alpha/def :portkey.aws.ec2.bundle-task/bundle-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.bundle-task/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.bundle-task/progress (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.bundle-task/start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.bundle-task/state (clojure.spec.alpha/and :portkey.aws.ec2/bundle-task-state))
(clojure.spec.alpha/def :portkey.aws.ec2.bundle-task/update-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/bundle-task (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.bundle-task/bundle-id :portkey.aws.ec2/bundle-task-error :portkey.aws.ec2.bundle-task/instance-id :portkey.aws.ec2.bundle-task/progress :portkey.aws.ec2.bundle-task/start-time :portkey.aws.ec2.bundle-task/state :portkey.aws.ec2/storage :portkey.aws.ec2.bundle-task/update-time]))

(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-attachment-propagations-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-attachment-propagations-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-attachment-propagations-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-attachment-propagations-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-attachment-propagations-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/get-transit-gateway-attachment-propagations-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.get-transit-gateway-attachment-propagations-request/transit-gateway-attachment-id] :opt-un [:portkey.aws.ec2.get-transit-gateway-attachment-propagations-request/filters :portkey.aws.ec2.get-transit-gateway-attachment-propagations-request/max-results :portkey.aws.ec2.get-transit-gateway-attachment-propagations-request/next-token :portkey.aws.ec2.get-transit-gateway-attachment-propagations-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/client-certificate-revocation-list-status-code #{:pending :active "active" "pending"})

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-cpu-options-request/core-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-cpu-options-request/threads-per-core (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-cpu-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-cpu-options-request/core-count :portkey.aws.ec2.launch-template-cpu-options-request/threads-per-core]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-placement-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-placement-request/affinity (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-placement-request/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-placement-request/host-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-placement-request/spread-domain (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-placement-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-placement-request/availability-zone :portkey.aws.ec2.launch-template-placement-request/affinity :portkey.aws.ec2.launch-template-placement-request/group-name :portkey.aws.ec2.launch-template-placement-request/host-id :portkey.aws.ec2/tenancy :portkey.aws.ec2.launch-template-placement-request/spread-domain]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-config-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-config))

(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/platform (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/role-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/disk-containers (clojure.spec.alpha/and :portkey.aws.ec2/image-disk-container-list))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/hypervisor (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/architecture (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/license-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/import-image-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.import-image-request/dry-run :portkey.aws.ec2.import-image-request/platform :portkey.aws.ec2.import-image-request/role-name :portkey.aws.ec2.import-image-request/encrypted :portkey.aws.ec2/client-data :portkey.aws.ec2.import-image-request/description :portkey.aws.ec2.import-image-request/kms-key-id :portkey.aws.ec2.import-image-request/disk-containers :portkey.aws.ec2.import-image-request/hypervisor :portkey.aws.ec2.import-image-request/architecture :portkey.aws.ec2.import-image-request/license-type :portkey.aws.ec2.import-image-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.elastic-inference-accelerator-association/elastic-inference-accelerator-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.elastic-inference-accelerator-association/elastic-inference-accelerator-association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.elastic-inference-accelerator-association/elastic-inference-accelerator-association-state (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.elastic-inference-accelerator-association/elastic-inference-accelerator-association-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/elastic-inference-accelerator-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.elastic-inference-accelerator-association/elastic-inference-accelerator-arn :portkey.aws.ec2.elastic-inference-accelerator-association/elastic-inference-accelerator-association-id :portkey.aws.ec2.elastic-inference-accelerator-association/elastic-inference-accelerator-association-state :portkey.aws.ec2.elastic-inference-accelerator-association/elastic-inference-accelerator-association-time]))

(clojure.spec.alpha/def :portkey.aws.ec2/security-group-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/security-group))

(clojure.spec.alpha/def :portkey.aws.ec2/service-type-detail-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/service-type-detail))

(clojure.spec.alpha/def :portkey.aws.ec2/principal-type #{:role :service "User" :all "Role" :account "Account" "OrganizationUnit" :organization-unit "Service" "All" :user})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-request/service-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoint-service-configurations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-endpoint-service-configurations-request/dry-run :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-request/service-ids :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-request/filters :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-request/max-results :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-count-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-count))

(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-route-request/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-route-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-route-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-route-request/blackhole (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-route-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-transit-gateway-route-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-transit-gateway-route-request/destination-cidr-block :portkey.aws.ec2.create-transit-gateway-route-request/transit-gateway-route-table-id] :opt-un [:portkey.aws.ec2.create-transit-gateway-route-request/transit-gateway-attachment-id :portkey.aws.ec2.create-transit-gateway-route-request/blackhole :portkey.aws.ec2.create-transit-gateway-route-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.confirm-product-instance-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.confirm-product-instance-request/product-code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.confirm-product-instance-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/confirm-product-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.confirm-product-instance-request/instance-id :portkey.aws.ec2.confirm-product-instance-request/product-code] :opt-un [:portkey.aws.ec2.confirm-product-instance-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/describe-conversion-task-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/conversion-task))

(clojure.spec.alpha/def :portkey.aws.ec2.route/instance-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route/nat-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route/destination-ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route/origin (clojure.spec.alpha/and :portkey.aws.ec2/route-origin))
(clojure.spec.alpha/def :portkey.aws.ec2.route/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route/destination-prefix-list-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route/vpc-peering-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route/state (clojure.spec.alpha/and :portkey.aws.ec2/route-state))
(clojure.spec.alpha/def :portkey.aws.ec2.route/gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route/egress-only-internet-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/route (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.route/instance-owner-id :portkey.aws.ec2.route/transit-gateway-id :portkey.aws.ec2.route/instance-id :portkey.aws.ec2.route/nat-gateway-id :portkey.aws.ec2.route/network-interface-id :portkey.aws.ec2.route/destination-ipv-6-cidr-block :portkey.aws.ec2.route/origin :portkey.aws.ec2.route/destination-cidr-block :portkey.aws.ec2.route/destination-prefix-list-id :portkey.aws.ec2.route/vpc-peering-connection-id :portkey.aws.ec2.route/state :portkey.aws.ec2.route/gateway-id :portkey.aws.ec2.route/egress-only-internet-gateway-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.dns-entry/dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.dns-entry/hosted-zone-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/dns-entry (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.dns-entry/dns-name :portkey.aws.ec2.dns-entry/hosted-zone-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.revoke-client-vpn-ingress-result/status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-authorization-rule-status))
(clojure.spec.alpha/def :portkey.aws.ec2/revoke-client-vpn-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.revoke-client-vpn-ingress-result/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpn-gateways-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpn-gateways-request/vpn-gateway-ids (clojure.spec.alpha/and :portkey.aws.ec2/vpn-gateway-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpn-gateways-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpn-gateways-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpn-gateways-request/filters :portkey.aws.ec2.describe-vpn-gateways-request/vpn-gateway-ids :portkey.aws.ec2.describe-vpn-gateways-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpn-connection-request/vpn-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpn-connection-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpn-connection-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-vpn-connection-request/vpn-connection-id] :opt-un [:portkey.aws.ec2.delete-vpn-connection-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.get-console-screenshot-result/image-data (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-console-screenshot-result/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/get-console-screenshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.get-console-screenshot-result/image-data :portkey.aws.ec2.get-console-screenshot-result/instance-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-egress-only-internet-gateways-result/egress-only-internet-gateways (clojure.spec.alpha/and :portkey.aws.ec2/egress-only-internet-gateway-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-egress-only-internet-gateways-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-egress-only-internet-gateways-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-egress-only-internet-gateways-result/egress-only-internet-gateways :portkey.aws.ec2.describe-egress-only-internet-gateways-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/nat-gateway-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/nat-gateway))

(clojure.spec.alpha/def :portkey.aws.ec2/moving-address-status-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/moving-address-status))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-state-change-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-state-change))

(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection-status/code (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-connection-status-code))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection-status/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-connection-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-vpn-connection-status/code :portkey.aws.ec2.client-vpn-connection-status/message]))

(clojure.spec.alpha/def :portkey.aws.ec2/delete-transit-gateway-route-table-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/transit-gateway-route-table]))

(clojure.spec.alpha/def :portkey.aws.ec2/iam-instance-profile-association-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/iam-instance-profile-association))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-aggregate-id-format-result/use-long-ids-aggregated (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-aggregate-id-format-result/statuses (clojure.spec.alpha/and :portkey.aws.ec2/id-format-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-aggregate-id-format-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-aggregate-id-format-result/use-long-ids-aggregated :portkey.aws.ec2.describe-aggregate-id-format-result/statuses]))

(clojure.spec.alpha/def :portkey.aws.ec2/double clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.ec2.cpu-options-request/core-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.cpu-options-request/threads-per-core (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/cpu-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cpu-options-request/core-count :portkey.aws.ec2.cpu-options-request/threads-per-core]))

(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-fleet-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-fleet-request/spot-fleet-request-config (clojure.spec.alpha/and :portkey.aws.ec2/spot-fleet-request-config-data))
(clojure.spec.alpha/def :portkey.aws.ec2/request-spot-fleet-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.request-spot-fleet-request/spot-fleet-request-config] :opt-un [:portkey.aws.ec2.request-spot-fleet-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/private-ip-address-config-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/scheduled-instances-private-ip-address-config))

(clojure.spec.alpha/def :portkey.aws.ec2/service-type #{:interface "Interface" :gateway "Gateway"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-instances-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-instances-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-instances-request/fleet-id (clojure.spec.alpha/and :portkey.aws.ec2/fleet-identifier))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-instances-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fleet-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-fleet-instances-request/fleet-id] :opt-un [:portkey.aws.ec2.describe-fleet-instances-request/dry-run :portkey.aws.ec2.describe-fleet-instances-request/max-results :portkey.aws.ec2.describe-fleet-instances-request/next-token :portkey.aws.ec2.describe-fleet-instances-request/filters]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instances-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instances-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instances-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instances-request/scheduled-instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instance-id-request-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instances-request/slot-start-time-range (clojure.spec.alpha/and :portkey.aws.ec2/slot-start-time-range-request))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-scheduled-instances-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-scheduled-instances-request/dry-run :portkey.aws.ec2.describe-scheduled-instances-request/filters :portkey.aws.ec2.describe-scheduled-instances-request/max-results :portkey.aws.ec2.describe-scheduled-instances-request/next-token :portkey.aws.ec2.describe-scheduled-instances-request/scheduled-instance-ids :portkey.aws.ec2.describe-scheduled-instances-request/slot-start-time-range]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-flow-logs-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-flow-logs-request/flow-log-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-flow-logs-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-flow-logs-request/flow-log-ids] :opt-un [:portkey.aws.ec2.delete-flow-logs-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.ebs-instance-block-device-specification/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.ebs-instance-block-device-specification/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/ebs-instance-block-device-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.ebs-instance-block-device-specification/delete-on-termination :portkey.aws.ec2.ebs-instance-block-device-specification/volume-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-internet-gateway-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/internet-gateway]))

(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-ipv-6-address (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/ipv-6-address]))

(clojure.spec.alpha/def :portkey.aws.ec2.associated-target-network/network-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associated-target-network/network-type (clojure.spec.alpha/and :portkey.aws.ec2/associated-network-type))
(clojure.spec.alpha/def :portkey.aws.ec2/associated-target-network (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.associated-target-network/network-id :portkey.aws.ec2.associated-target-network/network-type]))

(clojure.spec.alpha/def :portkey.aws.ec2/default-route-table-association-value #{:disable :enable "enable" "disable"})

(clojure.spec.alpha/def :portkey.aws.ec2.ebs-instance-block-device/attach-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.ebs-instance-block-device/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.ebs-instance-block-device/status (clojure.spec.alpha/and :portkey.aws.ec2/attachment-status))
(clojure.spec.alpha/def :portkey.aws.ec2.ebs-instance-block-device/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/ebs-instance-block-device (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.ebs-instance-block-device/attach-time :portkey.aws.ec2.ebs-instance-block-device/delete-on-termination :portkey.aws.ec2.ebs-instance-block-device/status :portkey.aws.ec2.ebs-instance-block-device/volume-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.route-table/associations (clojure.spec.alpha/and :portkey.aws.ec2/route-table-association-list))
(clojure.spec.alpha/def :portkey.aws.ec2.route-table/propagating-vgws (clojure.spec.alpha/and :portkey.aws.ec2/propagating-vgw-list))
(clojure.spec.alpha/def :portkey.aws.ec2.route-table/route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route-table/routes (clojure.spec.alpha/and :portkey.aws.ec2/route-list))
(clojure.spec.alpha/def :portkey.aws.ec2.route-table/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.route-table/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route-table/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/route-table (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.route-table/associations :portkey.aws.ec2.route-table/propagating-vgws :portkey.aws.ec2.route-table/route-table-id :portkey.aws.ec2.route-table/routes :portkey.aws.ec2.route-table/tags :portkey.aws.ec2.route-table/vpc-id :portkey.aws.ec2.route-table/owner-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/license-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/license-configuration))

(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instance-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/scheduled-instance))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template))

(clojure.spec.alpha/def :portkey.aws.ec2/target-groups-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/target-groups]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservations-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-host-reservations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/host-reservation-set :portkey.aws.ec2.describe-host-reservations-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.propagating-vgw/gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/propagating-vgw (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.propagating-vgw/gateway-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-addresses-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-addresses-request/public-ips (clojure.spec.alpha/and :portkey.aws.ec2/public-ip-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-addresses-request/allocation-ids (clojure.spec.alpha/and :portkey.aws.ec2/allocation-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-addresses-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-addresses-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-addresses-request/filters :portkey.aws.ec2.describe-addresses-request/public-ips :portkey.aws.ec2.describe-addresses-request/allocation-ids :portkey.aws.ec2.describe-addresses-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/reset-fpga-image-attribute-name #{:load-permission "loadPermission"})

(clojure.spec.alpha/def :portkey.aws.ec2/flow-log-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/flow-log))

(clojure.spec.alpha/def :portkey.aws.ec2/prefix-list-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-network-interface-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-network-interface))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-acls-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-acls-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-acls-request/network-acl-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-acls-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-acls-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/describe-network-acls-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-network-acls-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-network-acls-request/filters :portkey.aws.ec2.describe-network-acls-request/dry-run :portkey.aws.ec2.describe-network-acls-request/network-acl-ids :portkey.aws.ec2.describe-network-acls-request/next-token :portkey.aws.ec2.describe-network-acls-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpn-connection-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpn-connection))

(clojure.spec.alpha/def :portkey.aws.ec2/on-demand-allocation-strategy #{"lowestPrice" :lowest-price "prioritized" :prioritized})

(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/reserved-instances-offering-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/fixed-price (clojure.spec.alpha/and :portkey.aws.ec2/float))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/pricing-details (clojure.spec.alpha/and :portkey.aws.ec2/pricing-details-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/instance-tenancy (clojure.spec.alpha/and :portkey.aws.ec2/tenancy))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/marketplace (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/duration (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/usage-price (clojure.spec.alpha/and :portkey.aws.ec2/float))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/product-description (clojure.spec.alpha/and :portkey.aws.ec2/ri-product-description))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/offering-class (clojure.spec.alpha/and :portkey.aws.ec2/offering-class-type))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/recurring-charges (clojure.spec.alpha/and :portkey.aws.ec2/recurring-charges-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/offering-type (clojure.spec.alpha/and :portkey.aws.ec2/offering-type-values))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-offering/scope (clojure.spec.alpha/and :portkey.aws.ec2/scope))
(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-offering (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reserved-instances-offering/currency-code :portkey.aws.ec2.reserved-instances-offering/reserved-instances-offering-id :portkey.aws.ec2/instance-type :portkey.aws.ec2.reserved-instances-offering/fixed-price :portkey.aws.ec2.reserved-instances-offering/availability-zone :portkey.aws.ec2.reserved-instances-offering/pricing-details :portkey.aws.ec2.reserved-instances-offering/instance-tenancy :portkey.aws.ec2.reserved-instances-offering/marketplace :portkey.aws.ec2.reserved-instances-offering/duration :portkey.aws.ec2.reserved-instances-offering/usage-price :portkey.aws.ec2.reserved-instances-offering/product-description :portkey.aws.ec2.reserved-instances-offering/offering-class :portkey.aws.ec2.reserved-instances-offering/recurring-charges :portkey.aws.ec2.reserved-instances-offering/offering-type :portkey.aws.ec2.reserved-instances-offering/scope]))

(clojure.spec.alpha/def :portkey.aws.ec2.load-permission-modifications/add (clojure.spec.alpha/and :portkey.aws.ec2/load-permission-list-request))
(clojure.spec.alpha/def :portkey.aws.ec2.load-permission-modifications/remove (clojure.spec.alpha/and :portkey.aws.ec2/load-permission-list-request))
(clojure.spec.alpha/def :portkey.aws.ec2/load-permission-modifications (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.load-permission-modifications/add :portkey.aws.ec2.load-permission-modifications/remove]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-peering-connections-result/vpc-peering-connections (clojure.spec.alpha/and :portkey.aws.ec2/vpc-peering-connection-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-peering-connections-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-peering-connections-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-peering-connections-result/vpc-peering-connections :portkey.aws.ec2.describe-vpc-peering-connections-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-endpoint-type #{:interface "Interface" :gateway "Gateway"})

(clojure.spec.alpha/def :portkey.aws.ec2.storage/s-3 (clojure.spec.alpha/and :portkey.aws.ec2/s-3-storage))
(clojure.spec.alpha/def :portkey.aws.ec2/storage (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.storage/s-3]))

(clojure.spec.alpha/def :portkey.aws.ec2/value-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-table-state #{:deleted "deleting" :pending :deleting "deleted" :available "pending" "available"})

(clojure.spec.alpha/def :portkey.aws.ec2.modify-id-format-request/resource (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-id-format-request/use-long-ids (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-id-format-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-id-format-request/resource :portkey.aws.ec2.modify-id-format-request/use-long-ids] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-authorization-rules-result/authorization-rules (clojure.spec.alpha/and :portkey.aws.ec2/authorization-rule-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-client-vpn-authorization-rules-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-client-vpn-authorization-rules-result/authorization-rules :portkey.aws.ec2/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/end-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/target-volume-type (clojure.spec.alpha/and :portkey.aws.ec2/volume-type))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/original-volume-type (clojure.spec.alpha/and :portkey.aws.ec2/volume-type))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/original-iops (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/progress (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/original-size (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/modification-state (clojure.spec.alpha/and :portkey.aws.ec2/volume-modification-state))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/target-iops (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-modification/target-size (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/volume-modification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.volume-modification/end-time :portkey.aws.ec2.volume-modification/target-volume-type :portkey.aws.ec2.volume-modification/original-volume-type :portkey.aws.ec2.volume-modification/start-time :portkey.aws.ec2.volume-modification/status-message :portkey.aws.ec2.volume-modification/original-iops :portkey.aws.ec2.volume-modification/progress :portkey.aws.ec2.volume-modification/original-size :portkey.aws.ec2.volume-modification/modification-state :portkey.aws.ec2.volume-modification/volume-id :portkey.aws.ec2.volume-modification/target-iops :portkey.aws.ec2.volume-modification/target-size]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-instances-result/active-instances (clojure.spec.alpha/and :portkey.aws.ec2/active-instance-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-instances-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-instances-result/fleet-id (clojure.spec.alpha/and :portkey.aws.ec2/fleet-identifier))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fleet-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-fleet-instances-result/active-instances :portkey.aws.ec2.describe-fleet-instances-result/next-token :portkey.aws.ec2.describe-fleet-instances-result/fleet-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.peering-connection-options-request/allow-dns-resolution-from-remote-vpc (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.peering-connection-options-request/allow-egress-from-local-classic-link-to-remote-vpc (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.peering-connection-options-request/allow-egress-from-local-vpc-to-remote-classic-link (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/peering-connection-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.peering-connection-options-request/allow-dns-resolution-from-remote-vpc :portkey.aws.ec2.peering-connection-options-request/allow-egress-from-local-classic-link-to-remote-vpc :portkey.aws.ec2.peering-connection-options-request/allow-egress-from-local-vpc-to-remote-classic-link]))

(clojure.spec.alpha/def :portkey.aws.ec2/run-scheduled-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/instance-id-set]))

(clojure.spec.alpha/def :portkey.aws.ec2/customer-gateway-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/ip-ranges (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-status-event-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-status-event))

(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-authentication-type #{:directoryserviceauthentication :certificateauthentication "directory-service-authentication" "certificate-authentication"})

(clojure.spec.alpha/def :portkey.aws.ec2/public-ip-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/connection-notification-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/connection-notification))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ec2/group-identifier-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/security-group-identifier))

(clojure.spec.alpha/def :portkey.aws.ec2.reset-network-interface-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.reset-network-interface-attribute-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reset-network-interface-attribute-request/source-dest-check (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/reset-network-interface-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.reset-network-interface-attribute-request/network-interface-id] :opt-un [:portkey.aws.ec2.reset-network-interface-attribute-request/dry-run :portkey.aws.ec2.reset-network-interface-attribute-request/source-dest-check]))

(clojure.spec.alpha/def :portkey.aws.ec2.filter/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.filter/values (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.filter/name :portkey.aws.ec2.filter/values]))

(clojure.spec.alpha/def :portkey.aws.ec2.reject-transit-gateway-vpc-attachment-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reject-transit-gateway-vpc-attachment-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/reject-transit-gateway-vpc-attachment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.reject-transit-gateway-vpc-attachment-request/transit-gateway-attachment-id] :opt-un [:portkey.aws.ec2.reject-transit-gateway-vpc-attachment-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-modification-result-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/reserved-instances-modification-result))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-internet-gateways-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-internet-gateways-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-internet-gateways-request/internet-gateway-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-internet-gateways-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-internet-gateways-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/describe-internet-gateways-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-internet-gateways-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-internet-gateways-request/filters :portkey.aws.ec2.describe-internet-gateways-request/dry-run :portkey.aws.ec2.describe-internet-gateways-request/internet-gateway-ids :portkey.aws.ec2.describe-internet-gateways-request/next-token :portkey.aws.ec2.describe-internet-gateways-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-iam-instance-profile-request/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-iam-instance-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.disassociate-iam-instance-profile-request/association-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-ipv-6-address-request/ipv-6-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-ipv-6-address-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-ipv-6-address-request/ipv-6-address]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpn-protocol #{"openvpn" :openvpn})

(clojure.spec.alpha/def :portkey.aws.ec2.copy-fpga-image-result/fpga-image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/copy-fpga-image-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.copy-fpga-image-result/fpga-image-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-attribute-request/enable-dns-hostnames (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-attribute-request/enable-dns-support (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-attribute-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-vpc-attribute-request/vpc-id] :opt-un [:portkey.aws.ec2.modify-vpc-attribute-request/enable-dns-hostnames :portkey.aws.ec2.modify-vpc-attribute-request/enable-dns-support]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection-vpc-info/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection-vpc-info/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection-vpc-info/peering-options (clojure.spec.alpha/and :portkey.aws.ec2/vpc-peering-connection-options-description))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection-vpc-info/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection-vpc-info/region (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-peering-connection-vpc-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc-peering-connection-vpc-info/cidr-block :portkey.aws.ec2/ipv-6-cidr-block-set :portkey.aws.ec2/cidr-block-set :portkey.aws.ec2.vpc-peering-connection-vpc-info/owner-id :portkey.aws.ec2.vpc-peering-connection-vpc-info/peering-options :portkey.aws.ec2.vpc-peering-connection-vpc-info/vpc-id :portkey.aws.ec2.vpc-peering-connection-vpc-info/region]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-customer-gateway-request/customer-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-customer-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-customer-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-customer-gateway-request/customer-gateway-id] :opt-un [:portkey.aws.ec2.delete-customer-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-monitoring-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-monitoring))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection/accepter-vpc-info (clojure.spec.alpha/and :portkey.aws.ec2/vpc-peering-connection-vpc-info))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection/expiration-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection/requester-vpc-info (clojure.spec.alpha/and :portkey.aws.ec2/vpc-peering-connection-vpc-info))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection/status (clojure.spec.alpha/and :portkey.aws.ec2/vpc-peering-connection-state-reason))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection/vpc-peering-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-peering-connection (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc-peering-connection/accepter-vpc-info :portkey.aws.ec2.vpc-peering-connection/expiration-time :portkey.aws.ec2.vpc-peering-connection/requester-vpc-info :portkey.aws.ec2.vpc-peering-connection/status :portkey.aws.ec2.vpc-peering-connection/tags :portkey.aws.ec2.vpc-peering-connection/vpc-peering-connection-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-reserved-instances-listing-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-reserved-instances-listing-request/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.create-reserved-instances-listing-request/price-schedules (clojure.spec.alpha/and :portkey.aws.ec2/price-schedule-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-reserved-instances-listing-request/reserved-instances-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-reserved-instances-listing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-reserved-instances-listing-request/client-token :portkey.aws.ec2.create-reserved-instances-listing-request/instance-count :portkey.aws.ec2.create-reserved-instances-listing-request/price-schedules :portkey.aws.ec2.create-reserved-instances-listing-request/reserved-instances-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2/export-task-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/target-groups (clojure.spec.alpha/coll-of :portkey.aws.ec2/target-group :min-count 1 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ec2/target-reservation-value-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/target-reservation-value))

(clojure.spec.alpha/def :portkey.aws.ec2/image-state #{"failed" :pending "error" "invalid" :invalid "transient" :transient :deregistered :error :available "deregistered" "pending" "available" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.create-image-result/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-image-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-image-result/image-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-table-association-request/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-table-association-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-table-association-request/route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/replace-route-table-association-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.replace-route-table-association-request/association-id :portkey.aws.ec2.replace-route-table-association-request/route-table-id] :opt-un [:portkey.aws.ec2.replace-route-table-association-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-principal-id-format-result/principals (clojure.spec.alpha/and :portkey.aws.ec2/principal-id-format-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-principal-id-format-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-principal-id-format-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-principal-id-format-result/principals :portkey.aws.ec2.describe-principal-id-format-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-transit-gateway-vpc-attachment-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/transit-gateway-vpc-attachment]))

(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-ipv-6-address/ipv-6-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-ipv-6-address (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-interface-ipv-6-address/ipv-6-address]))

(clojure.spec.alpha/def :portkey.aws.ec2/host-reservation-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.create-snapshot-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-snapshot-request/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-snapshot-request/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-snapshot-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-snapshot-request/volume-id] :opt-un [:portkey.aws.ec2.create-snapshot-request/description :portkey.aws.ec2.create-snapshot-request/tag-specifications :portkey.aws.ec2.create-snapshot-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpn-state #{:deleted "deleting" :pending :deleting "deleted" :available "pending" "available"})

(clojure.spec.alpha/def :portkey.aws.ec2/account-attribute-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/account-attribute))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-lifecycle #{:ondemand "spot" "on-demand" :spot})

(clojure.spec.alpha/def :portkey.aws.ec2/zone-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.allocate-hosts-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.allocate-hosts-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.allocate-hosts-request/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.allocate-hosts-request/quantity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.allocate-hosts-request/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2/allocate-hosts-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.allocate-hosts-request/availability-zone :portkey.aws.ec2.allocate-hosts-request/instance-type :portkey.aws.ec2.allocate-hosts-request/quantity] :opt-un [:portkey.aws.ec2/auto-placement :portkey.aws.ec2.allocate-hosts-request/client-token :portkey.aws.ec2.allocate-hosts-request/tag-specifications]))

(clojure.spec.alpha/def :portkey.aws.ec2/ipv-6-range-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/ipv-6-range))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-classic-link-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.disable-transit-gateway-route-table-propagation-result/propagation (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-propagation))
(clojure.spec.alpha/def :portkey.aws.ec2/disable-transit-gateway-route-table-propagation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disable-transit-gateway-route-table-propagation-result/propagation]))

(clojure.spec.alpha/def :portkey.aws.ec2/move-status #{:moving-to-vpc "movingToVpc" :restoring-to-classic "restoringToClassic"})

(clojure.spec.alpha/def :portkey.aws.ec2.credit-specification/cpu-credits (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/credit-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.credit-specification/cpu-credits]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-image-request/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/block-device-mapping-request-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-image-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-image-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-image-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-image-request/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-image-request/no-reboot (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-image-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-image-request/instance-id :portkey.aws.ec2.create-image-request/name] :opt-un [:portkey.aws.ec2.create-image-request/block-device-mappings :portkey.aws.ec2.create-image-request/description :portkey.aws.ec2.create-image-request/dry-run :portkey.aws.ec2.create-image-request/no-reboot]))

(clojure.spec.alpha/def :portkey.aws.ec2/withdraw-byoip-cidr-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/byoip-cidr]))

(clojure.spec.alpha/def :portkey.aws.ec2.prefix-list-id/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.prefix-list-id/prefix-list-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/prefix-list-id (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.prefix-list-id/description :portkey.aws.ec2.prefix-list-id/prefix-list-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/spot-instance-request-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/security-group-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/pricing-details-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/pricing-detail))

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-connection-route-request/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-connection-route-request/vpn-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpn-connection-route-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-vpn-connection-route-request/destination-cidr-block :portkey.aws.ec2.create-vpn-connection-route-request/vpn-connection-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.purchase/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase/duration (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase/host-id-set (clojure.spec.alpha/and :portkey.aws.ec2/response-host-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase/host-reservation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase/hourly-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase/instance-family (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase/upfront-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/purchase (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.purchase/currency-code :portkey.aws.ec2.purchase/duration :portkey.aws.ec2.purchase/host-id-set :portkey.aws.ec2.purchase/host-reservation-id :portkey.aws.ec2.purchase/hourly-price :portkey.aws.ec2.purchase/instance-family :portkey.aws.ec2/payment-option :portkey.aws.ec2.purchase/upfront-price]))

(clojure.spec.alpha/def :portkey.aws.ec2.terminate-client-vpn-connections-result/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.terminate-client-vpn-connections-result/username (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.terminate-client-vpn-connections-result/connection-statuses (clojure.spec.alpha/and :portkey.aws.ec2/terminate-connection-status-set))
(clojure.spec.alpha/def :portkey.aws.ec2/terminate-client-vpn-connections-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.terminate-client-vpn-connections-result/client-vpn-endpoint-id :portkey.aws.ec2.terminate-client-vpn-connections-result/username :portkey.aws.ec2.terminate-client-vpn-connections-result/connection-statuses]))

(clojure.spec.alpha/def :portkey.aws.ec2/replace-iam-instance-profile-association-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/iam-instance-profile-association]))

(clojure.spec.alpha/def :portkey.aws.ec2/hypervisor-type #{"ovm" "xen" :ovm :xen})

(clojure.spec.alpha/def :portkey.aws.ec2.history-record/timestamp (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/history-record (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/event-information :portkey.aws.ec2/event-type :portkey.aws.ec2.history-record/timestamp]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-egress-only-internet-gateway-result/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-egress-only-internet-gateway-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-egress-only-internet-gateway-result/client-token :portkey.aws.ec2/egress-only-internet-gateway]))

(clojure.spec.alpha/def :portkey.aws.ec2.export-transit-gateway-routes-result/s-3-location (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/export-transit-gateway-routes-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.export-transit-gateway-routes-result/s-3-location]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-egress-only-internet-gateway-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-egress-only-internet-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-egress-only-internet-gateway-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-egress-only-internet-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-egress-only-internet-gateway-request/vpc-id] :opt-un [:portkey.aws.ec2.create-egress-only-internet-gateway-request/client-token :portkey.aws.ec2.create-egress-only-internet-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-vpn-gateway-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/vpn-gateway]))

(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/sriov-net-support (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/billing-products (clojure.spec.alpha/and :portkey.aws.ec2/billing-product-list))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/block-device-mapping-request-list))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/architecture (clojure.spec.alpha/and :portkey.aws.ec2/architecture-values))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/virtualization-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/image-location (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/root-device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/ramdisk-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.register-image-request/ena-support (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/register-image-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.register-image-request/name] :opt-un [:portkey.aws.ec2.register-image-request/dry-run :portkey.aws.ec2.register-image-request/kernel-id :portkey.aws.ec2.register-image-request/sriov-net-support :portkey.aws.ec2.register-image-request/billing-products :portkey.aws.ec2.register-image-request/description :portkey.aws.ec2.register-image-request/block-device-mappings :portkey.aws.ec2.register-image-request/architecture :portkey.aws.ec2.register-image-request/virtualization-type :portkey.aws.ec2.register-image-request/image-location :portkey.aws.ec2.register-image-request/root-device-name :portkey.aws.ec2.register-image-request/ramdisk-id :portkey.aws.ec2.register-image-request/ena-support]))

(clojure.spec.alpha/def :portkey.aws.ec2/connection-notification-type #{"Topic" :topic})

(clojure.spec.alpha/def :portkey.aws.ec2.modify-hosts-request/host-ids (clojure.spec.alpha/and :portkey.aws.ec2/request-host-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-hosts-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2/auto-placement :portkey.aws.ec2.modify-hosts-request/host-ids] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2/vpn-connection-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/route-table-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/route-table))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-volume-request/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-volume-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-volume-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-volume-request/volume-id] :opt-un [:portkey.aws.ec2.delete-volume-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-subnet-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/subnet]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-error/launch-template-and-overrides (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-and-overrides-response))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-error/lifecycle (clojure.spec.alpha/and :portkey.aws.ec2/instance-lifecycle))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-error/error-code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-error/error-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-fleet-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-fleet-error/launch-template-and-overrides :portkey.aws.ec2.create-fleet-error/lifecycle :portkey.aws.ec2.create-fleet-error/error-code :portkey.aws.ec2.create-fleet-error/error-message]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-acl-entry-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-acl-entry-request/egress (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-acl-entry-request/network-acl-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-acl-entry-request/rule-number (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-network-acl-entry-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-network-acl-entry-request/egress :portkey.aws.ec2.delete-network-acl-entry-request/network-acl-id :portkey.aws.ec2.delete-network-acl-entry-request/rule-number] :opt-un [:portkey.aws.ec2.delete-network-acl-entry-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-conversion-tasks-request/conversion-task-ids (clojure.spec.alpha/and :portkey.aws.ec2/conversion-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-conversion-tasks-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-conversion-tasks-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-conversion-tasks-request/conversion-task-ids :portkey.aws.ec2.describe-conversion-tasks-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment/subnet-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment/creation-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment/vpc-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-state))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-vpc-attachment/options (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-vpc-attachment-options))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-vpc-attachment (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-vpc-attachment/transit-gateway-id :portkey.aws.ec2.transit-gateway-vpc-attachment/subnet-ids :portkey.aws.ec2.transit-gateway-vpc-attachment/tags :portkey.aws.ec2.transit-gateway-vpc-attachment/transit-gateway-attachment-id :portkey.aws.ec2.transit-gateway-vpc-attachment/vpc-id :portkey.aws.ec2.transit-gateway-vpc-attachment/creation-time :portkey.aws.ec2.transit-gateway-vpc-attachment/vpc-owner-id :portkey.aws.ec2.transit-gateway-vpc-attachment/state :portkey.aws.ec2.transit-gateway-vpc-attachment/options]))

(clojure.spec.alpha/def :portkey.aws.ec2/architecture-values #{:arm-64 "x86_64" :i-386 :x-86-64 "arm64" "i386"})

(clojure.spec.alpha/def :portkey.aws.ec2.cancelled-spot-instance-request/spot-instance-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.cancelled-spot-instance-request/state (clojure.spec.alpha/and :portkey.aws.ec2/cancel-spot-instance-request-state))
(clojure.spec.alpha/def :portkey.aws.ec2/cancelled-spot-instance-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cancelled-spot-instance-request/spot-instance-request-id :portkey.aws.ec2.cancelled-spot-instance-request/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.copy-image-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-image-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-image-request/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-image-request/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-image-request/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-image-request/source-image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-image-request/source-region (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-image-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/copy-image-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.copy-image-request/name :portkey.aws.ec2.copy-image-request/source-image-id :portkey.aws.ec2.copy-image-request/source-region] :opt-un [:portkey.aws.ec2.copy-image-request/client-token :portkey.aws.ec2.copy-image-request/description :portkey.aws.ec2.copy-image-request/encrypted :portkey.aws.ec2.copy-image-request/kms-key-id :portkey.aws.ec2.copy-image-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-conversion-request/conversion-task-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-conversion-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-conversion-request/reason-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-conversion-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.cancel-conversion-request/conversion-task-id] :opt-un [:portkey.aws.ec2.cancel-conversion-request/dry-run :portkey.aws.ec2.cancel-conversion-request/reason-message]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-permissions-request/network-interface-permission-ids (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-permission-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-permissions-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-permissions-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-permissions-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-network-interface-permissions-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-network-interface-permissions-request/network-interface-permission-ids :portkey.aws.ec2.describe-network-interface-permissions-request/filters :portkey.aws.ec2.describe-network-interface-permissions-request/next-token :portkey.aws.ec2.describe-network-interface-permissions-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route/transit-gateway-attachments (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route-attachment-list))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route/type (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route-type))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route-state))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-route/destination-cidr-block :portkey.aws.ec2.transit-gateway-route/transit-gateway-attachments :portkey.aws.ec2.transit-gateway-route/type :portkey.aws.ec2.transit-gateway-route/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-subnet-cidr-block-result/ipv-6-cidr-block-association (clojure.spec.alpha/and :portkey.aws.ec2/subnet-ipv-6-cidr-block-association))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-subnet-cidr-block-result/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-subnet-cidr-block-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disassociate-subnet-cidr-block-result/ipv-6-cidr-block-association :portkey.aws.ec2.disassociate-subnet-cidr-block-result/subnet-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-stale-security-groups-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-stale-security-groups-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-stale-security-groups-result/next-token :portkey.aws.ec2/stale-security-group-set]))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-attachment-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/volume-attachment))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-spot-fleet-request-request/spot-fleet-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-spot-fleet-request-request/target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-spot-fleet-request-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-spot-fleet-request-request/spot-fleet-request-id] :opt-un [:portkey.aws.ec2/excess-capacity-termination-policy :portkey.aws.ec2.modify-spot-fleet-request-request/target-capacity]))

(clojure.spec.alpha/def :portkey.aws.ec2.blob-attribute-value/value (clojure.spec.alpha/and :portkey.aws.ec2/blob))
(clojure.spec.alpha/def :portkey.aws.ec2/blob-attribute-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.blob-attribute-value/value]))

(clojure.spec.alpha/def :portkey.aws.ec2/export-environment #{:citrix "microsoft" "citrix" :vmware :microsoft "vmware"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-flow-logs-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-flow-logs-request/filter (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-flow-logs-request/flow-log-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-flow-logs-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-flow-logs-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-flow-logs-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-flow-logs-request/dry-run :portkey.aws.ec2.describe-flow-logs-request/filter :portkey.aws.ec2.describe-flow-logs-request/flow-log-ids :portkey.aws.ec2.describe-flow-logs-request/max-results :portkey.aws.ec2.describe-flow-logs-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-elastic-gpus-request/elastic-gpu-ids (clojure.spec.alpha/and :portkey.aws.ec2/elastic-gpu-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-elastic-gpus-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-elastic-gpus-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-elastic-gpus-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-elastic-gpus-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-elastic-gpus-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-elastic-gpus-request/elastic-gpu-ids :portkey.aws.ec2.describe-elastic-gpus-request/dry-run :portkey.aws.ec2.describe-elastic-gpus-request/filters :portkey.aws.ec2.describe-elastic-gpus-request/max-results :portkey.aws.ec2.describe-elastic-gpus-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/load-permission-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/load-permission))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-security-group-request/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-security-group-request/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-security-group-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-security-group-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-security-group-request/group-id :portkey.aws.ec2.delete-security-group-request/group-name :portkey.aws.ec2.delete-security-group-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-export-details/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-export-details/target-environment (clojure.spec.alpha/and :portkey.aws.ec2/export-environment))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-export-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-export-details/instance-id :portkey.aws.ec2.instance-export-details/target-environment]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-transit-gateway-route-table-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-transit-gateway-route-table-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-transit-gateway-route-table-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-transit-gateway-route-table-request/transit-gateway-route-table-id] :opt-un [:portkey.aws.ec2.delete-transit-gateway-route-table-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-result/service-configurations (clojure.spec.alpha/and :portkey.aws.ec2/service-configuration-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoint-service-configurations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-endpoint-service-configurations-result/service-configurations :portkey.aws.ec2.describe-vpc-endpoint-service-configurations-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/reserved-instance-value-set (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instance-reservation-value-set))
(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/target-configuration-value-set (clojure.spec.alpha/and :portkey.aws.ec2/target-reservation-value-set))
(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/validation-failure-reason (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/output-reserved-instances-will-expire-at (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/payment-due (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/is-valid-exchange (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/reserved-instance-value-rollup (clojure.spec.alpha/and :portkey.aws.ec2/reservation-value))
(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/target-configuration-value-rollup (clojure.spec.alpha/and :portkey.aws.ec2/reservation-value))
(clojure.spec.alpha/def :portkey.aws.ec2/get-reserved-instances-exchange-quote-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.get-reserved-instances-exchange-quote-result/reserved-instance-value-set :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/currency-code :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/target-configuration-value-set :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/validation-failure-reason :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/output-reserved-instances-will-expire-at :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/payment-due :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/is-valid-exchange :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/reserved-instance-value-rollup :portkey.aws.ec2.get-reserved-instances-exchange-quote-result/target-configuration-value-rollup]))

(clojure.spec.alpha/def :portkey.aws.ec2/service-type-detail (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/service-type]))

(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-config-request/launch-template-specification (clojure.spec.alpha/and :portkey.aws.ec2/fleet-launch-template-specification-request))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-config-request/overrides (clojure.spec.alpha/and :portkey.aws.ec2/fleet-launch-template-overrides-list-request))
(clojure.spec.alpha/def :portkey.aws.ec2/fleet-launch-template-config-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.fleet-launch-template-config-request/launch-template-specification :portkey.aws.ec2.fleet-launch-template-config-request/overrides]))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-attachment-state #{"attached" "detaching" :detached "detached" :busy "busy" "attaching" :attaching :attached :detaching})

(clojure.spec.alpha/def :portkey.aws.ec2/volume-modification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/volume-modification))

(clojure.spec.alpha/def :portkey.aws.ec2.confirm-product-instance-result/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.confirm-product-instance-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/confirm-product-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.confirm-product-instance-result/owner-id :portkey.aws.ec2.confirm-product-instance-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-request/instance-types (clojure.spec.alpha/and :portkey.aws.ec2/instance-type-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-request/end-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-request/product-descriptions (clojure.spec.alpha/and :portkey.aws.ec2/product-description-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-request/start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-price-history-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-spot-price-history-request/dry-run :portkey.aws.ec2.describe-spot-price-history-request/instance-types :portkey.aws.ec2.describe-spot-price-history-request/end-time :portkey.aws.ec2.describe-spot-price-history-request/product-descriptions :portkey.aws.ec2.describe-spot-price-history-request/start-time :portkey.aws.ec2.describe-spot-price-history-request/availability-zone :portkey.aws.ec2.describe-spot-price-history-request/next-token :portkey.aws.ec2.describe-spot-price-history-request/filters :portkey.aws.ec2.describe-spot-price-history-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2.internet-gateway-attachment/state (clojure.spec.alpha/and :portkey.aws.ec2/attachment-status))
(clojure.spec.alpha/def :portkey.aws.ec2.internet-gateway-attachment/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/internet-gateway-attachment (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.internet-gateway-attachment/state :portkey.aws.ec2.internet-gateway-attachment/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device/iops (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device/volume-size (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-ebs-block-device (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-ebs-block-device/encrypted :portkey.aws.ec2.launch-template-ebs-block-device/delete-on-termination :portkey.aws.ec2.launch-template-ebs-block-device/iops :portkey.aws.ec2.launch-template-ebs-block-device/kms-key-id :portkey.aws.ec2.launch-template-ebs-block-device/snapshot-id :portkey.aws.ec2.launch-template-ebs-block-device/volume-size :portkey.aws.ec2/volume-type]))

(clojure.spec.alpha/def :portkey.aws.ec2.bundle-instance-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.bundle-instance-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/bundle-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.bundle-instance-request/instance-id :portkey.aws.ec2/storage] :opt-un [:portkey.aws.ec2.bundle-instance-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-identifier (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-result/reserved-instances-offerings (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-offering-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-reserved-instances-offerings-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-reserved-instances-offerings-result/reserved-instances-offerings :portkey.aws.ec2.describe-reserved-instances-offerings-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-private-ip-address-config/primary (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-private-ip-address-config/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-private-ip-address-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instances-private-ip-address-config/primary :portkey.aws.ec2.scheduled-instances-private-ip-address-config/private-ip-address]))

(clojure.spec.alpha/def :portkey.aws.ec2/product-code-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/association-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-monitoring/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-monitoring (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-monitoring/instance-id :portkey.aws.ec2/monitoring]))

(clojure.spec.alpha/def :portkey.aws.ec2/spot-price-history-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/spot-price))

(clojure.spec.alpha/def :portkey.aws.ec2/byoip-cidr-state #{"pending-provision" :advertised "failed-provision" :provisioned "deprovisioned" "failed-deprovision" "advertised" :pendingprovision :pendingdeprovision :failedprovision :deprovisioned "pending-deprovision" :faileddeprovision "provisioned"})

(clojure.spec.alpha/def :portkey.aws.ec2.get-launch-template-data-result/launch-template-data (clojure.spec.alpha/and :portkey.aws.ec2/response-launch-template-data))
(clojure.spec.alpha/def :portkey.aws.ec2/get-launch-template-data-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.get-launch-template-data-result/launch-template-data]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-peering-connection-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-peering-connection-request/vpc-peering-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpc-peering-connection-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-vpc-peering-connection-request/vpc-peering-connection-id] :opt-un [:portkey.aws.ec2.delete-vpc-peering-connection-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection-options/static-routes-only (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/vpn-connection-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpn-connection-options/static-routes-only]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-reserved-instances-result/reserved-instances-modification-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-reserved-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-reserved-instances-result/reserved-instances-modification-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.network-acl-entry/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl-entry/egress (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl-entry/ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl-entry/protocol (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl-entry/rule-number (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/network-acl-entry (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-acl-entry/cidr-block :portkey.aws.ec2.network-acl-entry/egress :portkey.aws.ec2/icmp-type-code :portkey.aws.ec2.network-acl-entry/ipv-6-cidr-block :portkey.aws.ec2/port-range :portkey.aws.ec2.network-acl-entry/protocol :portkey.aws.ec2/rule-action :portkey.aws.ec2.network-acl-entry/rule-number]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/nat-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/destination-ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/vpc-peering-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-request/egress-only-internet-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-route-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-route-request/route-table-id] :opt-un [:portkey.aws.ec2.create-route-request/transit-gateway-id :portkey.aws.ec2.create-route-request/dry-run :portkey.aws.ec2.create-route-request/instance-id :portkey.aws.ec2.create-route-request/nat-gateway-id :portkey.aws.ec2.create-route-request/network-interface-id :portkey.aws.ec2.create-route-request/destination-ipv-6-cidr-block :portkey.aws.ec2.create-route-request/destination-cidr-block :portkey.aws.ec2.create-route-request/vpc-peering-connection-id :portkey.aws.ec2.create-route-request/gateway-id :portkey.aws.ec2.create-route-request/egress-only-internet-gateway-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.terminate-connection-status/connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.terminate-connection-status/previous-status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-connection-status))
(clojure.spec.alpha/def :portkey.aws.ec2.terminate-connection-status/current-status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-connection-status))
(clojure.spec.alpha/def :portkey.aws.ec2/terminate-connection-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.terminate-connection-status/connection-id :portkey.aws.ec2.terminate-connection-status/previous-status :portkey.aws.ec2.terminate-connection-status/current-status]))

(clojure.spec.alpha/def :portkey.aws.ec2.provisioned-bandwidth/provision-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.provisioned-bandwidth/provisioned (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.provisioned-bandwidth/request-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.provisioned-bandwidth/requested (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.provisioned-bandwidth/status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/provisioned-bandwidth (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.provisioned-bandwidth/provision-time :portkey.aws.ec2.provisioned-bandwidth/provisioned :portkey.aws.ec2.provisioned-bandwidth/request-time :portkey.aws.ec2.provisioned-bandwidth/requested :portkey.aws.ec2.provisioned-bandwidth/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-capacity-reservation-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-capacity-reservation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cancel-capacity-reservation-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-transit-gateway-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/transit-gateway]))

(clojure.spec.alpha/def :portkey.aws.ec2.pci-id/device-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.pci-id/vendor-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.pci-id/subsystem-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.pci-id/subsystem-vendor-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/pci-id (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.pci-id/device-id :portkey.aws.ec2.pci-id/vendor-id :portkey.aws.ec2.pci-id/subsystem-id :portkey.aws.ec2.pci-id/subsystem-vendor-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/vgw-telemetry-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/vgw-telemetry))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-state #{:deleted "deleting" :creating "error" "in-use" :deleting :inuse "creating" "deleted" :error :available "available"})

(clojure.spec.alpha/def :portkey.aws.ec2.spot-placement/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-placement/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-placement (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-placement/availability-zone :portkey.aws.ec2.spot-placement/group-name :portkey.aws.ec2/tenancy]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-classic-link-result/vpcs (clojure.spec.alpha/and :portkey.aws.ec2/vpc-classic-link-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-classic-link-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-classic-link-result/vpcs]))

(clojure.spec.alpha/def :portkey.aws.ec2.security-group/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.security-group/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.security-group/ip-permissions (clojure.spec.alpha/and :portkey.aws.ec2/ip-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.security-group/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.security-group/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.security-group/ip-permissions-egress (clojure.spec.alpha/and :portkey.aws.ec2/ip-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.security-group/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.security-group/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/security-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.security-group/description :portkey.aws.ec2.security-group/group-name :portkey.aws.ec2.security-group/ip-permissions :portkey.aws.ec2.security-group/owner-id :portkey.aws.ec2.security-group/group-id :portkey.aws.ec2.security-group/ip-permissions-egress :portkey.aws.ec2.security-group/tags :portkey.aws.ec2.security-group/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/recurring-charges-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/recurring-charge))

(clojure.spec.alpha/def :portkey.aws.ec2/snapshot-detail-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/snapshot-detail))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-endpoint-connection-notifications-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-endpoint-connection-notifications-request/connection-notification-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpc-endpoint-connection-notifications-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-vpc-endpoint-connection-notifications-request/connection-notification-ids] :opt-un [:portkey.aws.ec2.delete-vpc-endpoint-connection-notifications-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/occurrence-day-request-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/integer))

(clojure.spec.alpha/def :portkey.aws.ec2.id-format/deadline (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.id-format/resource (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.id-format/use-long-ids (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/id-format (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.id-format/deadline :portkey.aws.ec2.id-format/resource :portkey.aws.ec2.id-format/use-long-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-specification/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-specification/launch-template-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-specification/version (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-specification/launch-template-id :portkey.aws.ec2.launch-template-specification/launch-template-name :portkey.aws.ec2.launch-template-specification/version]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-byoip-cidrs-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-byoip-cidrs-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2/max-results] :opt-un [:portkey.aws.ec2.describe-byoip-cidrs-request/dry-run :portkey.aws.ec2/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-dhcp-options-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/dhcp-options]))

(clojure.spec.alpha/def :portkey.aws.ec2.volume/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.volume/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.volume/attachments (clojure.spec.alpha/and :portkey.aws.ec2/volume-attachment-list))
(clojure.spec.alpha/def :portkey.aws.ec2.volume/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume/size (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.volume/iops (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.volume/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume/create-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.volume/state (clojure.spec.alpha/and :portkey.aws.ec2/volume-state))
(clojure.spec.alpha/def :portkey.aws.ec2.volume/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/volume (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.volume/encrypted :portkey.aws.ec2.volume/tags :portkey.aws.ec2.volume/attachments :portkey.aws.ec2.volume/availability-zone :portkey.aws.ec2.volume/kms-key-id :portkey.aws.ec2.volume/size :portkey.aws.ec2.volume/iops :portkey.aws.ec2/volume-type :portkey.aws.ec2.volume/volume-id :portkey.aws.ec2.volume/create-time :portkey.aws.ec2.volume/state :portkey.aws.ec2.volume/snapshot-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/spot-instance-type #{:persistent :onetime "persistent" "one-time"})

(clojure.spec.alpha/def :portkey.aws.ec2.start-instances-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.start-instances-request/additional-info (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.start-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/start-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.start-instances-request/instance-ids] :opt-un [:portkey.aws.ec2.start-instances-request/additional-info :portkey.aws.ec2.start-instances-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.ebs-block-device/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.ebs-block-device/iops (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.ebs-block-device/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.ebs-block-device/volume-size (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.ebs-block-device/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.ebs-block-device/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/ebs-block-device (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.ebs-block-device/delete-on-termination :portkey.aws.ec2.ebs-block-device/iops :portkey.aws.ec2.ebs-block-device/snapshot-id :portkey.aws.ec2.ebs-block-device/volume-size :portkey.aws.ec2/volume-type :portkey.aws.ec2.ebs-block-device/encrypted :portkey.aws.ec2.ebs-block-device/kms-key-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.new-dhcp-configuration/key (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.new-dhcp-configuration/values (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/new-dhcp-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.new-dhcp-configuration/key :portkey.aws.ec2.new-dhcp-configuration/values]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-interface-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-interface-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-network-interface-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-network-interface-request/network-interface-id] :opt-un [:portkey.aws.ec2.delete-network-interface-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.cidr-authorization-context/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.cidr-authorization-context/signature (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/cidr-authorization-context (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.cidr-authorization-context/message :portkey.aws.ec2.cidr-authorization-context/signature] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/service-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/vpc-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/connection-notification-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/connection-events (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpc-endpoint-connection-notification-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/connection-notification-arn :portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/connection-events] :opt-un [:portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/dry-run :portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/service-id :portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/vpc-endpoint-id :portkey.aws.ec2.create-vpc-endpoint-connection-notification-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/spot-fleet-tag-specification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/spot-fleet-tag-specification))

(clojure.spec.alpha/def :portkey.aws.ec2.assign-ipv-6-addresses-result/assigned-ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/ipv-6-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.assign-ipv-6-addresses-result/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/assign-ipv-6-addresses-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.assign-ipv-6-addresses-result/assigned-ipv-6-addresses :portkey.aws.ec2.assign-ipv-6-addresses-result/network-interface-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.placement/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.placement/affinity (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.placement/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.placement/partition-number (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.placement/host-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.placement/spread-domain (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/placement (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.placement/availability-zone :portkey.aws.ec2.placement/affinity :portkey.aws.ec2.placement/group-name :portkey.aws.ec2.placement/partition-number :portkey.aws.ec2.placement/host-id :portkey.aws.ec2/tenancy :portkey.aws.ec2.placement/spread-domain]))

(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/request-host-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-configuration/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-configuration/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-configuration/platform (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-configuration/scope (clojure.spec.alpha/and :portkey.aws.ec2/scope))
(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reserved-instances-configuration/availability-zone :portkey.aws.ec2.reserved-instances-configuration/instance-count :portkey.aws.ec2/instance-type :portkey.aws.ec2.reserved-instances-configuration/platform :portkey.aws.ec2.reserved-instances-configuration/scope]))

(clojure.spec.alpha/def :portkey.aws.ec2/interface-permission-type #{:eipassociate "EIP-ASSOCIATE" :instanceattach "INSTANCE-ATTACH"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/volume-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-attribute-request/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-volume-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-volume-attribute-request/attribute :portkey.aws.ec2.describe-volume-attribute-request/volume-id] :opt-un [:portkey.aws.ec2.describe-volume-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.user-bucket-details/s-3-bucket (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.user-bucket-details/s-3-key (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/user-bucket-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.user-bucket-details/s-3-bucket :portkey.aws.ec2.user-bucket-details/s-3-key]))

(clojure.spec.alpha/def :portkey.aws.ec2/pool-max-results (clojure.spec.alpha/int-in 1 10))

(clojure.spec.alpha/def :portkey.aws.ec2/occurrence-day-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/integer))

(clojure.spec.alpha/def :portkey.aws.ec2/snapshot-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/snapshot))

(clojure.spec.alpha/def :portkey.aws.ec2/modify-volume-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/volume-modification]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-lifecycle-type #{"spot" "scheduled" :scheduled :spot})

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/transit-gateway-route))

(clojure.spec.alpha/def :portkey.aws.ec2.export-client-vpn-client-configuration-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.export-client-vpn-client-configuration-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/export-client-vpn-client-configuration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.export-client-vpn-client-configuration-request/client-vpn-endpoint-id] :opt-un [:portkey.aws.ec2.export-client-vpn-client-configuration-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/license-specification-list-request (clojure.spec.alpha/coll-of :portkey.aws.ec2/license-configuration-request))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-request/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-launch-template-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-launch-template-request/dry-run :portkey.aws.ec2.delete-launch-template-request/launch-template-id :portkey.aws.ec2/launch-template-name]))

(clojure.spec.alpha/def :portkey.aws.ec2.unmonitor-instances-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.unmonitor-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/unmonitor-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.unmonitor-instances-request/instance-ids] :opt-un [:portkey.aws.ec2.unmonitor-instances-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/availability-zone-state #{:unavailable "impaired" :information :impaired :available "information" "unavailable" "available"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-result/volumes (clojure.spec.alpha/and :portkey.aws.ec2/volume-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-volumes-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-volumes-result/volumes :portkey.aws.ec2.describe-volumes-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-snapshot-request/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-snapshot-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-snapshot-request/snapshot-id] :opt-un [:portkey.aws.ec2.delete-snapshot-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-conversion-tasks-result/conversion-tasks (clojure.spec.alpha/and :portkey.aws.ec2/describe-conversion-task-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-conversion-tasks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-conversion-tasks-result/conversion-tasks]))

(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-endpoint-status-code #{:pendingassociate :deleted "deleting" :deleting "pending-associate" "deleted" :available "available"})

(clojure.spec.alpha/def :portkey.aws.ec2.subnet/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/default-for-az (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/available-ip-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/subnet-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/assign-ipv-6-address-on-creation (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/state (clojure.spec.alpha/and :portkey.aws.ec2/subnet-state))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/map-public-ip-on-launch (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/ipv-6-cidr-block-association-set (clojure.spec.alpha/and :portkey.aws.ec2/subnet-ipv-6-cidr-block-association-set))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet/availability-zone-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/subnet (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.subnet/subnet-id :portkey.aws.ec2.subnet/owner-id :portkey.aws.ec2.subnet/default-for-az :portkey.aws.ec2.subnet/tags :portkey.aws.ec2.subnet/available-ip-address-count :portkey.aws.ec2.subnet/availability-zone :portkey.aws.ec2.subnet/cidr-block :portkey.aws.ec2.subnet/subnet-arn :portkey.aws.ec2.subnet/vpc-id :portkey.aws.ec2.subnet/assign-ipv-6-address-on-creation :portkey.aws.ec2.subnet/state :portkey.aws.ec2.subnet/map-public-ip-on-launch :portkey.aws.ec2.subnet/ipv-6-cidr-block-association-set :portkey.aws.ec2.subnet/availability-zone-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.authorize-client-vpn-ingress-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-client-vpn-ingress-request/target-network-cidr (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-client-vpn-ingress-request/access-group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-client-vpn-ingress-request/authorize-all-groups (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-client-vpn-ingress-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-client-vpn-ingress-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/authorize-client-vpn-ingress-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.authorize-client-vpn-ingress-request/client-vpn-endpoint-id :portkey.aws.ec2.authorize-client-vpn-ingress-request/target-network-cidr] :opt-un [:portkey.aws.ec2.authorize-client-vpn-ingress-request/access-group-id :portkey.aws.ec2.authorize-client-vpn-ingress-request/authorize-all-groups :portkey.aws.ec2.authorize-client-vpn-ingress-request/description :portkey.aws.ec2.authorize-client-vpn-ingress-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-listings-result/reserved-instances-listings (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-listing-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-reserved-instances-listings-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-reserved-instances-listings-result/reserved-instances-listings]))

(clojure.spec.alpha/def :portkey.aws.ec2/terminate-connection-status-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/terminate-connection-status))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/associate-public-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/instance-ipv-6-address-list-request))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/device-index (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/groups (clojure.spec.alpha/and :portkey.aws.ec2/security-group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/private-ip-addresses (clojure.spec.alpha/and :portkey.aws.ec2/private-ip-address-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/secondary-private-ip-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/ipv-6-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-instance-network-interface-specification-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-instance-network-interface-specification-request/associate-public-ip-address :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/ipv-6-addresses :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/subnet-id :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/network-interface-id :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/device-index :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/description :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/groups :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/delete-on-termination :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/private-ip-addresses :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/secondary-private-ip-address-count :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/private-ip-address :portkey.aws.ec2.launch-template-instance-network-interface-specification-request/ipv-6-address-count]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-instances-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-instances-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-instances-request/spot-fleet-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-fleet-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-spot-fleet-instances-request/spot-fleet-request-id] :opt-un [:portkey.aws.ec2.describe-spot-fleet-instances-request/dry-run :portkey.aws.ec2.describe-spot-fleet-instances-request/max-results :portkey.aws.ec2.describe-spot-fleet-instances-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation-specification-response/capacity-reservation-target (clojure.spec.alpha/and :portkey.aws.ec2/capacity-reservation-target-response))
(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation-specification-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/capacity-reservation-preference :portkey.aws.ec2.capacity-reservation-specification-response/capacity-reservation-target]))

(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-request/disk-container (clojure.spec.alpha/and :portkey.aws.ec2/snapshot-disk-container))
(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-request/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-request/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-request/role-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/import-snapshot-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/client-data :portkey.aws.ec2.import-snapshot-request/client-token :portkey.aws.ec2.import-snapshot-request/description :portkey.aws.ec2.import-snapshot-request/disk-container :portkey.aws.ec2.import-snapshot-request/dry-run :portkey.aws.ec2.import-snapshot-request/encrypted :portkey.aws.ec2.import-snapshot-request/kms-key-id :portkey.aws.ec2.import-snapshot-request/role-name]))

(clojure.spec.alpha/def :portkey.aws.ec2.authorize-client-vpn-ingress-result/status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-authorization-rule-status))
(clojure.spec.alpha/def :portkey.aws.ec2/authorize-client-vpn-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.authorize-client-vpn-ingress-result/status]))

(clojure.spec.alpha/def :portkey.aws.ec2/dhcp-configuration-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/dhcp-configuration))

(clojure.spec.alpha/def :portkey.aws.ec2.create-reserved-instances-listing-result/reserved-instances-listings (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-listing-list))
(clojure.spec.alpha/def :portkey.aws.ec2/create-reserved-instances-listing-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-reserved-instances-listing-result/reserved-instances-listings]))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-datafeed-subscription/bucket (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-datafeed-subscription/fault (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-state-fault))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-datafeed-subscription/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-datafeed-subscription/prefix (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-datafeed-subscription/state (clojure.spec.alpha/and :portkey.aws.ec2/datafeed-subscription-state))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-datafeed-subscription (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-datafeed-subscription/bucket :portkey.aws.ec2.spot-datafeed-subscription/fault :portkey.aws.ec2.spot-datafeed-subscription/owner-id :portkey.aws.ec2.spot-datafeed-subscription/prefix :portkey.aws.ec2.spot-datafeed-subscription/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-image-tasks-result/import-image-tasks (clojure.spec.alpha/and :portkey.aws.ec2/import-image-task-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-image-tasks-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-import-image-tasks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-import-image-tasks-result/import-image-tasks :portkey.aws.ec2.describe-import-image-tasks-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-request/service-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoint-service-permissions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-vpc-endpoint-service-permissions-request/service-id] :opt-un [:portkey.aws.ec2.describe-vpc-endpoint-service-permissions-request/dry-run :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-request/filters :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-request/max-results :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-activity-status #{:pendingtermination :pendingfulfillment "error" "pending-termination" :fulfilled :error "fulfilled" "pending-fulfillment"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-status-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-status-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-status-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-status-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-status-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-status-request/include-all-instances (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-instance-status-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-instance-status-request/filters :portkey.aws.ec2.describe-instance-status-request/instance-ids :portkey.aws.ec2.describe-instance-status-request/max-results :portkey.aws.ec2.describe-instance-status-request/next-token :portkey.aws.ec2.describe-instance-status-request/dry-run :portkey.aws.ec2.describe-instance-status-request/include-all-instances]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-count/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-count/state (clojure.spec.alpha/and :portkey.aws.ec2/listing-state))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-count (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-count/instance-count :portkey.aws.ec2.instance-count/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.disable-vpc-classic-link-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.disable-vpc-classic-link-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/disable-vpc-classic-link-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.disable-vpc-classic-link-request/vpc-id] :opt-un [:portkey.aws.ec2.disable-vpc-classic-link-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/host-instance-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/host-instance))

(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/security-group-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/placement (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-placement))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/security-groups (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/instance-market-options (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-instance-market-options))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/elastic-inference-accelerators (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-elastic-inference-accelerator-response-list))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/elastic-gpu-specifications (clojure.spec.alpha/and :portkey.aws.ec2/elastic-gpu-specification-response-list))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/license-specifications (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-license-list))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/ram-disk-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/disable-api-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/hibernation-options (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-hibernation-options))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/monitoring (clojure.spec.alpha/and :portkey.aws.ec2/launch-templates-monitoring))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-block-device-mapping-list))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/capacity-reservation-specification (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-capacity-reservation-specification-response))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/cpu-options (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-cpu-options))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/user-data (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/instance-initiated-shutdown-behavior (clojure.spec.alpha/and :portkey.aws.ec2/shutdown-behavior))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/iam-instance-profile (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-iam-instance-profile-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.response-launch-template-data/network-interfaces (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-instance-network-interface-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2/response-launch-template-data (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.response-launch-template-data/tag-specifications :portkey.aws.ec2.response-launch-template-data/kernel-id :portkey.aws.ec2/credit-specification :portkey.aws.ec2.response-launch-template-data/security-group-ids :portkey.aws.ec2.response-launch-template-data/image-id :portkey.aws.ec2.response-launch-template-data/placement :portkey.aws.ec2.response-launch-template-data/security-groups :portkey.aws.ec2.response-launch-template-data/ebs-optimized :portkey.aws.ec2.response-launch-template-data/instance-market-options :portkey.aws.ec2/instance-type :portkey.aws.ec2.response-launch-template-data/elastic-inference-accelerators :portkey.aws.ec2.response-launch-template-data/key-name :portkey.aws.ec2.response-launch-template-data/elastic-gpu-specifications :portkey.aws.ec2.response-launch-template-data/license-specifications :portkey.aws.ec2.response-launch-template-data/ram-disk-id :portkey.aws.ec2.response-launch-template-data/disable-api-termination :portkey.aws.ec2.response-launch-template-data/hibernation-options :portkey.aws.ec2.response-launch-template-data/monitoring :portkey.aws.ec2.response-launch-template-data/block-device-mappings :portkey.aws.ec2.response-launch-template-data/capacity-reservation-specification :portkey.aws.ec2.response-launch-template-data/cpu-options :portkey.aws.ec2.response-launch-template-data/user-data :portkey.aws.ec2.response-launch-template-data/instance-initiated-shutdown-behavior :portkey.aws.ec2.response-launch-template-data/iam-instance-profile :portkey.aws.ec2.response-launch-template-data/network-interfaces]))

(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-volume-detail-item/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-volume-detail-item/bytes-converted (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-volume-detail-item/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-volume-detail-item/image (clojure.spec.alpha/and :portkey.aws.ec2/disk-image-description))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-volume-detail-item/status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-volume-detail-item/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-volume-detail-item/volume (clojure.spec.alpha/and :portkey.aws.ec2/disk-image-volume-description))
(clojure.spec.alpha/def :portkey.aws.ec2/import-instance-volume-detail-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.import-instance-volume-detail-item/availability-zone :portkey.aws.ec2.import-instance-volume-detail-item/bytes-converted :portkey.aws.ec2.import-instance-volume-detail-item/description :portkey.aws.ec2.import-instance-volume-detail-item/image :portkey.aws.ec2.import-instance-volume-detail-item/status :portkey.aws.ec2.import-instance-volume-detail-item/status-message :portkey.aws.ec2.import-instance-volume-detail-item/volume]))

(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-specification/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-specification/version (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/fleet-launch-template-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.fleet-launch-template-specification/launch-template-id :portkey.aws.ec2/launch-template-name :portkey.aws.ec2.fleet-launch-template-specification/version]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-image-tasks-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-image-tasks-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-image-tasks-request/import-task-ids (clojure.spec.alpha/and :portkey.aws.ec2/import-task-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-image-tasks-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-image-tasks-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-import-image-tasks-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-import-image-tasks-request/dry-run :portkey.aws.ec2.describe-import-image-tasks-request/filters :portkey.aws.ec2.describe-import-image-tasks-request/import-task-ids :portkey.aws.ec2.describe-import-image-tasks-request/max-results :portkey.aws.ec2.describe-import-image-tasks-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-endpoints-result/client-vpn-endpoints (clojure.spec.alpha/and :portkey.aws.ec2/endpoint-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-client-vpn-endpoints-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-client-vpn-endpoints-result/client-vpn-endpoints :portkey.aws.ec2/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/delete-fleet-success-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/delete-fleet-success-item))

(clojure.spec.alpha/def :portkey.aws.ec2.copy-snapshot-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-snapshot-request/destination-region (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-snapshot-request/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-snapshot-request/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-snapshot-request/presigned-url (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-snapshot-request/source-region (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-snapshot-request/source-snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-snapshot-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/copy-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.copy-snapshot-request/source-region :portkey.aws.ec2.copy-snapshot-request/source-snapshot-id] :opt-un [:portkey.aws.ec2.copy-snapshot-request/description :portkey.aws.ec2.copy-snapshot-request/destination-region :portkey.aws.ec2.copy-snapshot-request/encrypted :portkey.aws.ec2.copy-snapshot-request/kms-key-id :portkey.aws.ec2.copy-snapshot-request/presigned-url :portkey.aws.ec2.copy-snapshot-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-credit-specifications-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-credit-specifications-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-credit-specifications-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-credit-specifications-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/describe-instance-credit-specifications-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-credit-specifications-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-instance-credit-specifications-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-instance-credit-specifications-request/dry-run :portkey.aws.ec2.describe-instance-credit-specifications-request/filters :portkey.aws.ec2.describe-instance-credit-specifications-request/instance-ids :portkey.aws.ec2.describe-instance-credit-specifications-request/max-results :portkey.aws.ec2.describe-instance-credit-specifications-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection-options-specification/static-routes-only (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection-options-specification/tunnel-options (clojure.spec.alpha/and :portkey.aws.ec2/tunnel-options-list))
(clojure.spec.alpha/def :portkey.aws.ec2/vpn-connection-options-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpn-connection-options-specification/static-routes-only :portkey.aws.ec2.vpn-connection-options-specification/tunnel-options]))

(clojure.spec.alpha/def :portkey.aws.ec2/tenancy #{"host" :default :host "dedicated" :dedicated "default"})

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-offering-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/ipv-6-support-value #{:disable :enable "enable" "disable"})

(clojure.spec.alpha/def :portkey.aws.ec2.delete-internet-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-internet-gateway-request/internet-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-internet-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-internet-gateway-request/internet-gateway-id] :opt-un [:portkey.aws.ec2.delete-internet-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-security-group-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-result/fleets (clojure.spec.alpha/and :portkey.aws.ec2/fleet-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fleets-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-fleets-result/next-token :portkey.aws.ec2.describe-fleets-result/fleets]))

(clojure.spec.alpha/def :portkey.aws.ec2.attach-volume-request/device (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-volume-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-volume-request/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-volume-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/attach-volume-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.attach-volume-request/device :portkey.aws.ec2.attach-volume-request/instance-id :portkey.aws.ec2.attach-volume-request/volume-id] :opt-un [:portkey.aws.ec2.attach-volume-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/affinity #{"host" :default :host "default"})

(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-attachment/attach-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-attachment/attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-attachment/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-attachment/device-index (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-attachment/status (clojure.spec.alpha/and :portkey.aws.ec2/attachment-status))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-network-interface-attachment (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-network-interface-attachment/attach-time :portkey.aws.ec2.instance-network-interface-attachment/attachment-id :portkey.aws.ec2.instance-network-interface-attachment/delete-on-termination :portkey.aws.ec2.instance-network-interface-attachment/device-index :portkey.aws.ec2.instance-network-interface-attachment/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-status-result/instance-statuses (clojure.spec.alpha/and :portkey.aws.ec2/instance-status-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-status-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-instance-status-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-instance-status-result/instance-statuses :portkey.aws.ec2.describe-instance-status-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-identity-id-format-request/principal-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-identity-id-format-request/resource (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-identity-id-format-request/use-long-ids (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-identity-id-format-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-identity-id-format-request/principal-arn :portkey.aws.ec2.modify-identity-id-format-request/resource :portkey.aws.ec2.modify-identity-id-format-request/use-long-ids] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-detail/disk-image-size (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-detail/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-detail/format (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-detail/status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-detail/progress (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-detail/url (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-detail/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-detail/device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-detail/user-bucket (clojure.spec.alpha/and :portkey.aws.ec2/user-bucket-details))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-detail/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/snapshot-detail (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.snapshot-detail/disk-image-size :portkey.aws.ec2.snapshot-detail/status-message :portkey.aws.ec2.snapshot-detail/format :portkey.aws.ec2.snapshot-detail/status :portkey.aws.ec2.snapshot-detail/progress :portkey.aws.ec2.snapshot-detail/url :portkey.aws.ec2.snapshot-detail/description :portkey.aws.ec2.snapshot-detail/device-name :portkey.aws.ec2.snapshot-detail/user-bucket :portkey.aws.ec2.snapshot-detail/snapshot-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-response-success-item/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-response-success-item/launch-template-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-response-success-item/version-number (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-launch-template-versions-response-success-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-launch-template-versions-response-success-item/launch-template-id :portkey.aws.ec2.delete-launch-template-versions-response-success-item/launch-template-name :portkey.aws.ec2.delete-launch-template-versions-response-success-item/version-number]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-export-task-request/export-task-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-export-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.cancel-export-task-request/export-task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/fpga-image-global-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/shell-version (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/update-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/owner-alias (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/public (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/fpga-image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/create-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/product-codes (clojure.spec.alpha/and :portkey.aws.ec2/product-code-list))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/state (clojure.spec.alpha/and :portkey.aws.ec2/fpga-image-state))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/fpga-image (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.fpga-image/fpga-image-global-id :portkey.aws.ec2.fpga-image/shell-version :portkey.aws.ec2/pci-id :portkey.aws.ec2.fpga-image/update-time :portkey.aws.ec2.fpga-image/owner-id :portkey.aws.ec2.fpga-image/tags :portkey.aws.ec2.fpga-image/owner-alias :portkey.aws.ec2.fpga-image/public :portkey.aws.ec2.fpga-image/fpga-image-id :portkey.aws.ec2.fpga-image/description :portkey.aws.ec2.fpga-image/create-time :portkey.aws.ec2.fpga-image/product-codes :portkey.aws.ec2.fpga-image/state :portkey.aws.ec2.fpga-image/name]))

(clojure.spec.alpha/def :portkey.aws.ec2.advertise-byoip-cidr-request/cidr (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.advertise-byoip-cidr-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/advertise-byoip-cidr-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.advertise-byoip-cidr-request/cidr] :opt-un [:portkey.aws.ec2.advertise-byoip-cidr-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-state-fault/code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-state-fault/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-instance-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-instance-state-fault/code :portkey.aws.ec2.spot-instance-state-fault/message]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-vpc-attachment-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/transit-gateway-vpc-attachment))

(clojure.spec.alpha/def :portkey.aws.ec2.create-security-group-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-security-group-request/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-security-group-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-security-group-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-security-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-security-group-request/description :portkey.aws.ec2.create-security-group-request/group-name] :opt-un [:portkey.aws.ec2.create-security-group-request/vpc-id :portkey.aws.ec2.create-security-group-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-request/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-request/client-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-request/authentication-options (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-authentication-request-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-request/server-certificate-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-request/dns-servers (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-client-vpn-endpoint-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-client-vpn-endpoint-request/client-cidr-block :portkey.aws.ec2.create-client-vpn-endpoint-request/server-certificate-arn :portkey.aws.ec2.create-client-vpn-endpoint-request/authentication-options :portkey.aws.ec2/connection-log-options] :opt-un [:portkey.aws.ec2.create-client-vpn-endpoint-request/dry-run :portkey.aws.ec2.create-client-vpn-endpoint-request/tag-specifications :portkey.aws.ec2.create-client-vpn-endpoint-request/description :portkey.aws.ec2/transport-protocol :portkey.aws.ec2.create-client-vpn-endpoint-request/dns-servers :portkey.aws.ec2.create-client-vpn-endpoint-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/dhcp-configuration-value-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/attribute-value))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-association/ip-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-association/public-dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-association/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-network-interface-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-network-interface-association/ip-owner-id :portkey.aws.ec2.instance-network-interface-association/public-dns-name :portkey.aws.ec2.instance-network-interface-association/public-ip]))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-market-options/max-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-market-options/block-duration-minutes (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-market-options/valid-until (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-market-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-market-options/max-price :portkey.aws.ec2/spot-instance-type :portkey.aws.ec2.spot-market-options/block-duration-minutes :portkey.aws.ec2.spot-market-options/valid-until :portkey.aws.ec2/instance-interruption-behavior]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/fleet-data))

(clojure.spec.alpha/def :portkey.aws.ec2/bundle-task-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/bundle-task))

(clojure.spec.alpha/def :portkey.aws.ec2/group-name-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-placement/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-placement/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-placement (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instances-placement/availability-zone :portkey.aws.ec2.scheduled-instances-placement/group-name]))

(clojure.spec.alpha/def :portkey.aws.ec2/key-name-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/create-network-interface-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/network-interface]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateways-request/transit-gateway-ids (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateways-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateways-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateways-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateways-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-transit-gateways-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-transit-gateways-request/transit-gateway-ids :portkey.aws.ec2.describe-transit-gateways-request/filters :portkey.aws.ec2.describe-transit-gateways-request/max-results :portkey.aws.ec2.describe-transit-gateways-request/next-token :portkey.aws.ec2.describe-transit-gateways-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-event-start-time-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-event-start-time-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-event-start-time-request/instance-event-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-event-start-time-request/not-before (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-instance-event-start-time-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-instance-event-start-time-request/instance-id :portkey.aws.ec2.modify-instance-event-start-time-request/instance-event-id :portkey.aws.ec2.modify-instance-event-start-time-request/not-before] :opt-un [:portkey.aws.ec2.modify-instance-event-start-time-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-instances/launch-template-and-overrides (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-and-overrides-response))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-instances/lifecycle (clojure.spec.alpha/and :portkey.aws.ec2/instance-lifecycle))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-instances/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-ids-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-instances/platform (clojure.spec.alpha/and :portkey.aws.ec2/platform-values))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fleets-instances (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-fleets-instances/launch-template-and-overrides :portkey.aws.ec2.describe-fleets-instances/lifecycle :portkey.aws.ec2.describe-fleets-instances/instance-ids :portkey.aws.ec2/instance-type :portkey.aws.ec2.describe-fleets-instances/platform]))

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-block-device-mapping/device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-block-device-mapping/ebs (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instances-ebs))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-block-device-mapping/no-device (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-block-device-mapping/virtual-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-block-device-mapping (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instances-block-device-mapping/device-name :portkey.aws.ec2.scheduled-instances-block-device-mapping/ebs :portkey.aws.ec2.scheduled-instances-block-device-mapping/no-device :portkey.aws.ec2.scheduled-instances-block-device-mapping/virtual-name]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-instance/launch-template-and-overrides (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-and-overrides-response))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-instance/lifecycle (clojure.spec.alpha/and :portkey.aws.ec2/instance-lifecycle))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-instance/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-ids-set))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-instance/platform (clojure.spec.alpha/and :portkey.aws.ec2/platform-values))
(clojure.spec.alpha/def :portkey.aws.ec2/create-fleet-instance (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-fleet-instance/launch-template-and-overrides :portkey.aws.ec2.create-fleet-instance/lifecycle :portkey.aws.ec2.create-fleet-instance/instance-ids :portkey.aws.ec2/instance-type :portkey.aws.ec2.create-fleet-instance/platform]))

(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-ingress-request/source-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-ingress-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-ingress-request/to-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-ingress-request/source-security-group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-ingress-request/ip-protocol (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-ingress-request/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-ingress-request/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-ingress-request/from-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-ingress-request/ip-permissions (clojure.spec.alpha/and :portkey.aws.ec2/ip-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-ingress-request/cidr-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/revoke-security-group-ingress-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.revoke-security-group-ingress-request/source-security-group-owner-id :portkey.aws.ec2.revoke-security-group-ingress-request/dry-run :portkey.aws.ec2.revoke-security-group-ingress-request/to-port :portkey.aws.ec2.revoke-security-group-ingress-request/source-security-group-name :portkey.aws.ec2.revoke-security-group-ingress-request/ip-protocol :portkey.aws.ec2.revoke-security-group-ingress-request/group-name :portkey.aws.ec2.revoke-security-group-ingress-request/group-id :portkey.aws.ec2.revoke-security-group-ingress-request/from-port :portkey.aws.ec2.revoke-security-group-ingress-request/ip-permissions :portkey.aws.ec2.revoke-security-group-ingress-request/cidr-ip]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-attribute-result/attachment (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-attachment))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-attribute-result/description (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-attribute-result/groups (clojure.spec.alpha/and :portkey.aws.ec2/group-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-attribute-result/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-attribute-result/source-dest-check (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-network-interface-attribute-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-network-interface-attribute-result/attachment :portkey.aws.ec2.describe-network-interface-attribute-result/description :portkey.aws.ec2.describe-network-interface-attribute-result/groups :portkey.aws.ec2.describe-network-interface-attribute-result/network-interface-id :portkey.aws.ec2.describe-network-interface-attribute-result/source-dest-check]))

(clojure.spec.alpha/def :portkey.aws.ec2.attach-network-interface-result/attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/attach-network-interface-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.attach-network-interface-result/attachment-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-launch-template-config-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/fleet-launch-template-config))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-result/allowed-principals (clojure.spec.alpha/and :portkey.aws.ec2/allowed-principal-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoint-service-permissions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-endpoint-service-permissions-result/allowed-principals :portkey.aws.ec2.describe-vpc-endpoint-service-permissions-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.disk-image-volume-description/id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disk-image-volume-description/size (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2/disk-image-volume-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disk-image-volume-description/id :portkey.aws.ec2.disk-image-volume-description/size]))

(clojure.spec.alpha/def :portkey.aws.ec2/account-attribute-name #{:supportedplatforms :defaultvpc "supported-platforms" "default-vpc"})

(clojure.spec.alpha/def :portkey.aws.ec2.host-properties/cores (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.host-properties/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host-properties/sockets (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.host-properties/total-v-cpus (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/host-properties (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.host-properties/cores :portkey.aws.ec2.host-properties/instance-type :portkey.aws.ec2.host-properties/sockets :portkey.aws.ec2.host-properties/total-v-cpus]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpn-connection-route-request/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpn-connection-route-request/vpn-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpn-connection-route-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-vpn-connection-route-request/destination-cidr-block :portkey.aws.ec2.delete-vpn-connection-route-request/vpn-connection-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-fpga-image-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-fpga-image-request/fpga-image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-fpga-image-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-fpga-image-request/fpga-image-id] :opt-un [:portkey.aws.ec2.delete-fpga-image-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-key-pair-request/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-key-pair-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-key-pair-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-key-pair-request/key-name] :opt-un [:portkey.aws.ec2.create-key-pair-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-credit-specifications-result/instance-credit-specifications (clojure.spec.alpha/and :portkey.aws.ec2/instance-credit-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-credit-specifications-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-instance-credit-specifications-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-instance-credit-specifications-result/instance-credit-specifications :portkey.aws.ec2.describe-instance-credit-specifications-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-gateway-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-gateway-request/type (clojure.spec.alpha/and :portkey.aws.ec2/gateway-type))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-gateway-request/amazon-side-asn (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpn-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-vpn-gateway-request/type] :opt-un [:portkey.aws.ec2.create-vpn-gateway-request/availability-zone :portkey.aws.ec2.create-vpn-gateway-request/amazon-side-asn :portkey.aws.ec2.create-vpn-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/association-status-code #{:associating "associating" :associated "disassociated" :disassociated "associated" :disassociating :associationfailed "disassociating" "association-failed"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interfaces-result/network-interfaces (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interfaces-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-network-interfaces-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-network-interfaces-result/network-interfaces :portkey.aws.ec2.describe-network-interfaces-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-permissions-result/network-interface-permissions (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-permissions-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-network-interface-permissions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-network-interface-permissions-result/network-interface-permissions :portkey.aws.ec2.describe-network-interface-permissions-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.replace-iam-instance-profile-association-request/iam-instance-profile (clojure.spec.alpha/and :portkey.aws.ec2/iam-instance-profile-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-iam-instance-profile-association-request/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/replace-iam-instance-profile-association-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.replace-iam-instance-profile-association-request/iam-instance-profile :portkey.aws.ec2.replace-iam-instance-profile-association-request/association-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.create-fpga-image-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fpga-image-request/input-storage-location (clojure.spec.alpha/and :portkey.aws.ec2/storage-location))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fpga-image-request/logs-storage-location (clojure.spec.alpha/and :portkey.aws.ec2/storage-location))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fpga-image-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fpga-image-request/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fpga-image-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-fpga-image-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-fpga-image-request/input-storage-location] :opt-un [:portkey.aws.ec2.create-fpga-image-request/dry-run :portkey.aws.ec2.create-fpga-image-request/logs-storage-location :portkey.aws.ec2.create-fpga-image-request/description :portkey.aws.ec2.create-fpga-image-request/name :portkey.aws.ec2.create-fpga-image-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-response-error-item/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-response-error-item/launch-template-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-response-error-item/version-number (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-launch-template-versions-response-error-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-launch-template-versions-response-error-item/launch-template-id :portkey.aws.ec2.delete-launch-template-versions-response-error-item/launch-template-name :portkey.aws.ec2.delete-launch-template-versions-response-error-item/version-number :portkey.aws.ec2/response-error]))

(clojure.spec.alpha/def :portkey.aws.ec2.enable-vgw-route-propagation-request/gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.enable-vgw-route-propagation-request/route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/enable-vgw-route-propagation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.enable-vgw-route-propagation-request/gateway-id :portkey.aws.ec2.enable-vgw-route-propagation-request/route-table-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/platform (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/term-end-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/network-platform (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/recurrence (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instance-recurrence))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/create-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/next-slot-start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/total-scheduled-instance-hours (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/hourly-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/slot-duration-in-hours (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/previous-slot-end-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/scheduled-instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance/term-start-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instance (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instance/platform :portkey.aws.ec2.scheduled-instance/term-end-date :portkey.aws.ec2.scheduled-instance/network-platform :portkey.aws.ec2.scheduled-instance/instance-count :portkey.aws.ec2.scheduled-instance/recurrence :portkey.aws.ec2.scheduled-instance/create-date :portkey.aws.ec2.scheduled-instance/instance-type :portkey.aws.ec2.scheduled-instance/next-slot-start-time :portkey.aws.ec2.scheduled-instance/total-scheduled-instance-hours :portkey.aws.ec2.scheduled-instance/availability-zone :portkey.aws.ec2.scheduled-instance/hourly-price :portkey.aws.ec2.scheduled-instance/slot-duration-in-hours :portkey.aws.ec2.scheduled-instance/previous-slot-end-time :portkey.aws.ec2.scheduled-instance/scheduled-instance-id :portkey.aws.ec2.scheduled-instance/term-start-date]))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-transit-gateway-route-table-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-transit-gateway-route-table-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-transit-gateway-route-table-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-transit-gateway-route-table-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.disassociate-transit-gateway-route-table-request/transit-gateway-route-table-id :portkey.aws.ec2.disassociate-transit-gateway-route-table-request/transit-gateway-attachment-id] :opt-un [:portkey.aws.ec2.disassociate-transit-gateway-route-table-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides-request/max-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides-request/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides-request/weighted-capacity (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides-request/priority (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2/fleet-launch-template-overrides-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/instance-type :portkey.aws.ec2.fleet-launch-template-overrides-request/max-price :portkey.aws.ec2.fleet-launch-template-overrides-request/subnet-id :portkey.aws.ec2.fleet-launch-template-overrides-request/availability-zone :portkey.aws.ec2.fleet-launch-template-overrides-request/weighted-capacity :portkey.aws.ec2.fleet-launch-template-overrides-request/priority :portkey.aws.ec2/placement]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-default-subnet-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/subnet]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-tenancy #{:default "default"})

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment-association/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment-association/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-association-state))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-attachment-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-attachment-association/transit-gateway-route-table-id :portkey.aws.ec2.transit-gateway-attachment-association/state]))

(clojure.spec.alpha/def :portkey.aws.ec2/active-instance-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/active-instance))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-type #{:r-3large :i-3large :c-4xlarge "m1.large" :m-524xlarge "t3.small" :a-1medium :c-3xlarge "cc1.4xlarge" :cg-14xlarge "z1d.large" :i-28xlarge :r-48xlarge :t-2small "x1e.32xlarge" "r5d.xlarge" "r5a.large" :c-518xlarge "r5a.xlarge" :c-1xlarge :r-5d-12xlarge "m5d.24xlarge" "c1.medium" "r4.2xlarge" :c-48xlarge :x-1exlarge "r3.8xlarge" "r5.4xlarge" "d2.xlarge" "m3.2xlarge" :c-5n-18xlarge "i2.8xlarge" "h1.16xlarge" "m5.xlarge" "r5a.2xlarge" "t3.2xlarge" "g2.2xlarge" :m-5xlarge :m-52xlarge "g3.8xlarge" :z-1d-12xlarge :c-5d-4xlarge "t3.xlarge" :z-1d-2xlarge "c3.8xlarge" :i-38xlarge :m-5a-2xlarge "t2.large" :r-5dmetal "x1e.4xlarge" "t3.nano" :u-9tb-1metal :m-512xlarge :m-42xlarge "p2.16xlarge" "m1.xlarge" "m5a.24xlarge" :g-34xlarge "d2.8xlarge" "r5d.large" "m4.4xlarge" :r-5dxlarge :m-5large "t2.2xlarge" "r4.16xlarge" :t-2large "u-12tb1.metal" :c-34xlarge "r5d.4xlarge" :x-116xlarge :r-512xlarge "g3.16xlarge" "z1d.2xlarge" "t3.large" "h1.2xlarge" :c-5large "g3.4xlarge" "cr1.8xlarge" "t1.micro" :x-1e-16xlarge "a1.2xlarge" "c5d.large" :d-28xlarge :x-1e-4xlarge :g-3sxlarge "r5a.24xlarge" :m-5alarge :r-524xlarge "z1d.xlarge" :r-5a-4xlarge :r-5d-24xlarge :r-34xlarge "c5.4xlarge" "p3dn.24xlarge" :z-1d-6xlarge :m-32xlarge "c3.2xlarge" "g2.8xlarge" "z1d.3xlarge" "c5d.18xlarge" :m-54xlarge :r-5d-4xlarge :t-2xlarge "c4.8xlarge" "c5.18xlarge" :r-4large "x1e.2xlarge" "r5.metal" "z1d.6xlarge" :g-22xlarge :h-18xlarge :c-3large "m2.xlarge" "m1.small" "i2.4xlarge" "c3.4xlarge" "i3.16xlarge" :i-3metal :t-2micro :m-5d-4xlarge :c-38xlarge "t2.micro" :c-5n-9xlarge :r-416xlarge "z1d.metal" :g-316xlarge :p-316xlarge "g3s.xlarge" "d2.2xlarge" :r-5axlarge "x1.32xlarge" :r-38xlarge "m4.2xlarge" "r5d.24xlarge" :r-32xlarge :c-52xlarge "u-6tb1.metal" "i3.4xlarge" :r-5xlarge :t-3xlarge :p-32xlarge "m4.10xlarge" "i3.metal" "m1.medium" "c5n.xlarge" :cc-14xlarge "c4.4xlarge" :c-5n-2xlarge "hi1.4xlarge" :d-2xlarge :c-5nlarge :i-2xlarge "r3.xlarge" "c5n.large" :t-3large :m-5dmetal "x1e.16xlarge" :i-32xlarge :c-44xlarge :a-12xlarge :m-22xlarge "m5.large" :t-2medium "r5.xlarge" :r-5a-12xlarge :r-3xlarge "c4.2xlarge" :m-416xlarge "i3.8xlarge" "p3.2xlarge" :m-5dlarge "m5.4xlarge" "t3.medium" :c-5n-4xlarge "u-9tb1.metal" :r-42xlarge :c-59xlarge :i-22xlarge "t2.small" :m-1small :c-5d-9xlarge "c5n.4xlarge" "r4.xlarge" :t-22xlarge :u-12tb-1metal "m5a.2xlarge" "m5.2xlarge" :m-3large "z1d.12xlarge" "t3.micro" :a-14xlarge "c5.large" "c5.2xlarge" :m-5a-4xlarge :f-14xlarge "f1.2xlarge" "m5d.4xlarge" "c5d.xlarge" :r-52xlarge "m3.xlarge" :g-38xlarge :m-5d-12xlarge "c5d.9xlarge" "r3.2xlarge" "m5d.metal" :c-32xlarge :p-38xlarge "cg1.4xlarge" :c-42xlarge :c-5d-2xlarge :z-1dlarge "r3.4xlarge" :r-44xlarge :m-5axlarge :p-2xlarge :hs-18xlarge :t-2nano :m-44xlarge :p-3dn-24xlarge :i-34xlarge :m-24xlarge "t2.xlarge" "c4.xlarge" "m2.2xlarge" :m-5a-24xlarge "f1.4xlarge" :c-54xlarge "r5.large" :t-3small "p2.8xlarge" :h-12xlarge "r5d.12xlarge" "m5.metal" "x1.16xlarge" "m4.large" "c5n.2xlarge" :m-410xlarge :t-3nano "m4.16xlarge" "r3.large" "d2.4xlarge" "h1.8xlarge" "i3.2xlarge" :h-116xlarge "c4.large" "h1.4xlarge" :r-5dlarge "m5d.12xlarge" :d-24xlarge :m-3medium :g-28xlarge :m-1xlarge "m4.xlarge" "m5a.large" "f1.16xlarge" "r5.12xlarge" "m5a.4xlarge" "i2.2xlarge" "p3.16xlarge" :z-1d-3xlarge :a-1xlarge "i3.xlarge" :c-4large :cc-28xlarge "c5n.9xlarge" :t-32xlarge :r-4xlarge :i-24xlarge :r-5large :m-4xlarge :m-3xlarge :z-1dmetal "t2.nano" "m2.4xlarge" :f-12xlarge "r5a.4xlarge" :r-5alarge :r-5metal "r5d.metal" :r-5a-2xlarge "r4.large" "m5a.xlarge" "c3.xlarge" :m-4large "p2.xlarge" "c5d.4xlarge" :m-5metal :m-1medium :m-1large :x-1e-32xlarge :i-3xlarge "i3.large" "a1.4xlarge" "r4.8xlarge" "a1.xlarge" "t2.medium" :m-5a-12xlarge :c-5nxlarge "p3.8xlarge" "m5a.12xlarge" "c3.large" :c-1medium "m3.medium" "a1.medium" :x-1e-2xlarge "m5d.2xlarge" :u-6tb-1metal "r5d.2xlarge" :f-116xlarge :c-5dxlarge :cr-18xlarge "i2.xlarge" "m5.24xlarge" "c5n.18xlarge" "r5a.12xlarge" "c5.9xlarge" "m5d.large" :z-1dxlarge "m5.12xlarge" :h-14xlarge "cc2.8xlarge" "hs1.8xlarge" :r-5d-2xlarge :c-5d-18xlarge :t-3medium :x-132xlarge "m3.large" :m-5d-2xlarge :p-216xlarge "x1e.xlarge" "c1.xlarge" "c5d.2xlarge" :c-5xlarge "x1e.8xlarge" :t-1micro :d-22xlarge :t-3micro :a-1large "r5.2xlarge" :m-2xlarge :x-1e-8xlarge "m5d.xlarge" :p-28xlarge :r-54xlarge :c-5dlarge "a1.large" :r-5a-24xlarge "c5.xlarge" :i-316xlarge :m-5d-24xlarge "r4.4xlarge" "r5.24xlarge" :m-5dxlarge :hi-14xlarge})

(clojure.spec.alpha/def :portkey.aws.ec2/route-state #{"blackhole" :active "active" :blackhole})

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-regions-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-regions-request/region-names (clojure.spec.alpha/and :portkey.aws.ec2/region-name-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-regions-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-regions-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-regions-request/filters :portkey.aws.ec2.describe-regions-request/region-names :portkey.aws.ec2.describe-regions-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-connection-status-code #{:failedtoterminate "terminated" "failed-to-terminate" :terminating :active "terminating" :terminated "active"})

(clojure.spec.alpha/def :portkey.aws.ec2/modify-transit-gateway-vpc-attachment-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/transit-gateway-vpc-attachment]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-client-vpn-endpoint-result/status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-endpoint-status))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-client-vpn-endpoint-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-client-vpn-endpoint-result/status]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-type-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-type))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway/transit-gateway-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-state))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway/creation-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway/options (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-options))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway/transit-gateway-id :portkey.aws.ec2.transit-gateway/transit-gateway-arn :portkey.aws.ec2.transit-gateway/state :portkey.aws.ec2.transit-gateway/owner-id :portkey.aws.ec2.transit-gateway/description :portkey.aws.ec2.transit-gateway/creation-time :portkey.aws.ec2.transit-gateway/options :portkey.aws.ec2.transit-gateway/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2/subnet-state #{:pending :available "pending" "available"})

(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-authentication/type (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-authentication-type))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-authentication/active-directory (clojure.spec.alpha/and :portkey.aws.ec2/directory-service-authentication))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-authentication/mutual-authentication (clojure.spec.alpha/and :portkey.aws.ec2/certificate-authentication))
(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-authentication (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-vpn-authentication/type :portkey.aws.ec2.client-vpn-authentication/active-directory :portkey.aws.ec2.client-vpn-authentication/mutual-authentication]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/stale-ip-permission-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/stale-ip-permission))

(clojure.spec.alpha/def :portkey.aws.ec2/image-attribute-name #{:description "kernel" "productCodes" "blockDeviceMapping" :ramdisk :product-codes "launchPermission" :block-device-mapping "ramdisk" :sriov-net-support :kernel :launch-permission "description" "sriovNetSupport"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpn-connections-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpn-connections-request/vpn-connection-ids (clojure.spec.alpha/and :portkey.aws.ec2/vpn-connection-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpn-connections-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpn-connections-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpn-connections-request/filters :portkey.aws.ec2.describe-vpn-connections-request/vpn-connection-ids :portkey.aws.ec2.describe-vpn-connections-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/nat-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/destination-ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/vpc-peering-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-request/egress-only-internet-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/replace-route-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.replace-route-request/route-table-id] :opt-un [:portkey.aws.ec2.replace-route-request/transit-gateway-id :portkey.aws.ec2.replace-route-request/dry-run :portkey.aws.ec2.replace-route-request/instance-id :portkey.aws.ec2.replace-route-request/nat-gateway-id :portkey.aws.ec2.replace-route-request/network-interface-id :portkey.aws.ec2.replace-route-request/destination-ipv-6-cidr-block :portkey.aws.ec2.replace-route-request/destination-cidr-block :portkey.aws.ec2.replace-route-request/vpc-peering-connection-id :portkey.aws.ec2.replace-route-request/gateway-id :portkey.aws.ec2.replace-route-request/egress-only-internet-gateway-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification-result/reserved-instances-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification-result/target-configuration (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-configuration))
(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-modification-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reserved-instances-modification-result/reserved-instances-id :portkey.aws.ec2.reserved-instances-modification-result/target-configuration]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-attribute-result/auto-enable-io (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-attribute-result/product-codes (clojure.spec.alpha/and :portkey.aws.ec2/product-code-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-attribute-result/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-volume-attribute-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-volume-attribute-result/auto-enable-io :portkey.aws.ec2.describe-volume-attribute-result/product-codes :portkey.aws.ec2.describe-volume-attribute-result/volume-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-attachment-propagation-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/transit-gateway-attachment-propagation))

(clojure.spec.alpha/def :portkey.aws.ec2.unassign-ipv-6-addresses-request/ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/ipv-6-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.unassign-ipv-6-addresses-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/unassign-ipv-6-addresses-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.unassign-ipv-6-addresses-request/ipv-6-addresses :portkey.aws.ec2.unassign-ipv-6-addresses-request/network-interface-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-task-details/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-task-details/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-task-details/platform (clojure.spec.alpha/and :portkey.aws.ec2/platform-values))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-task-details/volumes (clojure.spec.alpha/and :portkey.aws.ec2/import-instance-volume-detail-set))
(clojure.spec.alpha/def :portkey.aws.ec2/import-instance-task-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.import-instance-task-details/description :portkey.aws.ec2.import-instance-task-details/instance-id :portkey.aws.ec2.import-instance-task-details/platform :portkey.aws.ec2.import-instance-task-details/volumes]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-client-vpn-target-network-result/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-client-vpn-target-network-result/status (clojure.spec.alpha/and :portkey.aws.ec2/association-status))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-client-vpn-target-network-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.associate-client-vpn-target-network-result/association-id :portkey.aws.ec2.associate-client-vpn-target-network-result/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.enable-transit-gateway-route-table-propagation-result/propagation (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-propagation))
(clojure.spec.alpha/def :portkey.aws.ec2/enable-transit-gateway-route-table-propagation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.enable-transit-gateway-route-table-propagation-result/propagation]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-modifications-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-modifications-result/reserved-instances-modifications (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-modification-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-reserved-instances-modifications-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-reserved-instances-modifications-result/next-token :portkey.aws.ec2.describe-reserved-instances-modifications-result/reserved-instances-modifications]))

(clojure.spec.alpha/def :portkey.aws.ec2/cancel-bundle-task-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/bundle-task]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-permission/group (clojure.spec.alpha/and :portkey.aws.ec2/permission-group))
(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-permission/user-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-volume-permission (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-volume-permission/group :portkey.aws.ec2.create-volume-permission/user-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.get-host-reservation-purchase-preview-result/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2.get-host-reservation-purchase-preview-result/purchase (clojure.spec.alpha/and :portkey.aws.ec2/purchase-set))
(clojure.spec.alpha/def :portkey.aws.ec2.get-host-reservation-purchase-preview-result/total-hourly-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-host-reservation-purchase-preview-result/total-upfront-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/get-host-reservation-purchase-preview-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.get-host-reservation-purchase-preview-result/currency-code :portkey.aws.ec2.get-host-reservation-purchase-preview-result/purchase :portkey.aws.ec2.get-host-reservation-purchase-preview-result/total-hourly-price :portkey.aws.ec2.get-host-reservation-purchase-preview-result/total-upfront-price]))

(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint-status/code (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-endpoint-status-code))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint-status/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-endpoint-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-vpn-endpoint-status/code :portkey.aws.ec2.client-vpn-endpoint-status/message]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-spot-datafeed-subscription-request/bucket (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-spot-datafeed-subscription-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-spot-datafeed-subscription-request/prefix (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-spot-datafeed-subscription-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-spot-datafeed-subscription-request/bucket] :opt-un [:portkey.aws.ec2.create-spot-datafeed-subscription-request/dry-run :portkey.aws.ec2.create-spot-datafeed-subscription-request/prefix]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-availability-zones-result/availability-zones (clojure.spec.alpha/and :portkey.aws.ec2/availability-zone-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-availability-zones-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-availability-zones-result/availability-zones]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-status-details/impaired-since (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status-details/name (clojure.spec.alpha/and :portkey.aws.ec2/status-name))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status-details/status (clojure.spec.alpha/and :portkey.aws.ec2/status-type))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-status-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-status-details/impaired-since :portkey.aws.ec2.instance-status-details/name :portkey.aws.ec2.instance-status-details/status]))

(clojure.spec.alpha/def :portkey.aws.ec2/describe-network-acls-max-results (clojure.spec.alpha/int-in 5 1000))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshot-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/snapshot-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshot-attribute-request/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshot-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-snapshot-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-snapshot-attribute-request/attribute :portkey.aws.ec2.describe-snapshot-attribute-request/snapshot-id] :opt-un [:portkey.aws.ec2.describe-snapshot-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.subnet-cidr-block-state/state (clojure.spec.alpha/and :portkey.aws.ec2/subnet-cidr-block-state-code))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet-cidr-block-state/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/subnet-cidr-block-state (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.subnet-cidr-block-state/state :portkey.aws.ec2.subnet-cidr-block-state/status-message]))

(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-egress-request/source-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-egress-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-egress-request/to-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-egress-request/source-security-group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-egress-request/ip-protocol (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-egress-request/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-egress-request/from-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-egress-request/ip-permissions (clojure.spec.alpha/and :portkey.aws.ec2/ip-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-egress-request/cidr-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/authorize-security-group-egress-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.authorize-security-group-egress-request/group-id] :opt-un [:portkey.aws.ec2.authorize-security-group-egress-request/source-security-group-owner-id :portkey.aws.ec2.authorize-security-group-egress-request/dry-run :portkey.aws.ec2.authorize-security-group-egress-request/to-port :portkey.aws.ec2.authorize-security-group-egress-request/source-security-group-name :portkey.aws.ec2.authorize-security-group-egress-request/ip-protocol :portkey.aws.ec2.authorize-security-group-egress-request/from-port :portkey.aws.ec2.authorize-security-group-egress-request/ip-permissions :portkey.aws.ec2.authorize-security-group-egress-request/cidr-ip]))

(clojure.spec.alpha/def :portkey.aws.ec2.import-key-pair-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.import-key-pair-request/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-key-pair-request/public-key-material (clojure.spec.alpha/and :portkey.aws.ec2/blob))
(clojure.spec.alpha/def :portkey.aws.ec2/import-key-pair-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.import-key-pair-request/key-name :portkey.aws.ec2.import-key-pair-request/public-key-material] :opt-un [:portkey.aws.ec2.import-key-pair-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.iam-instance-profile-specification/arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.iam-instance-profile-specification/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/iam-instance-profile-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.iam-instance-profile-specification/arn :portkey.aws.ec2.iam-instance-profile-specification/name]))

(clojure.spec.alpha/def :portkey.aws.ec2/spot-instance-request-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/spot-instance-request))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-client-vpn-route-result/status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-route-status))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-client-vpn-route-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-client-vpn-route-result/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.hibernation-options-request/configured (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/hibernation-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.hibernation-options-request/configured]))

(clojure.spec.alpha/def :portkey.aws.ec2/placement-group-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-route-table-request/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-route-table-request/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-route-table-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-transit-gateway-route-table-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-transit-gateway-route-table-request/transit-gateway-id] :opt-un [:portkey.aws.ec2.create-transit-gateway-route-table-request/tag-specifications :portkey.aws.ec2.create-transit-gateway-route-table-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.volume-detail/size (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2/volume-detail (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.volume-detail/size] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2/region-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/region))

(clojure.spec.alpha/def :portkey.aws.ec2/end-date-type #{:limited "limited" :unlimited "unlimited"})

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-spot-market-options-request/max-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-spot-market-options-request/block-duration-minutes (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-spot-market-options-request/valid-until (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-spot-market-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-spot-market-options-request/max-price :portkey.aws.ec2/spot-instance-type :portkey.aws.ec2.launch-template-spot-market-options-request/block-duration-minutes :portkey.aws.ec2.launch-template-spot-market-options-request/valid-until :portkey.aws.ec2/instance-interruption-behavior]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-tags-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-tags-request/resources (clojure.spec.alpha/and :portkey.aws.ec2/resource-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-tags-request/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-tags-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-tags-request/resources] :opt-un [:portkey.aws.ec2.delete-tags-request/dry-run :portkey.aws.ec2.delete-tags-request/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleet-success-item/current-fleet-state (clojure.spec.alpha/and :portkey.aws.ec2/fleet-state-code))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleet-success-item/previous-fleet-state (clojure.spec.alpha/and :portkey.aws.ec2/fleet-state-code))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleet-success-item/fleet-id (clojure.spec.alpha/and :portkey.aws.ec2/fleet-identifier))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-fleet-success-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-fleet-success-item/current-fleet-state :portkey.aws.ec2.delete-fleet-success-item/previous-fleet-state :portkey.aws.ec2.delete-fleet-success-item/fleet-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-reserved-instances-listing-result/reserved-instances-listings (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-listing-list))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-reserved-instances-listing-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cancel-reserved-instances-listing-result/reserved-instances-listings]))

(clojure.spec.alpha/def :portkey.aws.ec2/public-ipv-4-pool-range-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/public-ipv-4-pool-range))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-dhcp-options-request/dhcp-options-ids (clojure.spec.alpha/and :portkey.aws.ec2/dhcp-options-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-dhcp-options-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-dhcp-options-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-dhcp-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-dhcp-options-request/dhcp-options-ids :portkey.aws.ec2.describe-dhcp-options-request/filters :portkey.aws.ec2.describe-dhcp-options-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.restore-address-to-classic-result/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/restore-address-to-classic-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.restore-address-to-classic-result/public-ip :portkey.aws.ec2/status]))

(clojure.spec.alpha/def :portkey.aws.ec2/response-host-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.disk-image-description/checksum (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disk-image-description/format (clojure.spec.alpha/and :portkey.aws.ec2/disk-image-format))
(clojure.spec.alpha/def :portkey.aws.ec2.disk-image-description/import-manifest-url (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disk-image-description/size (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2/disk-image-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disk-image-description/checksum :portkey.aws.ec2.disk-image-description/format :portkey.aws.ec2.disk-image-description/import-manifest-url :portkey.aws.ec2.disk-image-description/size]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template/create-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template/created-by (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template/default-version-number (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template/latest-version-number (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template/launch-template-id :portkey.aws.ec2/launch-template-name :portkey.aws.ec2.launch-template/create-time :portkey.aws.ec2.launch-template/created-by :portkey.aws.ec2.launch-template/default-version-number :portkey.aws.ec2.launch-template/latest-version-number :portkey.aws.ec2.launch-template/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.client-certificate-revocation-list-status/code (clojure.spec.alpha/and :portkey.aws.ec2/client-certificate-revocation-list-status-code))
(clojure.spec.alpha/def :portkey.aws.ec2.client-certificate-revocation-list-status/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/client-certificate-revocation-list-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-certificate-revocation-list-status/code :portkey.aws.ec2.client-certificate-revocation-list-status/message]))

(clojure.spec.alpha/def :portkey.aws.ec2/host-tenancy #{"host" :host "dedicated" :dedicated})

(clojure.spec.alpha/def :portkey.aws.ec2.available-capacity/available-instance-capacity (clojure.spec.alpha/and :portkey.aws.ec2/available-instance-capacity-list))
(clojure.spec.alpha/def :portkey.aws.ec2.available-capacity/available-v-cpus (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/available-capacity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.available-capacity/available-instance-capacity :portkey.aws.ec2.available-capacity/available-v-cpus]))

(clojure.spec.alpha/def :portkey.aws.ec2/service-detail-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/service-detail))

(clojure.spec.alpha/def :portkey.aws.ec2.storage-location/bucket (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.storage-location/key (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/storage-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.storage-location/bucket :portkey.aws.ec2.storage-location/key]))

(clojure.spec.alpha/def :portkey.aws.ec2/bundle-task-state #{:waitingforshutdown :bundling "failed" "waiting-for-shutdown" :pending "complete" "storing" "cancelling" :complete "bundling" :cancelling "pending" :storing :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.icmp-type-code/code (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.icmp-type-code/type (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/icmp-type-code (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.icmp-type-code/code :portkey.aws.ec2.icmp-type-code/type]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-private-ip-address/association (clojure.spec.alpha/and :portkey.aws.ec2/instance-network-interface-association))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-private-ip-address/primary (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-private-ip-address/private-dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-private-ip-address/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-private-ip-address (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-private-ip-address/association :portkey.aws.ec2.instance-private-ip-address/primary :portkey.aws.ec2.instance-private-ip-address/private-dns-name :portkey.aws.ec2.instance-private-ip-address/private-ip-address]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-acls-result/network-acls (clojure.spec.alpha/and :portkey.aws.ec2/network-acl-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-acls-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-network-acls-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-network-acls-result/network-acls :portkey.aws.ec2.describe-network-acls-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/fpga-image-attribute-name #{:description "productCodes" :load-permission :name :product-codes "name" "description" "loadPermission"})

(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation-target-response/capacity-reservation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation-target-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.capacity-reservation-target-response/capacity-reservation-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/describe-internet-gateways-max-results (clojure.spec.alpha/int-in 5 1000))

(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpu-specification/type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-specification (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.elastic-gpu-specification/type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-listing-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/reserved-instances-listing))

(clojure.spec.alpha/def :portkey.aws.ec2.export-client-vpn-client-certificate-revocation-list-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.export-client-vpn-client-certificate-revocation-list-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/export-client-vpn-client-certificate-revocation-list-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.export-client-vpn-client-certificate-revocation-list-request/client-vpn-endpoint-id] :opt-un [:portkey.aws.ec2.export-client-vpn-client-certificate-revocation-list-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/service-state #{:deleted "Failed" :pending :deleting "Deleting" "Deleted" :available "Pending" "Available" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.associate-iam-instance-profile-request/iam-instance-profile (clojure.spec.alpha/and :portkey.aws.ec2/iam-instance-profile-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-iam-instance-profile-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-iam-instance-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.associate-iam-instance-profile-request/iam-instance-profile :portkey.aws.ec2.associate-iam-instance-profile-request/instance-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/capacity-reservation))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-classic-link/classic-link-enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-classic-link/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-classic-link/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-classic-link (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc-classic-link/classic-link-enabled :portkey.aws.ec2.vpc-classic-link/tags :portkey.aws.ec2.vpc-classic-link/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-import-task-result/import-task-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-import-task-result/previous-state (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-import-task-result/state (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-import-task-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cancel-import-task-result/import-task-id :portkey.aws.ec2.cancel-import-task-result/previous-state :portkey.aws.ec2.cancel-import-task-result/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/disk-image-size (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/format (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/progress (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/url (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/user-bucket (clojure.spec.alpha/and :portkey.aws.ec2/user-bucket-details))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-task-detail/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/snapshot-task-detail (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.snapshot-task-detail/disk-image-size :portkey.aws.ec2.snapshot-task-detail/status-message :portkey.aws.ec2.snapshot-task-detail/encrypted :portkey.aws.ec2.snapshot-task-detail/format :portkey.aws.ec2.snapshot-task-detail/status :portkey.aws.ec2.snapshot-task-detail/progress :portkey.aws.ec2.snapshot-task-detail/url :portkey.aws.ec2.snapshot-task-detail/description :portkey.aws.ec2.snapshot-task-detail/kms-key-id :portkey.aws.ec2.snapshot-task-detail/user-bucket :portkey.aws.ec2.snapshot-task-detail/snapshot-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/placement (clojure.spec.alpha/and :portkey.aws.ec2/spot-placement))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/addressing-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/security-groups (clojure.spec.alpha/and :portkey.aws.ec2/group-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/monitoring (clojure.spec.alpha/and :portkey.aws.ec2/run-instances-monitoring-enabled))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/block-device-mapping-list))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/ramdisk-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/user-data (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/iam-instance-profile (clojure.spec.alpha/and :portkey.aws.ec2/iam-instance-profile-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-specification/network-interfaces (clojure.spec.alpha/and :portkey.aws.ec2/instance-network-interface-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-specification/kernel-id :portkey.aws.ec2.launch-specification/image-id :portkey.aws.ec2.launch-specification/placement :portkey.aws.ec2.launch-specification/addressing-type :portkey.aws.ec2.launch-specification/subnet-id :portkey.aws.ec2.launch-specification/security-groups :portkey.aws.ec2.launch-specification/ebs-optimized :portkey.aws.ec2/instance-type :portkey.aws.ec2.launch-specification/key-name :portkey.aws.ec2.launch-specification/monitoring :portkey.aws.ec2.launch-specification/block-device-mappings :portkey.aws.ec2.launch-specification/ramdisk-id :portkey.aws.ec2.launch-specification/user-data :portkey.aws.ec2.launch-specification/iam-instance-profile :portkey.aws.ec2.launch-specification/network-interfaces]))

(clojure.spec.alpha/def :portkey.aws.ec2/id-format-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/id-format))

(clojure.spec.alpha/def :portkey.aws.ec2.register-image-result/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/register-image-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.register-image-result/image-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-tag-specification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-tag-specification))

(clojure.spec.alpha/def :portkey.aws.ec2/describe-fpga-image-attribute-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/fpga-image-attribute]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-target-networks-result/client-vpn-target-networks (clojure.spec.alpha/and :portkey.aws.ec2/target-network-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-client-vpn-target-networks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-client-vpn-target-networks-result/client-vpn-target-networks :portkey.aws.ec2/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/allowed-principal-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/allowed-principal))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservations-request/filter (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservations-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservations-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-host-reservations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-host-reservations-request/filter :portkey.aws.ec2/host-reservation-id-set :portkey.aws.ec2.describe-host-reservations-request/max-results :portkey.aws.ec2.describe-host-reservations-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/platform (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/import-task-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/progress (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/snapshot-details (clojure.spec.alpha/and :portkey.aws.ec2/snapshot-detail-list))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/hypervisor (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/architecture (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-result/license-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/import-image-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.import-image-result/platform :portkey.aws.ec2.import-image-result/import-task-id :portkey.aws.ec2.import-image-result/image-id :portkey.aws.ec2.import-image-result/status-message :portkey.aws.ec2.import-image-result/encrypted :portkey.aws.ec2.import-image-result/status :portkey.aws.ec2.import-image-result/progress :portkey.aws.ec2.import-image-result/description :portkey.aws.ec2.import-image-result/snapshot-details :portkey.aws.ec2.import-image-result/kms-key-id :portkey.aws.ec2.import-image-result/hypervisor :portkey.aws.ec2.import-image-result/architecture :portkey.aws.ec2.import-image-result/license-type]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-ipv-6-address-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-ipv-6-address))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-attribute-name #{:auto-enable-io "productCodes" "autoEnableIO" :product-codes})

(clojure.spec.alpha/def :portkey.aws.ec2.modify-launch-template-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-launch-template-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-launch-template-request/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-launch-template-request/default-version (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-launch-template-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-launch-template-request/dry-run :portkey.aws.ec2.modify-launch-template-request/client-token :portkey.aws.ec2.modify-launch-template-request/launch-template-id :portkey.aws.ec2/launch-template-name :portkey.aws.ec2.modify-launch-template-request/default-version]))

(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation-instance-platform #{"Red Hat Enterprise Linux" "Windows with SQL Server Standard" :red-hat-enterprise-linux :windows "Windows with SQL Server Enterprise" :linux-unix "Windows with SQL Server Web" "SUSE Linux" :linuxwith-sql-server-web "Linux with SQL Server Standard" :windowswith-sql-server-enterprise "Windows" :windowswith-sql-server-standard :windowswith-sql-server-web "Linux/UNIX" :suse-linux "Windows with SQL Server" :linuxwith-sql-server-standard "Linux with SQL Server Enterprise" :linuxwith-sql-server-enterprise :windowswith-sql-server "Linux with SQL Server Web"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-templates-result/launch-templates (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-templates-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-launch-templates-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-launch-templates-result/launch-templates :portkey.aws.ec2.describe-launch-templates-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/prefix-list-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/prefix-list))

(clojure.spec.alpha/def :portkey.aws.ec2/endpoint-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/client-vpn-endpoint))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-credit-specification/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-credit-specification/cpu-credits (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-credit-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-credit-specification/instance-id :portkey.aws.ec2.instance-credit-specification/cpu-credits]))

(clojure.spec.alpha/def :portkey.aws.ec2.assign-private-ip-addresses-request/allow-reassignment (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.assign-private-ip-addresses-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.assign-private-ip-addresses-request/private-ip-addresses (clojure.spec.alpha/and :portkey.aws.ec2/private-ip-address-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.assign-private-ip-addresses-request/secondary-private-ip-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/assign-private-ip-addresses-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.assign-private-ip-addresses-request/network-interface-id] :opt-un [:portkey.aws.ec2.assign-private-ip-addresses-request/allow-reassignment :portkey.aws.ec2.assign-private-ip-addresses-request/private-ip-addresses :portkey.aws.ec2.assign-private-ip-addresses-request/secondary-private-ip-address-count]))

(clojure.spec.alpha/def :portkey.aws.ec2.detach-network-interface-request/attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-network-interface-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-network-interface-request/force (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/detach-network-interface-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.detach-network-interface-request/attachment-id] :opt-un [:portkey.aws.ec2.detach-network-interface-request/dry-run :portkey.aws.ec2.detach-network-interface-request/force]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-event-type #{"service-error" "fleet-change" :instancechange :serviceerror "instance-change" :fleetchange})

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-state-code #{:deleted :modifying "deleted-terminating" "deleted-running" "failed" :deletedrunning :submitted :active "deleted" "submitted" "modifying" "active" :deletedterminating :failed})

(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instance-id-request-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-connections-result/connections (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-connection-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-client-vpn-connections-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-client-vpn-connections-result/connections :portkey.aws.ec2/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-subnet-cidr-block-result/ipv-6-cidr-block-association (clojure.spec.alpha/and :portkey.aws.ec2/subnet-ipv-6-cidr-block-association))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-subnet-cidr-block-result/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-subnet-cidr-block-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.associate-subnet-cidr-block-result/ipv-6-cidr-block-association :portkey.aws.ec2.associate-subnet-cidr-block-result/subnet-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-address-request/allocation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-address-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-address-request/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-address-request/allow-reassociation (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-address-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-address-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-address-request/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-address-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.associate-address-request/allocation-id :portkey.aws.ec2.associate-address-request/instance-id :portkey.aws.ec2.associate-address-request/public-ip :portkey.aws.ec2.associate-address-request/allow-reassociation :portkey.aws.ec2.associate-address-request/dry-run :portkey.aws.ec2.associate-address-request/network-interface-id :portkey.aws.ec2.associate-address-request/private-ip-address]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connections-result/vpc-endpoint-connections (clojure.spec.alpha/and :portkey.aws.ec2/vpc-endpoint-connection-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connections-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoint-connections-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-endpoint-connections-result/vpc-endpoint-connections :portkey.aws.ec2.describe-vpc-endpoint-connections-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.attribute-boolean-value/value (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/attribute-boolean-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.attribute-boolean-value/value]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.price-schedule-specification/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2.price-schedule-specification/price (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.price-schedule-specification/term (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2/price-schedule-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.price-schedule-specification/currency-code :portkey.aws.ec2.price-schedule-specification/price :portkey.aws.ec2.price-schedule-specification/term]))

(clojure.spec.alpha/def :portkey.aws.ec2.export-to-s-3-task-specification/s-3-bucket (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.export-to-s-3-task-specification/s-3-prefix (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/export-to-s-3-task-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/container-format :portkey.aws.ec2/disk-image-format :portkey.aws.ec2.export-to-s-3-task-specification/s-3-bucket :portkey.aws.ec2.export-to-s-3-task-specification/s-3-prefix]))

(clojure.spec.alpha/def :portkey.aws.ec2.monitor-instances-result/instance-monitorings (clojure.spec.alpha/and :portkey.aws.ec2/instance-monitoring-list))
(clojure.spec.alpha/def :portkey.aws.ec2/monitor-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.monitor-instances-result/instance-monitorings]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-client-vpn-endpoint-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-client-vpn-endpoint-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-client-vpn-endpoint-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-client-vpn-endpoint-request/client-vpn-endpoint-id] :opt-un [:portkey.aws.ec2.delete-client-vpn-endpoint-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-internet-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-internet-gateway-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-internet-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-result/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpc-endpoint-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/vpc-endpoint :portkey.aws.ec2.create-vpc-endpoint-result/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/availability-zone-group (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/spot-instance-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/type (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-type))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/actual-block-hourly-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/block-duration-minutes (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/valid-from (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/status (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-status))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/spot-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/launched-availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/launch-group (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/product-description (clojure.spec.alpha/and :portkey.aws.ec2/ri-product-description))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/create-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/fault (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-state-fault))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/state (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-state))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-request/valid-until (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-instance-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-instance-request/availability-zone-group :portkey.aws.ec2.spot-instance-request/spot-instance-request-id :portkey.aws.ec2.spot-instance-request/instance-id :portkey.aws.ec2.spot-instance-request/type :portkey.aws.ec2.spot-instance-request/actual-block-hourly-price :portkey.aws.ec2.spot-instance-request/block-duration-minutes :portkey.aws.ec2.spot-instance-request/valid-from :portkey.aws.ec2/launch-specification :portkey.aws.ec2.spot-instance-request/tags :portkey.aws.ec2.spot-instance-request/status :portkey.aws.ec2.spot-instance-request/spot-price :portkey.aws.ec2.spot-instance-request/launched-availability-zone :portkey.aws.ec2/instance-interruption-behavior :portkey.aws.ec2.spot-instance-request/launch-group :portkey.aws.ec2.spot-instance-request/product-description :portkey.aws.ec2.spot-instance-request/create-time :portkey.aws.ec2.spot-instance-request/fault :portkey.aws.ec2.spot-instance-request/state :portkey.aws.ec2.spot-instance-request/valid-until]))

(clojure.spec.alpha/def :portkey.aws.ec2.elastic-inference-accelerator/type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/elastic-inference-accelerator (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.elastic-inference-accelerator/type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2/rule-action #{"allow" :allow "deny" :deny})

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-attachment-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpc-attachment))

(clojure.spec.alpha/def :portkey.aws.ec2/associated-network-type #{"vpc" :vpc})

(clojure.spec.alpha/def :portkey.aws.ec2.reset-fpga-image-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.reset-fpga-image-attribute-request/fpga-image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reset-fpga-image-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/reset-fpga-image-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2/reset-fpga-image-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.reset-fpga-image-attribute-request/fpga-image-id] :opt-un [:portkey.aws.ec2.reset-fpga-image-attribute-request/dry-run :portkey.aws.ec2.reset-fpga-image-attribute-request/attribute]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-instance-requests-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-instance-requests-request/spot-instance-request-ids (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-request-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-spot-instance-requests-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.cancel-spot-instance-requests-request/spot-instance-request-ids] :opt-un [:portkey.aws.ec2.cancel-spot-instance-requests-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.get-console-output-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-console-output-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.get-console-output-request/latest (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/get-console-output-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.get-console-output-request/instance-id] :opt-un [:portkey.aws.ec2.get-console-output-request/dry-run :portkey.aws.ec2.get-console-output-request/latest]))

(clojure.spec.alpha/def :portkey.aws.ec2.import-key-pair-result/key-fingerprint (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-key-pair-result/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/import-key-pair-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.import-key-pair-result/key-fingerprint :portkey.aws.ec2.import-key-pair-result/key-name]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-network-acl-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/network-acl]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-transit-gateway-route-table-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-transit-gateway-route-table-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-transit-gateway-route-table-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-transit-gateway-route-table-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.associate-transit-gateway-route-table-request/transit-gateway-route-table-id :portkey.aws.ec2.associate-transit-gateway-route-table-request/transit-gateway-attachment-id] :opt-un [:portkey.aws.ec2.associate-transit-gateway-route-table-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/elastic-inference-accelerators (clojure.spec.alpha/coll-of :portkey.aws.ec2/elastic-inference-accelerator))

(clojure.spec.alpha/def :portkey.aws.ec2/associated-target-network-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/associated-target-network))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoint-connection-notifications-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/connection-notification-set :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/service-configuration-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/service-configuration))

(clojure.spec.alpha/def :portkey.aws.ec2.successful-instance-credit-specification-item/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/successful-instance-credit-specification-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.successful-instance-credit-specification-item/instance-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-iam-instance-profile-associations-result/iam-instance-profile-associations (clojure.spec.alpha/and :portkey.aws.ec2/iam-instance-profile-association-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-iam-instance-profile-associations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-iam-instance-profile-associations-result/iam-instance-profile-associations :portkey.aws.ec2/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-route-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-route-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-route-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-nat-gateways-request/filter (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-nat-gateways-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-nat-gateways-request/nat-gateway-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-nat-gateways-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-nat-gateways-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-nat-gateways-request/filter :portkey.aws.ec2.describe-nat-gateways-request/max-results :portkey.aws.ec2.describe-nat-gateways-request/nat-gateway-ids :portkey.aws.ec2.describe-nat-gateways-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpn-static-route/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-static-route/source (clojure.spec.alpha/and :portkey.aws.ec2/vpn-static-route-source))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-static-route/state (clojure.spec.alpha/and :portkey.aws.ec2/vpn-state))
(clojure.spec.alpha/def :portkey.aws.ec2/vpn-static-route (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpn-static-route/destination-cidr-block :portkey.aws.ec2.vpn-static-route/source :portkey.aws.ec2.vpn-static-route/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-client-vpn-target-network-result/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-client-vpn-target-network-result/status (clojure.spec.alpha/and :portkey.aws.ec2/association-status))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-client-vpn-target-network-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disassociate-client-vpn-target-network-result/association-id :portkey.aws.ec2.disassociate-client-vpn-target-network-result/status]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-route-table-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/route-table]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-type #{:request "maintain" :instant :maintain "request" "instant"})

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/subnet-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/vpc-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/private-dns-enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/policy-document (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/creation-timestamp (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/network-interface-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/groups (clojure.spec.alpha/and :portkey.aws.ec2/group-identifier-set))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/service-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/dns-entries (clojure.spec.alpha/and :portkey.aws.ec2/dns-entry-set))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint/route-table-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-endpoint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/vpc-endpoint-type :portkey.aws.ec2.vpc-endpoint/subnet-ids :portkey.aws.ec2.vpc-endpoint/vpc-endpoint-id :portkey.aws.ec2.vpc-endpoint/private-dns-enabled :portkey.aws.ec2.vpc-endpoint/policy-document :portkey.aws.ec2.vpc-endpoint/creation-timestamp :portkey.aws.ec2.vpc-endpoint/vpc-id :portkey.aws.ec2.vpc-endpoint/network-interface-ids :portkey.aws.ec2.vpc-endpoint/groups :portkey.aws.ec2/state :portkey.aws.ec2.vpc-endpoint/service-name :portkey.aws.ec2.vpc-endpoint/dns-entries :portkey.aws.ec2.vpc-endpoint/route-table-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-status-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-status-result/volume-statuses (clojure.spec.alpha/and :portkey.aws.ec2/volume-status-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-volume-status-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-volume-status-result/next-token :portkey.aws.ec2.describe-volume-status-result/volume-statuses]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-request/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-request/amazon-provided-ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-request/instance-tenancy (clojure.spec.alpha/and :portkey.aws.ec2/tenancy))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpc-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-vpc-request/cidr-block] :opt-un [:portkey.aws.ec2.create-vpc-request/amazon-provided-ipv-6-cidr-block :portkey.aws.ec2.create-vpc-request/dry-run :portkey.aws.ec2.create-vpc-request/instance-tenancy]))

(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/availability-zone-group (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/type (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-type))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/block-duration-minutes (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/valid-from (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/launch-specification (clojure.spec.alpha/and :portkey.aws.ec2/request-spot-launch-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/spot-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/launch-group (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-request/valid-until (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/request-spot-instances-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.request-spot-instances-request/availability-zone-group :portkey.aws.ec2.request-spot-instances-request/dry-run :portkey.aws.ec2.request-spot-instances-request/type :portkey.aws.ec2.request-spot-instances-request/instance-count :portkey.aws.ec2.request-spot-instances-request/block-duration-minutes :portkey.aws.ec2.request-spot-instances-request/valid-from :portkey.aws.ec2.request-spot-instances-request/launch-specification :portkey.aws.ec2.request-spot-instances-request/spot-price :portkey.aws.ec2/instance-interruption-behavior :portkey.aws.ec2.request-spot-instances-request/launch-group :portkey.aws.ec2.request-spot-instances-request/client-token :portkey.aws.ec2.request-spot-instances-request/valid-until]))

(clojure.spec.alpha/def :portkey.aws.ec2/key-pair-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/key-pair-info))

(clojure.spec.alpha/def :portkey.aws.ec2/purchased-scheduled-instance-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/scheduled-instance))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-route-tables-result/route-tables (clojure.spec.alpha/and :portkey.aws.ec2/route-table-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-route-tables-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-route-tables-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-route-tables-result/route-tables :portkey.aws.ec2.describe-route-tables-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-tag-specification-request-list))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/credit-specification (clojure.spec.alpha/and :portkey.aws.ec2/credit-specification-request))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/security-group-ids (clojure.spec.alpha/and :portkey.aws.ec2/security-group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/placement (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-placement-request))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/security-groups (clojure.spec.alpha/and :portkey.aws.ec2/security-group-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/instance-market-options (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-instance-market-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/elastic-inference-accelerators (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-elastic-inference-accelerator-list))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/elastic-gpu-specifications (clojure.spec.alpha/and :portkey.aws.ec2/elastic-gpu-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/license-specifications (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-license-specification-list-request))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/ram-disk-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/disable-api-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/hibernation-options (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-hibernation-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/monitoring (clojure.spec.alpha/and :portkey.aws.ec2/launch-templates-monitoring-request))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-block-device-mapping-request-list))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/capacity-reservation-specification (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-capacity-reservation-specification-request))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/cpu-options (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-cpu-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/user-data (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/instance-initiated-shutdown-behavior (clojure.spec.alpha/and :portkey.aws.ec2/shutdown-behavior))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/iam-instance-profile (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-iam-instance-profile-specification-request))
(clojure.spec.alpha/def :portkey.aws.ec2.request-launch-template-data/network-interfaces (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-instance-network-interface-specification-request-list))
(clojure.spec.alpha/def :portkey.aws.ec2/request-launch-template-data (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.request-launch-template-data/tag-specifications :portkey.aws.ec2.request-launch-template-data/kernel-id :portkey.aws.ec2.request-launch-template-data/credit-specification :portkey.aws.ec2.request-launch-template-data/security-group-ids :portkey.aws.ec2.request-launch-template-data/image-id :portkey.aws.ec2.request-launch-template-data/placement :portkey.aws.ec2.request-launch-template-data/security-groups :portkey.aws.ec2.request-launch-template-data/ebs-optimized :portkey.aws.ec2.request-launch-template-data/instance-market-options :portkey.aws.ec2/instance-type :portkey.aws.ec2.request-launch-template-data/elastic-inference-accelerators :portkey.aws.ec2.request-launch-template-data/key-name :portkey.aws.ec2.request-launch-template-data/elastic-gpu-specifications :portkey.aws.ec2.request-launch-template-data/license-specifications :portkey.aws.ec2.request-launch-template-data/ram-disk-id :portkey.aws.ec2.request-launch-template-data/disable-api-termination :portkey.aws.ec2.request-launch-template-data/hibernation-options :portkey.aws.ec2.request-launch-template-data/monitoring :portkey.aws.ec2.request-launch-template-data/block-device-mappings :portkey.aws.ec2.request-launch-template-data/capacity-reservation-specification :portkey.aws.ec2.request-launch-template-data/cpu-options :portkey.aws.ec2.request-launch-template-data/user-data :portkey.aws.ec2.request-launch-template-data/instance-initiated-shutdown-behavior :portkey.aws.ec2.request-launch-template-data/iam-instance-profile :portkey.aws.ec2.request-launch-template-data/network-interfaces]))

(clojure.spec.alpha/def :portkey.aws.ec2/group-identifier-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/group-identifier))

(clojure.spec.alpha/def :portkey.aws.ec2.create-network-acl-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-acl-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-network-acl-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-network-acl-request/vpc-id] :opt-un [:portkey.aws.ec2.create-network-acl-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-error-item/error (clojure.spec.alpha/and :portkey.aws.ec2/cancel-spot-fleet-requests-error))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-error-item/spot-fleet-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-spot-fleet-requests-error-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cancel-spot-fleet-requests-error-item/error :portkey.aws.ec2.cancel-spot-fleet-requests-error-item/spot-fleet-request-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-export-tasks-result/export-tasks (clojure.spec.alpha/and :portkey.aws.ec2/export-task-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-export-tasks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-export-tasks-result/export-tasks]))

(clojure.spec.alpha/def :portkey.aws.ec2/payment-option #{"AllUpfront" "PartialUpfront" "NoUpfront" :no-upfront :all-upfront :partial-upfront})

(clojure.spec.alpha/def :portkey.aws.ec2/instance-status-details-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-status-details))

(clojure.spec.alpha/def :portkey.aws.ec2.key-pair-info/key-fingerprint (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.key-pair-info/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/key-pair-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.key-pair-info/key-fingerprint :portkey.aws.ec2.key-pair-info/key-name]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-bundle-tasks-request/bundle-ids (clojure.spec.alpha/and :portkey.aws.ec2/bundle-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-bundle-tasks-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-bundle-tasks-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-bundle-tasks-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-bundle-tasks-request/bundle-ids :portkey.aws.ec2.describe-bundle-tasks-request/filters :portkey.aws.ec2.describe-bundle-tasks-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/price-schedule-specification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/price-schedule-specification))

(clojure.spec.alpha/def :portkey.aws.ec2.association-status/code (clojure.spec.alpha/and :portkey.aws.ec2/association-status-code))
(clojure.spec.alpha/def :portkey.aws.ec2.association-status/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/association-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.association-status/code :portkey.aws.ec2.association-status/message]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/attachment (clojure.spec.alpha/and :portkey.aws.ec2/instance-network-interface-attachment))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/instance-ipv-6-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/mac-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/source-dest-check (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/status (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-status))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/private-dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/groups (clojure.spec.alpha/and :portkey.aws.ec2/group-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/private-ip-addresses (clojure.spec.alpha/and :portkey.aws.ec2/instance-private-ip-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/association (clojure.spec.alpha/and :portkey.aws.ec2/instance-network-interface-association))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-network-interface (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-network-interface/attachment :portkey.aws.ec2.instance-network-interface/ipv-6-addresses :portkey.aws.ec2.instance-network-interface/subnet-id :portkey.aws.ec2.instance-network-interface/owner-id :portkey.aws.ec2.instance-network-interface/mac-address :portkey.aws.ec2.instance-network-interface/network-interface-id :portkey.aws.ec2.instance-network-interface/source-dest-check :portkey.aws.ec2.instance-network-interface/status :portkey.aws.ec2.instance-network-interface/private-dns-name :portkey.aws.ec2.instance-network-interface/description :portkey.aws.ec2.instance-network-interface/vpc-id :portkey.aws.ec2.instance-network-interface/groups :portkey.aws.ec2.instance-network-interface/private-ip-addresses :portkey.aws.ec2.instance-network-interface/association :portkey.aws.ec2.instance-network-interface/private-ip-address]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-instances-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instances-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instances-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instances-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-instances-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-instances-request/filters :portkey.aws.ec2.describe-instances-request/instance-ids :portkey.aws.ec2.describe-instances-request/dry-run :portkey.aws.ec2.describe-instances-request/max-results :portkey.aws.ec2.describe-instances-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-nat-gateway-request/allocation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-nat-gateway-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-nat-gateway-request/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-nat-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-nat-gateway-request/allocation-id :portkey.aws.ec2.create-nat-gateway-request/subnet-id] :opt-un [:portkey.aws.ec2.create-nat-gateway-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/accept-transit-gateway-vpc-attachment-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/transit-gateway-vpc-attachment]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-launch-template-config-list-request (clojure.spec.alpha/coll-of :portkey.aws.ec2/fleet-launch-template-config-request :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-error/code (clojure.spec.alpha/and :portkey.aws.ec2/cancel-batch-error-code))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-error/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-spot-fleet-requests-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cancel-spot-fleet-requests-error/code :portkey.aws.ec2.cancel-spot-fleet-requests-error/message]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpn-static-route-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpn-static-route))

(clojure.spec.alpha/def :portkey.aws.ec2.reservation/groups (clojure.spec.alpha/and :portkey.aws.ec2/group-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reservation/instances (clojure.spec.alpha/and :portkey.aws.ec2/instance-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reservation/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reservation/requester-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reservation/reservation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/reservation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reservation/groups :portkey.aws.ec2.reservation/instances :portkey.aws.ec2.reservation/owner-id :portkey.aws.ec2.reservation/requester-id :portkey.aws.ec2.reservation/reservation-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.unsuccessful-item-error/code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.unsuccessful-item-error/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/unsuccessful-item-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.unsuccessful-item-error/code :portkey.aws.ec2.unsuccessful-item-error/message]))

(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-association-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/elastic-gpu-association))

(clojure.spec.alpha/def :portkey.aws.ec2/delete-transit-gateway-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/transit-gateway]))

(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-association-result/new-association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/replace-network-acl-association-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.replace-network-acl-association-result/new-association-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-status-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-status-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-status-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-status-request/volume-ids (clojure.spec.alpha/and :portkey.aws.ec2/volume-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volume-status-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-volume-status-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-volume-status-request/filters :portkey.aws.ec2.describe-volume-status-request/max-results :portkey.aws.ec2.describe-volume-status-request/next-token :portkey.aws.ec2.describe-volume-status-request/volume-ids :portkey.aws.ec2.describe-volume-status-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-peering-connection-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpc-peering-connection))

(clojure.spec.alpha/def :portkey.aws.ec2.import-client-vpn-client-certificate-revocation-list-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/import-client-vpn-client-certificate-revocation-list-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.import-client-vpn-client-certificate-revocation-list-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2/unsuccessful-item-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/unsuccessful-item))

(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-client-vpn-target-network-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-client-vpn-target-network-request/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-client-vpn-target-network-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-client-vpn-target-network-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.associate-client-vpn-target-network-request/client-vpn-endpoint-id :portkey.aws.ec2.associate-client-vpn-target-network-request/subnet-id] :opt-un [:portkey.aws.ec2.associate-client-vpn-target-network-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.terminate-client-vpn-connections-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.terminate-client-vpn-connections-request/connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.terminate-client-vpn-connections-request/username (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.terminate-client-vpn-connections-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/terminate-client-vpn-connections-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.terminate-client-vpn-connections-request/client-vpn-endpoint-id] :opt-un [:portkey.aws.ec2.terminate-client-vpn-connections-request/connection-id :portkey.aws.ec2.terminate-client-vpn-connections-request/username :portkey.aws.ec2.terminate-client-vpn-connections-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/security-group-references (clojure.spec.alpha/coll-of :portkey.aws.ec2/security-group-reference))

(clojure.spec.alpha/def :portkey.aws.ec2.allocate-address-request/domain (clojure.spec.alpha/and :portkey.aws.ec2/domain-type))
(clojure.spec.alpha/def :portkey.aws.ec2.allocate-address-request/address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.allocate-address-request/public-ipv-4-pool (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.allocate-address-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/allocate-address-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.allocate-address-request/domain :portkey.aws.ec2.allocate-address-request/address :portkey.aws.ec2.allocate-address-request/public-ipv-4-pool :portkey.aws.ec2.allocate-address-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-result/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-result/import-task-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/import-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.import-snapshot-result/description :portkey.aws.ec2.import-snapshot-result/import-task-id :portkey.aws.ec2/snapshot-task-detail]))

(clojure.spec.alpha/def :portkey.aws.ec2.stale-ip-permission/from-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.stale-ip-permission/ip-protocol (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.stale-ip-permission/prefix-list-ids (clojure.spec.alpha/and :portkey.aws.ec2/prefix-list-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.stale-ip-permission/to-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.stale-ip-permission/user-id-group-pairs (clojure.spec.alpha/and :portkey.aws.ec2/user-id-group-pair-set))
(clojure.spec.alpha/def :portkey.aws.ec2/stale-ip-permission (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.stale-ip-permission/from-port :portkey.aws.ec2.stale-ip-permission/ip-protocol :portkey.aws.ec2/ip-ranges :portkey.aws.ec2.stale-ip-permission/prefix-list-ids :portkey.aws.ec2.stale-ip-permission/to-port :portkey.aws.ec2.stale-ip-permission/user-id-group-pairs]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-association-state #{:associating "associating" :associated "disassociated" :disassociated "associated" :disassociating "disassociating"})

(clojure.spec.alpha/def :portkey.aws.ec2/traffic-type #{:all "REJECT" :reject "ALL" "ACCEPT" :accept})

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-cidr-block-association-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpc-cidr-block-association))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-client-vpn-endpoint-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-client-vpn-endpoint-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-client-vpn-endpoint-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2/availability-zone-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/availability-zone))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-tag-specification/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-tag-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/resource-type :portkey.aws.ec2.launch-template-tag-specification/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint-connection/service-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint-connection/vpc-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint-connection/vpc-endpoint-owner (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint-connection/vpc-endpoint-state (clojure.spec.alpha/and :portkey.aws.ec2/state))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-endpoint-connection/creation-timestamp (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-endpoint-connection (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc-endpoint-connection/service-id :portkey.aws.ec2.vpc-endpoint-connection/vpc-endpoint-id :portkey.aws.ec2.vpc-endpoint-connection/vpc-endpoint-owner :portkey.aws.ec2.vpc-endpoint-connection/vpc-endpoint-state :portkey.aws.ec2.vpc-endpoint-connection/creation-timestamp]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-route-result/status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-route-status))
(clojure.spec.alpha/def :portkey.aws.ec2/create-client-vpn-route-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-client-vpn-route-result/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-spot-market-options/max-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-spot-market-options/block-duration-minutes (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-spot-market-options/valid-until (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-spot-market-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-spot-market-options/max-price :portkey.aws.ec2/spot-instance-type :portkey.aws.ec2.launch-template-spot-market-options/block-duration-minutes :portkey.aws.ec2.launch-template-spot-market-options/valid-until :portkey.aws.ec2/instance-interruption-behavior]))

(clojure.spec.alpha/def :portkey.aws.ec2.availability-zone/state (clojure.spec.alpha/and :portkey.aws.ec2/availability-zone-state))
(clojure.spec.alpha/def :portkey.aws.ec2.availability-zone/messages (clojure.spec.alpha/and :portkey.aws.ec2/availability-zone-message-list))
(clojure.spec.alpha/def :portkey.aws.ec2.availability-zone/region-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.availability-zone/zone-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.availability-zone/zone-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/availability-zone (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.availability-zone/state :portkey.aws.ec2.availability-zone/messages :portkey.aws.ec2.availability-zone/region-name :portkey.aws.ec2.availability-zone/zone-name :portkey.aws.ec2.availability-zone/zone-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-snapshot-tasks-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-snapshot-tasks-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-snapshot-tasks-request/import-task-ids (clojure.spec.alpha/and :portkey.aws.ec2/import-task-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-snapshot-tasks-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-snapshot-tasks-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-import-snapshot-tasks-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-import-snapshot-tasks-request/dry-run :portkey.aws.ec2.describe-import-snapshot-tasks-request/filters :portkey.aws.ec2.describe-import-snapshot-tasks-request/import-task-ids :portkey.aws.ec2.describe-import-snapshot-tasks-request/max-results :portkey.aws.ec2.describe-import-snapshot-tasks-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/route-origin #{"EnableVgwRoutePropagation" "CreateRouteTable" "CreateRoute" :create-route :create-route-table :enable-vgw-route-propagation})

(clojure.spec.alpha/def :portkey.aws.ec2.disable-vpc-classic-link-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/disable-vpc-classic-link-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disable-vpc-classic-link-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image-attribute/fpga-image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image-attribute/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image-attribute/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image-attribute/load-permissions (clojure.spec.alpha/and :portkey.aws.ec2/load-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image-attribute/product-codes (clojure.spec.alpha/and :portkey.aws.ec2/product-code-list))
(clojure.spec.alpha/def :portkey.aws.ec2/fpga-image-attribute (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.fpga-image-attribute/fpga-image-id :portkey.aws.ec2.fpga-image-attribute/name :portkey.aws.ec2.fpga-image-attribute/description :portkey.aws.ec2.fpga-image-attribute/load-permissions :portkey.aws.ec2.fpga-image-attribute/product-codes]))

(clojure.spec.alpha/def :portkey.aws.ec2/allocation-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/create-volume-permission-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/create-volume-permission))

(clojure.spec.alpha/def :portkey.aws.ec2.target-network/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.target-network/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.target-network/target-network-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.target-network/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.target-network/status (clojure.spec.alpha/and :portkey.aws.ec2/association-status))
(clojure.spec.alpha/def :portkey.aws.ec2.target-network/security-groups (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/target-network (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.target-network/association-id :portkey.aws.ec2.target-network/vpc-id :portkey.aws.ec2.target-network/target-network-id :portkey.aws.ec2.target-network/client-vpn-endpoint-id :portkey.aws.ec2.target-network/status :portkey.aws.ec2.target-network/security-groups]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-attachments-result/transit-gateway-attachments (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-attachments-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-transit-gateway-attachments-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-transit-gateway-attachments-result/transit-gateway-attachments :portkey.aws.ec2.describe-transit-gateway-attachments-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/status #{:move-in-progress :in-classic "InClassic" "MoveInProgress" :in-vpc "InVpc"})

(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-type #{"natGateway" :interface "interface" :nat-gateway})

(clojure.spec.alpha/def :portkey.aws.ec2.update-security-group-rule-descriptions-egress-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/update-security-group-rule-descriptions-egress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.update-security-group-rule-descriptions-egress-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2/cancelled-spot-instance-request-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/cancelled-spot-instance-request))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-ipv-6-cidr-block-association/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-ipv-6-cidr-block-association/ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-ipv-6-cidr-block-association/ipv-6-cidr-block-state (clojure.spec.alpha/and :portkey.aws.ec2/vpc-cidr-block-state))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-ipv-6-cidr-block-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc-ipv-6-cidr-block-association/association-id :portkey.aws.ec2.vpc-ipv-6-cidr-block-association/ipv-6-cidr-block :portkey.aws.ec2.vpc-ipv-6-cidr-block-association/ipv-6-cidr-block-state]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-attachment-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/transit-gateway-attachment))

(clojure.spec.alpha/def :portkey.aws.ec2.certificate-authentication-request/client-root-certificate-chain-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/certificate-authentication-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.certificate-authentication-request/client-root-certificate-chain-arn]))

(clojure.spec.alpha/def :portkey.aws.ec2/image-disk-container-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/image-disk-container))

(clojure.spec.alpha/def :portkey.aws.ec2/event-type #{:fleet-request-change "fleetRequestChange" "instanceChange" :instance-change "error" :error})

(clojure.spec.alpha/def :portkey.aws.ec2.moving-address-status/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/moving-address-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/move-status :portkey.aws.ec2.moving-address-status/public-ip]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-peering-connections-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-peering-connections-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-peering-connections-request/vpc-peering-connection-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-peering-connections-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-peering-connections-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-peering-connections-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-peering-connections-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-peering-connections-request/filters :portkey.aws.ec2.describe-vpc-peering-connections-request/dry-run :portkey.aws.ec2.describe-vpc-peering-connections-request/vpc-peering-connection-ids :portkey.aws.ec2.describe-vpc-peering-connections-request/next-token :portkey.aws.ec2.describe-vpc-peering-connections-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/start (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/fixed-price (clojure.spec.alpha/and :portkey.aws.ec2/float))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/end (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/instance-tenancy (clojure.spec.alpha/and :portkey.aws.ec2/tenancy))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/duration (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/usage-price (clojure.spec.alpha/and :portkey.aws.ec2/float))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/product-description (clojure.spec.alpha/and :portkey.aws.ec2/ri-product-description))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/reserved-instances-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/state (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instance-state))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/offering-class (clojure.spec.alpha/and :portkey.aws.ec2/offering-class-type))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/recurring-charges (clojure.spec.alpha/and :portkey.aws.ec2/recurring-charges-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/offering-type (clojure.spec.alpha/and :portkey.aws.ec2/offering-type-values))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances/scope (clojure.spec.alpha/and :portkey.aws.ec2/scope))
(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reserved-instances/currency-code :portkey.aws.ec2.reserved-instances/instance-count :portkey.aws.ec2.reserved-instances/start :portkey.aws.ec2/instance-type :portkey.aws.ec2.reserved-instances/fixed-price :portkey.aws.ec2.reserved-instances/end :portkey.aws.ec2.reserved-instances/tags :portkey.aws.ec2.reserved-instances/availability-zone :portkey.aws.ec2.reserved-instances/instance-tenancy :portkey.aws.ec2.reserved-instances/duration :portkey.aws.ec2.reserved-instances/usage-price :portkey.aws.ec2.reserved-instances/product-description :portkey.aws.ec2.reserved-instances/reserved-instances-id :portkey.aws.ec2.reserved-instances/state :portkey.aws.ec2.reserved-instances/offering-class :portkey.aws.ec2.reserved-instances/recurring-charges :portkey.aws.ec2.reserved-instances/offering-type :portkey.aws.ec2.reserved-instances/scope]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-default-vpc-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/vpc]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-attribute))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interface-attribute-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-network-interface-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-network-interface-attribute-request/network-interface-id] :opt-un [:portkey.aws.ec2.describe-network-interface-attribute-request/attribute :portkey.aws.ec2.describe-network-interface-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/transit-gateway))

(clojure.spec.alpha/def :portkey.aws.ec2/restorable-by-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-permission-state/state (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-permission-state-code))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-permission-state/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-permission-state (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-interface-permission-state/state :portkey.aws.ec2.network-interface-permission-state/status-message]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-credit-specification-result/successful-instance-credit-specifications (clojure.spec.alpha/and :portkey.aws.ec2/successful-instance-credit-specification-set))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-credit-specification-result/unsuccessful-instance-credit-specifications (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-instance-credit-specification-set))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-instance-credit-specification-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-instance-credit-specification-result/successful-instance-credit-specifications :portkey.aws.ec2.modify-instance-credit-specification-result/unsuccessful-instance-credit-specifications]))

(clojure.spec.alpha/def :portkey.aws.ec2/next-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21076__auto__] (clojure.core/<= 1 (clojure.core/count s__21076__auto__))) (clojure.core/fn [s__21077__auto__] (clojure.core/< (clojure.core/count s__21077__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-routes-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-routes-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-routes-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-client-vpn-routes-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-client-vpn-routes-request/client-vpn-endpoint-id] :opt-un [:portkey.aws.ec2.describe-client-vpn-routes-request/filters :portkey.aws.ec2/max-results :portkey.aws.ec2/next-token :portkey.aws.ec2.describe-client-vpn-routes-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.reset-fpga-image-attribute-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/reset-fpga-image-attribute-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reset-fpga-image-attribute-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.restore-address-to-classic-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.restore-address-to-classic-request/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/restore-address-to-classic-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.restore-address-to-classic-request/public-ip] :opt-un [:portkey.aws.ec2.restore-address-to-classic-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.disable-vpc-classic-link-dns-support-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/disable-vpc-classic-link-dns-support-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disable-vpc-classic-link-dns-support-request/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpu-association/elastic-gpu-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpu-association/elastic-gpu-association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpu-association/elastic-gpu-association-state (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpu-association/elastic-gpu-association-time (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.elastic-gpu-association/elastic-gpu-id :portkey.aws.ec2.elastic-gpu-association/elastic-gpu-association-id :portkey.aws.ec2.elastic-gpu-association/elastic-gpu-association-state :portkey.aws.ec2.elastic-gpu-association/elastic-gpu-association-time]))

(clojure.spec.alpha/def :portkey.aws.ec2.slot-start-time-range-request/earliest-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.slot-start-time-range-request/latest-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/slot-start-time-range-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.slot-start-time-range-request/earliest-time :portkey.aws.ec2.slot-start-time-range-request/latest-time]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-route-table-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-route-table-request/route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-route-table-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-route-table-request/route-table-id] :opt-un [:portkey.aws.ec2.delete-route-table-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/egress-only-internet-gateway-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/egress-only-internet-gateway))

(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-specifications (clojure.spec.alpha/coll-of :portkey.aws.ec2/elastic-gpu-specification))

(clojure.spec.alpha/def :portkey.aws.ec2/excess-capacity-termination-policy #{:default "noTermination" "default" :no-termination})

(clojure.spec.alpha/def :portkey.aws.ec2.prefix-list/cidrs (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.prefix-list/prefix-list-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.prefix-list/prefix-list-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/prefix-list (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.prefix-list/cidrs :portkey.aws.ec2.prefix-list/prefix-list-id :portkey.aws.ec2.prefix-list/prefix-list-name]))

(clojure.spec.alpha/def :portkey.aws.ec2/import-instance-volume-detail-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/import-instance-volume-detail-item))

(clojure.spec.alpha/def :portkey.aws.ec2/status-type #{:initializing :passed :insufficientdata "failed" "initializing" "insufficient-data" :failed "passed"})

(clojure.spec.alpha/def :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request-options/dns-support (clojure.spec.alpha/and :portkey.aws.ec2/dns-support-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request-options/ipv-6-support (clojure.spec.alpha/and :portkey.aws.ec2/ipv-6-support-value))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-transit-gateway-vpc-attachment-request-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request-options/dns-support :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request-options/ipv-6-support]))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-monitoring/enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-fleet-monitoring (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-fleet-monitoring/enabled]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-block-device-mapping-specification/device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-block-device-mapping-specification/ebs (clojure.spec.alpha/and :portkey.aws.ec2/ebs-instance-block-device-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-block-device-mapping-specification/no-device (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-block-device-mapping-specification/virtual-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-block-device-mapping-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-block-device-mapping-specification/device-name :portkey.aws.ec2.instance-block-device-mapping-specification/ebs :portkey.aws.ec2.instance-block-device-mapping-specification/no-device :portkey.aws.ec2.instance-block-device-mapping-specification/virtual-name]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-templates-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-templates-request/launch-template-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-templates-request/launch-template-names (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-name-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-templates-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-templates-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-templates-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-launch-templates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-launch-templates-request/dry-run :portkey.aws.ec2.describe-launch-templates-request/launch-template-ids :portkey.aws.ec2.describe-launch-templates-request/launch-template-names :portkey.aws.ec2.describe-launch-templates-request/filters :portkey.aws.ec2.describe-launch-templates-request/next-token :portkey.aws.ec2.describe-launch-templates-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-listing/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-listing/create-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-listing/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-listing/status (clojure.spec.alpha/and :portkey.aws.ec2/listing-status))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-listing/price-schedules (clojure.spec.alpha/and :portkey.aws.ec2/price-schedule-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-listing/update-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-listing/reserved-instances-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-listing/reserved-instances-listing-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-listing/instance-counts (clojure.spec.alpha/and :portkey.aws.ec2/instance-count-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-listing/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-listing (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reserved-instances-listing/status-message :portkey.aws.ec2.reserved-instances-listing/create-date :portkey.aws.ec2.reserved-instances-listing/tags :portkey.aws.ec2.reserved-instances-listing/status :portkey.aws.ec2.reserved-instances-listing/price-schedules :portkey.aws.ec2.reserved-instances-listing/update-date :portkey.aws.ec2.reserved-instances-listing/reserved-instances-id :portkey.aws.ec2.reserved-instances-listing/reserved-instances-listing-id :portkey.aws.ec2.reserved-instances-listing/instance-counts :portkey.aws.ec2.reserved-instances-listing/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/load-permission-list-request (clojure.spec.alpha/coll-of :portkey.aws.ec2/load-permission-request))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-image-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/image-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-image-attribute-request/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-image-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-image-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-image-attribute-request/attribute :portkey.aws.ec2.describe-image-attribute-request/image-id] :opt-un [:portkey.aws.ec2.describe-image-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-cidr-block-state/state (clojure.spec.alpha/and :portkey.aws.ec2/vpc-cidr-block-state-code))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-cidr-block-state/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-cidr-block-state (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc-cidr-block-state/state :portkey.aws.ec2.vpc-cidr-block-state/status-message]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-status-summary/details (clojure.spec.alpha/and :portkey.aws.ec2/instance-status-details-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status-summary/status (clojure.spec.alpha/and :portkey.aws.ec2/summary-status))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-status-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-status-summary/details :portkey.aws.ec2.instance-status-summary/status]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-attachment-state #{:deleted :modifying "rejecting" "deleting" :rejected "failed" :pending "pendingAcceptance" :rejecting :pending-acceptance :deleting "rollingBack" "failing" :rolling-back :failing "deleted" "modifying" :available "rejected" "pending" "available" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway-address/allocation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway-address/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway-address/private-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway-address/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/nat-gateway-address (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.nat-gateway-address/allocation-id :portkey.aws.ec2.nat-gateway-address/network-interface-id :portkey.aws.ec2.nat-gateway-address/private-ip :portkey.aws.ec2.nat-gateway-address/public-ip]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-status-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-status))

(clojure.spec.alpha/def :portkey.aws.ec2/placement-group-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/placement-group))

(clojure.spec.alpha/def :portkey.aws.ec2.release-hosts-result/successful (clojure.spec.alpha/and :portkey.aws.ec2/response-host-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.release-hosts-result/unsuccessful (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-item-list))
(clojure.spec.alpha/def :portkey.aws.ec2/release-hosts-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.release-hosts-result/successful :portkey.aws.ec2.release-hosts-result/unsuccessful]))

(clojure.spec.alpha/def :portkey.aws.ec2/deprovision-byoip-cidr-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/byoip-cidr]))

(clojure.spec.alpha/def :portkey.aws.ec2/address-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/address))

(clojure.spec.alpha/def :portkey.aws.ec2.disable-vpc-classic-link-dns-support-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/disable-vpc-classic-link-dns-support-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disable-vpc-classic-link-dns-support-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-customer-gateway-request/bgp-asn (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.create-customer-gateway-request/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-customer-gateway-request/type (clojure.spec.alpha/and :portkey.aws.ec2/gateway-type))
(clojure.spec.alpha/def :portkey.aws.ec2.create-customer-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-customer-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-customer-gateway-request/bgp-asn :portkey.aws.ec2.create-customer-gateway-request/public-ip :portkey.aws.ec2.create-customer-gateway-request/type] :opt-un [:portkey.aws.ec2.create-customer-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-request-options/amazon-side-asn (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-request-options/auto-accept-shared-attachments (clojure.spec.alpha/and :portkey.aws.ec2/auto-accept-shared-attachments-value))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-request-options/default-route-table-association (clojure.spec.alpha/and :portkey.aws.ec2/default-route-table-association-value))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-request-options/default-route-table-propagation (clojure.spec.alpha/and :portkey.aws.ec2/default-route-table-propagation-value))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-request-options/vpn-ecmp-support (clojure.spec.alpha/and :portkey.aws.ec2/vpn-ecmp-support-value))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-request-options/dns-support (clojure.spec.alpha/and :portkey.aws.ec2/dns-support-value))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-request-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-request-options/amazon-side-asn :portkey.aws.ec2.transit-gateway-request-options/auto-accept-shared-attachments :portkey.aws.ec2.transit-gateway-request-options/default-route-table-association :portkey.aws.ec2.transit-gateway-request-options/default-route-table-propagation :portkey.aws.ec2.transit-gateway-request-options/vpn-ecmp-support :portkey.aws.ec2.transit-gateway-request-options/dns-support]))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-offering-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/reserved-instances-offering))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-credit-specification-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-credit-specification-request/cpu-credits (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-credit-specification-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-credit-specification-request/instance-id :portkey.aws.ec2.instance-credit-specification-request/cpu-credits]))

(clojure.spec.alpha/def :portkey.aws.ec2.import-volume-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-volume-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-volume-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.import-volume-request/image (clojure.spec.alpha/and :portkey.aws.ec2/disk-image-detail))
(clojure.spec.alpha/def :portkey.aws.ec2.import-volume-request/volume (clojure.spec.alpha/and :portkey.aws.ec2/volume-detail))
(clojure.spec.alpha/def :portkey.aws.ec2/import-volume-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.import-volume-request/availability-zone :portkey.aws.ec2.import-volume-request/image :portkey.aws.ec2.import-volume-request/volume] :opt-un [:portkey.aws.ec2.import-volume-request/description :portkey.aws.ec2.import-volume-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/group-ids (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-tags-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-tags-result/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-description-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-tags-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-tags-result/next-token :portkey.aws.ec2.describe-tags-result/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.cidr-block/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/cidr-block (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cidr-block/cidr-block]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-placement-request/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-placement-request/host-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-placement-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-placement-request/tenancy (clojure.spec.alpha/and :portkey.aws.ec2/host-tenancy))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-placement-request/partition-number (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-instance-placement-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-instance-placement-request/instance-id] :opt-un [:portkey.aws.ec2/affinity :portkey.aws.ec2.modify-instance-placement-request/group-name :portkey.aws.ec2.modify-instance-placement-request/host-id :portkey.aws.ec2.modify-instance-placement-request/tenancy :portkey.aws.ec2.modify-instance-placement-request/partition-number]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-moving-addresses-result/moving-address-statuses (clojure.spec.alpha/and :portkey.aws.ec2/moving-address-status-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-moving-addresses-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-moving-addresses-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-moving-addresses-result/moving-address-statuses :portkey.aws.ec2.describe-moving-addresses-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-capacity-reservation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/capacity-reservation]))

(clojure.spec.alpha/def :portkey.aws.ec2.reject-vpc-endpoint-connections-result/unsuccessful (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-item-set))
(clojure.spec.alpha/def :portkey.aws.ec2/reject-vpc-endpoint-connections-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reject-vpc-endpoint-connections-result/unsuccessful]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-connection-notification-result/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpc-endpoint-connection-notification-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/connection-notification :portkey.aws.ec2.create-vpc-endpoint-connection-notification-result/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-authorization-rules-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-authorization-rules-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-authorization-rules-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-client-vpn-authorization-rules-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-client-vpn-authorization-rules-request/client-vpn-endpoint-id] :opt-un [:portkey.aws.ec2.describe-client-vpn-authorization-rules-request/dry-run :portkey.aws.ec2/next-token :portkey.aws.ec2.describe-client-vpn-authorization-rules-request/filters :portkey.aws.ec2/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-route/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-route/destination-cidr (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-route/target-subnet (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-route/type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-route/origin (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-route/status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-route-status))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-route/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-route (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-vpn-route/client-vpn-endpoint-id :portkey.aws.ec2.client-vpn-route/destination-cidr :portkey.aws.ec2.client-vpn-route/target-subnet :portkey.aws.ec2.client-vpn-route/type :portkey.aws.ec2.client-vpn-route/origin :portkey.aws.ec2.client-vpn-route/status :portkey.aws.ec2.client-vpn-route/description]))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/reserved-instances))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-egress-only-internet-gateways-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-egress-only-internet-gateways-request/egress-only-internet-gateway-ids (clojure.spec.alpha/and :portkey.aws.ec2/egress-only-internet-gateway-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-egress-only-internet-gateways-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-egress-only-internet-gateways-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-egress-only-internet-gateways-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-egress-only-internet-gateways-request/dry-run :portkey.aws.ec2.describe-egress-only-internet-gateways-request/egress-only-internet-gateway-ids :portkey.aws.ec2.describe-egress-only-internet-gateways-request/max-results :portkey.aws.ec2.describe-egress-only-internet-gateways-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/image-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/image))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-capacity-reservation-specification-response/capacity-reservation-target (clojure.spec.alpha/and :portkey.aws.ec2/capacity-reservation-target-response))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-capacity-reservation-specification-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/capacity-reservation-preference :portkey.aws.ec2.launch-template-capacity-reservation-specification-response/capacity-reservation-target]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-images-result/images (clojure.spec.alpha/and :portkey.aws.ec2/image-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-images-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-images-result/images]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-peering-connection-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-peering-connection-request/peer-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-peering-connection-request/peer-vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-peering-connection-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-peering-connection-request/peer-region (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpc-peering-connection-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-vpc-peering-connection-request/dry-run :portkey.aws.ec2.create-vpc-peering-connection-request/peer-owner-id :portkey.aws.ec2.create-vpc-peering-connection-request/peer-vpc-id :portkey.aws.ec2.create-vpc-peering-connection-request/vpc-id :portkey.aws.ec2.create-vpc-peering-connection-request/peer-region]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-flow-logs-result/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-flow-logs-result/flow-log-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-flow-logs-result/unsuccessful (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-item-set))
(clojure.spec.alpha/def :portkey.aws.ec2/create-flow-logs-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-flow-logs-result/client-token :portkey.aws.ec2.create-flow-logs-result/flow-log-ids :portkey.aws.ec2.create-flow-logs-result/unsuccessful]))

(clojure.spec.alpha/def :portkey.aws.ec2/user-id-group-pair-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/user-id-group-pair))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-result/successfully-deleted-launch-template-versions (clojure.spec.alpha/and :portkey.aws.ec2/delete-launch-template-versions-response-success-set))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-result/unsuccessfully-deleted-launch-template-versions (clojure.spec.alpha/and :portkey.aws.ec2/delete-launch-template-versions-response-error-set))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-launch-template-versions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-launch-template-versions-result/successfully-deleted-launch-template-versions :portkey.aws.ec2.delete-launch-template-versions-result/unsuccessfully-deleted-launch-template-versions]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-connections-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-connections-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-connections-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-client-vpn-connections-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-client-vpn-connections-request/client-vpn-endpoint-id] :opt-un [:portkey.aws.ec2.describe-client-vpn-connections-request/filters :portkey.aws.ec2/next-token :portkey.aws.ec2/max-results :portkey.aws.ec2.describe-client-vpn-connections-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-capacity-reservations-request/capacity-reservation-ids (clojure.spec.alpha/and :portkey.aws.ec2/capacity-reservation-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-capacity-reservations-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-capacity-reservations-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-capacity-reservations-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-capacity-reservations-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-capacity-reservations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-capacity-reservations-request/capacity-reservation-ids :portkey.aws.ec2.describe-capacity-reservations-request/next-token :portkey.aws.ec2.describe-capacity-reservations-request/max-results :portkey.aws.ec2.describe-capacity-reservations-request/filters :portkey.aws.ec2.describe-capacity-reservations-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.s-3-storage/aws-access-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.s-3-storage/bucket (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.s-3-storage/prefix (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.s-3-storage/upload-policy (clojure.spec.alpha/and :portkey.aws.ec2/blob))
(clojure.spec.alpha/def :portkey.aws.ec2.s-3-storage/upload-policy-signature (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/s-3-storage (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.s-3-storage/aws-access-key-id :portkey.aws.ec2.s-3-storage/bucket :portkey.aws.ec2.s-3-storage/prefix :portkey.aws.ec2.s-3-storage/upload-policy :portkey.aws.ec2.s-3-storage/upload-policy-signature]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-route-result/route (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route))
(clojure.spec.alpha/def :portkey.aws.ec2/create-transit-gateway-route-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-transit-gateway-route-result/route]))

(clojure.spec.alpha/def :portkey.aws.ec2.recurring-charge/amount (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.recurring-charge/frequency (clojure.spec.alpha/and :portkey.aws.ec2/recurring-charge-frequency))
(clojure.spec.alpha/def :portkey.aws.ec2/recurring-charge (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.recurring-charge/amount :portkey.aws.ec2.recurring-charge/frequency]))

(clojure.spec.alpha/def :portkey.aws.ec2/spot-fleet-request-config-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/spot-fleet-request-config))

(clojure.spec.alpha/def :portkey.aws.ec2.provision-byoip-cidr-request/cidr (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.provision-byoip-cidr-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.provision-byoip-cidr-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/provision-byoip-cidr-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.provision-byoip-cidr-request/cidr] :opt-un [:portkey.aws.ec2/cidr-authorization-context :portkey.aws.ec2.provision-byoip-cidr-request/description :portkey.aws.ec2.provision-byoip-cidr-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.byoip-cidr/cidr (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.byoip-cidr/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.byoip-cidr/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.byoip-cidr/state (clojure.spec.alpha/and :portkey.aws.ec2/byoip-cidr-state))
(clojure.spec.alpha/def :portkey.aws.ec2/byoip-cidr (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.byoip-cidr/cidr :portkey.aws.ec2.byoip-cidr/description :portkey.aws.ec2.byoip-cidr/status-message :portkey.aws.ec2.byoip-cidr/state]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-permission-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-permission))

(clojure.spec.alpha/def :portkey.aws.ec2/price-schedule-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/price-schedule))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-instance-requests-result/spot-instance-requests (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-request-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-instance-requests-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-instance-requests-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-spot-instance-requests-result/spot-instance-requests :portkey.aws.ec2.describe-spot-instance-requests-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.disable-vgw-route-propagation-request/gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disable-vgw-route-propagation-request/route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/disable-vgw-route-propagation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.disable-vgw-route-propagation-request/gateway-id :portkey.aws.ec2.disable-vgw-route-propagation-request/route-table-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-private-ip-address-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-private-ip-address))

(clojure.spec.alpha/def :portkey.aws.ec2.directory-service-authentication-request/directory-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/directory-service-authentication-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.directory-service-authentication-request/directory-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-launch-template-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-launch-template-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-launch-template-request/launch-template-data (clojure.spec.alpha/and :portkey.aws.ec2/request-launch-template-data))
(clojure.spec.alpha/def :portkey.aws.ec2/create-launch-template-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2/launch-template-name :portkey.aws.ec2.create-launch-template-request/launch-template-data] :opt-un [:portkey.aws.ec2.create-launch-template-request/dry-run :portkey.aws.ec2.create-launch-template-request/client-token :portkey.aws.ec2/version-description]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-ipv-6-address/ipv-6-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-ipv-6-address (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-ipv-6-address/ipv-6-address]))

(clojure.spec.alpha/def :portkey.aws.ec2.group-identifier/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.group-identifier/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/group-identifier (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.group-identifier/group-name :portkey.aws.ec2.group-identifier/group-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/fpga-image-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/fpga-image))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-price/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-price/product-description (clojure.spec.alpha/and :portkey.aws.ec2/ri-product-description))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-price/spot-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-price/timestamp (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-price (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-price/availability-zone :portkey.aws.ec2/instance-type :portkey.aws.ec2.spot-price/product-description :portkey.aws.ec2.spot-price/spot-price :portkey.aws.ec2.spot-price/timestamp]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-listings-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-listings-request/reserved-instances-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-listings-request/reserved-instances-listing-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-reserved-instances-listings-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-reserved-instances-listings-request/filters :portkey.aws.ec2.describe-reserved-instances-listings-request/reserved-instances-id :portkey.aws.ec2.describe-reserved-instances-listings-request/reserved-instances-listing-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-connection-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/client-vpn-connection))

(clojure.spec.alpha/def :portkey.aws.ec2.create-subnet-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-subnet-request/availability-zone-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-subnet-request/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-subnet-request/ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-subnet-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-subnet-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-subnet-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-subnet-request/cidr-block :portkey.aws.ec2.create-subnet-request/vpc-id] :opt-un [:portkey.aws.ec2.create-subnet-request/availability-zone :portkey.aws.ec2.create-subnet-request/availability-zone-id :portkey.aws.ec2.create-subnet-request/ipv-6-cidr-block :portkey.aws.ec2.create-subnet-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instance-availability-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/scheduled-instance-availability))

(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway/delete-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway/nat-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway/failure-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway/nat-gateway-addresses (clojure.spec.alpha/and :portkey.aws.ec2/nat-gateway-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway/create-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway/state (clojure.spec.alpha/and :portkey.aws.ec2/nat-gateway-state))
(clojure.spec.alpha/def :portkey.aws.ec2.nat-gateway/failure-code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/nat-gateway (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.nat-gateway/delete-time :portkey.aws.ec2/provisioned-bandwidth :portkey.aws.ec2.nat-gateway/subnet-id :portkey.aws.ec2.nat-gateway/nat-gateway-id :portkey.aws.ec2.nat-gateway/tags :portkey.aws.ec2.nat-gateway/failure-message :portkey.aws.ec2.nat-gateway/vpc-id :portkey.aws.ec2.nat-gateway/nat-gateway-addresses :portkey.aws.ec2.nat-gateway/create-time :portkey.aws.ec2.nat-gateway/state :portkey.aws.ec2.nat-gateway/failure-code]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-customer-gateway-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/customer-gateway]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-hosts-result/hosts (clojure.spec.alpha/and :portkey.aws.ec2/host-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-hosts-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-hosts-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-hosts-result/hosts :portkey.aws.ec2.describe-hosts-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-status #{"OK" :ok :impaired "IMPAIRED"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fpga-image-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fpga-image-attribute-request/fpga-image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fpga-image-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/fpga-image-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fpga-image-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-fpga-image-attribute-request/fpga-image-id :portkey.aws.ec2.describe-fpga-image-attribute-request/attribute] :opt-un [:portkey.aws.ec2.describe-fpga-image-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-iam-instance-profile-specification/arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-iam-instance-profile-specification/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-iam-instance-profile-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-iam-instance-profile-specification/arn :portkey.aws.ec2.launch-template-iam-instance-profile-specification/name]))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-status/code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-status/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-instance-status/update-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-instance-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-instance-status/code :portkey.aws.ec2.spot-instance-status/message :portkey.aws.ec2.spot-instance-status/update-time]))

(clojure.spec.alpha/def :portkey.aws.ec2/delete-launch-template-versions-response-success-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/delete-launch-template-versions-response-success-item))

(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-attachment-propagations-result/transit-gateway-attachment-propagations (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-propagation-list))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-attachment-propagations-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/get-transit-gateway-attachment-propagations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.get-transit-gateway-attachment-propagations-result/transit-gateway-attachment-propagations :portkey.aws.ec2.get-transit-gateway-attachment-propagations-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.enable-vpc-classic-link-dns-support-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/enable-vpc-classic-link-dns-support-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.enable-vpc-classic-link-dns-support-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.tag-description/key (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.tag-description/resource-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.tag-description/value (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/tag-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.tag-description/key :portkey.aws.ec2.tag-description/resource-id :portkey.aws.ec2/resource-type :portkey.aws.ec2.tag-description/value]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-attachment-resource-type #{:vpn "vpc" "vpn" :vpc})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-request/transit-gateway-attachment-ids (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-transit-gateway-vpc-attachments-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-transit-gateway-vpc-attachments-request/transit-gateway-attachment-ids :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-request/filters :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-request/max-results :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-request/next-token :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.search-transit-gateway-routes-result/routes (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route-list))
(clojure.spec.alpha/def :portkey.aws.ec2.search-transit-gateway-routes-result/additional-routes-available (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/search-transit-gateway-routes-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.search-transit-gateway-routes-result/routes :portkey.aws.ec2.search-transit-gateway-routes-result/additional-routes-available]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-client-vpn-route-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-client-vpn-route-request/target-vpc-subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-client-vpn-route-request/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-client-vpn-route-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-client-vpn-route-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-client-vpn-route-request/client-vpn-endpoint-id :portkey.aws.ec2.delete-client-vpn-route-request/destination-cidr-block] :opt-un [:portkey.aws.ec2.delete-client-vpn-route-request/target-vpc-subnet-id :portkey.aws.ec2.delete-client-vpn-route-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-template-versions-result/launch-template-versions (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-version-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-template-versions-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-launch-template-versions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-launch-template-versions-result/launch-template-versions :portkey.aws.ec2.describe-launch-template-versions-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/account-attribute-value-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/account-attribute-value))

(clojure.spec.alpha/def :portkey.aws.ec2.update-security-group-rule-descriptions-ingress-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.update-security-group-rule-descriptions-ingress-request/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.update-security-group-rule-descriptions-ingress-request/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.update-security-group-rule-descriptions-ingress-request/ip-permissions (clojure.spec.alpha/and :portkey.aws.ec2/ip-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2/update-security-group-rule-descriptions-ingress-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.update-security-group-rule-descriptions-ingress-request/ip-permissions] :opt-un [:portkey.aws.ec2.update-security-group-rule-descriptions-ingress-request/dry-run :portkey.aws.ec2.update-security-group-rule-descriptions-ingress-request/group-id :portkey.aws.ec2.update-security-group-rule-descriptions-ingress-request/group-name]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-peering-connection-options-request/accepter-peering-connection-options (clojure.spec.alpha/and :portkey.aws.ec2/peering-connection-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-peering-connection-options-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-peering-connection-options-request/requester-peering-connection-options (clojure.spec.alpha/and :portkey.aws.ec2/peering-connection-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-peering-connection-options-request/vpc-peering-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-peering-connection-options-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-vpc-peering-connection-options-request/vpc-peering-connection-id] :opt-un [:portkey.aws.ec2.modify-vpc-peering-connection-options-request/accepter-peering-connection-options :portkey.aws.ec2.modify-vpc-peering-connection-options-request/dry-run :portkey.aws.ec2.modify-vpc-peering-connection-options-request/requester-peering-connection-options]))

(clojure.spec.alpha/def :portkey.aws.ec2/import-snapshot-task-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/import-snapshot-task))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-license-configuration/license-configuration-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-license-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-license-configuration/license-configuration-arn]))

(clojure.spec.alpha/def :portkey.aws.ec2.dhcp-options/dhcp-configurations (clojure.spec.alpha/and :portkey.aws.ec2/dhcp-configuration-list))
(clojure.spec.alpha/def :portkey.aws.ec2.dhcp-options/dhcp-options-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.dhcp-options/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.dhcp-options/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/dhcp-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.dhcp-options/dhcp-configurations :portkey.aws.ec2.dhcp-options/dhcp-options-id :portkey.aws.ec2.dhcp-options/owner-id :portkey.aws.ec2.dhcp-options/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-authentication-request/type (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-authentication-type))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-authentication-request/active-directory (clojure.spec.alpha/and :portkey.aws.ec2/directory-service-authentication-request))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-authentication-request/mutual-authentication (clojure.spec.alpha/and :portkey.aws.ec2/certificate-authentication-request))
(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-authentication-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-vpn-authentication-request/type :portkey.aws.ec2.client-vpn-authentication-request/active-directory :portkey.aws.ec2.client-vpn-authentication-request/mutual-authentication]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-ipv-6-address-list-request (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-ipv-6-address-request))

(clojure.spec.alpha/def :portkey.aws.ec2/spot-instance-interruption-behavior #{"stop" :terminate "hibernate" "terminate" :stop :hibernate})

(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-monitoring-enabled/enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/run-instances-monitoring-enabled (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.run-instances-monitoring-enabled/enabled] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2/authorization-rule-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/authorization-rule))

(clojure.spec.alpha/def :portkey.aws.ec2/user-id-group-pair-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/user-id-group-pair))

(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.get-password-data-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-password-data-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/get-password-data-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.get-password-data-request/instance-id] :opt-un [:portkey.aws.ec2.get-password-data-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-attachment-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-service-configuration-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-service-configuration-request/acceptance-required (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-service-configuration-request/network-load-balancer-arns (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-service-configuration-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpc-endpoint-service-configuration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-vpc-endpoint-service-configuration-request/network-load-balancer-arns] :opt-un [:portkey.aws.ec2.create-vpc-endpoint-service-configuration-request/dry-run :portkey.aws.ec2.create-vpc-endpoint-service-configuration-request/acceptance-required :portkey.aws.ec2.create-vpc-endpoint-service-configuration-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/disk-image-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/disk-image))

(clojure.spec.alpha/def :portkey.aws.ec2/tag-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/tag))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-attachments-request/transit-gateway-attachment-ids (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-attachments-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-attachments-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-attachments-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-attachments-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-transit-gateway-attachments-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-transit-gateway-attachments-request/transit-gateway-attachment-ids :portkey.aws.ec2.describe-transit-gateway-attachments-request/filters :portkey.aws.ec2.describe-transit-gateway-attachments-request/max-results :portkey.aws.ec2.describe-transit-gateway-attachments-request/next-token :portkey.aws.ec2.describe-transit-gateway-attachments-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.client-data/comment (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-data/upload-end (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.client-data/upload-size (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.client-data/upload-start (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/client-data (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-data/comment :portkey.aws.ec2.client-data/upload-end :portkey.aws.ec2.client-data/upload-size :portkey.aws.ec2.client-data/upload-start]))

(clojure.spec.alpha/def :portkey.aws.ec2/network-acl-association-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/network-acl-association))

(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-authorization-rule-status-code #{"failed" :revoking "revoking" "authorizing" :authorizing :active "active" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.modify-volume-attribute-request/auto-enable-io (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-volume-attribute-request/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-volume-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-volume-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-volume-attribute-request/volume-id] :opt-un [:portkey.aws.ec2.modify-volume-attribute-request/auto-enable-io :portkey.aws.ec2.modify-volume-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-identity-id-format-request/principal-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-identity-id-format-request/resource (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-identity-id-format-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-identity-id-format-request/principal-arn] :opt-un [:portkey.aws.ec2.describe-identity-id-format-request/resource]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-launch-template-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/launch-template]))

(clojure.spec.alpha/def :portkey.aws.ec2.image-disk-container/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image-disk-container/device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image-disk-container/format (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image-disk-container/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image-disk-container/url (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/image-disk-container (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.image-disk-container/description :portkey.aws.ec2.image-disk-container/device-name :portkey.aws.ec2.image-disk-container/format :portkey.aws.ec2.image-disk-container/snapshot-id :portkey.aws.ec2.image-disk-container/url :portkey.aws.ec2/user-bucket]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-result/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-result/status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-endpoint-status))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-endpoint-result/dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-client-vpn-endpoint-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-client-vpn-endpoint-result/client-vpn-endpoint-id :portkey.aws.ec2.create-client-vpn-endpoint-result/status :portkey.aws.ec2.create-client-vpn-endpoint-result/dns-name]))

(clojure.spec.alpha/def :portkey.aws.ec2/product-code-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/product-code))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-datafeed-subscription-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-datafeed-subscription-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-spot-datafeed-subscription-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-info-status #{:insufficientdata "impaired" :ok "insufficient-data" :impaired "ok"})

(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/type (clojure.spec.alpha/and :portkey.aws.ec2/fleet-type))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/valid-from (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/instance-pools-to-use-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/spot-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/iam-fleet-role (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/launch-template-configs (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-config-list))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/fulfilled-capacity (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/terminate-instances-with-expiration (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/on-demand-fulfilled-capacity (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/launch-specifications (clojure.spec.alpha/and :portkey.aws.ec2/launch-specs-list))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/replace-unhealthy-instances (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/on-demand-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config-data/valid-until (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-fleet-request-config-data (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.spot-fleet-request-config-data/iam-fleet-role :portkey.aws.ec2.spot-fleet-request-config-data/target-capacity] :opt-un [:portkey.aws.ec2/on-demand-allocation-strategy :portkey.aws.ec2.spot-fleet-request-config-data/type :portkey.aws.ec2.spot-fleet-request-config-data/valid-from :portkey.aws.ec2.spot-fleet-request-config-data/instance-pools-to-use-count :portkey.aws.ec2/excess-capacity-termination-policy :portkey.aws.ec2.spot-fleet-request-config-data/spot-price :portkey.aws.ec2/allocation-strategy :portkey.aws.ec2/instance-interruption-behavior :portkey.aws.ec2.spot-fleet-request-config-data/launch-template-configs :portkey.aws.ec2/load-balancers-config :portkey.aws.ec2.spot-fleet-request-config-data/fulfilled-capacity :portkey.aws.ec2.spot-fleet-request-config-data/terminate-instances-with-expiration :portkey.aws.ec2.spot-fleet-request-config-data/on-demand-fulfilled-capacity :portkey.aws.ec2.spot-fleet-request-config-data/client-token :portkey.aws.ec2.spot-fleet-request-config-data/launch-specifications :portkey.aws.ec2.spot-fleet-request-config-data/replace-unhealthy-instances :portkey.aws.ec2.spot-fleet-request-config-data/on-demand-target-capacity :portkey.aws.ec2.spot-fleet-request-config-data/valid-until]))

(clojure.spec.alpha/def :portkey.aws.ec2.authorization-rule/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorization-rule/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorization-rule/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorization-rule/access-all (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.authorization-rule/destination-cidr (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorization-rule/status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-authorization-rule-status))
(clojure.spec.alpha/def :portkey.aws.ec2/authorization-rule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.authorization-rule/client-vpn-endpoint-id :portkey.aws.ec2.authorization-rule/description :portkey.aws.ec2.authorization-rule/group-id :portkey.aws.ec2.authorization-rule/access-all :portkey.aws.ec2.authorization-rule/destination-cidr :portkey.aws.ec2.authorization-rule/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-network-acl-entry-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-acl-entry-request/network-acl-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-acl-entry-request/rule-number (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-acl-entry-request/egress (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-acl-entry-request/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-acl-entry-request/ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-acl-entry-request/protocol (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-network-acl-entry-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-network-acl-entry-request/egress :portkey.aws.ec2.create-network-acl-entry-request/network-acl-id :portkey.aws.ec2.create-network-acl-entry-request/protocol :portkey.aws.ec2/rule-action :portkey.aws.ec2.create-network-acl-entry-request/rule-number] :opt-un [:portkey.aws.ec2.create-network-acl-entry-request/dry-run :portkey.aws.ec2/icmp-type-code :portkey.aws.ec2.create-network-acl-entry-request/cidr-block :portkey.aws.ec2.create-network-acl-entry-request/ipv-6-cidr-block :portkey.aws.ec2/port-range]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-overrides/spot-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-overrides/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-overrides/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-overrides/weighted-capacity (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-overrides/priority (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-overrides (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/instance-type :portkey.aws.ec2.launch-template-overrides/spot-price :portkey.aws.ec2.launch-template-overrides/subnet-id :portkey.aws.ec2.launch-template-overrides/availability-zone :portkey.aws.ec2.launch-template-overrides/weighted-capacity :portkey.aws.ec2.launch-template-overrides/priority]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-modifications-result/volumes-modifications (clojure.spec.alpha/and :portkey.aws.ec2/volume-modification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-modifications-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-volumes-modifications-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-volumes-modifications-result/volumes-modifications :portkey.aws.ec2.describe-volumes-modifications-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-market-options-request/spot-options (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-spot-market-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-instance-market-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/market-type :portkey.aws.ec2.launch-template-instance-market-options-request/spot-options]))

(clojure.spec.alpha/def :portkey.aws.ec2.host-offering/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2.host-offering/duration (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.host-offering/hourly-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host-offering/instance-family (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host-offering/offering-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host-offering/upfront-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/host-offering (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.host-offering/currency-code :portkey.aws.ec2.host-offering/duration :portkey.aws.ec2.host-offering/hourly-price :portkey.aws.ec2.host-offering/instance-family :portkey.aws.ec2.host-offering/offering-id :portkey.aws.ec2/payment-option :portkey.aws.ec2.host-offering/upfront-price]))

(clojure.spec.alpha/def :portkey.aws.ec2/unsuccessful-instance-credit-specification-error-code #{:invalid-instance-id-malformed :incorrect-instance-state "InvalidInstanceID.Malformed" "InstanceCreditSpecification.NotSupported" :invalid-instance-id-not-found "InvalidInstanceID.NotFound" "IncorrectInstanceState" :instance-credit-specification-not-supported})

(clojure.spec.alpha/def :portkey.aws.ec2.enable-transit-gateway-route-table-propagation-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.enable-transit-gateway-route-table-propagation-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.enable-transit-gateway-route-table-propagation-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/enable-transit-gateway-route-table-propagation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.enable-transit-gateway-route-table-propagation-request/transit-gateway-route-table-id :portkey.aws.ec2.enable-transit-gateway-route-table-propagation-request/transit-gateway-attachment-id] :opt-un [:portkey.aws.ec2.enable-transit-gateway-route-table-propagation-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.accept-vpc-endpoint-connections-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.accept-vpc-endpoint-connections-request/service-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.accept-vpc-endpoint-connections-request/vpc-endpoint-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/accept-vpc-endpoint-connections-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.accept-vpc-endpoint-connections-request/service-id :portkey.aws.ec2.accept-vpc-endpoint-connections-request/vpc-endpoint-ids] :opt-un [:portkey.aws.ec2.accept-vpc-endpoint-connections-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/conversion-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-public-ipv-4-pools-result/public-ipv-4-pools (clojure.spec.alpha/and :portkey.aws.ec2/public-ipv-4-pool-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-public-ipv-4-pools-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-public-ipv-4-pools-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-public-ipv-4-pools-result/public-ipv-4-pools :portkey.aws.ec2.describe-public-ipv-4-pools-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-key-pair-request/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-key-pair-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-key-pair-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-key-pair-request/key-name] :opt-un [:portkey.aws.ec2.delete-key-pair-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/listing-state #{:pending "sold" :sold "cancelled" :cancelled :available "pending" "available"})

(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-events-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/volume-status-event))

(clojure.spec.alpha/def :portkey.aws.ec2/datafeed-subscription-state #{:inactive "Active" "Inactive" :active})

(clojure.spec.alpha/def :portkey.aws.ec2.connection-log-options/enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.connection-log-options/cloudwatch-log-group (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.connection-log-options/cloudwatch-log-stream (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/connection-log-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.connection-log-options/enabled :portkey.aws.ec2.connection-log-options/cloudwatch-log-group :portkey.aws.ec2.connection-log-options/cloudwatch-log-stream]))

(clojure.spec.alpha/def :portkey.aws.ec2.service-detail/service-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.service-detail/service-type (clojure.spec.alpha/and :portkey.aws.ec2/service-type-detail-set))
(clojure.spec.alpha/def :portkey.aws.ec2.service-detail/availability-zones (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.service-detail/owner (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.service-detail/base-endpoint-dns-names (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.service-detail/private-dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.service-detail/vpc-endpoint-policy-supported (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.service-detail/acceptance-required (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/service-detail (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.service-detail/service-name :portkey.aws.ec2.service-detail/service-type :portkey.aws.ec2.service-detail/availability-zones :portkey.aws.ec2.service-detail/owner :portkey.aws.ec2.service-detail/base-endpoint-dns-names :portkey.aws.ec2.service-detail/private-dns-name :portkey.aws.ec2.service-detail/vpc-endpoint-policy-supported :portkey.aws.ec2.service-detail/acceptance-required]))

(clojure.spec.alpha/def :portkey.aws.ec2.stop-instances-result/stopping-instances (clojure.spec.alpha/and :portkey.aws.ec2/instance-state-change-list))
(clojure.spec.alpha/def :portkey.aws.ec2/stop-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.stop-instances-result/stopping-instances]))

(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/network-interface))

(clojure.spec.alpha/def :portkey.aws.ec2/cancel-batch-error-code #{:fleet-request-id-does-not-exist "fleetRequestIdDoesNotExist" "unexpectedError" "fleetRequestIdMalformed" :fleet-request-not-in-cancellable-state "fleetRequestNotInCancellableState" :fleet-request-id-malformed :unexpected-error})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoints-result/vpc-endpoints (clojure.spec.alpha/and :portkey.aws.ec2/vpc-endpoint-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoints-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoints-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-endpoints-result/vpc-endpoints :portkey.aws.ec2.describe-vpc-endpoints-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.deregister-image-request/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.deregister-image-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/deregister-image-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.deregister-image-request/image-id] :opt-un [:portkey.aws.ec2.deregister-image-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.target-configuration/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.target-configuration/offering-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/target-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.target-configuration/instance-count :portkey.aws.ec2.target-configuration/offering-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/allocation-strategy #{"lowestPrice" :diversified :lowest-price "diversified"})

(clojure.spec.alpha/def :portkey.aws.ec2/status-name #{:reachability "reachability"})

(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-event/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-event/event-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-event/event-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-event/not-after (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-event/not-before (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.volume-status-event/description :portkey.aws.ec2.volume-status-event/event-id :portkey.aws.ec2.volume-status-event/event-type :portkey.aws.ec2.volume-status-event/not-after :portkey.aws.ec2.volume-status-event/not-before]))

(clojure.spec.alpha/def :portkey.aws.ec2/describe-fleets-error-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/describe-fleet-error))

(clojure.spec.alpha/def :portkey.aws.ec2/target-reservation-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/reservation-value :portkey.aws.ec2/target-configuration]))

(clojure.spec.alpha/def :portkey.aws.ec2.get-launch-template-data-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.get-launch-template-data-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/get-launch-template-data-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.get-launch-template-data-request/instance-id] :opt-un [:portkey.aws.ec2.get-launch-template-data-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-endpoints-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-endpoints-request/vpc-endpoint-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpc-endpoints-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-vpc-endpoints-request/vpc-endpoint-ids] :opt-un [:portkey.aws.ec2.delete-vpc-endpoints-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-intances-ids (clojure.spec.alpha/coll-of :portkey.aws.ec2/reserved-instances-id))

(clojure.spec.alpha/def :portkey.aws.ec2.purchase-scheduled-instances-result/scheduled-instance-set (clojure.spec.alpha/and :portkey.aws.ec2/purchased-scheduled-instance-set))
(clojure.spec.alpha/def :portkey.aws.ec2/purchase-scheduled-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.purchase-scheduled-instances-result/scheduled-instance-set]))

(clojure.spec.alpha/def :portkey.aws.ec2.copy-fpga-image-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-fpga-image-request/source-fpga-image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-fpga-image-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-fpga-image-request/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-fpga-image-request/source-region (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.copy-fpga-image-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/copy-fpga-image-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.copy-fpga-image-request/source-fpga-image-id :portkey.aws.ec2.copy-fpga-image-request/source-region] :opt-un [:portkey.aws.ec2.copy-fpga-image-request/dry-run :portkey.aws.ec2.copy-fpga-image-request/description :portkey.aws.ec2.copy-fpga-image-request/name :portkey.aws.ec2.copy-fpga-image-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.attribute-value/value (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/attribute-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.attribute-value/value]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-capacity-reservation-request/capacity-reservation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-capacity-reservation-request/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-capacity-reservation-request/end-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-capacity-reservation-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-capacity-reservation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-capacity-reservation-request/capacity-reservation-id] :opt-un [:portkey.aws.ec2.modify-capacity-reservation-request/instance-count :portkey.aws.ec2.modify-capacity-reservation-request/end-date :portkey.aws.ec2/end-date-type :portkey.aws.ec2.modify-capacity-reservation-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-block-device-mapping-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-block-device-mapping))

(clojure.spec.alpha/def :portkey.aws.ec2.create-dhcp-options-request/dhcp-configurations (clojure.spec.alpha/and :portkey.aws.ec2/new-dhcp-configuration-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-dhcp-options-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-dhcp-options-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-dhcp-options-request/dhcp-configurations] :opt-un [:portkey.aws.ec2.create-dhcp-options-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.network-acl-association/network-acl-association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl-association/network-acl-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl-association/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/network-acl-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-acl-association/network-acl-association-id :portkey.aws.ec2.network-acl-association/network-acl-id :portkey.aws.ec2.network-acl-association/subnet-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/private-ip-address-specification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/private-ip-address-specification))

(clojure.spec.alpha/def :portkey.aws.ec2.accept-transit-gateway-vpc-attachment-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.accept-transit-gateway-vpc-attachment-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/accept-transit-gateway-vpc-attachment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.accept-transit-gateway-vpc-attachment-request/transit-gateway-attachment-id] :opt-un [:portkey.aws.ec2.accept-transit-gateway-vpc-attachment-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/auto-placement #{"off" "on" :off :on})

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-tag-specification-request-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-tag-specification-request))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-addresses-result/addresses (clojure.spec.alpha/and :portkey.aws.ec2/address-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-addresses-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-addresses-result/addresses]))

(clojure.spec.alpha/def :portkey.aws.ec2.purchase-host-reservation-result/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-host-reservation-result/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-host-reservation-result/purchase (clojure.spec.alpha/and :portkey.aws.ec2/purchase-set))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-host-reservation-result/total-hourly-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-host-reservation-result/total-upfront-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/purchase-host-reservation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.purchase-host-reservation-result/client-token :portkey.aws.ec2.purchase-host-reservation-result/currency-code :portkey.aws.ec2.purchase-host-reservation-result/purchase :portkey.aws.ec2.purchase-host-reservation-result/total-hourly-price :portkey.aws.ec2.purchase-host-reservation-result/total-upfront-price]))

(clojure.spec.alpha/def :portkey.aws.ec2.search-transit-gateway-routes-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.search-transit-gateway-routes-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.search-transit-gateway-routes-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2.search-transit-gateway-routes-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/search-transit-gateway-routes-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.search-transit-gateway-routes-request/transit-gateway-route-table-id :portkey.aws.ec2.search-transit-gateway-routes-request/filters] :opt-un [:portkey.aws.ec2.search-transit-gateway-routes-request/max-results :portkey.aws.ec2.search-transit-gateway-routes-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-prefix-lists-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-prefix-lists-result/prefix-lists (clojure.spec.alpha/and :portkey.aws.ec2/prefix-list-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-prefix-lists-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-prefix-lists-result/next-token :portkey.aws.ec2.describe-prefix-lists-result/prefix-lists]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-route-tables-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-route-tables-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-route-tables-request/route-table-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-route-tables-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-route-tables-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-route-tables-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-route-tables-request/filters :portkey.aws.ec2.describe-route-tables-request/dry-run :portkey.aws.ec2.describe-route-tables-request/route-table-ids :portkey.aws.ec2.describe-route-tables-request/next-token :portkey.aws.ec2.describe-route-tables-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2/prefix-list-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/prefix-list-id))

(clojure.spec.alpha/def :portkey.aws.ec2/auto-accept-shared-attachments-value #{:disable :enable "enable" "disable"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-identity-id-format-result/statuses (clojure.spec.alpha/and :portkey.aws.ec2/id-format-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-identity-id-format-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-identity-id-format-result/statuses]))

(clojure.spec.alpha/def :portkey.aws.ec2/availability-zone-message-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/availability-zone-message))

(clojure.spec.alpha/def :portkey.aws.ec2.create-launch-template-version-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-launch-template-version-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-launch-template-version-request/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-launch-template-version-request/source-version (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-launch-template-version-request/launch-template-data (clojure.spec.alpha/and :portkey.aws.ec2/request-launch-template-data))
(clojure.spec.alpha/def :portkey.aws.ec2/create-launch-template-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-launch-template-version-request/launch-template-data] :opt-un [:portkey.aws.ec2.create-launch-template-version-request/dry-run :portkey.aws.ec2.create-launch-template-version-request/client-token :portkey.aws.ec2.create-launch-template-version-request/launch-template-id :portkey.aws.ec2/launch-template-name :portkey.aws.ec2.create-launch-template-version-request/source-version :portkey.aws.ec2/version-description]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-request/connection-notification-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoint-connection-notifications-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-request/dry-run :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-request/connection-notification-id :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-request/filters :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-request/max-results :portkey.aws.ec2.describe-vpc-endpoint-connection-notifications-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-attribute-name #{:enable-dns-support :enable-dns-hostnames "enableDnsHostnames" "enableDnsSupport"})

(clojure.spec.alpha/def :portkey.aws.ec2.modify-fleet-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fleet-request/excess-capacity-termination-policy (clojure.spec.alpha/and :portkey.aws.ec2/fleet-excess-capacity-termination-policy))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fleet-request/fleet-id (clojure.spec.alpha/and :portkey.aws.ec2/fleet-identifier))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fleet-request/target-capacity-specification (clojure.spec.alpha/and :portkey.aws.ec2/target-capacity-specification-request))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-fleet-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-fleet-request/fleet-id :portkey.aws.ec2.modify-fleet-request/target-capacity-specification] :opt-un [:portkey.aws.ec2.modify-fleet-request/dry-run :portkey.aws.ec2.modify-fleet-request/excess-capacity-termination-policy]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-hibernation-options/configured (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-hibernation-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-hibernation-options/configured]))

(clojure.spec.alpha/def :portkey.aws.ec2/history-records (clojure.spec.alpha/coll-of :portkey.aws.ec2/history-record))

(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-datafeed-subscription-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/spot-datafeed-subscription]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-instance-export-task-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-instance-export-task-request/export-to-s-3-task (clojure.spec.alpha/and :portkey.aws.ec2/export-to-s-3-task-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.create-instance-export-task-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-instance-export-task-request/target-environment (clojure.spec.alpha/and :portkey.aws.ec2/export-environment))
(clojure.spec.alpha/def :portkey.aws.ec2/create-instance-export-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-instance-export-task-request/instance-id] :opt-un [:portkey.aws.ec2.create-instance-export-task-request/description :portkey.aws.ec2.create-instance-export-task-request/export-to-s-3-task :portkey.aws.ec2.create-instance-export-task-request/target-environment]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-block-device-mapping-specification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-block-device-mapping-specification))

(clojure.spec.alpha/def :portkey.aws.ec2/tag-description-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/tag-description))

(clojure.spec.alpha/def :portkey.aws.ec2.load-permission-request/group (clojure.spec.alpha/and :portkey.aws.ec2/permission-group))
(clojure.spec.alpha/def :portkey.aws.ec2.load-permission-request/user-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/load-permission-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.load-permission-request/group :portkey.aws.ec2.load-permission-request/user-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/describe-instance-credit-specifications-max-results (clojure.spec.alpha/int-in 5 1000))

(clojure.spec.alpha/def :portkey.aws.ec2.create-tags-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-tags-request/resources (clojure.spec.alpha/and :portkey.aws.ec2/resource-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-tags-request/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/create-tags-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-tags-request/resources :portkey.aws.ec2.create-tags-request/tags] :opt-un [:portkey.aws.ec2.create-tags-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-request/event-type (clojure.spec.alpha/and :portkey.aws.ec2/fleet-event-type))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-request/fleet-id (clojure.spec.alpha/and :portkey.aws.ec2/fleet-identifier))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-request/start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fleet-history-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-fleet-history-request/fleet-id :portkey.aws.ec2.describe-fleet-history-request/start-time] :opt-un [:portkey.aws.ec2.describe-fleet-history-request/dry-run :portkey.aws.ec2.describe-fleet-history-request/event-type :portkey.aws.ec2.describe-fleet-history-request/max-results :portkey.aws.ec2.describe-fleet-history-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/product-code-values #{"marketplace" :devpay :marketplace "devpay"})

(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-config/launch-template-specification (clojure.spec.alpha/and :portkey.aws.ec2/fleet-launch-template-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-config/overrides (clojure.spec.alpha/and :portkey.aws.ec2/fleet-launch-template-overrides-list))
(clojure.spec.alpha/def :portkey.aws.ec2/fleet-launch-template-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.fleet-launch-template-config/launch-template-specification :portkey.aws.ec2.fleet-launch-template-config/overrides]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-reserved-instances-listing-request/reserved-instances-listing-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-reserved-instances-listing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.cancel-reserved-instances-listing-request/reserved-instances-listing-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-health-status #{"healthy" :unhealthy :healthy "unhealthy"})

(clojure.spec.alpha/def :portkey.aws.ec2/purchase-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/purchase))

(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-route-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/client-vpn-route))

(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-route-status/code (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-route-status-code))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-route-status/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-route-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-vpn-route-status/code :portkey.aws.ec2.client-vpn-route-status/message]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-fleet-instances-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/create-fleet-instance))

(clojure.spec.alpha/def :portkey.aws.ec2.attach-vpn-gateway-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-vpn-gateway-request/vpn-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-vpn-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/attach-vpn-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.attach-vpn-gateway-request/vpc-id :portkey.aws.ec2.attach-vpn-gateway-request/vpn-gateway-id] :opt-un [:portkey.aws.ec2.attach-vpn-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.ipv-6-cidr-block/ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/ipv-6-cidr-block (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.ipv-6-cidr-block/ipv-6-cidr-block]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-transit-gateway-route-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-transit-gateway-route-request/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-transit-gateway-route-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-transit-gateway-route-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-transit-gateway-route-request/transit-gateway-route-table-id :portkey.aws.ec2.delete-transit-gateway-route-request/destination-cidr-block] :opt-un [:portkey.aws.ec2.delete-transit-gateway-route-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/import-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/conversion-task]))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-client-vpn-target-network-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-client-vpn-target-network-request/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-client-vpn-target-network-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-client-vpn-target-network-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.disassociate-client-vpn-target-network-request/client-vpn-endpoint-id :portkey.aws.ec2.disassociate-client-vpn-target-network-request/association-id] :opt-un [:portkey.aws.ec2.disassociate-client-vpn-target-network-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/fpga-image-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-result/transit-gateway-vpc-attachments (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-vpc-attachment-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-transit-gateway-vpc-attachments-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-transit-gateway-vpc-attachments-result/transit-gateway-vpc-attachments :portkey.aws.ec2.describe-transit-gateway-vpc-attachments-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/placement-strategy #{"cluster" :cluster :spread "partition" :partition "spread"})

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-request/spot-fleet-request-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-request/terminate-instances (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-spot-fleet-requests-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.cancel-spot-fleet-requests-request/spot-fleet-request-ids :portkey.aws.ec2.cancel-spot-fleet-requests-request/terminate-instances] :opt-un [:portkey.aws.ec2.cancel-spot-fleet-requests-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-transit-gateway-route-table-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/transit-gateway-route-table]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-route-table-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-route-table-request/route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-route-table-request/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-route-table-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.associate-route-table-request/route-table-id :portkey.aws.ec2.associate-route-table-request/subnet-id] :opt-un [:portkey.aws.ec2.associate-route-table-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/user-group-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-public-ipv-4-pools-request/pool-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-public-ipv-4-pools-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/pool-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-public-ipv-4-pools-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-public-ipv-4-pools-request/pool-ids :portkey.aws.ec2/next-token :portkey.aws.ec2.describe-public-ipv-4-pools-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-vpc-cidr-block-result/ipv-6-cidr-block-association (clojure.spec.alpha/and :portkey.aws.ec2/vpc-ipv-6-cidr-block-association))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-vpc-cidr-block-result/cidr-block-association (clojure.spec.alpha/and :portkey.aws.ec2/vpc-cidr-block-association))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-vpc-cidr-block-result/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-vpc-cidr-block-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.associate-vpc-cidr-block-result/ipv-6-cidr-block-association :portkey.aws.ec2.associate-vpc-cidr-block-result/cidr-block-association :portkey.aws.ec2.associate-vpc-cidr-block-result/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/internet-gateway-attachment-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/internet-gateway-attachment))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-key-pairs-result/key-pairs (clojure.spec.alpha/and :portkey.aws.ec2/key-pair-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-key-pairs-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-key-pairs-result/key-pairs]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-internet-gateways-result/internet-gateways (clojure.spec.alpha/and :portkey.aws.ec2/internet-gateway-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-internet-gateways-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-internet-gateways-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-internet-gateways-result/internet-gateways :portkey.aws.ec2.describe-internet-gateways-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-classic-link-dns-support-result/vpcs (clojure.spec.alpha/and :portkey.aws.ec2/classic-link-dns-support-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-classic-link-dns-support-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/next-token :portkey.aws.ec2.describe-vpc-classic-link-dns-support-result/vpcs]))

(clojure.spec.alpha/def :portkey.aws.ec2.detach-internet-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-internet-gateway-request/internet-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-internet-gateway-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/detach-internet-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.detach-internet-gateway-request/internet-gateway-id :portkey.aws.ec2.detach-internet-gateway-request/vpc-id] :opt-un [:portkey.aws.ec2.detach-internet-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.license-configuration/license-configuration-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/license-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.license-configuration/license-configuration-arn]))

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-ebs/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-ebs/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-ebs/iops (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-ebs/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-ebs/volume-size (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-ebs/volume-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-ebs (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instances-ebs/delete-on-termination :portkey.aws.ec2.scheduled-instances-ebs/encrypted :portkey.aws.ec2.scheduled-instances-ebs/iops :portkey.aws.ec2.scheduled-instances-ebs/snapshot-id :portkey.aws.ec2.scheduled-instances-ebs/volume-size :portkey.aws.ec2.scheduled-instances-ebs/volume-type]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-id-format-result/statuses (clojure.spec.alpha/and :portkey.aws.ec2/id-format-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-id-format-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-id-format-result/statuses]))

(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-info/details (clojure.spec.alpha/and :portkey.aws.ec2/volume-status-details-list))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-info/status (clojure.spec.alpha/and :portkey.aws.ec2/volume-status-info-status))
(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.volume-status-info/details :portkey.aws.ec2.volume-status-info/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-capacity/available-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-capacity/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-capacity/total-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-capacity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-capacity/available-capacity :portkey.aws.ec2.instance-capacity/instance-type :portkey.aws.ec2.instance-capacity/total-capacity]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-block-device-mapping/device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-block-device-mapping/ebs (clojure.spec.alpha/and :portkey.aws.ec2/ebs-instance-block-device))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-block-device-mapping (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-block-device-mapping/device-name :portkey.aws.ec2.instance-block-device-mapping/ebs]))

(clojure.spec.alpha/def :portkey.aws.ec2/connection-notification-state #{"Disabled" :disabled "Enabled" :enabled})

(clojure.spec.alpha/def :portkey.aws.ec2/target-configuration-request-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/target-configuration-request))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshot-attribute-result/create-volume-permissions (clojure.spec.alpha/and :portkey.aws.ec2/create-volume-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshot-attribute-result/product-codes (clojure.spec.alpha/and :portkey.aws.ec2/product-code-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshot-attribute-result/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-snapshot-attribute-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-snapshot-attribute-result/create-volume-permissions :portkey.aws.ec2.describe-snapshot-attribute-result/product-codes :portkey.aws.ec2.describe-snapshot-attribute-result/snapshot-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-interruption-behavior #{"stop" :terminate "hibernate" "terminate" :stop :hibernate})

(clojure.spec.alpha/def :portkey.aws.ec2/create-launch-template-version-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/launch-template-version]))

(clojure.spec.alpha/def :portkey.aws.ec2/customer-gateway-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/customer-gateway))

(clojure.spec.alpha/def :portkey.aws.ec2.withdraw-byoip-cidr-request/cidr (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.withdraw-byoip-cidr-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/withdraw-byoip-cidr-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.withdraw-byoip-cidr-request/cidr] :opt-un [:portkey.aws.ec2.withdraw-byoip-cidr-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-options/allocation-strategy (clojure.spec.alpha/and :portkey.aws.ec2/spot-allocation-strategy))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-options/instance-interruption-behavior (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-interruption-behavior))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-options/instance-pools-to-use-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-options/single-instance-type (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-options/single-availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-options/min-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-options/allocation-strategy :portkey.aws.ec2.spot-options/instance-interruption-behavior :portkey.aws.ec2.spot-options/instance-pools-to-use-count :portkey.aws.ec2.spot-options/single-instance-type :portkey.aws.ec2.spot-options/single-availability-zone :portkey.aws.ec2.spot-options/min-target-capacity]))

(clojure.spec.alpha/def :portkey.aws.ec2.classic-link-dns-support/classic-link-dns-supported (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.classic-link-dns-support/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/classic-link-dns-support (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.classic-link-dns-support/classic-link-dns-supported :portkey.aws.ec2.classic-link-dns-support/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-cidr-block-state-code #{:associating "associating" :associated "failed" "disassociated" :disassociated "associated" "failing" :failing :disassociating "disassociating" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.enable-volume-io-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.enable-volume-io-request/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/enable-volume-io-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.enable-volume-io-request/volume-id] :opt-un [:portkey.aws.ec2.enable-volume-io-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/public-ipv-4-pool-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/public-ipv-4-pool))

(clojure.spec.alpha/def :portkey.aws.ec2/monitoring-state #{:disabled :pending "enabled" :disabling "disabling" "disabled" "pending" :enabled})

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instance-reservation-value-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/reserved-instance-reservation-value))

(clojure.spec.alpha/def :portkey.aws.ec2.hibernation-options/configured (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/hibernation-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.hibernation-options/configured]))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.get-console-output-result/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-console-output-result/output (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-console-output-result/timestamp (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/get-console-output-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.get-console-output-result/instance-id :portkey.aws.ec2.get-console-output-result/output :portkey.aws.ec2.get-console-output-result/timestamp]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-subnet-request/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-subnet-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-subnet-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-subnet-request/subnet-id] :opt-un [:portkey.aws.ec2.delete-subnet-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-vpc-cidr-block-request/amazon-provided-ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-vpc-cidr-block-request/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-vpc-cidr-block-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-vpc-cidr-block-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.associate-vpc-cidr-block-request/vpc-id] :opt-un [:portkey.aws.ec2.associate-vpc-cidr-block-request/amazon-provided-ipv-6-cidr-block :portkey.aws.ec2.associate-vpc-cidr-block-request/cidr-block]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-placement-groups-result/placement-groups (clojure.spec.alpha/and :portkey.aws.ec2/placement-group-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-placement-groups-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-placement-groups-result/placement-groups]))

(clojure.spec.alpha/def :portkey.aws.ec2/dhcp-options-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/create-vpc-peering-connection-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/vpc-peering-connection]))

(clojure.spec.alpha/def :portkey.aws.ec2.dns-servers-options-modify-structure/custom-dns-servers (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.dns-servers-options-modify-structure/enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/dns-servers-options-modify-structure (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.dns-servers-options-modify-structure/custom-dns-servers :portkey.aws.ec2.dns-servers-options-modify-structure/enabled]))

(clojure.spec.alpha/def :portkey.aws.ec2/scope #{"Availability Zone" :availability-zone :region "Region"})

(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-permission-state-code #{"granted" :pending :revoking :revoked "revoking" "revoked" :granted "pending"})

(clojure.spec.alpha/def :portkey.aws.ec2/reset-image-attribute-name #{"launchPermission" :launch-permission})

(clojure.spec.alpha/def :portkey.aws.ec2.modify-hosts-result/successful (clojure.spec.alpha/and :portkey.aws.ec2/response-host-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-hosts-result/unsuccessful (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-item-list))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-hosts-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-hosts-result/successful :portkey.aws.ec2.modify-hosts-result/unsuccessful]))

(clojure.spec.alpha/def :portkey.aws.ec2.connection-log-response-options/enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.connection-log-response-options/cloudwatch-log-group (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.connection-log-response-options/cloudwatch-log-stream (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/connection-log-response-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.connection-log-response-options/enabled :portkey.aws.ec2.connection-log-response-options/cloudwatch-log-group :portkey.aws.ec2.connection-log-response-options/cloudwatch-log-stream]))

(clojure.spec.alpha/def :portkey.aws.ec2/device-type #{:ebs "ebs" "instance-store" :instancestore})

(clojure.spec.alpha/def :portkey.aws.ec2/create-vpn-connection-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/vpn-connection]))

(clojure.spec.alpha/def :portkey.aws.ec2/route-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/route))

(clojure.spec.alpha/def :portkey.aws.ec2.pricing-detail/count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.pricing-detail/price (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2/pricing-detail (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.pricing-detail/count :portkey.aws.ec2.pricing-detail/price]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-type #{"static" :static "propagated" :propagated})

(clojure.spec.alpha/def :portkey.aws.ec2.import-volume-task-details/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-volume-task-details/bytes-converted (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.import-volume-task-details/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-volume-task-details/image (clojure.spec.alpha/and :portkey.aws.ec2/disk-image-description))
(clojure.spec.alpha/def :portkey.aws.ec2.import-volume-task-details/volume (clojure.spec.alpha/and :portkey.aws.ec2/disk-image-volume-description))
(clojure.spec.alpha/def :portkey.aws.ec2/import-volume-task-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.import-volume-task-details/availability-zone :portkey.aws.ec2.import-volume-task-details/bytes-converted :portkey.aws.ec2.import-volume-task-details/description :portkey.aws.ec2.import-volume-task-details/image :portkey.aws.ec2.import-volume-task-details/volume]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-match-criteria #{:targeted :open "targeted" "open"})

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route-table-state))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table/default-association-route-table (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table/default-propagation-route-table (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table/creation-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-table (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-route-table/transit-gateway-route-table-id :portkey.aws.ec2.transit-gateway-route-table/transit-gateway-id :portkey.aws.ec2.transit-gateway-route-table/state :portkey.aws.ec2.transit-gateway-route-table/default-association-route-table :portkey.aws.ec2.transit-gateway-route-table/default-propagation-route-table :portkey.aws.ec2.transit-gateway-route-table/creation-time :portkey.aws.ec2.transit-gateway-route-table/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2/subnet-cidr-block-state-code #{:associating "associating" :associated "failed" "disassociated" :disassociated "associated" "failing" :failing :disassociating "disassociating" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-customer-gateways-result/customer-gateways (clojure.spec.alpha/and :portkey.aws.ec2/customer-gateway-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-customer-gateways-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-customer-gateways-result/customer-gateways]))

(clojure.spec.alpha/def :portkey.aws.ec2/fpga-image-state-code #{"failed" :pending :unavailable :available "unavailable" "pending" "available" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/security-group-ids (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instances-security-group-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/placement (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instances-placement))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/monitoring (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instances-monitoring))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instances-block-device-mapping-set))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/ramdisk-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/user-data (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/iam-instance-profile (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instances-iam-instance-profile))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-launch-specification/network-interfaces (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instances-network-interface-set))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-launch-specification (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.scheduled-instances-launch-specification/image-id] :opt-un [:portkey.aws.ec2.scheduled-instances-launch-specification/kernel-id :portkey.aws.ec2.scheduled-instances-launch-specification/security-group-ids :portkey.aws.ec2.scheduled-instances-launch-specification/placement :portkey.aws.ec2.scheduled-instances-launch-specification/subnet-id :portkey.aws.ec2.scheduled-instances-launch-specification/ebs-optimized :portkey.aws.ec2.scheduled-instances-launch-specification/instance-type :portkey.aws.ec2.scheduled-instances-launch-specification/key-name :portkey.aws.ec2.scheduled-instances-launch-specification/monitoring :portkey.aws.ec2.scheduled-instances-launch-specification/block-device-mappings :portkey.aws.ec2.scheduled-instances-launch-specification/ramdisk-id :portkey.aws.ec2.scheduled-instances-launch-specification/user-data :portkey.aws.ec2.scheduled-instances-launch-specification/iam-instance-profile :portkey.aws.ec2.scheduled-instances-launch-specification/network-interfaces]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-license-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-license-configuration))

(clojure.spec.alpha/def :portkey.aws.ec2/product-description-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.disable-transit-gateway-route-table-propagation-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disable-transit-gateway-route-table-propagation-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disable-transit-gateway-route-table-propagation-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/disable-transit-gateway-route-table-propagation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.disable-transit-gateway-route-table-propagation-request/transit-gateway-route-table-id :portkey.aws.ec2.disable-transit-gateway-route-table-propagation-request/transit-gateway-attachment-id] :opt-un [:portkey.aws.ec2.disable-transit-gateway-route-table-propagation-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-account-attributes-result/account-attributes (clojure.spec.alpha/and :portkey.aws.ec2/account-attribute-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-account-attributes-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-account-attributes-result/account-attributes]))

(clojure.spec.alpha/def :portkey.aws.ec2.on-demand-options/allocation-strategy (clojure.spec.alpha/and :portkey.aws.ec2/fleet-on-demand-allocation-strategy))
(clojure.spec.alpha/def :portkey.aws.ec2.on-demand-options/single-instance-type (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.on-demand-options/single-availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.on-demand-options/min-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/on-demand-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.on-demand-options/allocation-strategy :portkey.aws.ec2.on-demand-options/single-instance-type :portkey.aws.ec2.on-demand-options/single-availability-zone :portkey.aws.ec2.on-demand-options/min-target-capacity]))

(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-status #{:associated "detaching" "in-use" "associated" :inuse "attaching" :attaching :available "available" :detaching})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instances-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-scheduled-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-scheduled-instances-result/next-token :portkey.aws.ec2/scheduled-instance-set]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-connection-notification-result/return-value (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-endpoint-connection-notification-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-vpc-endpoint-connection-notification-result/return-value]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/fleet-identifier))

(clojure.spec.alpha/def :portkey.aws.ec2.vpn-tunnel-options-specification/tunnel-inside-cidr (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-tunnel-options-specification/pre-shared-key (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/vpn-tunnel-options-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpn-tunnel-options-specification/tunnel-inside-cidr :portkey.aws.ec2.vpn-tunnel-options-specification/pre-shared-key]))

(clojure.spec.alpha/def :portkey.aws.ec2.replace-transit-gateway-route-result/route (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route))
(clojure.spec.alpha/def :portkey.aws.ec2/replace-transit-gateway-route-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.replace-transit-gateway-route-result/route]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-subnet-attribute-request/assign-ipv-6-address-on-creation (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-subnet-attribute-request/map-public-ip-on-launch (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-subnet-attribute-request/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-subnet-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-subnet-attribute-request/subnet-id] :opt-un [:portkey.aws.ec2.modify-subnet-attribute-request/assign-ipv-6-address-on-creation :portkey.aws.ec2.modify-subnet-attribute-request/map-public-ip-on-launch]))

(clojure.spec.alpha/def :portkey.aws.ec2.purchase-reserved-instances-offering-result/reserved-instances-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/purchase-reserved-instances-offering-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.purchase-reserved-instances-offering-result/reserved-instances-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-classic-link-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpc-classic-link))

(clojure.spec.alpha/def :portkey.aws.ec2.deprovision-byoip-cidr-request/cidr (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.deprovision-byoip-cidr-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/deprovision-byoip-cidr-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.deprovision-byoip-cidr-request/cidr] :opt-un [:portkey.aws.ec2.deprovision-byoip-cidr-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-vpc-cidr-block-result/ipv-6-cidr-block-association (clojure.spec.alpha/and :portkey.aws.ec2/vpc-ipv-6-cidr-block-association))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-vpc-cidr-block-result/cidr-block-association (clojure.spec.alpha/and :portkey.aws.ec2/vpc-cidr-block-association))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-vpc-cidr-block-result/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-vpc-cidr-block-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disassociate-vpc-cidr-block-result/ipv-6-cidr-block-association :portkey.aws.ec2.disassociate-vpc-cidr-block-result/cidr-block-association :portkey.aws.ec2.disassociate-vpc-cidr-block-result/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/group-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-disk-container/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-disk-container/format (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot-disk-container/url (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/snapshot-disk-container (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.snapshot-disk-container/description :portkey.aws.ec2.snapshot-disk-container/format :portkey.aws.ec2.snapshot-disk-container/url :portkey.aws.ec2/user-bucket]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-spot-datafeed-subscription-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-spot-datafeed-subscription-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-spot-datafeed-subscription-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-credit-specification-list-request (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-credit-specification-request))

(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-instances-result/spot-instance-requests (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-request-list))
(clojure.spec.alpha/def :portkey.aws.ec2/request-spot-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.request-spot-instances-result/spot-instance-requests]))

(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/type (clojure.spec.alpha/and :portkey.aws.ec2/fleet-type))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/fleet-id (clojure.spec.alpha/and :portkey.aws.ec2/fleet-identifier))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/fulfilled-on-demand-capacity (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/valid-from (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/excess-capacity-termination-policy (clojure.spec.alpha/and :portkey.aws.ec2/fleet-excess-capacity-termination-policy))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/launch-template-configs (clojure.spec.alpha/and :portkey.aws.ec2/fleet-launch-template-config-list))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/fulfilled-capacity (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/create-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/fleet-state (clojure.spec.alpha/and :portkey.aws.ec2/fleet-state-code))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/terminate-instances-with-expiration (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/instances (clojure.spec.alpha/and :portkey.aws.ec2/describe-fleets-instances-set))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/activity-status (clojure.spec.alpha/and :portkey.aws.ec2/fleet-activity-status))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/replace-unhealthy-instances (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/valid-until (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-data/errors (clojure.spec.alpha/and :portkey.aws.ec2/describe-fleets-error-set))
(clojure.spec.alpha/def :portkey.aws.ec2/fleet-data (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.fleet-data/type :portkey.aws.ec2.fleet-data/fleet-id :portkey.aws.ec2.fleet-data/fulfilled-on-demand-capacity :portkey.aws.ec2.fleet-data/valid-from :portkey.aws.ec2.fleet-data/tags :portkey.aws.ec2.fleet-data/excess-capacity-termination-policy :portkey.aws.ec2/spot-options :portkey.aws.ec2.fleet-data/launch-template-configs :portkey.aws.ec2/on-demand-options :portkey.aws.ec2.fleet-data/fulfilled-capacity :portkey.aws.ec2.fleet-data/create-time :portkey.aws.ec2.fleet-data/fleet-state :portkey.aws.ec2.fleet-data/terminate-instances-with-expiration :portkey.aws.ec2/target-capacity-specification :portkey.aws.ec2.fleet-data/instances :portkey.aws.ec2.fleet-data/activity-status :portkey.aws.ec2.fleet-data/client-token :portkey.aws.ec2.fleet-data/replace-unhealthy-instances :portkey.aws.ec2.fleet-data/valid-until :portkey.aws.ec2.fleet-data/errors]))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-vpc-cidr-block-request/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-vpc-cidr-block-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.disassociate-vpc-cidr-block-request/association-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.price-schedule/active (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.price-schedule/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2.price-schedule/price (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.price-schedule/term (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2/price-schedule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.price-schedule/active :portkey.aws.ec2.price-schedule/currency-code :portkey.aws.ec2.price-schedule/price :portkey.aws.ec2.price-schedule/term]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-services-result/service-names (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-services-result/service-details (clojure.spec.alpha/and :portkey.aws.ec2/service-detail-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-services-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoint-services-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-endpoint-services-result/service-names :portkey.aws.ec2.describe-vpc-endpoint-services-result/service-details :portkey.aws.ec2.describe-vpc-endpoint-services-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.update-security-group-rule-descriptions-egress-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.update-security-group-rule-descriptions-egress-request/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.update-security-group-rule-descriptions-egress-request/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.update-security-group-rule-descriptions-egress-request/ip-permissions (clojure.spec.alpha/and :portkey.aws.ec2/ip-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2/update-security-group-rule-descriptions-egress-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.update-security-group-rule-descriptions-egress-request/ip-permissions] :opt-un [:portkey.aws.ec2.update-security-group-rule-descriptions-egress-request/dry-run :portkey.aws.ec2.update-security-group-rule-descriptions-egress-request/group-id :portkey.aws.ec2.update-security-group-rule-descriptions-egress-request/group-name]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-group-references-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-group-references-request/group-id (clojure.spec.alpha/and :portkey.aws.ec2/group-ids))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-security-group-references-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-security-group-references-request/group-id] :opt-un [:portkey.aws.ec2.describe-security-group-references-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-placement-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-instance-placement-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-instance-placement-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-associations-result/associations (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route-table-association-list))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-associations-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/get-transit-gateway-route-table-associations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.get-transit-gateway-route-table-associations-result/associations :portkey.aws.ec2.get-transit-gateway-route-table-associations-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.iam-instance-profile-association/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.iam-instance-profile-association/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.iam-instance-profile-association/state (clojure.spec.alpha/and :portkey.aws.ec2/iam-instance-profile-association-state))
(clojure.spec.alpha/def :portkey.aws.ec2.iam-instance-profile-association/timestamp (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/iam-instance-profile-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.iam-instance-profile-association/association-id :portkey.aws.ec2.iam-instance-profile-association/instance-id :portkey.aws.ec2/iam-instance-profile :portkey.aws.ec2.iam-instance-profile-association/state :portkey.aws.ec2.iam-instance-profile-association/timestamp]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpcs-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpcs-request/vpc-ids (clojure.spec.alpha/and :portkey.aws.ec2/vpc-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpcs-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpcs-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpcs-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpcs-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpcs-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpcs-request/filters :portkey.aws.ec2.describe-vpcs-request/vpc-ids :portkey.aws.ec2.describe-vpcs-request/dry-run :portkey.aws.ec2.describe-vpcs-request/next-token :portkey.aws.ec2.describe-vpcs-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instance-state #{:retired :paymentfailed :paymentpending :active "payment-pending" "payment-failed" "active" "retired"})

(clojure.spec.alpha/def :portkey.aws.ec2.delete-route-request/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-route-request/destination-ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-route-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-route-request/route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-route-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-route-request/route-table-id] :opt-un [:portkey.aws.ec2.delete-route-request/destination-cidr-block :portkey.aws.ec2.delete-route-request/destination-ipv-6-cidr-block :portkey.aws.ec2.delete-route-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-services-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-services-request/service-names (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-services-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-services-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-services-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoint-services-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-endpoint-services-request/dry-run :portkey.aws.ec2.describe-vpc-endpoint-services-request/service-names :portkey.aws.ec2.describe-vpc-endpoint-services-request/filters :portkey.aws.ec2.describe-vpc-endpoint-services-request/max-results :portkey.aws.ec2.describe-vpc-endpoint-services-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/allocation-state #{"released" "released-permanent-failure" :underassessment :releasedpermanentfailure :released "permanent-failure" "under-assessment" :available :permanentfailure "available"})

(clojure.spec.alpha/def :portkey.aws.ec2.reboot-instances-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reboot-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/reboot-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.reboot-instances-request/instance-ids] :opt-un [:portkey.aws.ec2.reboot-instances-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.connection-notification/connection-notification-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.connection-notification/service-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.connection-notification/vpc-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.connection-notification/connection-notification-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.connection-notification/connection-events (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/connection-notification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.connection-notification/connection-notification-id :portkey.aws.ec2.connection-notification/service-id :portkey.aws.ec2.connection-notification/vpc-endpoint-id :portkey.aws.ec2/connection-notification-type :portkey.aws.ec2.connection-notification/connection-notification-arn :portkey.aws.ec2.connection-notification/connection-events :portkey.aws.ec2/connection-notification-state]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-block-device-mapping/device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-block-device-mapping/virtual-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-block-device-mapping/ebs (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-ebs-block-device))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-block-device-mapping/no-device (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-block-device-mapping (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-block-device-mapping/device-name :portkey.aws.ec2.launch-template-block-device-mapping/virtual-name :portkey.aws.ec2.launch-template-block-device-mapping/ebs :portkey.aws.ec2.launch-template-block-device-mapping/no-device]))

(clojure.spec.alpha/def :portkey.aws.ec2/export-task-state #{:completed "completed" "cancelling" "cancelled" :cancelled :active "active" :cancelling})

(clojure.spec.alpha/def :portkey.aws.ec2/log-destination-type #{:s-3 :cloudwatchlogs "cloud-watch-logs" "s3"})

(clojure.spec.alpha/def :portkey.aws.ec2.instance-state-change/current-state (clojure.spec.alpha/and :portkey.aws.ec2/instance-state))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-state-change/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-state-change/previous-state (clojure.spec.alpha/and :portkey.aws.ec2/instance-state))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-state-change (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-state-change/current-state :portkey.aws.ec2.instance-state-change/instance-id :portkey.aws.ec2.instance-state-change/previous-state]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-attribute-result/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-attribute-result/enable-dns-hostnames (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-attribute-result/enable-dns-support (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-attribute-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-attribute-result/vpc-id :portkey.aws.ec2.describe-vpc-attribute-result/enable-dns-hostnames :portkey.aws.ec2.describe-vpc-attribute-result/enable-dns-support]))

(clojure.spec.alpha/def :portkey.aws.ec2.monitoring/state (clojure.spec.alpha/and :portkey.aws.ec2/monitoring-state))
(clojure.spec.alpha/def :portkey.aws.ec2/monitoring (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.monitoring/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpu-health/status (clojure.spec.alpha/and :portkey.aws.ec2/elastic-gpu-status))
(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-health (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.elastic-gpu-health/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-flow-logs-result/flow-logs (clojure.spec.alpha/and :portkey.aws.ec2/flow-log-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-flow-logs-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-flow-logs-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-flow-logs-result/flow-logs :portkey.aws.ec2.describe-flow-logs-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instance-availability-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-scheduled-instance-availability-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-scheduled-instance-availability-result/next-token :portkey.aws.ec2/scheduled-instance-availability-set]))

(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-entry-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-entry-request/network-acl-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-entry-request/rule-number (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-entry-request/egress (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-entry-request/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-entry-request/ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-entry-request/protocol (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/replace-network-acl-entry-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.replace-network-acl-entry-request/egress :portkey.aws.ec2.replace-network-acl-entry-request/network-acl-id :portkey.aws.ec2.replace-network-acl-entry-request/protocol :portkey.aws.ec2/rule-action :portkey.aws.ec2.replace-network-acl-entry-request/rule-number] :opt-un [:portkey.aws.ec2.replace-network-acl-entry-request/dry-run :portkey.aws.ec2/icmp-type-code :portkey.aws.ec2.replace-network-acl-entry-request/cidr-block :portkey.aws.ec2.replace-network-acl-entry-request/ipv-6-cidr-block :portkey.aws.ec2/port-range]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-endpoint-service-configurations-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-endpoint-service-configurations-request/service-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpc-endpoint-service-configurations-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-vpc-endpoint-service-configurations-request/service-ids] :opt-un [:portkey.aws.ec2.delete-vpc-endpoint-service-configurations-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.event-information/event-description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.event-information/event-sub-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.event-information/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/event-information (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.event-information/event-description :portkey.aws.ec2.event-information/event-sub-type :portkey.aws.ec2.event-information/instance-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-instance-network-interface-specification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-instance-network-interface-specification))

(clojure.spec.alpha/def :portkey.aws.ec2/create-vpc-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/vpc]))

(clojure.spec.alpha/def :portkey.aws.ec2.allocate-address-result/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.allocate-address-result/allocation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.allocate-address-result/public-ipv-4-pool (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.allocate-address-result/domain (clojure.spec.alpha/and :portkey.aws.ec2/domain-type))
(clojure.spec.alpha/def :portkey.aws.ec2/allocate-address-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.allocate-address-result/public-ip :portkey.aws.ec2.allocate-address-result/allocation-id :portkey.aws.ec2.allocate-address-result/public-ipv-4-pool :portkey.aws.ec2.allocate-address-result/domain]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-specs-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/spot-fleet-launch-specification))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-request/volume-ids (clojure.spec.alpha/and :portkey.aws.ec2/volume-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-volumes-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-volumes-request/filters :portkey.aws.ec2.describe-volumes-request/volume-ids :portkey.aws.ec2.describe-volumes-request/dry-run :portkey.aws.ec2.describe-volumes-request/max-results :portkey.aws.ec2.describe-volumes-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.unsuccessful-instance-credit-specification-item/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.unsuccessful-instance-credit-specification-item/error (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-instance-credit-specification-item-error))
(clojure.spec.alpha/def :portkey.aws.ec2/unsuccessful-instance-credit-specification-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.unsuccessful-instance-credit-specification-item/instance-id :portkey.aws.ec2.unsuccessful-instance-credit-specification-item/error]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device-request/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device-request/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device-request/iops (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device-request/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device-request/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-ebs-block-device-request/volume-size (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-ebs-block-device-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-ebs-block-device-request/encrypted :portkey.aws.ec2.launch-template-ebs-block-device-request/delete-on-termination :portkey.aws.ec2.launch-template-ebs-block-device-request/iops :portkey.aws.ec2.launch-template-ebs-block-device-request/kms-key-id :portkey.aws.ec2.launch-template-ebs-block-device-request/snapshot-id :portkey.aws.ec2.launch-template-ebs-block-device-request/volume-size :portkey.aws.ec2/volume-type]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-elastic-inference-accelerator/type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-elastic-inference-accelerator (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.launch-template-elastic-inference-accelerator/type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-egress-only-internet-gateway-result/return-code (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-egress-only-internet-gateway-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-egress-only-internet-gateway-result/return-code]))

(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-details/name (clojure.spec.alpha/and :portkey.aws.ec2/volume-status-name))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-details/status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.volume-status-details/name :portkey.aws.ec2.volume-status-details/status]))

(clojure.spec.alpha/def :portkey.aws.ec2/load-balancers-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/classic-load-balancers-config :portkey.aws.ec2/target-groups-config]))

(clojure.spec.alpha/def :portkey.aws.ec2/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ec2/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpus/elastic-gpu-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpus/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpus/elastic-gpu-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpus/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpus (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.elastic-gpus/elastic-gpu-id :portkey.aws.ec2.elastic-gpus/availability-zone :portkey.aws.ec2.elastic-gpus/elastic-gpu-type :portkey.aws.ec2/elastic-gpu-health :portkey.aws.ec2/elastic-gpu-state :portkey.aws.ec2.elastic-gpus/instance-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table-propagation/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table-propagation/resource-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table-propagation/resource-type (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-resource-type))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table-propagation/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-propagation-state))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-table-propagation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-route-table-propagation/transit-gateway-attachment-id :portkey.aws.ec2.transit-gateway-route-table-propagation/resource-id :portkey.aws.ec2.transit-gateway-route-table-propagation/resource-type :portkey.aws.ec2.transit-gateway-route-table-propagation/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/subnet-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/options (clojure.spec.alpha/and :portkey.aws.ec2/create-transit-gateway-vpc-attachment-request-options))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-transit-gateway-vpc-attachment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/transit-gateway-id :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/vpc-id :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/subnet-ids] :opt-un [:portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/options :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/tag-specifications :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.move-address-to-vpc-result/allocation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/move-address-to-vpc-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.move-address-to-vpc-result/allocation-id :portkey.aws.ec2/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.classic-load-balancer/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/classic-load-balancer (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.classic-load-balancer/name]))

(clojure.spec.alpha/def :portkey.aws.ec2.ip-permission/from-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.ip-permission/ip-protocol (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.ip-permission/ip-ranges (clojure.spec.alpha/and :portkey.aws.ec2/ip-range-list))
(clojure.spec.alpha/def :portkey.aws.ec2.ip-permission/ipv-6-ranges (clojure.spec.alpha/and :portkey.aws.ec2/ipv-6-range-list))
(clojure.spec.alpha/def :portkey.aws.ec2.ip-permission/prefix-list-ids (clojure.spec.alpha/and :portkey.aws.ec2/prefix-list-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.ip-permission/to-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.ip-permission/user-id-group-pairs (clojure.spec.alpha/and :portkey.aws.ec2/user-id-group-pair-list))
(clojure.spec.alpha/def :portkey.aws.ec2/ip-permission (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.ip-permission/from-port :portkey.aws.ec2.ip-permission/ip-protocol :portkey.aws.ec2.ip-permission/ip-ranges :portkey.aws.ec2.ip-permission/ipv-6-ranges :portkey.aws.ec2.ip-permission/prefix-list-ids :portkey.aws.ec2.ip-permission/to-port :portkey.aws.ec2.ip-permission/user-id-group-pairs]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-transit-gateway-vpc-attachment-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-transit-gateway-vpc-attachment-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-transit-gateway-vpc-attachment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-transit-gateway-vpc-attachment-request/transit-gateway-attachment-id] :opt-un [:portkey.aws.ec2.delete-transit-gateway-vpc-attachment-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/ip-permission-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/ip-permission))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-bundle-tasks-result/bundle-tasks (clojure.spec.alpha/and :portkey.aws.ec2/bundle-task-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-bundle-tasks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-bundle-tasks-result/bundle-tasks]))

(clojure.spec.alpha/def :portkey.aws.ec2.slot-date-time-range-request/earliest-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.slot-date-time-range-request/latest-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/slot-date-time-range-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.slot-date-time-range-request/earliest-time :portkey.aws.ec2.slot-date-time-range-request/latest-time] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-account-attributes-request/attribute-names (clojure.spec.alpha/and :portkey.aws.ec2/account-attribute-name-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-account-attributes-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-account-attributes-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-account-attributes-request/attribute-names :portkey.aws.ec2.describe-account-attributes-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-attachment-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/transit-gateway-route-attachment))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-license-specification-list-request (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-license-configuration-request))

(clojure.spec.alpha/def :portkey.aws.ec2.enable-vpc-classic-link-dns-support-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/enable-vpc-classic-link-dns-support-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.enable-vpc-classic-link-dns-support-request/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/ri-product-description #{"Windows (Amazon VPC)" :windows :linux-unix :windows-amazon-vpc :linux-unix-amazon-vpc "Windows" "Linux/UNIX" "Linux/UNIX (Amazon VPC)"})

(clojure.spec.alpha/def :portkey.aws.ec2/instance-ids-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-id))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/volume))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-endpoint-connection-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpc-endpoint-connection))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshots-result/snapshots (clojure.spec.alpha/and :portkey.aws.ec2/snapshot-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-snapshots-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-snapshots-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-snapshots-result/snapshots :portkey.aws.ec2.describe-snapshots-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-table-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-peering-connections-max-results (clojure.spec.alpha/int-in 5 1000))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-target-networks-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-target-networks-request/association-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-target-networks-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-target-networks-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-client-vpn-target-networks-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-client-vpn-target-networks-request/client-vpn-endpoint-id] :opt-un [:portkey.aws.ec2.describe-client-vpn-target-networks-request/association-ids :portkey.aws.ec2/max-results :portkey.aws.ec2/next-token :portkey.aws.ec2.describe-client-vpn-target-networks-request/filters :portkey.aws.ec2.describe-client-vpn-target-networks-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/dhcp-options-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/dhcp-options))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-table-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/transit-gateway-route-table))

(clojure.spec.alpha/def :portkey.aws.ec2/default-route-table-propagation-value #{:disable :enable "enable" "disable"})

(clojure.spec.alpha/def :portkey.aws.ec2.unsuccessful-item/error (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-item-error))
(clojure.spec.alpha/def :portkey.aws.ec2.unsuccessful-item/resource-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/unsuccessful-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.unsuccessful-item/error :portkey.aws.ec2.unsuccessful-item/resource-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/principal-id-format-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/principal-id-format))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-tags-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-tags-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-tags-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-tags-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-tags-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-tags-request/dry-run :portkey.aws.ec2.describe-tags-request/filters :portkey.aws.ec2.describe-tags-request/max-results :portkey.aws.ec2.describe-tags-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.attach-network-interface-request/device-index (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-network-interface-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-network-interface-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-network-interface-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/attach-network-interface-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.attach-network-interface-request/device-index :portkey.aws.ec2.attach-network-interface-request/instance-id :portkey.aws.ec2.attach-network-interface-request/network-interface-id] :opt-un [:portkey.aws.ec2.attach-network-interface-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instance-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-transit-gateway-route-table-result/association (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-association))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-transit-gateway-route-table-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disassociate-transit-gateway-route-table-result/association]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-success-item/current-spot-fleet-request-state (clojure.spec.alpha/and :portkey.aws.ec2/batch-state))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-success-item/previous-spot-fleet-request-state (clojure.spec.alpha/and :portkey.aws.ec2/batch-state))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-success-item/spot-fleet-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-spot-fleet-requests-success-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cancel-spot-fleet-requests-success-item/current-spot-fleet-request-state :portkey.aws.ec2.cancel-spot-fleet-requests-success-item/previous-spot-fleet-request-state :portkey.aws.ec2.cancel-spot-fleet-requests-success-item/spot-fleet-request-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/associated-target-networks (clojure.spec.alpha/and :portkey.aws.ec2/associated-target-network-set))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/client-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/deletion-time (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-endpoint-status))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/authentication-options (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-authentication-list))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/connection-log-options (clojure.spec.alpha/and :portkey.aws.ec2/connection-log-response-options))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/server-certificate-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/creation-time (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/dns-servers (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/split-tunnel (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-endpoint/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-endpoint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-vpn-endpoint/associated-target-networks :portkey.aws.ec2.client-vpn-endpoint/dns-name :portkey.aws.ec2/vpn-protocol :portkey.aws.ec2.client-vpn-endpoint/client-cidr-block :portkey.aws.ec2.client-vpn-endpoint/deletion-time :portkey.aws.ec2.client-vpn-endpoint/tags :portkey.aws.ec2.client-vpn-endpoint/status :portkey.aws.ec2.client-vpn-endpoint/authentication-options :portkey.aws.ec2.client-vpn-endpoint/connection-log-options :portkey.aws.ec2.client-vpn-endpoint/description :portkey.aws.ec2.client-vpn-endpoint/server-certificate-arn :portkey.aws.ec2.client-vpn-endpoint/creation-time :portkey.aws.ec2/transport-protocol :portkey.aws.ec2.client-vpn-endpoint/dns-servers :portkey.aws.ec2.client-vpn-endpoint/split-tunnel :portkey.aws.ec2.client-vpn-endpoint/client-vpn-endpoint-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-config/launch-template-specification (clojure.spec.alpha/and :portkey.aws.ec2/fleet-launch-template-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-config/overrides (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-overrides-list))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-config/launch-template-specification :portkey.aws.ec2.launch-template-config/overrides]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateways-result/transit-gateways (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateways-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-transit-gateways-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-transit-gateways-result/transit-gateways :portkey.aws.ec2.describe-transit-gateways-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-interface-permission-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-network-interface-permission-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-network-interface-permission-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-interface-permission-request/network-interface-permission-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-interface-permission-request/force (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-interface-permission-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-network-interface-permission-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-network-interface-permission-request/network-interface-permission-id] :opt-un [:portkey.aws.ec2.delete-network-interface-permission-request/force :portkey.aws.ec2.delete-network-interface-permission-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.release-hosts-request/host-ids (clojure.spec.alpha/and :portkey.aws.ec2/request-host-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2/release-hosts-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.release-hosts-request/host-ids] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-request/reserved-instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instance-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.get-reserved-instances-exchange-quote-request/target-configurations (clojure.spec.alpha/and :portkey.aws.ec2/target-configuration-request-set))
(clojure.spec.alpha/def :portkey.aws.ec2/get-reserved-instances-exchange-quote-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.get-reserved-instances-exchange-quote-request/reserved-instance-ids] :opt-un [:portkey.aws.ec2.get-reserved-instances-exchange-quote-request/dry-run :portkey.aws.ec2.get-reserved-instances-exchange-quote-request/target-configurations]))

(clojure.spec.alpha/def :portkey.aws.ec2/propagating-vgw-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/propagating-vgw))

(clojure.spec.alpha/def :portkey.aws.ec2/disk-image-format #{"VHD" "VMDK" :vmdk :raw :vhd "RAW"})

(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-attachment/attach-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-attachment/attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-attachment/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-attachment/device-index (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-attachment/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-attachment/instance-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-attachment/status (clojure.spec.alpha/and :portkey.aws.ec2/attachment-status))
(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-attachment (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-interface-attachment/attach-time :portkey.aws.ec2.network-interface-attachment/attachment-id :portkey.aws.ec2.network-interface-attachment/delete-on-termination :portkey.aws.ec2.network-interface-attachment/device-index :portkey.aws.ec2.network-interface-attachment/instance-id :portkey.aws.ec2.network-interface-attachment/instance-owner-id :portkey.aws.ec2.network-interface-attachment/status]))

(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-network-interface-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/scheduled-instances-network-interface))

(clojure.spec.alpha/def :portkey.aws.ec2/security-group-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.create-fpga-image-result/fpga-image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fpga-image-result/fpga-image-global-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-fpga-image-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-fpga-image-result/fpga-image-id :portkey.aws.ec2.create-fpga-image-result/fpga-image-global-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config/create-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config/spot-fleet-request-config (clojure.spec.alpha/and :portkey.aws.ec2/spot-fleet-request-config-data))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config/spot-fleet-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-request-config/spot-fleet-request-state (clojure.spec.alpha/and :portkey.aws.ec2/batch-state))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-fleet-request-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/activity-status :portkey.aws.ec2.spot-fleet-request-config/create-time :portkey.aws.ec2.spot-fleet-request-config/spot-fleet-request-config :portkey.aws.ec2.spot-fleet-request-config/spot-fleet-request-id :portkey.aws.ec2.spot-fleet-request-config/spot-fleet-request-state]))

(clojure.spec.alpha/def :portkey.aws.ec2.replace-transit-gateway-route-request/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-transit-gateway-route-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-transit-gateway-route-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-transit-gateway-route-request/blackhole (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-transit-gateway-route-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/replace-transit-gateway-route-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.replace-transit-gateway-route-request/destination-cidr-block :portkey.aws.ec2.replace-transit-gateway-route-request/transit-gateway-route-table-id] :opt-un [:portkey.aws.ec2.replace-transit-gateway-route-request/transit-gateway-attachment-id :portkey.aws.ec2.replace-transit-gateway-route-request/blackhole :portkey.aws.ec2.replace-transit-gateway-route-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/domain-type #{"standard" "vpc" :vpc :standard})

(clojure.spec.alpha/def :portkey.aws.ec2.vgw-telemetry/accepted-route-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.vgw-telemetry/last-status-change (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.vgw-telemetry/outside-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vgw-telemetry/status (clojure.spec.alpha/and :portkey.aws.ec2/telemetry-status))
(clojure.spec.alpha/def :portkey.aws.ec2.vgw-telemetry/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/vgw-telemetry (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vgw-telemetry/accepted-route-count :portkey.aws.ec2.vgw-telemetry/last-status-change :portkey.aws.ec2.vgw-telemetry/outside-ip-address :portkey.aws.ec2.vgw-telemetry/status :portkey.aws.ec2.vgw-telemetry/status-message]))

(clojure.spec.alpha/def :portkey.aws.ec2/cancel-spot-instance-request-state #{:open :closed :completed "completed" "closed" "cancelled" :cancelled :active "active" "open"})

(clojure.spec.alpha/def :portkey.aws.ec2.report-instance-status-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.report-instance-status-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.report-instance-status-request/end-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.report-instance-status-request/instances (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.report-instance-status-request/reason-codes (clojure.spec.alpha/and :portkey.aws.ec2/reason-codes-list))
(clojure.spec.alpha/def :portkey.aws.ec2.report-instance-status-request/start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.report-instance-status-request/status (clojure.spec.alpha/and :portkey.aws.ec2/report-status-type))
(clojure.spec.alpha/def :portkey.aws.ec2/report-instance-status-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.report-instance-status-request/instances :portkey.aws.ec2.report-instance-status-request/reason-codes :portkey.aws.ec2.report-instance-status-request/status] :opt-un [:portkey.aws.ec2.report-instance-status-request/description :portkey.aws.ec2.report-instance-status-request/dry-run :portkey.aws.ec2.report-instance-status-request/end-time :portkey.aws.ec2.report-instance-status-request/start-time]))

(clojure.spec.alpha/def :portkey.aws.ec2/subnet-ipv-6-cidr-block-association-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/subnet-ipv-6-cidr-block-association))

(clojure.spec.alpha/def :portkey.aws.ec2.create-flow-logs-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-flow-logs-request/resource-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-flow-logs-request/deliver-logs-permission-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-flow-logs-request/resource-type (clojure.spec.alpha/and :portkey.aws.ec2/flow-logs-resource-type))
(clojure.spec.alpha/def :portkey.aws.ec2.create-flow-logs-request/log-group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-flow-logs-request/log-destination (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-flow-logs-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-flow-logs-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-flow-logs-request/resource-ids :portkey.aws.ec2.create-flow-logs-request/resource-type :portkey.aws.ec2/traffic-type] :opt-un [:portkey.aws.ec2.create-flow-logs-request/dry-run :portkey.aws.ec2.create-flow-logs-request/deliver-logs-permission-arn :portkey.aws.ec2/log-destination-type :portkey.aws.ec2.create-flow-logs-request/log-group-name :portkey.aws.ec2.create-flow-logs-request/log-destination :portkey.aws.ec2.create-flow-logs-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-images-request/executable-users (clojure.spec.alpha/and :portkey.aws.ec2/executable-by-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-images-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-images-request/image-ids (clojure.spec.alpha/and :portkey.aws.ec2/image-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-images-request/owners (clojure.spec.alpha/and :portkey.aws.ec2/owner-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-images-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-images-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-images-request/executable-users :portkey.aws.ec2.describe-images-request/filters :portkey.aws.ec2.describe-images-request/image-ids :portkey.aws.ec2.describe-images-request/owners :portkey.aws.ec2.describe-images-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/attachment (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-attachment))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/tag-set (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-ipv-6-addresses-list))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/interface-type (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-type))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/mac-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/source-dest-check (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/status (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-status))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/private-dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/requester-managed (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/groups (clojure.spec.alpha/and :portkey.aws.ec2/group-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/private-ip-addresses (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-private-ip-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/association (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-association))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/requester-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/network-interface (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-interface/attachment :portkey.aws.ec2.network-interface/tag-set :portkey.aws.ec2.network-interface/ipv-6-addresses :portkey.aws.ec2.network-interface/interface-type :portkey.aws.ec2.network-interface/subnet-id :portkey.aws.ec2.network-interface/owner-id :portkey.aws.ec2.network-interface/mac-address :portkey.aws.ec2.network-interface/network-interface-id :portkey.aws.ec2.network-interface/source-dest-check :portkey.aws.ec2.network-interface/availability-zone :portkey.aws.ec2.network-interface/status :portkey.aws.ec2.network-interface/private-dns-name :portkey.aws.ec2.network-interface/requester-managed :portkey.aws.ec2.network-interface/description :portkey.aws.ec2.network-interface/vpc-id :portkey.aws.ec2.network-interface/groups :portkey.aws.ec2.network-interface/private-ip-addresses :portkey.aws.ec2.network-interface/association :portkey.aws.ec2.network-interface/requester-id :portkey.aws.ec2.network-interface/private-ip-address]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-network-interface-attribute-request/attachment (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-attachment-changes))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-network-interface-attribute-request/description (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-network-interface-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-network-interface-attribute-request/groups (clojure.spec.alpha/and :portkey.aws.ec2/security-group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-network-interface-attribute-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-network-interface-attribute-request/source-dest-check (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-network-interface-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-network-interface-attribute-request/network-interface-id] :opt-un [:portkey.aws.ec2.modify-network-interface-attribute-request/attachment :portkey.aws.ec2.modify-network-interface-attribute-request/description :portkey.aws.ec2.modify-network-interface-attribute-request/dry-run :portkey.aws.ec2.modify-network-interface-attribute-request/groups :portkey.aws.ec2.modify-network-interface-attribute-request/source-dest-check]))

(clojure.spec.alpha/def :portkey.aws.ec2.revoke-client-vpn-ingress-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-client-vpn-ingress-request/target-network-cidr (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-client-vpn-ingress-request/access-group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-client-vpn-ingress-request/revoke-all-groups (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-client-vpn-ingress-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/revoke-client-vpn-ingress-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.revoke-client-vpn-ingress-request/client-vpn-endpoint-id :portkey.aws.ec2.revoke-client-vpn-ingress-request/target-network-cidr] :opt-un [:portkey.aws.ec2.revoke-client-vpn-ingress-request/access-group-id :portkey.aws.ec2.revoke-client-vpn-ingress-request/revoke-all-groups :portkey.aws.ec2.revoke-client-vpn-ingress-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-bundle-task-request/bundle-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-bundle-task-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-bundle-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.cancel-bundle-task-request/bundle-id] :opt-un [:portkey.aws.ec2.cancel-bundle-task-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21076__auto__] (clojure.core/<= 3 (clojure.core/count s__21076__auto__))) (clojure.core/fn [s__21077__auto__] (clojure.core/< (clojure.core/count s__21077__auto__) 128)) (clojure.core/fn [s__21078__auto__] (clojure.core/re-matches #"[a-zA-Z0-9\(\)\.\-/_]+" s__21078__auto__))))

(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/state-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/owner-alias (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/progress (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/data-encryption-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/state (clojure.spec.alpha/and :portkey.aws.ec2/snapshot-state))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/volume-size (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.snapshot/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.snapshot/start-time :portkey.aws.ec2.snapshot/state-message :portkey.aws.ec2.snapshot/owner-id :portkey.aws.ec2.snapshot/encrypted :portkey.aws.ec2.snapshot/tags :portkey.aws.ec2.snapshot/owner-alias :portkey.aws.ec2.snapshot/progress :portkey.aws.ec2.snapshot/description :portkey.aws.ec2.snapshot/data-encryption-key-id :portkey.aws.ec2.snapshot/kms-key-id :portkey.aws.ec2.snapshot/volume-id :portkey.aws.ec2.snapshot/state :portkey.aws.ec2.snapshot/volume-size :portkey.aws.ec2.snapshot/snapshot-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/flow-logs-resource-type #{:network-interface "Subnet" :vpc "NetworkInterface" :subnet "VPC"})

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-launch-template-overrides-list-request (clojure.spec.alpha/coll-of :portkey.aws.ec2/fleet-launch-template-overrides-request :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ec2/resource-type #{:networkacl :vpcpeeringconnection :dedicatedhost :natgateway "vpn-gateway" "subnet" :transitgatewayattachment "transit-gateway" :dhcpoptions "vpc" "elastic-ip" "dedicated-host" "spot-instances-request" :instance :elasticip :launchtemplate "route-table" "image" "natgateway" :securitygroup :vpngateway "transit-gateway-route-table" :routetable "snapshot" "vpn-connection" :reservedinstances :fpgaimage :volume "internet-gateway" :vpnconnection :snapshot "reserved-instances" :fleet "instance" :vpc "fleet" :spotinstancesrequest "network-interface" "security-group" :clientvpnendpoint "volume" "dhcp-options" :image :networkinterface "vpc-peering-connection" "customer-gateway" "fpga-image" :transitgateway :transitgatewayroutetable :customergateway :subnet "network-acl" "client-vpn-endpoint" :internetgateway "launch-template" "transit-gateway-attachment"})

(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-propagations-result/transit-gateway-route-table-propagations (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route-table-propagation-list))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-propagations-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/get-transit-gateway-route-table-propagations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.get-transit-gateway-route-table-propagations-result/transit-gateway-route-table-propagations :portkey.aws.ec2.get-transit-gateway-route-table-propagations-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-status-event/code (clojure.spec.alpha/and :portkey.aws.ec2/event-code))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status-event/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status-event/not-after (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status-event/not-before (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status-event/not-before-deadline (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-status-event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/instance-event-id :portkey.aws.ec2.instance-status-event/code :portkey.aws.ec2.instance-status-event/description :portkey.aws.ec2.instance-status-event/not-after :portkey.aws.ec2.instance-status-event/not-before :portkey.aws.ec2.instance-status-event/not-before-deadline]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection-options-description/allow-dns-resolution-from-remote-vpc (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection-options-description/allow-egress-from-local-classic-link-to-remote-vpc (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection-options-description/allow-egress-from-local-vpc-to-remote-classic-link (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-peering-connection-options-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc-peering-connection-options-description/allow-dns-resolution-from-remote-vpc :portkey.aws.ec2.vpc-peering-connection-options-description/allow-egress-from-local-classic-link-to-remote-vpc :portkey.aws.ec2.vpc-peering-connection-options-description/allow-egress-from-local-vpc-to-remote-classic-link]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-service-configuration-result/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpc-endpoint-service-configuration-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/service-configuration :portkey.aws.ec2.create-vpc-endpoint-service-configuration-result/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-options/amazon-side-asn (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-options/auto-accept-shared-attachments (clojure.spec.alpha/and :portkey.aws.ec2/auto-accept-shared-attachments-value))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-options/default-route-table-association (clojure.spec.alpha/and :portkey.aws.ec2/default-route-table-association-value))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-options/association-default-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-options/default-route-table-propagation (clojure.spec.alpha/and :portkey.aws.ec2/default-route-table-propagation-value))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-options/propagation-default-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-options/vpn-ecmp-support (clojure.spec.alpha/and :portkey.aws.ec2/vpn-ecmp-support-value))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-options/dns-support (clojure.spec.alpha/and :portkey.aws.ec2/dns-support-value))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-options/amazon-side-asn :portkey.aws.ec2.transit-gateway-options/auto-accept-shared-attachments :portkey.aws.ec2.transit-gateway-options/default-route-table-association :portkey.aws.ec2.transit-gateway-options/association-default-route-table-id :portkey.aws.ec2.transit-gateway-options/default-route-table-propagation :portkey.aws.ec2.transit-gateway-options/propagation-default-route-table-id :portkey.aws.ec2.transit-gateway-options/vpn-ecmp-support :portkey.aws.ec2.transit-gateway-options/dns-support]))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-name #{:ioperformance :ioenabled "io-performance" "io-enabled"})

(clojure.spec.alpha/def :portkey.aws.ec2.internet-gateway/attachments (clojure.spec.alpha/and :portkey.aws.ec2/internet-gateway-attachment-list))
(clojure.spec.alpha/def :portkey.aws.ec2.internet-gateway/internet-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.internet-gateway/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.internet-gateway/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/internet-gateway (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.internet-gateway/attachments :portkey.aws.ec2.internet-gateway/internet-gateway-id :portkey.aws.ec2.internet-gateway/owner-id :portkey.aws.ec2.internet-gateway/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-classic-link-instances-result/instances (clojure.spec.alpha/and :portkey.aws.ec2/classic-link-instance-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-classic-link-instances-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-classic-link-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-classic-link-instances-result/instances :portkey.aws.ec2.describe-classic-link-instances-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc/cidr-block-association-set (clojure.spec.alpha/and :portkey.aws.ec2/vpc-cidr-block-association-set))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc/instance-tenancy (clojure.spec.alpha/and :portkey.aws.ec2/tenancy))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc/state (clojure.spec.alpha/and :portkey.aws.ec2/vpc-state))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc/dhcp-options-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc/is-default (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc/ipv-6-cidr-block-association-set (clojure.spec.alpha/and :portkey.aws.ec2/vpc-ipv-6-cidr-block-association-set))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc/cidr-block-association-set :portkey.aws.ec2.vpc/owner-id :portkey.aws.ec2.vpc/tags :portkey.aws.ec2.vpc/cidr-block :portkey.aws.ec2.vpc/instance-tenancy :portkey.aws.ec2.vpc/vpc-id :portkey.aws.ec2.vpc/state :portkey.aws.ec2.vpc/dhcp-options-id :portkey.aws.ec2.vpc/is-default :portkey.aws.ec2.vpc/ipv-6-cidr-block-association-set]))

(clojure.spec.alpha/def :portkey.aws.ec2.reset-image-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/reset-image-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.reset-image-attribute-request/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reset-image-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/reset-image-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.reset-image-attribute-request/attribute :portkey.aws.ec2.reset-image-attribute-request/image-id] :opt-un [:portkey.aws.ec2.reset-image-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-import-task-request/cancel-reason (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-import-task-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-import-task-request/import-task-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-import-task-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cancel-import-task-request/cancel-reason :portkey.aws.ec2.cancel-import-task-request/dry-run :portkey.aws.ec2.cancel-import-task-request/import-task-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-tenancy-result/return-value (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-tenancy-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-vpc-tenancy-result/return-value]))

(clojure.spec.alpha/def :portkey.aws.ec2/ipv-6-address-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-state #{"blackhole" :deleted "deleting" :pending :deleting :active "deleted" "active" "pending" :blackhole})

(clojure.spec.alpha/def :portkey.aws.ec2/resource-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-credit-specification-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-credit-specification-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-credit-specification-request/instance-credit-specifications (clojure.spec.alpha/and :portkey.aws.ec2/instance-credit-specification-list-request))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-instance-credit-specification-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-instance-credit-specification-request/instance-credit-specifications] :opt-un [:portkey.aws.ec2.modify-instance-credit-specification-request/dry-run :portkey.aws.ec2.modify-instance-credit-specification-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-classic-link-instances-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-classic-link-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-classic-link-instances-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-classic-link-instances-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-classic-link-instances-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-classic-link-instances-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-classic-link-instances-request/filters :portkey.aws.ec2.describe-classic-link-instances-request/dry-run :portkey.aws.ec2.describe-classic-link-instances-request/instance-ids :portkey.aws.ec2.describe-classic-link-instances-request/max-results :portkey.aws.ec2.describe-classic-link-instances-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-permission-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/network-interface-permission))

(clojure.spec.alpha/def :portkey.aws.ec2/batch-state #{:cancelled-terminating :modifying :cancelled-running "cancelled_running" "failed" :submitted "cancelled" :cancelled :active "submitted" "modifying" "active" "cancelled_terminating" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2/operation-type #{:remove "remove" "add" :add})

(clojure.spec.alpha/def :portkey.aws.ec2.create-default-vpc-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-default-vpc-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-default-vpc-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoints-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoints-request/vpc-endpoint-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoints-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoints-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoints-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoints-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-endpoints-request/dry-run :portkey.aws.ec2.describe-vpc-endpoints-request/vpc-endpoint-ids :portkey.aws.ec2.describe-vpc-endpoints-request/filters :portkey.aws.ec2.describe-vpc-endpoints-request/max-results :portkey.aws.ec2.describe-vpc-endpoints-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instance-availability-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instance-availability-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instance-availability-request/first-slot-start-time-range (clojure.spec.alpha/and :portkey.aws.ec2/slot-date-time-range-request))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instance-availability-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instance-availability-request/max-slot-duration-in-hours (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instance-availability-request/min-slot-duration-in-hours (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instance-availability-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-scheduled-instance-availability-request/recurrence (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instance-recurrence-request))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-scheduled-instance-availability-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-scheduled-instance-availability-request/first-slot-start-time-range :portkey.aws.ec2.describe-scheduled-instance-availability-request/recurrence] :opt-un [:portkey.aws.ec2.describe-scheduled-instance-availability-request/dry-run :portkey.aws.ec2.describe-scheduled-instance-availability-request/filters :portkey.aws.ec2.describe-scheduled-instance-availability-request/max-results :portkey.aws.ec2.describe-scheduled-instance-availability-request/max-slot-duration-in-hours :portkey.aws.ec2.describe-scheduled-instance-availability-request/min-slot-duration-in-hours :portkey.aws.ec2.describe-scheduled-instance-availability-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-on-demand-allocation-strategy #{"prioritized" "lowest-price" :prioritized :lowestprice})

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-elastic-inference-accelerator-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-elastic-inference-accelerator))

(clojure.spec.alpha/def :portkey.aws.ec2.reservation-value/hourly-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reservation-value/remaining-total-value (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reservation-value/remaining-upfront-value (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/reservation-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reservation-value/hourly-price :portkey.aws.ec2.reservation-value/remaining-total-value :portkey.aws.ec2.reservation-value/remaining-upfront-value]))

(clojure.spec.alpha/def :portkey.aws.ec2.host-instance/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host-instance/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/host-instance (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.host-instance/instance-id :portkey.aws.ec2.host-instance/instance-type]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-instances-result/reservations (clojure.spec.alpha/and :portkey.aws.ec2/reservation-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instances-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-instances-result/reservations :portkey.aws.ec2.describe-instances-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/snapshot-attribute-name #{"productCodes" "createVolumePermission" :product-codes :create-volume-permission})

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-cpu-options/core-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-cpu-options/threads-per-core (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-cpu-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-cpu-options/core-count :portkey.aws.ec2.launch-template-cpu-options/threads-per-core]))

(clojure.spec.alpha/def :portkey.aws.ec2/currency-code-values #{:usd "USD"})

(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-attribute #{:description "groupSet" :group-set :source-dest-check "attachment" "sourceDestCheck" "description" :attachment})

(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/platform (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/import-task-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/progress (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/snapshot-details (clojure.spec.alpha/and :portkey.aws.ec2/snapshot-detail-list))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/hypervisor (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/architecture (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-image-task/license-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/import-image-task (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.import-image-task/platform :portkey.aws.ec2.import-image-task/import-task-id :portkey.aws.ec2.import-image-task/image-id :portkey.aws.ec2.import-image-task/status-message :portkey.aws.ec2.import-image-task/encrypted :portkey.aws.ec2.import-image-task/status :portkey.aws.ec2.import-image-task/progress :portkey.aws.ec2.import-image-task/description :portkey.aws.ec2.import-image-task/snapshot-details :portkey.aws.ec2.import-image-task/kms-key-id :portkey.aws.ec2.import-image-task/hypervisor :portkey.aws.ec2.import-image-task/architecture :portkey.aws.ec2.import-image-task/license-type]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-customer-gateways-request/customer-gateway-ids (clojure.spec.alpha/and :portkey.aws.ec2/customer-gateway-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-customer-gateways-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-customer-gateways-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-customer-gateways-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-customer-gateways-request/customer-gateway-ids :portkey.aws.ec2.describe-customer-gateways-request/filters :portkey.aws.ec2.describe-customer-gateways-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.load-permission/user-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.load-permission/group (clojure.spec.alpha/and :portkey.aws.ec2/permission-group))
(clojure.spec.alpha/def :portkey.aws.ec2/load-permission (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.load-permission/user-id :portkey.aws.ec2.load-permission/group]))

(clojure.spec.alpha/def :portkey.aws.ec2.unassign-ipv-6-addresses-result/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.unassign-ipv-6-addresses-result/unassigned-ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/ipv-6-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2/unassign-ipv-6-addresses-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.unassign-ipv-6-addresses-result/network-interface-id :portkey.aws.ec2.unassign-ipv-6-addresses-result/unassigned-ipv-6-addresses]))

(clojure.spec.alpha/def :portkey.aws.ec2.license-configuration-request/license-configuration-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/license-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.license-configuration-request/license-configuration-arn]))

(clojure.spec.alpha/def :portkey.aws.ec2/report-instance-reason-codes #{"password-not-available" "performance-instance-store" :other :performancenetwork :performanceebsvolume "not-accepting-credentials" "unresponsive" :performanceother :passwordnotavailable "other" "performance-ebs-volume" :notacceptingcredentials "instance-stuck-in-state" :performanceinstancestore "performance-network" :instancestuckinstate :unresponsive "performance-other"})

(clojure.spec.alpha/def :portkey.aws.ec2/billing-product-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservation-offerings-request/filter (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservation-offerings-request/max-duration (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservation-offerings-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservation-offerings-request/min-duration (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservation-offerings-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservation-offerings-request/offering-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-host-reservation-offerings-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-host-reservation-offerings-request/filter :portkey.aws.ec2.describe-host-reservation-offerings-request/max-duration :portkey.aws.ec2.describe-host-reservation-offerings-request/max-results :portkey.aws.ec2.describe-host-reservation-offerings-request/min-duration :portkey.aws.ec2.describe-host-reservation-offerings-request/next-token :portkey.aws.ec2.describe-host-reservation-offerings-request/offering-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.reset-snapshot-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/snapshot-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.reset-snapshot-attribute-request/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reset-snapshot-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/reset-snapshot-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.reset-snapshot-attribute-request/attribute :portkey.aws.ec2.reset-snapshot-attribute-request/snapshot-id] :opt-un [:portkey.aws.ec2.reset-snapshot-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-details-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/volume-status-details))

(clojure.spec.alpha/def :portkey.aws.ec2/byoip-cidr-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/byoip-cidr))

(clojure.spec.alpha/def :portkey.aws.ec2.import-client-vpn-client-certificate-revocation-list-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-client-vpn-client-certificate-revocation-list-request/certificate-revocation-list (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-client-vpn-client-certificate-revocation-list-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/import-client-vpn-client-certificate-revocation-list-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.import-client-vpn-client-certificate-revocation-list-request/client-vpn-endpoint-id :portkey.aws.ec2.import-client-vpn-client-certificate-revocation-list-request/certificate-revocation-list] :opt-un [:portkey.aws.ec2.import-client-vpn-client-certificate-revocation-list-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-launch-template-overrides-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/fleet-launch-template-overrides))

(clojure.spec.alpha/def :portkey.aws.ec2/summary-status #{:initializing :insufficientdata :notapplicable "impaired" "initializing" :ok "insufficient-data" :impaired "not-applicable" "ok"})

(clojure.spec.alpha/def :portkey.aws.ec2.delete-transit-gateway-request/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-transit-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-transit-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-transit-gateway-request/transit-gateway-id] :opt-un [:portkey.aws.ec2.delete-transit-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-request/fleet-ids (clojure.spec.alpha/and :portkey.aws.ec2/fleet-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleets-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fleets-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-fleets-request/dry-run :portkey.aws.ec2.describe-fleets-request/max-results :portkey.aws.ec2.describe-fleets-request/next-token :portkey.aws.ec2.describe-fleets-request/fleet-ids :portkey.aws.ec2.describe-fleets-request/filters]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpn-gateway-request/vpn-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpn-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpn-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-vpn-gateway-request/vpn-gateway-id] :opt-un [:portkey.aws.ec2.delete-vpn-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-flow-logs-result/unsuccessful (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-item-set))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-flow-logs-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-flow-logs-result/unsuccessful]))

(clojure.spec.alpha/def :portkey.aws.ec2/bundle-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/egress-only-internet-gateway-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/egress-only-internet-gateway-id))

(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides/max-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides/weighted-capacity (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides/priority (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-overrides/placement (clojure.spec.alpha/and :portkey.aws.ec2/placement-response))
(clojure.spec.alpha/def :portkey.aws.ec2/fleet-launch-template-overrides (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/instance-type :portkey.aws.ec2.fleet-launch-template-overrides/max-price :portkey.aws.ec2.fleet-launch-template-overrides/subnet-id :portkey.aws.ec2.fleet-launch-template-overrides/availability-zone :portkey.aws.ec2.fleet-launch-template-overrides/weighted-capacity :portkey.aws.ec2.fleet-launch-template-overrides/priority :portkey.aws.ec2.fleet-launch-template-overrides/placement]))

(clojure.spec.alpha/def :portkey.aws.ec2.attach-classic-link-vpc-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-classic-link-vpc-request/groups (clojure.spec.alpha/and :portkey.aws.ec2/group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-classic-link-vpc-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-classic-link-vpc-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/attach-classic-link-vpc-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.attach-classic-link-vpc-request/groups :portkey.aws.ec2.attach-classic-link-vpc-request/instance-id :portkey.aws.ec2.attach-classic-link-vpc-request/vpc-id] :opt-un [:portkey.aws.ec2.attach-classic-link-vpc-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-snapshot-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/snapshot-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-snapshot-attribute-request/create-volume-permission (clojure.spec.alpha/and :portkey.aws.ec2/create-volume-permission-modifications))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-snapshot-attribute-request/group-names (clojure.spec.alpha/and :portkey.aws.ec2/group-name-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-snapshot-attribute-request/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-snapshot-attribute-request/user-ids (clojure.spec.alpha/and :portkey.aws.ec2/user-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-snapshot-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-snapshot-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-snapshot-attribute-request/snapshot-id] :opt-un [:portkey.aws.ec2.modify-snapshot-attribute-request/attribute :portkey.aws.ec2.modify-snapshot-attribute-request/create-volume-permission :portkey.aws.ec2.modify-snapshot-attribute-request/group-names :portkey.aws.ec2/operation-type :portkey.aws.ec2.modify-snapshot-attribute-request/user-ids :portkey.aws.ec2.modify-snapshot-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-fpga-image-attribute-request/user-ids (clojure.spec.alpha/and :portkey.aws.ec2/user-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fpga-image-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fpga-image-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/fpga-image-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fpga-image-attribute-request/fpga-image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fpga-image-attribute-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fpga-image-attribute-request/load-permission (clojure.spec.alpha/and :portkey.aws.ec2/load-permission-modifications))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fpga-image-attribute-request/product-codes (clojure.spec.alpha/and :portkey.aws.ec2/product-code-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fpga-image-attribute-request/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-fpga-image-attribute-request/user-groups (clojure.spec.alpha/and :portkey.aws.ec2/user-group-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-fpga-image-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-fpga-image-attribute-request/fpga-image-id] :opt-un [:portkey.aws.ec2.modify-fpga-image-attribute-request/user-ids :portkey.aws.ec2.modify-fpga-image-attribute-request/dry-run :portkey.aws.ec2.modify-fpga-image-attribute-request/attribute :portkey.aws.ec2.modify-fpga-image-attribute-request/description :portkey.aws.ec2/operation-type :portkey.aws.ec2.modify-fpga-image-attribute-request/load-permission :portkey.aws.ec2.modify-fpga-image-attribute-request/product-codes :portkey.aws.ec2.modify-fpga-image-attribute-request/name :portkey.aws.ec2.modify-fpga-image-attribute-request/user-groups]))

(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-fleet-response/spot-fleet-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/request-spot-fleet-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.request-spot-fleet-response/spot-fleet-request-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-elastic-inference-accelerator-response-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-elastic-inference-accelerator-response))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-requests-response/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-requests-response/spot-fleet-request-configs (clojure.spec.alpha/and :portkey.aws.ec2/spot-fleet-request-config-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-fleet-requests-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-spot-fleet-requests-response/next-token :portkey.aws.ec2.describe-spot-fleet-requests-response/spot-fleet-request-configs]))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-type #{"standard" "sc1" "io1" :sc-1 :st-1 "gp2" "st1" :io-1 :standard :gp-2})

(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation-state #{"expired" "failed" :pending "cancelled" :cancelled :active :expired "active" "pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-route-status-code #{"deleting" "failed" :creating :deleting :active "creating" "active" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.customer-gateway/bgp-asn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.customer-gateway/customer-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.customer-gateway/ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.customer-gateway/state (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.customer-gateway/type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.customer-gateway/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/customer-gateway (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.customer-gateway/bgp-asn :portkey.aws.ec2.customer-gateway/customer-gateway-id :portkey.aws.ec2.customer-gateway/ip-address :portkey.aws.ec2.customer-gateway/state :portkey.aws.ec2.customer-gateway/type :portkey.aws.ec2.customer-gateway/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpn-connections-result/vpn-connections (clojure.spec.alpha/and :portkey.aws.ec2/vpn-connection-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpn-connections-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpn-connections-result/vpn-connections]))

(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-permission/network-interface-permission-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-permission/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-permission/aws-account-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-permission/aws-service (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-permission/permission (clojure.spec.alpha/and :portkey.aws.ec2/interface-permission-type))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-permission/permission-state (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-permission-state))
(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-permission (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-interface-permission/network-interface-permission-id :portkey.aws.ec2.network-interface-permission/network-interface-id :portkey.aws.ec2.network-interface-permission/aws-account-id :portkey.aws.ec2.network-interface-permission/aws-service :portkey.aws.ec2.network-interface-permission/permission :portkey.aws.ec2.network-interface-permission/permission-state]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-configuration-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-configuration-request/service-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-configuration-request/acceptance-required (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-configuration-request/add-network-load-balancer-arns (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-configuration-request/remove-network-load-balancer-arns (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-endpoint-service-configuration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-vpc-endpoint-service-configuration-request/service-id] :opt-un [:portkey.aws.ec2.modify-vpc-endpoint-service-configuration-request/dry-run :portkey.aws.ec2.modify-vpc-endpoint-service-configuration-request/acceptance-required :portkey.aws.ec2.modify-vpc-endpoint-service-configuration-request/add-network-load-balancer-arns :portkey.aws.ec2.modify-vpc-endpoint-service-configuration-request/remove-network-load-balancer-arns]))

(clojure.spec.alpha/def :portkey.aws.ec2/response-host-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table-association/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table-association/resource-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table-association/resource-type (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-resource-type))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-table-association/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-association-state))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-table-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-route-table-association/transit-gateway-attachment-id :portkey.aws.ec2.transit-gateway-route-table-association/resource-id :portkey.aws.ec2.transit-gateway-route-table-association/resource-type :portkey.aws.ec2.transit-gateway-route-table-association/state]))

(clojure.spec.alpha/def :portkey.aws.ec2/account-attribute-name-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/account-attribute-name))

(clojure.spec.alpha/def :portkey.aws.ec2.target-capacity-specification-request/total-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.target-capacity-specification-request/on-demand-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.target-capacity-specification-request/spot-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/target-capacity-specification-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.target-capacity-specification-request/total-target-capacity] :opt-un [:portkey.aws.ec2.target-capacity-specification-request/on-demand-target-capacity :portkey.aws.ec2.target-capacity-specification-request/spot-target-capacity :portkey.aws.ec2/default-target-capacity-type]))

(clojure.spec.alpha/def :portkey.aws.ec2/tunnel-options-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpn-tunnel-options-specification))

(clojure.spec.alpha/def :portkey.aws.ec2/vpn-ecmp-support-value #{:disable :enable "enable" "disable"})

(clojure.spec.alpha/def :portkey.aws.ec2.copy-image-result/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/copy-image-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.copy-image-result/image-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-cidr-block-association/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-cidr-block-association/cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-cidr-block-association/cidr-block-state (clojure.spec.alpha/and :portkey.aws.ec2/vpc-cidr-block-state))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-cidr-block-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc-cidr-block-association/association-id :portkey.aws.ec2.vpc-cidr-block-association/cidr-block :portkey.aws.ec2.vpc-cidr-block-association/cidr-block-state]))

(clojure.spec.alpha/def :portkey.aws.ec2.export-client-vpn-client-certificate-revocation-list-result/certificate-revocation-list (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.export-client-vpn-client-certificate-revocation-list-result/status (clojure.spec.alpha/and :portkey.aws.ec2/client-certificate-revocation-list-status))
(clojure.spec.alpha/def :portkey.aws.ec2/export-client-vpn-client-certificate-revocation-list-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.export-client-vpn-client-certificate-revocation-list-result/certificate-revocation-list :portkey.aws.ec2.export-client-vpn-client-certificate-revocation-list-result/status]))

(clojure.spec.alpha/def :portkey.aws.ec2.accept-reserved-instances-exchange-quote-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.accept-reserved-instances-exchange-quote-request/reserved-instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instance-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.accept-reserved-instances-exchange-quote-request/target-configurations (clojure.spec.alpha/and :portkey.aws.ec2/target-configuration-request-set))
(clojure.spec.alpha/def :portkey.aws.ec2/accept-reserved-instances-exchange-quote-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.accept-reserved-instances-exchange-quote-request/reserved-instance-ids] :opt-un [:portkey.aws.ec2.accept-reserved-instances-exchange-quote-request/dry-run :portkey.aws.ec2.accept-reserved-instances-exchange-quote-request/target-configurations]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-request/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-launch-template-versions-request/versions (clojure.spec.alpha/and :portkey.aws.ec2/version-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-launch-template-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-launch-template-versions-request/versions] :opt-un [:portkey.aws.ec2.delete-launch-template-versions-request/dry-run :portkey.aws.ec2.delete-launch-template-versions-request/launch-template-id :portkey.aws.ec2/launch-template-name]))

(clojure.spec.alpha/def :portkey.aws.ec2/accept-vpc-peering-connection-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/vpc-peering-connection]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/associate-public-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/instance-ipv-6-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/device-index (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/groups (clojure.spec.alpha/and :portkey.aws.ec2/group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/private-ip-addresses (clojure.spec.alpha/and :portkey.aws.ec2/private-ip-address-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/secondary-private-ip-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-network-interface-specification/ipv-6-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-instance-network-interface-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-instance-network-interface-specification/associate-public-ip-address :portkey.aws.ec2.launch-template-instance-network-interface-specification/ipv-6-addresses :portkey.aws.ec2.launch-template-instance-network-interface-specification/subnet-id :portkey.aws.ec2.launch-template-instance-network-interface-specification/network-interface-id :portkey.aws.ec2.launch-template-instance-network-interface-specification/device-index :portkey.aws.ec2.launch-template-instance-network-interface-specification/description :portkey.aws.ec2.launch-template-instance-network-interface-specification/groups :portkey.aws.ec2.launch-template-instance-network-interface-specification/delete-on-termination :portkey.aws.ec2.launch-template-instance-network-interface-specification/private-ip-addresses :portkey.aws.ec2.launch-template-instance-network-interface-specification/secondary-private-ip-address-count :portkey.aws.ec2.launch-template-instance-network-interface-specification/private-ip-address :portkey.aws.ec2.launch-template-instance-network-interface-specification/ipv-6-address-count]))

(clojure.spec.alpha/def :portkey.aws.ec2/host-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/host))

(clojure.spec.alpha/def :portkey.aws.ec2.detach-volume-request/device (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-volume-request/force (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-volume-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-volume-request/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-volume-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/detach-volume-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.detach-volume-request/volume-id] :opt-un [:portkey.aws.ec2.detach-volume-request/device :portkey.aws.ec2.detach-volume-request/force :portkey.aws.ec2.detach-volume-request/instance-id :portkey.aws.ec2.detach-volume-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.purchase-reserved-instances-offering-request/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-reserved-instances-offering-request/reserved-instances-offering-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-reserved-instances-offering-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-reserved-instances-offering-request/limit-price (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instance-limit-price))
(clojure.spec.alpha/def :portkey.aws.ec2/purchase-reserved-instances-offering-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.purchase-reserved-instances-offering-request/instance-count :portkey.aws.ec2.purchase-reserved-instances-offering-request/reserved-instances-offering-id] :opt-un [:portkey.aws.ec2.purchase-reserved-instances-offering-request/dry-run :portkey.aws.ec2.purchase-reserved-instances-offering-request/limit-price]))

(clojure.spec.alpha/def :portkey.aws.ec2/stale-security-group-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/stale-security-group))

(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-specification-response-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/elastic-gpu-specification-response))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-permission-modifications/add (clojure.spec.alpha/and :portkey.aws.ec2/launch-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-permission-modifications/remove (clojure.spec.alpha/and :portkey.aws.ec2/launch-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-permission-modifications (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-permission-modifications/add :portkey.aws.ec2.launch-permission-modifications/remove]))

(clojure.spec.alpha/def :portkey.aws.ec2.unassign-private-ip-addresses-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.unassign-private-ip-addresses-request/private-ip-addresses (clojure.spec.alpha/and :portkey.aws.ec2/private-ip-address-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/unassign-private-ip-addresses-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.unassign-private-ip-addresses-request/network-interface-id :portkey.aws.ec2.unassign-private-ip-addresses-request/private-ip-addresses] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2/classic-load-balancers-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/classic-load-balancers]))

(clojure.spec.alpha/def :portkey.aws.ec2.terminate-instances-result/terminating-instances (clojure.spec.alpha/and :portkey.aws.ec2/instance-state-change-list))
(clojure.spec.alpha/def :portkey.aws.ec2/terminate-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.terminate-instances-result/terminating-instances]))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/volume-status-item))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpcs-result/vpcs (clojure.spec.alpha/and :portkey.aws.ec2/vpc-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpcs-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpcs-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpcs-result/vpcs :portkey.aws.ec2.describe-vpcs-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.monitor-instances-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.monitor-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/monitor-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.monitor-instances-request/instance-ids] :opt-un [:portkey.aws.ec2.monitor-instances-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.export-task/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.export-task/export-task-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.export-task/state (clojure.spec.alpha/and :portkey.aws.ec2/export-task-state))
(clojure.spec.alpha/def :portkey.aws.ec2.export-task/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/export-task (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.export-task/description :portkey.aws.ec2.export-task/export-task-id :portkey.aws.ec2/export-to-s-3-task :portkey.aws.ec2/instance-export-details :portkey.aws.ec2.export-task/state :portkey.aws.ec2.export-task/status-message]))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-association/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-association/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-association/resource-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-association/resource-type (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-resource-type))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-association/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-association-state))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-association/transit-gateway-route-table-id :portkey.aws.ec2.transit-gateway-association/transit-gateway-attachment-id :portkey.aws.ec2.transit-gateway-association/resource-id :portkey.aws.ec2.transit-gateway-association/resource-type :portkey.aws.ec2.transit-gateway-association/state]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-state #{:deleted :modifying "deleting" :pending :deleting "deleted" "modifying" :available "pending" "available"})

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-endpoints-result/unsuccessful (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-item-set))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpc-endpoints-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-vpc-endpoints-result/unsuccessful]))

(clojure.spec.alpha/def :portkey.aws.ec2/dns-support-value #{:disable :enable "enable" "disable"})

(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-private-ip-address/association (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-association))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-private-ip-address/primary (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-private-ip-address/private-dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-private-ip-address/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-private-ip-address (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-interface-private-ip-address/association :portkey.aws.ec2.network-interface-private-ip-address/primary :portkey.aws.ec2.network-interface-private-ip-address/private-dns-name :portkey.aws.ec2.network-interface-private-ip-address/private-ip-address]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-placement-group-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-placement-group-request/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-placement-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-placement-group-request/group-name] :opt-un [:portkey.aws.ec2.delete-placement-group-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/tag-specification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/tag-specification))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-propagation/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-propagation/resource-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-propagation/resource-type (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-resource-type))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-propagation/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-propagation/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-propagation-state))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-propagation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-propagation/transit-gateway-attachment-id :portkey.aws.ec2.transit-gateway-propagation/resource-id :portkey.aws.ec2.transit-gateway-propagation/resource-type :portkey.aws.ec2.transit-gateway-propagation/transit-gateway-route-table-id :portkey.aws.ec2.transit-gateway-propagation/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/credit-specification (clojure.spec.alpha/and :portkey.aws.ec2/credit-specification-request))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/max-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/instance-ipv-6-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/security-group-ids (clojure.spec.alpha/and :portkey.aws.ec2/security-group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/security-groups (clojure.spec.alpha/and :portkey.aws.ec2/security-group-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/instance-market-options (clojure.spec.alpha/and :portkey.aws.ec2/instance-market-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/launch-template (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/elastic-gpu-specification (clojure.spec.alpha/and :portkey.aws.ec2/elastic-gpu-specifications))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/min-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/additional-info (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/license-specifications (clojure.spec.alpha/and :portkey.aws.ec2/license-specification-list-request))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/disable-api-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/hibernation-options (clojure.spec.alpha/and :portkey.aws.ec2/hibernation-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/monitoring (clojure.spec.alpha/and :portkey.aws.ec2/run-instances-monitoring-enabled))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/block-device-mapping-request-list))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/cpu-options (clojure.spec.alpha/and :portkey.aws.ec2/cpu-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/ramdisk-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/user-data (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/instance-initiated-shutdown-behavior (clojure.spec.alpha/and :portkey.aws.ec2/shutdown-behavior))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/iam-instance-profile (clojure.spec.alpha/and :portkey.aws.ec2/iam-instance-profile-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/network-interfaces (clojure.spec.alpha/and :portkey.aws.ec2/instance-network-interface-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.run-instances-request/ipv-6-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/run-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.run-instances-request/max-count :portkey.aws.ec2.run-instances-request/min-count] :opt-un [:portkey.aws.ec2.run-instances-request/dry-run :portkey.aws.ec2.run-instances-request/tag-specifications :portkey.aws.ec2.run-instances-request/kernel-id :portkey.aws.ec2.run-instances-request/credit-specification :portkey.aws.ec2.run-instances-request/ipv-6-addresses :portkey.aws.ec2.run-instances-request/security-group-ids :portkey.aws.ec2.run-instances-request/image-id :portkey.aws.ec2/placement :portkey.aws.ec2.run-instances-request/subnet-id :portkey.aws.ec2.run-instances-request/security-groups :portkey.aws.ec2.run-instances-request/ebs-optimized :portkey.aws.ec2.run-instances-request/instance-market-options :portkey.aws.ec2/instance-type :portkey.aws.ec2.run-instances-request/launch-template :portkey.aws.ec2.run-instances-request/elastic-gpu-specification :portkey.aws.ec2/elastic-inference-accelerators :portkey.aws.ec2.run-instances-request/key-name :portkey.aws.ec2.run-instances-request/additional-info :portkey.aws.ec2.run-instances-request/license-specifications :portkey.aws.ec2.run-instances-request/disable-api-termination :portkey.aws.ec2.run-instances-request/hibernation-options :portkey.aws.ec2.run-instances-request/monitoring :portkey.aws.ec2.run-instances-request/block-device-mappings :portkey.aws.ec2/capacity-reservation-specification :portkey.aws.ec2.run-instances-request/cpu-options :portkey.aws.ec2.run-instances-request/ramdisk-id :portkey.aws.ec2.run-instances-request/user-data :portkey.aws.ec2.run-instances-request/instance-initiated-shutdown-behavior :portkey.aws.ec2.run-instances-request/iam-instance-profile :portkey.aws.ec2.run-instances-request/client-token :portkey.aws.ec2.run-instances-request/private-ip-address :portkey.aws.ec2.run-instances-request/network-interfaces :portkey.aws.ec2.run-instances-request/ipv-6-address-count]))

(clojure.spec.alpha/def :portkey.aws.ec2/placement-group-state #{:deleted "deleting" :pending :deleting "deleted" :available "pending" "available"})

(clojure.spec.alpha/def :portkey.aws.ec2/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-error/launch-template-and-overrides (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-and-overrides-response))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-error/lifecycle (clojure.spec.alpha/and :portkey.aws.ec2/instance-lifecycle))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-error/error-code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-error/error-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fleet-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-fleet-error/launch-template-and-overrides :portkey.aws.ec2.describe-fleet-error/lifecycle :portkey.aws.ec2.describe-fleet-error/error-code :portkey.aws.ec2.describe-fleet-error/error-message]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-modifications-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-modifications-request/volume-ids (clojure.spec.alpha/and :portkey.aws.ec2/volume-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-modifications-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-modifications-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-volumes-modifications-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-volumes-modifications-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-volumes-modifications-request/dry-run :portkey.aws.ec2.describe-volumes-modifications-request/volume-ids :portkey.aws.ec2.describe-volumes-modifications-request/filters :portkey.aws.ec2.describe-volumes-modifications-request/next-token :portkey.aws.ec2.describe-volumes-modifications-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-actions-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/volume-status-action))

(clojure.spec.alpha/def :portkey.aws.ec2/vpn-static-route-source #{:static "Static"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-instances-response/active-instances (clojure.spec.alpha/and :portkey.aws.ec2/active-instance-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-instances-response/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-instances-response/spot-fleet-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-fleet-instances-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-spot-fleet-instances-response/active-instances :portkey.aws.ec2.describe-spot-fleet-instances-response/next-token :portkey.aws.ec2.describe-spot-fleet-instances-response/spot-fleet-request-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-price-history-result/spot-price-history (clojure.spec.alpha/and :portkey.aws.ec2/spot-price-history-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-price-history-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-spot-price-history-result/next-token :portkey.aws.ec2.describe-spot-price-history-result/spot-price-history]))

(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation-target/capacity-reservation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.capacity-reservation-target/capacity-reservation-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.reset-instance-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/instance-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.reset-instance-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.reset-instance-attribute-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/reset-instance-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.reset-instance-attribute-request/attribute :portkey.aws.ec2.reset-instance-attribute-request/instance-id] :opt-un [:portkey.aws.ec2.reset-instance-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-permissions-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-permissions-request/service-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-permissions-request/add-allowed-principals (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-permissions-request/remove-allowed-principals (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-endpoint-service-permissions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-vpc-endpoint-service-permissions-request/service-id] :opt-un [:portkey.aws.ec2.modify-vpc-endpoint-service-permissions-request/dry-run :portkey.aws.ec2.modify-vpc-endpoint-service-permissions-request/add-allowed-principals :portkey.aws.ec2.modify-vpc-endpoint-service-permissions-request/remove-allowed-principals]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-default-subnet-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-default-subnet-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-default-subnet-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-default-subnet-request/availability-zone] :opt-un [:portkey.aws.ec2.create-default-subnet-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-max-results (clojure.spec.alpha/int-in 5 1000))

(clojure.spec.alpha/def :portkey.aws.ec2.purchase-scheduled-instances-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-scheduled-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-scheduled-instances-request/purchase-requests (clojure.spec.alpha/and :portkey.aws.ec2/purchase-request-set))
(clojure.spec.alpha/def :portkey.aws.ec2/purchase-scheduled-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.purchase-scheduled-instances-request/purchase-requests] :opt-un [:portkey.aws.ec2.purchase-scheduled-instances-request/client-token :portkey.aws.ec2.purchase-scheduled-instances-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/host-offering-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/host-offering))

(clojure.spec.alpha/def :portkey.aws.ec2.move-address-to-vpc-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.move-address-to-vpc-request/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/move-address-to-vpc-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.move-address-to-vpc-request/public-ip] :opt-un [:portkey.aws.ec2.move-address-to-vpc-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-endpoint-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpc-endpoint))

(clojure.spec.alpha/def :portkey.aws.ec2.copy-snapshot-result/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/copy-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.copy-snapshot-result/snapshot-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-export-tasks-request/export-task-ids (clojure.spec.alpha/and :portkey.aws.ec2/export-task-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-export-tasks-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-export-tasks-request/export-task-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2/subnet-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instance-limit-price/amount (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instance-limit-price/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instance-limit-price (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reserved-instance-limit-price/amount :portkey.aws.ec2.reserved-instance-limit-price/currency-code]))

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-recurrence/frequency (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-recurrence/interval (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-recurrence/occurrence-relative-to-end (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-recurrence/occurrence-unit (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instance-recurrence (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instance-recurrence/frequency :portkey.aws.ec2.scheduled-instance-recurrence/interval :portkey.aws.ec2/occurrence-day-set :portkey.aws.ec2.scheduled-instance-recurrence/occurrence-relative-to-end :portkey.aws.ec2.scheduled-instance-recurrence/occurrence-unit]))

(clojure.spec.alpha/def :portkey.aws.ec2.attach-classic-link-vpc-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/attach-classic-link-vpc-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.attach-classic-link-vpc-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.allowed-principal/principal (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/allowed-principal (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/principal-type :portkey.aws.ec2.allowed-principal/principal]))

(clojure.spec.alpha/def :portkey.aws.ec2.tag-specification/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/tag-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/resource-type :portkey.aws.ec2.tag-specification/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-connection-request/customer-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-connection-request/type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-connection-request/vpn-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-connection-request/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-connection-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpn-connection-request/options (clojure.spec.alpha/and :portkey.aws.ec2/vpn-connection-options-specification))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpn-connection-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-vpn-connection-request/customer-gateway-id :portkey.aws.ec2.create-vpn-connection-request/type] :opt-un [:portkey.aws.ec2.create-vpn-connection-request/vpn-gateway-id :portkey.aws.ec2.create-vpn-connection-request/transit-gateway-id :portkey.aws.ec2.create-vpn-connection-request/dry-run :portkey.aws.ec2.create-vpn-connection-request/options]))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-route-table-request/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-route-table-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-route-table-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.disassociate-route-table-request/association-id] :opt-un [:portkey.aws.ec2.disassociate-route-table-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/unsuccessful-instance-credit-specification-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/unsuccessful-instance-credit-specification-item))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-hosts-request/filter (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-hosts-request/host-ids (clojure.spec.alpha/and :portkey.aws.ec2/request-host-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-hosts-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-hosts-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-hosts-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-hosts-request/filter :portkey.aws.ec2.describe-hosts-request/host-ids :portkey.aws.ec2.describe-hosts-request/max-results :portkey.aws.ec2.describe-hosts-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-state/code (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-state/name (clojure.spec.alpha/and :portkey.aws.ec2/instance-state-name))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-state (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-state/code :portkey.aws.ec2.instance-state/name]))

(clojure.spec.alpha/def :portkey.aws.ec2/advertise-byoip-cidr-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/byoip-cidr]))

(clojure.spec.alpha/def :portkey.aws.ec2/region-name-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.update-security-group-rule-descriptions-ingress-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/update-security-group-rule-descriptions-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.update-security-group-rule-descriptions-ingress-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-recurrence-request/frequency (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-recurrence-request/interval (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-recurrence-request/occurrence-days (clojure.spec.alpha/and :portkey.aws.ec2/occurrence-day-request-set))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-recurrence-request/occurrence-relative-to-end (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-recurrence-request/occurrence-unit (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instance-recurrence-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instance-recurrence-request/frequency :portkey.aws.ec2.scheduled-instance-recurrence-request/interval :portkey.aws.ec2.scheduled-instance-recurrence-request/occurrence-days :portkey.aws.ec2.scheduled-instance-recurrence-request/occurrence-relative-to-end :portkey.aws.ec2.scheduled-instance-recurrence-request/occurrence-unit]))

(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-item/actions (clojure.spec.alpha/and :portkey.aws.ec2/volume-status-actions-list))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-item/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-item/events (clojure.spec.alpha/and :portkey.aws.ec2/volume-status-events-list))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-item/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-status-item/volume-status (clojure.spec.alpha/and :portkey.aws.ec2/volume-status-info))
(clojure.spec.alpha/def :portkey.aws.ec2/volume-status-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.volume-status-item/actions :portkey.aws.ec2.volume-status-item/availability-zone :portkey.aws.ec2.volume-status-item/events :portkey.aws.ec2.volume-status-item/volume-id :portkey.aws.ec2.volume-status-item/volume-status]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/instance-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-instance-attribute-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-instance-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-instance-attribute-request/attribute :portkey.aws.ec2.describe-instance-attribute-request/instance-id] :opt-un [:portkey.aws.ec2.describe-instance-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/spot-instance-state #{:open :closed "failed" "closed" "cancelled" :cancelled :active "active" "open" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/total-instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/capacity-reservation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/end-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/tenancy (clojure.spec.alpha/and :portkey.aws.ec2/capacity-reservation-tenancy))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/create-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/ephemeral-storage (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/instance-platform (clojure.spec.alpha/and :portkey.aws.ec2/capacity-reservation-instance-platform))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/available-instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.capacity-reservation/state (clojure.spec.alpha/and :portkey.aws.ec2/capacity-reservation-state))
(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.capacity-reservation/total-instance-count :portkey.aws.ec2.capacity-reservation/capacity-reservation-id :portkey.aws.ec2.capacity-reservation/end-date :portkey.aws.ec2.capacity-reservation/tenancy :portkey.aws.ec2.capacity-reservation/ebs-optimized :portkey.aws.ec2.capacity-reservation/create-date :portkey.aws.ec2.capacity-reservation/instance-type :portkey.aws.ec2/end-date-type :portkey.aws.ec2.capacity-reservation/tags :portkey.aws.ec2.capacity-reservation/availability-zone :portkey.aws.ec2.capacity-reservation/ephemeral-storage :portkey.aws.ec2/instance-match-criteria :portkey.aws.ec2.capacity-reservation/instance-platform :portkey.aws.ec2.capacity-reservation/available-instance-count :portkey.aws.ec2.capacity-reservation/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-response/successful-fleet-requests (clojure.spec.alpha/and :portkey.aws.ec2/cancel-spot-fleet-requests-success-set))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-fleet-requests-response/unsuccessful-fleet-requests (clojure.spec.alpha/and :portkey.aws.ec2/cancel-spot-fleet-requests-error-set))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-spot-fleet-requests-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cancel-spot-fleet-requests-response/successful-fleet-requests :portkey.aws.ec2.cancel-spot-fleet-requests-response/unsuccessful-fleet-requests]))

(clojure.spec.alpha/def :portkey.aws.ec2.detach-classic-link-vpc-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-classic-link-vpc-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-classic-link-vpc-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/detach-classic-link-vpc-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.detach-classic-link-vpc-request/instance-id :portkey.aws.ec2.detach-classic-link-vpc-request/vpc-id] :opt-un [:portkey.aws.ec2.detach-classic-link-vpc-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-state-name #{"stopping" "running" "terminated" :pending :shuttingdown :running :stopping :stopped "stopped" :terminated "shutting-down" "pending"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-moving-addresses-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-moving-addresses-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-moving-addresses-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-moving-addresses-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-moving-addresses-request/public-ips (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-moving-addresses-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-moving-addresses-request/filters :portkey.aws.ec2.describe-moving-addresses-request/dry-run :portkey.aws.ec2.describe-moving-addresses-request/max-results :portkey.aws.ec2.describe-moving-addresses-request/next-token :portkey.aws.ec2.describe-moving-addresses-request/public-ips]))

(clojure.spec.alpha/def :portkey.aws.ec2.apply-security-groups-to-client-vpn-target-network-result/security-group-ids (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-security-group-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2/apply-security-groups-to-client-vpn-target-network-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.apply-security-groups-to-client-vpn-target-network-result/security-group-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleets-result/successful-fleet-deletions (clojure.spec.alpha/and :portkey.aws.ec2/delete-fleet-success-set))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleets-result/unsuccessful-fleet-deletions (clojure.spec.alpha/and :portkey.aws.ec2/delete-fleet-error-set))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-fleets-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-fleets-result/successful-fleet-deletions :portkey.aws.ec2.delete-fleets-result/unsuccessful-fleet-deletions]))

(clojure.spec.alpha/def :portkey.aws.ec2.availability-zone-message/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/availability-zone-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.availability-zone-message/message]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-result/fleet-id (clojure.spec.alpha/and :portkey.aws.ec2/fleet-identifier))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-result/errors (clojure.spec.alpha/and :portkey.aws.ec2/create-fleet-errors-set))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-result/instances (clojure.spec.alpha/and :portkey.aws.ec2/create-fleet-instances-set))
(clojure.spec.alpha/def :portkey.aws.ec2/create-fleet-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-fleet-result/fleet-id :portkey.aws.ec2.create-fleet-result/errors :portkey.aws.ec2.create-fleet-result/instances]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-version-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-version))

(clojure.spec.alpha/def :portkey.aws.ec2/version-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21077__auto__] (clojure.core/< (clojure.core/count s__21077__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-nat-gateway-result/nat-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-nat-gateway-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-nat-gateway-result/nat-gateway-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.user-bucket/s-3-bucket (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.user-bucket/s-3-key (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/user-bucket (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.user-bucket/s-3-bucket :portkey.aws.ec2.user-bucket/s-3-key]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-template-versions-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-template-versions-request/versions (clojure.spec.alpha/and :portkey.aws.ec2/version-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-template-versions-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-template-versions-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-template-versions-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-template-versions-request/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-template-versions-request/min-version (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-launch-template-versions-request/max-version (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-launch-template-versions-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-launch-template-versions-request/dry-run :portkey.aws.ec2.describe-launch-template-versions-request/versions :portkey.aws.ec2.describe-launch-template-versions-request/next-token :portkey.aws.ec2/launch-template-name :portkey.aws.ec2.describe-launch-template-versions-request/filters :portkey.aws.ec2.describe-launch-template-versions-request/max-results :portkey.aws.ec2.describe-launch-template-versions-request/launch-template-id :portkey.aws.ec2.describe-launch-template-versions-request/min-version :portkey.aws.ec2.describe-launch-template-versions-request/max-version]))

(clojure.spec.alpha/def :portkey.aws.ec2/elastic-inference-accelerator-association-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/elastic-inference-accelerator-association))

(clojure.spec.alpha/def :portkey.aws.ec2/host-reservation-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/host-reservation))

(clojure.spec.alpha/def :portkey.aws.ec2/unsuccessful-item-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/unsuccessful-item))

(clojure.spec.alpha/def :portkey.aws.ec2.allocate-hosts-result/host-ids (clojure.spec.alpha/and :portkey.aws.ec2/response-host-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2/allocate-hosts-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.allocate-hosts-result/host-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2/virtualization-type #{:hvm :paravirtual "paravirtual" "hvm"})

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-connection-notification-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-connection-notification-request/connection-notification-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-connection-notification-request/connection-notification-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-connection-notification-request/connection-events (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-endpoint-connection-notification-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-vpc-endpoint-connection-notification-request/connection-notification-id] :opt-un [:portkey.aws.ec2.modify-vpc-endpoint-connection-notification-request/dry-run :portkey.aws.ec2.modify-vpc-endpoint-connection-notification-request/connection-notification-arn :portkey.aws.ec2.modify-vpc-endpoint-connection-notification-request/connection-events]))

(clojure.spec.alpha/def :portkey.aws.ec2.accept-vpc-peering-connection-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.accept-vpc-peering-connection-request/vpc-peering-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/accept-vpc-peering-connection-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.accept-vpc-peering-connection-request/dry-run :portkey.aws.ec2.accept-vpc-peering-connection-request/vpc-peering-connection-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/sriov-net-support (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/source-dest-check (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/disable-api-termination (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/groups (clojure.spec.alpha/and :portkey.aws.ec2/group-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/instance-block-device-mapping-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/product-codes (clojure.spec.alpha/and :portkey.aws.ec2/product-code-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/root-device-name (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/ramdisk-id (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/user-data (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/instance-initiated-shutdown-behavior (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-attribute/ena-support (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-attribute (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-attribute/kernel-id :portkey.aws.ec2.instance-attribute/instance-id :portkey.aws.ec2.instance-attribute/ebs-optimized :portkey.aws.ec2.instance-attribute/instance-type :portkey.aws.ec2.instance-attribute/sriov-net-support :portkey.aws.ec2.instance-attribute/source-dest-check :portkey.aws.ec2.instance-attribute/disable-api-termination :portkey.aws.ec2.instance-attribute/groups :portkey.aws.ec2.instance-attribute/block-device-mappings :portkey.aws.ec2.instance-attribute/product-codes :portkey.aws.ec2.instance-attribute/root-device-name :portkey.aws.ec2.instance-attribute/ramdisk-id :portkey.aws.ec2.instance-attribute/user-data :portkey.aws.ec2.instance-attribute/instance-initiated-shutdown-behavior :portkey.aws.ec2.instance-attribute/ena-support]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-elastic-inference-accelerator-response/type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-elastic-inference-accelerator-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-elastic-inference-accelerator-response/type]))

(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-id/reserved-instances-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-id (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reserved-instances-id/reserved-instances-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-request/offering-class (clojure.spec.alpha/and :portkey.aws.ec2/offering-class-type))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-request/reserved-instances-ids (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-request/offering-type (clojure.spec.alpha/and :portkey.aws.ec2/offering-type-values))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-reserved-instances-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-reserved-instances-request/filters :portkey.aws.ec2.describe-reserved-instances-request/offering-class :portkey.aws.ec2.describe-reserved-instances-request/reserved-instances-ids :portkey.aws.ec2.describe-reserved-instances-request/dry-run :portkey.aws.ec2.describe-reserved-instances-request/offering-type]))

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/associate-public-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/private-ip-address-configs (clojure.spec.alpha/and :portkey.aws.ec2/private-ip-address-config-set))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instances-ipv-6-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/device-index (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/groups (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instances-security-group-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/secondary-private-ip-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-network-interface/ipv-6-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-network-interface (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instances-network-interface/associate-public-ip-address :portkey.aws.ec2.scheduled-instances-network-interface/private-ip-address-configs :portkey.aws.ec2.scheduled-instances-network-interface/ipv-6-addresses :portkey.aws.ec2.scheduled-instances-network-interface/subnet-id :portkey.aws.ec2.scheduled-instances-network-interface/network-interface-id :portkey.aws.ec2.scheduled-instances-network-interface/device-index :portkey.aws.ec2.scheduled-instances-network-interface/description :portkey.aws.ec2.scheduled-instances-network-interface/groups :portkey.aws.ec2.scheduled-instances-network-interface/delete-on-termination :portkey.aws.ec2.scheduled-instances-network-interface/secondary-private-ip-address-count :portkey.aws.ec2.scheduled-instances-network-interface/private-ip-address :portkey.aws.ec2.scheduled-instances-network-interface/ipv-6-address-count]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/vpc-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-attribute-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-vpc-attribute-request/attribute :portkey.aws.ec2.describe-vpc-attribute-request/vpc-id] :opt-un [:portkey.aws.ec2.describe-vpc-attribute-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/max-duration (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/min-duration (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/instance-tenancy (clojure.spec.alpha/and :portkey.aws.ec2/tenancy))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/include-marketplace (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/product-description (clojure.spec.alpha/and :portkey.aws.ec2/ri-product-description))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/offering-class (clojure.spec.alpha/and :portkey.aws.ec2/offering-class-type))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/offering-type (clojure.spec.alpha/and :portkey.aws.ec2/offering-type-values))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/max-instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-offerings-request/reserved-instances-offering-ids (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-offering-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-reserved-instances-offerings-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-reserved-instances-offerings-request/dry-run :portkey.aws.ec2.describe-reserved-instances-offerings-request/max-duration :portkey.aws.ec2.describe-reserved-instances-offerings-request/min-duration :portkey.aws.ec2/instance-type :portkey.aws.ec2.describe-reserved-instances-offerings-request/availability-zone :portkey.aws.ec2.describe-reserved-instances-offerings-request/next-token :portkey.aws.ec2.describe-reserved-instances-offerings-request/instance-tenancy :portkey.aws.ec2.describe-reserved-instances-offerings-request/include-marketplace :portkey.aws.ec2.describe-reserved-instances-offerings-request/filters :portkey.aws.ec2.describe-reserved-instances-offerings-request/product-description :portkey.aws.ec2.describe-reserved-instances-offerings-request/max-results :portkey.aws.ec2.describe-reserved-instances-offerings-request/offering-class :portkey.aws.ec2.describe-reserved-instances-offerings-request/offering-type :portkey.aws.ec2.describe-reserved-instances-offerings-request/max-instance-count :portkey.aws.ec2.describe-reserved-instances-offerings-request/reserved-instances-offering-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-credit-specification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-credit-specification))

(clojure.spec.alpha/def :portkey.aws.ec2/default-target-capacity-type #{:ondemand "spot" "on-demand" :spot})

(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-request/subnet-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-request/security-group-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-request/private-dns-enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-request/policy-document (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-request/service-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-request/route-table-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-vpc-endpoint-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-vpc-endpoint-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-vpc-endpoint-request/vpc-id :portkey.aws.ec2.create-vpc-endpoint-request/service-name] :opt-un [:portkey.aws.ec2.create-vpc-endpoint-request/dry-run :portkey.aws.ec2/vpc-endpoint-type :portkey.aws.ec2.create-vpc-endpoint-request/subnet-ids :portkey.aws.ec2.create-vpc-endpoint-request/security-group-ids :portkey.aws.ec2.create-vpc-endpoint-request/private-dns-enabled :portkey.aws.ec2.create-vpc-endpoint-request/policy-document :portkey.aws.ec2.create-vpc-endpoint-request/route-table-ids :portkey.aws.ec2.create-vpc-endpoint-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpc-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-vpc-request/vpc-id] :opt-un [:portkey.aws.ec2.delete-vpc-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-subnet-cidr-block-request/ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-subnet-cidr-block-request/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-subnet-cidr-block-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.associate-subnet-cidr-block-request/ipv-6-cidr-block :portkey.aws.ec2.associate-subnet-cidr-block-request/subnet-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.target-configuration-request/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.target-configuration-request/offering-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/target-configuration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.target-configuration-request/offering-id] :opt-un [:portkey.aws.ec2.target-configuration-request/instance-count]))

(clojure.spec.alpha/def :portkey.aws.ec2/delete-transit-gateway-vpc-attachment-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/transit-gateway-vpc-attachment]))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-configuration-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/reserved-instances-configuration))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-endpoint-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-vpc-endpoint-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fpga-images-result/fpga-images (clojure.spec.alpha/and :portkey.aws.ec2/fpga-image-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fpga-images-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-fpga-images-result/fpga-images :portkey.aws.ec2/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/capacity-reservation-preference :portkey.aws.ec2/capacity-reservation-target]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/end-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/tenancy (clojure.spec.alpha/and :portkey.aws.ec2/capacity-reservation-tenancy))
(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/ephemeral-storage (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/instance-platform (clojure.spec.alpha/and :portkey.aws.ec2/capacity-reservation-instance-platform))
(clojure.spec.alpha/def :portkey.aws.ec2.create-capacity-reservation-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-capacity-reservation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-capacity-reservation-request/instance-type :portkey.aws.ec2.create-capacity-reservation-request/instance-platform :portkey.aws.ec2.create-capacity-reservation-request/availability-zone :portkey.aws.ec2.create-capacity-reservation-request/instance-count] :opt-un [:portkey.aws.ec2.create-capacity-reservation-request/dry-run :portkey.aws.ec2.create-capacity-reservation-request/tag-specifications :portkey.aws.ec2.create-capacity-reservation-request/end-date :portkey.aws.ec2.create-capacity-reservation-request/tenancy :portkey.aws.ec2.create-capacity-reservation-request/ebs-optimized :portkey.aws.ec2/end-date-type :portkey.aws.ec2.create-capacity-reservation-request/ephemeral-storage :portkey.aws.ec2/instance-match-criteria :portkey.aws.ec2.create-capacity-reservation-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-result/history-records (clojure.spec.alpha/and :portkey.aws.ec2/history-record-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-result/last-evaluated-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-result/fleet-id (clojure.spec.alpha/and :portkey.aws.ec2/fleet-identifier))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fleet-history-result/start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fleet-history-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-fleet-history-result/history-records :portkey.aws.ec2.describe-fleet-history-result/last-evaluated-time :portkey.aws.ec2.describe-fleet-history-result/next-token :portkey.aws.ec2.describe-fleet-history-result/fleet-id :portkey.aws.ec2.describe-fleet-history-result/start-time]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interfaces-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interfaces-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interfaces-request/network-interface-ids (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interfaces-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-network-interfaces-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-network-interfaces-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-network-interfaces-request/filters :portkey.aws.ec2.describe-network-interfaces-request/dry-run :portkey.aws.ec2.describe-network-interfaces-request/network-interface-ids :portkey.aws.ec2.describe-network-interfaces-request/next-token :portkey.aws.ec2.describe-network-interfaces-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-network-interface-specification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-network-interface-specification))

(clojure.spec.alpha/def :portkey.aws.ec2/modify-fpga-image-attribute-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/fpga-image-attribute]))

(clojure.spec.alpha/def :portkey.aws.ec2.conversion-task/conversion-task-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.conversion-task/expiration-time (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.conversion-task/import-instance (clojure.spec.alpha/and :portkey.aws.ec2/import-instance-task-details))
(clojure.spec.alpha/def :portkey.aws.ec2.conversion-task/import-volume (clojure.spec.alpha/and :portkey.aws.ec2/import-volume-task-details))
(clojure.spec.alpha/def :portkey.aws.ec2.conversion-task/state (clojure.spec.alpha/and :portkey.aws.ec2/conversion-task-state))
(clojure.spec.alpha/def :portkey.aws.ec2.conversion-task/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.conversion-task/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/conversion-task (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.conversion-task/conversion-task-id :portkey.aws.ec2.conversion-task/expiration-time :portkey.aws.ec2.conversion-task/import-instance :portkey.aws.ec2.conversion-task/import-volume :portkey.aws.ec2.conversion-task/state :portkey.aws.ec2.conversion-task/status-message :portkey.aws.ec2.conversion-task/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-subnets-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-subnets-request/subnet-ids (clojure.spec.alpha/and :portkey.aws.ec2/subnet-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-subnets-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-subnets-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-subnets-request/filters :portkey.aws.ec2.describe-subnets-request/subnet-ids :portkey.aws.ec2.describe-subnets-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-route-tables-result/transit-gateway-route-tables (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route-table-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-route-tables-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-transit-gateway-route-tables-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-transit-gateway-route-tables-result/transit-gateway-route-tables :portkey.aws.ec2.describe-transit-gateway-route-tables-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-subnet-cidr-block-request/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-subnet-cidr-block-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.disassociate-subnet-cidr-block-request/association-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-routes-result/routes (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-route-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-client-vpn-routes-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-client-vpn-routes-result/routes :portkey.aws.ec2/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/successful-instance-credit-specification-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/successful-instance-credit-specification-item))

(clojure.spec.alpha/def :portkey.aws.ec2.bundle-task-error/code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.bundle-task-error/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/bundle-task-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.bundle-task-error/code :portkey.aws.ec2.bundle-task-error/message]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-volume-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-volume-request/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-volume-request/size (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-volume-request/iops (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-volume-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-volume-request/volume-id] :opt-un [:portkey.aws.ec2.modify-volume-request/dry-run :portkey.aws.ec2.modify-volume-request/size :portkey.aws.ec2/volume-type :portkey.aws.ec2.modify-volume-request/iops]))

(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-iam-instance-profile-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/iam-instance-profile-association]))

(clojure.spec.alpha/def :portkey.aws.ec2.dhcp-configuration/key (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.dhcp-configuration/values (clojure.spec.alpha/and :portkey.aws.ec2/dhcp-configuration-value-list))
(clojure.spec.alpha/def :portkey.aws.ec2/dhcp-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.dhcp-configuration/key :portkey.aws.ec2.dhcp-configuration/values]))

(clojure.spec.alpha/def :portkey.aws.ec2.key-pair/key-fingerprint (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.key-pair/key-material (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.key-pair/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/key-pair (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.key-pair/key-fingerprint :portkey.aws.ec2.key-pair/key-material :portkey.aws.ec2.key-pair/key-name]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-nat-gateway-request/nat-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-nat-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-nat-gateway-request/nat-gateway-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.block-device-mapping/device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.block-device-mapping/virtual-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.block-device-mapping/ebs (clojure.spec.alpha/and :portkey.aws.ec2/ebs-block-device))
(clojure.spec.alpha/def :portkey.aws.ec2.block-device-mapping/no-device (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/block-device-mapping (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.block-device-mapping/device-name :portkey.aws.ec2.block-device-mapping/virtual-name :portkey.aws.ec2.block-device-mapping/ebs :portkey.aws.ec2.block-device-mapping/no-device]))

(clojure.spec.alpha/def :portkey.aws.ec2/state #{:deleted "Failed" :rejected "Rejected" :pending "Expired" :pending-acceptance :deleting "Deleting" "Deleted" :expired :available "Pending" "Available" :failed "PendingAcceptance"})

(clojure.spec.alpha/def :portkey.aws.ec2.export-to-s-3-task/s-3-bucket (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.export-to-s-3-task/s-3-key (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/export-to-s-3-task (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/container-format :portkey.aws.ec2/disk-image-format :portkey.aws.ec2.export-to-s-3-task/s-3-bucket :portkey.aws.ec2.export-to-s-3-task/s-3-key]))

(clojure.spec.alpha/def :portkey.aws.ec2/network-acl-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/network-acl))

(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-propagations-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-propagations-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-propagations-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-propagations-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-propagations-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/get-transit-gateway-route-table-propagations-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.get-transit-gateway-route-table-propagations-request/transit-gateway-route-table-id] :opt-un [:portkey.aws.ec2.get-transit-gateway-route-table-propagations-request/filters :portkey.aws.ec2.get-transit-gateway-route-table-propagations-request/max-results :portkey.aws.ec2.get-transit-gateway-route-table-propagations-request/next-token :portkey.aws.ec2.get-transit-gateway-route-table-propagations-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/max-results (clojure.spec.alpha/int-in 5 255))

(clojure.spec.alpha/def :portkey.aws.ec2/target-network-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/target-network))

(clojure.spec.alpha/def :portkey.aws.ec2.public-ipv-4-pool/pool-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.public-ipv-4-pool/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.public-ipv-4-pool/pool-address-ranges (clojure.spec.alpha/and :portkey.aws.ec2/public-ipv-4-pool-range-set))
(clojure.spec.alpha/def :portkey.aws.ec2.public-ipv-4-pool/total-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.public-ipv-4-pool/total-available-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/public-ipv-4-pool (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.public-ipv-4-pool/pool-id :portkey.aws.ec2.public-ipv-4-pool/description :portkey.aws.ec2.public-ipv-4-pool/pool-address-ranges :portkey.aws.ec2.public-ipv-4-pool/total-address-count :portkey.aws.ec2.public-ipv-4-pool/total-available-address-count]))

(clojure.spec.alpha/def :portkey.aws.ec2.cpu-options/core-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.cpu-options/threads-per-core (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/cpu-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cpu-options/core-count :portkey.aws.ec2.cpu-options/threads-per-core]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-endpoint-connection-notifications-result/unsuccessful (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-item-set))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpc-endpoint-connection-notifications-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-vpc-endpoint-connection-notifications-result/unsuccessful]))

(clojure.spec.alpha/def :portkey.aws.ec2.tag/key (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.tag/value (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/tag (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.tag/key :portkey.aws.ec2.tag/value]))

(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/username (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/egress-bytes (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/egress-packets (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/status (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-connection-status))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/ingress-bytes (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/common-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/connection-end-time (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/ingress-packets (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/connection-established-time (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/client-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/timestamp (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.client-vpn-connection/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-connection (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.client-vpn-connection/username :portkey.aws.ec2.client-vpn-connection/connection-id :portkey.aws.ec2.client-vpn-connection/egress-bytes :portkey.aws.ec2.client-vpn-connection/egress-packets :portkey.aws.ec2.client-vpn-connection/status :portkey.aws.ec2.client-vpn-connection/ingress-bytes :portkey.aws.ec2.client-vpn-connection/common-name :portkey.aws.ec2.client-vpn-connection/connection-end-time :portkey.aws.ec2.client-vpn-connection/ingress-packets :portkey.aws.ec2.client-vpn-connection/connection-established-time :portkey.aws.ec2.client-vpn-connection/client-ip :portkey.aws.ec2.client-vpn-connection/timestamp :portkey.aws.ec2.client-vpn-connection/client-vpn-endpoint-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.accept-vpc-endpoint-connections-result/unsuccessful (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-item-set))
(clojure.spec.alpha/def :portkey.aws.ec2/accept-vpc-endpoint-connections-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.accept-vpc-endpoint-connections-result/unsuccessful]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-subnets-result/subnets (clojure.spec.alpha/and :portkey.aws.ec2/subnet-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-subnets-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-subnets-result/subnets]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-address-result/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-address-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.associate-address-result/association-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/recurring-charge-frequency #{"Hourly" :hourly})

(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-tag-specification/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-fleet-tag-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/resource-type :portkey.aws.ec2.spot-fleet-tag-specification/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2/user-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/executable-by-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/create-instance-export-task-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/export-task]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-peering-connection-options-result/accepter-peering-connection-options (clojure.spec.alpha/and :portkey.aws.ec2/peering-connection-options))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-peering-connection-options-result/requester-peering-connection-options (clojure.spec.alpha/and :portkey.aws.ec2/peering-connection-options))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-peering-connection-options-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-vpc-peering-connection-options-result/accepter-peering-connection-options :portkey.aws.ec2.modify-vpc-peering-connection-options-result/requester-peering-connection-options]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-client-vpn-endpoint-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-client-vpn-endpoint-request/server-certificate-arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-client-vpn-endpoint-request/dns-servers (clojure.spec.alpha/and :portkey.aws.ec2/dns-servers-options-modify-structure))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-client-vpn-endpoint-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-client-vpn-endpoint-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-client-vpn-endpoint-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-client-vpn-endpoint-request/client-vpn-endpoint-id] :opt-un [:portkey.aws.ec2.modify-client-vpn-endpoint-request/server-certificate-arn :portkey.aws.ec2/connection-log-options :portkey.aws.ec2.modify-client-vpn-endpoint-request/dns-servers :portkey.aws.ec2.modify-client-vpn-endpoint-request/description :portkey.aws.ec2.modify-client-vpn-endpoint-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-availability-zones-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-availability-zones-request/zone-names (clojure.spec.alpha/and :portkey.aws.ec2/zone-name-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-availability-zones-request/zone-ids (clojure.spec.alpha/and :portkey.aws.ec2/zone-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-availability-zones-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-availability-zones-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-availability-zones-request/filters :portkey.aws.ec2.describe-availability-zones-request/zone-names :portkey.aws.ec2.describe-availability-zones-request/zone-ids :portkey.aws.ec2.describe-availability-zones-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-name-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-name))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-market-options-request/spot-options (clojure.spec.alpha/and :portkey.aws.ec2/spot-market-options))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-market-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/market-type :portkey.aws.ec2.instance-market-options-request/spot-options]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-route-table-result/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-route-table-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.associate-route-table-result/association-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/platform-values #{:windows "Windows"})

(clojure.spec.alpha/def :portkey.aws.ec2.disk-image/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disk-image/image (clojure.spec.alpha/and :portkey.aws.ec2/disk-image-detail))
(clojure.spec.alpha/def :portkey.aws.ec2.disk-image/volume (clojure.spec.alpha/and :portkey.aws.ec2/volume-detail))
(clojure.spec.alpha/def :portkey.aws.ec2/disk-image (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disk-image/description :portkey.aws.ec2.disk-image/image :portkey.aws.ec2.disk-image/volume]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-capacity-reservation-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-capacity-reservation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-capacity-reservation-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-address-request/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-address-request/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.disassociate-address-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/disassociate-address-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.disassociate-address-request/association-id :portkey.aws.ec2.disassociate-address-request/public-ip :portkey.aws.ec2.disassociate-address-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/cancel-spot-fleet-requests-success-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/cancel-spot-fleet-requests-success-item))

(clojure.spec.alpha/def :portkey.aws.ec2.product-code/product-code-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.product-code/product-code-type (clojure.spec.alpha/and :portkey.aws.ec2/product-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2/product-code (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.product-code/product-code-id :portkey.aws.ec2.product-code/product-code-type]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-request/options (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-request-options))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-request/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-transit-gateway-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-transit-gateway-request/description :portkey.aws.ec2.create-transit-gateway-request/options :portkey.aws.ec2.create-transit-gateway-request/tag-specifications :portkey.aws.ec2.create-transit-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-permission-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-permission-request/aws-account-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-permission-request/aws-service (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-permission-request/permission (clojure.spec.alpha/and :portkey.aws.ec2/interface-permission-type))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-permission-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-network-interface-permission-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-network-interface-permission-request/network-interface-id :portkey.aws.ec2.create-network-interface-permission-request/permission] :opt-un [:portkey.aws.ec2.create-network-interface-permission-request/aws-account-id :portkey.aws.ec2.create-network-interface-permission-request/aws-service :portkey.aws.ec2.create-network-interface-permission-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-authentication-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/client-vpn-authentication))

(clojure.spec.alpha/def :portkey.aws.ec2.port-range/from (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.port-range/to (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/port-range (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.port-range/from :portkey.aws.ec2.port-range/to]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-state #{:pending :available "pending" "available"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-byoip-cidrs-result/byoip-cidrs (clojure.spec.alpha/and :portkey.aws.ec2/byoip-cidr-set))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-byoip-cidrs-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-byoip-cidrs-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-byoip-cidrs-result/byoip-cidrs :portkey.aws.ec2.describe-byoip-cidrs-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/attachment-status #{"attached" "detaching" :detached "detached" "attaching" :attaching :attached :detaching})

(clojure.spec.alpha/def :portkey.aws.ec2.peering-connection-options/allow-dns-resolution-from-remote-vpc (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.peering-connection-options/allow-egress-from-local-classic-link-to-remote-vpc (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.peering-connection-options/allow-egress-from-local-vpc-to-remote-classic-link (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/peering-connection-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.peering-connection-options/allow-dns-resolution-from-remote-vpc :portkey.aws.ec2.peering-connection-options/allow-egress-from-local-classic-link-to-remote-vpc :portkey.aws.ec2.peering-connection-options/allow-egress-from-local-vpc-to-remote-classic-link]))

(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-authentication-request-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/client-vpn-authentication-request))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-templates-monitoring/enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-templates-monitoring (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-templates-monitoring/enabled]))

(clojure.spec.alpha/def :portkey.aws.ec2/dns-entry-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/dns-entry))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-version/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-version/version-number (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-version/create-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-version/created-by (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-version/default-version (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-version/launch-template-data (clojure.spec.alpha/and :portkey.aws.ec2/response-launch-template-data))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-version/launch-template-id :portkey.aws.ec2/launch-template-name :portkey.aws.ec2.launch-template-version/version-number :portkey.aws.ec2/version-description :portkey.aws.ec2.launch-template-version/create-time :portkey.aws.ec2.launch-template-version/created-by :portkey.aws.ec2.launch-template-version/default-version :portkey.aws.ec2.launch-template-version/launch-template-data]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-fleet-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-fleet-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-fleet-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-attachment/state (clojure.spec.alpha/and :portkey.aws.ec2/attachment-status))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-attachment/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-attachment (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc-attachment/state :portkey.aws.ec2.vpc-attachment/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-transit-gateway-route-table-result/association (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-association))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-transit-gateway-route-table-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.associate-transit-gateway-route-table-result/association]))

(clojure.spec.alpha/def :portkey.aws.ec2.reject-vpc-endpoint-connections-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.reject-vpc-endpoint-connections-request/service-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reject-vpc-endpoint-connections-request/vpc-endpoint-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/reject-vpc-endpoint-connections-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.reject-vpc-endpoint-connections-request/service-id :portkey.aws.ec2.reject-vpc-endpoint-connections-request/vpc-endpoint-ids] :opt-un [:portkey.aws.ec2.reject-vpc-endpoint-connections-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-egress-request/source-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-egress-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-egress-request/to-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-egress-request/source-security-group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-egress-request/ip-protocol (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-egress-request/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-egress-request/from-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-egress-request/ip-permissions (clojure.spec.alpha/and :portkey.aws.ec2/ip-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.revoke-security-group-egress-request/cidr-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/revoke-security-group-egress-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.revoke-security-group-egress-request/group-id] :opt-un [:portkey.aws.ec2.revoke-security-group-egress-request/source-security-group-owner-id :portkey.aws.ec2.revoke-security-group-egress-request/dry-run :portkey.aws.ec2.revoke-security-group-egress-request/to-port :portkey.aws.ec2.revoke-security-group-egress-request/source-security-group-name :portkey.aws.ec2.revoke-security-group-egress-request/ip-protocol :portkey.aws.ec2.revoke-security-group-egress-request/from-port :portkey.aws.ec2.revoke-security-group-egress-request/ip-permissions :portkey.aws.ec2.revoke-security-group-egress-request/cidr-ip]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-status/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status/events (clojure.spec.alpha/and :portkey.aws.ec2/instance-status-event-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status/instance-status (clojure.spec.alpha/and :portkey.aws.ec2/instance-status-summary))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-status/system-status (clojure.spec.alpha/and :portkey.aws.ec2/instance-status-summary))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-status/availability-zone :portkey.aws.ec2.instance-status/events :portkey.aws.ec2.instance-status/instance-id :portkey.aws.ec2/instance-state :portkey.aws.ec2.instance-status/instance-status :portkey.aws.ec2.instance-status/system-status]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-iam-instance-profile-associations-request/association-ids (clojure.spec.alpha/and :portkey.aws.ec2/association-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-iam-instance-profile-associations-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-iam-instance-profile-associations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-iam-instance-profile-associations-request/association-ids :portkey.aws.ec2.describe-iam-instance-profile-associations-request/filters :portkey.aws.ec2/max-results :portkey.aws.ec2/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/spot-fleet-tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/placement (clojure.spec.alpha/and :portkey.aws.ec2/spot-placement))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/addressing-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/security-groups (clojure.spec.alpha/and :portkey.aws.ec2/group-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/spot-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/monitoring (clojure.spec.alpha/and :portkey.aws.ec2/spot-fleet-monitoring))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/weighted-capacity (clojure.spec.alpha/and :portkey.aws.ec2/double))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/block-device-mapping-list))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/ramdisk-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/user-data (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/iam-instance-profile (clojure.spec.alpha/and :portkey.aws.ec2/iam-instance-profile-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-fleet-launch-specification/network-interfaces (clojure.spec.alpha/and :portkey.aws.ec2/instance-network-interface-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-fleet-launch-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-fleet-launch-specification/tag-specifications :portkey.aws.ec2.spot-fleet-launch-specification/kernel-id :portkey.aws.ec2.spot-fleet-launch-specification/image-id :portkey.aws.ec2.spot-fleet-launch-specification/placement :portkey.aws.ec2.spot-fleet-launch-specification/addressing-type :portkey.aws.ec2.spot-fleet-launch-specification/subnet-id :portkey.aws.ec2.spot-fleet-launch-specification/security-groups :portkey.aws.ec2.spot-fleet-launch-specification/ebs-optimized :portkey.aws.ec2/instance-type :portkey.aws.ec2.spot-fleet-launch-specification/key-name :portkey.aws.ec2.spot-fleet-launch-specification/spot-price :portkey.aws.ec2.spot-fleet-launch-specification/monitoring :portkey.aws.ec2.spot-fleet-launch-specification/weighted-capacity :portkey.aws.ec2.spot-fleet-launch-specification/block-device-mappings :portkey.aws.ec2.spot-fleet-launch-specification/ramdisk-id :portkey.aws.ec2.spot-fleet-launch-specification/user-data :portkey.aws.ec2.spot-fleet-launch-specification/iam-instance-profile :portkey.aws.ec2.spot-fleet-launch-specification/network-interfaces]))

(clojure.spec.alpha/def :portkey.aws.ec2/ipv-6-cidr-block-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/ipv-6-cidr-block))

(clojure.spec.alpha/def :portkey.aws.ec2.detach-vpn-gateway-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-vpn-gateway-request/vpn-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.detach-vpn-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/detach-vpn-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.detach-vpn-gateway-request/vpc-id :portkey.aws.ec2.detach-vpn-gateway-request/vpn-gateway-id] :opt-un [:portkey.aws.ec2.detach-vpn-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.ip-range/cidr-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.ip-range/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/ip-range (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.ip-range/cidr-ip :portkey.aws.ec2.ip-range/description]))

(clojure.spec.alpha/def :portkey.aws.ec2/cidr-block-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/cidr-block))

(clojure.spec.alpha/def :portkey.aws.ec2.stale-security-group/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.stale-security-group/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.stale-security-group/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.stale-security-group/stale-ip-permissions (clojure.spec.alpha/and :portkey.aws.ec2/stale-ip-permission-set))
(clojure.spec.alpha/def :portkey.aws.ec2.stale-security-group/stale-ip-permissions-egress (clojure.spec.alpha/and :portkey.aws.ec2/stale-ip-permission-set))
(clojure.spec.alpha/def :portkey.aws.ec2.stale-security-group/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/stale-security-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.stale-security-group/description :portkey.aws.ec2.stale-security-group/group-id :portkey.aws.ec2.stale-security-group/group-name :portkey.aws.ec2.stale-security-group/stale-ip-permissions :portkey.aws.ec2.stale-security-group/stale-ip-permissions-egress :portkey.aws.ec2.stale-security-group/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/version-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/block-device-mapping-request-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/block-device-mapping))

(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-task/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-snapshot-task/import-task-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/import-snapshot-task (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.import-snapshot-task/description :portkey.aws.ec2.import-snapshot-task/import-task-id :portkey.aws.ec2/snapshot-task-detail]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-tenancy-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-tenancy-request/instance-tenancy (clojure.spec.alpha/and :portkey.aws.ec2/vpc-tenancy))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-tenancy-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-tenancy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-vpc-tenancy-request/vpc-id :portkey.aws.ec2.modify-vpc-tenancy-request/instance-tenancy] :opt-un [:portkey.aws.ec2.modify-vpc-tenancy-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.elastic-gpu-specification-response/type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-specification-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.elastic-gpu-specification-response/type]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-permissions-result/return-value (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-endpoint-service-permissions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-vpc-endpoint-service-permissions-result/return-value]))

(clojure.spec.alpha/def :portkey.aws.ec2/container-format #{:ova "ova"})

(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-ipv-6-addresses-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/network-interface-ipv-6-address))

(clojure.spec.alpha/def :portkey.aws.ec2/purchase-request-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/purchase-request :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-service-configuration-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-endpoint-service-configuration-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-vpc-endpoint-service-configuration-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-security-group-result/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-security-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-security-group-result/group-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection-state-reason/code (clojure.spec.alpha/and :portkey.aws.ec2/vpc-peering-connection-state-reason-code))
(clojure.spec.alpha/def :portkey.aws.ec2.vpc-peering-connection-state-reason/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/vpc-peering-connection-state-reason (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpc-peering-connection-state-reason/code :portkey.aws.ec2.vpc-peering-connection-state-reason/message]))

(clojure.spec.alpha/def :portkey.aws.ec2/new-dhcp-configuration-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/new-dhcp-configuration))

(clojure.spec.alpha/def :portkey.aws.ec2.get-password-data-result/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-password-data-result/password-data (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-password-data-result/timestamp (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/get-password-data-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.get-password-data-result/instance-id :portkey.aws.ec2.get-password-data-result/password-data :portkey.aws.ec2.get-password-data-result/timestamp]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-prefix-lists-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-prefix-lists-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-prefix-lists-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-prefix-lists-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-prefix-lists-request/prefix-list-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-prefix-lists-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-prefix-lists-request/dry-run :portkey.aws.ec2.describe-prefix-lists-request/filters :portkey.aws.ec2.describe-prefix-lists-request/max-results :portkey.aws.ec2.describe-prefix-lists-request/next-token :portkey.aws.ec2.describe-prefix-lists-request/prefix-list-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2/market-type #{"spot" :spot})

(clojure.spec.alpha/def :portkey.aws.ec2/import-volume-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/conversion-task]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance/public-dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/spot-instance-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/instance-lifecycle (clojure.spec.alpha/and :portkey.aws.ec2/instance-lifecycle-type))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/platform (clojure.spec.alpha/and :portkey.aws.ec2/platform-values))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/capacity-reservation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/root-device-type (clojure.spec.alpha/and :portkey.aws.ec2/device-type))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/security-groups (clojure.spec.alpha/and :portkey.aws.ec2/group-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/sriov-net-support (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/elastic-inference-accelerator-associations (clojure.spec.alpha/and :portkey.aws.ec2/elastic-inference-accelerator-association-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/source-dest-check (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/elastic-gpu-associations (clojure.spec.alpha/and :portkey.aws.ec2/elastic-gpu-association-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/private-dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/licenses (clojure.spec.alpha/and :portkey.aws.ec2/license-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/instance-block-device-mapping-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/hypervisor (clojure.spec.alpha/and :portkey.aws.ec2/hypervisor-type))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/architecture (clojure.spec.alpha/and :portkey.aws.ec2/architecture-values))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/capacity-reservation-specification (clojure.spec.alpha/and :portkey.aws.ec2/capacity-reservation-specification-response))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/product-codes (clojure.spec.alpha/and :portkey.aws.ec2/product-code-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/state (clojure.spec.alpha/and :portkey.aws.ec2/instance-state))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/root-device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/ramdisk-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/launch-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/public-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/ami-launch-index (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/state-transition-reason (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/network-interfaces (clojure.spec.alpha/and :portkey.aws.ec2/instance-network-interface-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance/ena-support (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/instance (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance/public-dns-name :portkey.aws.ec2.instance/kernel-id :portkey.aws.ec2.instance/spot-instance-request-id :portkey.aws.ec2.instance/instance-id :portkey.aws.ec2.instance/instance-lifecycle :portkey.aws.ec2.instance/platform :portkey.aws.ec2.instance/capacity-reservation-id :portkey.aws.ec2.instance/image-id :portkey.aws.ec2/placement :portkey.aws.ec2.instance/subnet-id :portkey.aws.ec2.instance/root-device-type :portkey.aws.ec2.instance/security-groups :portkey.aws.ec2.instance/ebs-optimized :portkey.aws.ec2/instance-type :portkey.aws.ec2.instance/sriov-net-support :portkey.aws.ec2.instance/tags :portkey.aws.ec2.instance/elastic-inference-accelerator-associations :portkey.aws.ec2.instance/source-dest-check :portkey.aws.ec2.instance/key-name :portkey.aws.ec2.instance/elastic-gpu-associations :portkey.aws.ec2.instance/private-dns-name :portkey.aws.ec2/hibernation-options :portkey.aws.ec2.instance/vpc-id :portkey.aws.ec2/monitoring :portkey.aws.ec2.instance/licenses :portkey.aws.ec2.instance/block-device-mappings :portkey.aws.ec2.instance/hypervisor :portkey.aws.ec2.instance/architecture :portkey.aws.ec2/virtualization-type :portkey.aws.ec2.instance/capacity-reservation-specification :portkey.aws.ec2.instance/product-codes :portkey.aws.ec2.instance/state :portkey.aws.ec2/cpu-options :portkey.aws.ec2.instance/root-device-name :portkey.aws.ec2.instance/ramdisk-id :portkey.aws.ec2.instance/launch-time :portkey.aws.ec2.instance/public-ip-address :portkey.aws.ec2/state-reason :portkey.aws.ec2/iam-instance-profile :portkey.aws.ec2.instance/ami-launch-index :portkey.aws.ec2.instance/client-token :portkey.aws.ec2.instance/state-transition-reason :portkey.aws.ec2.instance/private-ip-address :portkey.aws.ec2.instance/network-interfaces :portkey.aws.ec2.instance/ena-support]))

(clojure.spec.alpha/def :portkey.aws.ec2.terminate-instances-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.terminate-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/terminate-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.terminate-instances-request/instance-ids] :opt-un [:portkey.aws.ec2.terminate-instances-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-reserved-instances-request/reserved-instances-ids (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-reserved-instances-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-reserved-instances-request/target-configurations (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-configuration-list))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-reserved-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-reserved-instances-request/reserved-instances-ids :portkey.aws.ec2.modify-reserved-instances-request/target-configurations] :opt-un [:portkey.aws.ec2.modify-reserved-instances-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-acl-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-network-acl-request/network-acl-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-network-acl-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-network-acl-request/network-acl-id] :opt-un [:portkey.aws.ec2.delete-network-acl-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-placement-groups-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-placement-groups-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-placement-groups-request/group-names (clojure.spec.alpha/and :portkey.aws.ec2/placement-group-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-placement-groups-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-placement-groups-request/filters :portkey.aws.ec2.describe-placement-groups-request/dry-run :portkey.aws.ec2.describe-placement-groups-request/group-names]))

(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-specification-request/launch-template-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.fleet-launch-template-specification-request/version (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/fleet-launch-template-specification-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.fleet-launch-template-specification-request/launch-template-id :portkey.aws.ec2/launch-template-name :portkey.aws.ec2.fleet-launch-template-specification-request/version]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-image-attribute-request/user-ids (clojure.spec.alpha/and :portkey.aws.ec2/user-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-image-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-image-attribute-request/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-image-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-image-attribute-request/value (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-image-attribute-request/description (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-image-attribute-request/product-codes (clojure.spec.alpha/and :portkey.aws.ec2/product-code-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-image-attribute-request/user-groups (clojure.spec.alpha/and :portkey.aws.ec2/user-group-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-image-attribute-request/launch-permission (clojure.spec.alpha/and :portkey.aws.ec2/launch-permission-modifications))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-image-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-image-attribute-request/image-id] :opt-un [:portkey.aws.ec2.modify-image-attribute-request/user-ids :portkey.aws.ec2.modify-image-attribute-request/dry-run :portkey.aws.ec2.modify-image-attribute-request/attribute :portkey.aws.ec2.modify-image-attribute-request/value :portkey.aws.ec2.modify-image-attribute-request/description :portkey.aws.ec2/operation-type :portkey.aws.ec2.modify-image-attribute-request/product-codes :portkey.aws.ec2.modify-image-attribute-request/user-groups :portkey.aws.ec2.modify-image-attribute-request/launch-permission]))

(clojure.spec.alpha/def :portkey.aws.ec2/nat-gateway-state #{:deleted "deleting" "failed" :pending :deleting "deleted" :available "pending" "available" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-result/reserved-instances (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-reserved-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-reserved-instances-result/reserved-instances]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-nat-gateways-result/nat-gateways (clojure.spec.alpha/and :portkey.aws.ec2/nat-gateway-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-nat-gateways-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-nat-gateways-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-nat-gateways-result/nat-gateways :portkey.aws.ec2.describe-nat-gateways-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.accept-reserved-instances-exchange-quote-result/exchange-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/accept-reserved-instances-exchange-quote-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.accept-reserved-instances-exchange-quote-result/exchange-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.export-client-vpn-client-configuration-result/client-configuration (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/export-client-vpn-client-configuration-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.export-client-vpn-client-configuration-result/client-configuration]))

(clojure.spec.alpha/def :portkey.aws.ec2/block-device-mapping-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/block-device-mapping))

(clojure.spec.alpha/def :portkey.aws.ec2/blob clojure.core/bytes?)

(clojure.spec.alpha/def :portkey.aws.ec2/describe-fleets-instances-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/describe-fleets-instances))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleet-error-item/error (clojure.spec.alpha/and :portkey.aws.ec2/delete-fleet-error))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleet-error-item/fleet-id (clojure.spec.alpha/and :portkey.aws.ec2/fleet-identifier))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-fleet-error-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-fleet-error-item/error :portkey.aws.ec2.delete-fleet-error-item/fleet-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-block-device-mapping-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-block-device-mapping))

(clojure.spec.alpha/def :portkey.aws.ec2.security-group-reference/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.security-group-reference/referencing-vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.security-group-reference/vpc-peering-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/security-group-reference (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.security-group-reference/group-id :portkey.aws.ec2.security-group-reference/referencing-vpc-id :portkey.aws.ec2.security-group-reference/vpc-peering-connection-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.enable-vpc-classic-link-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.enable-vpc-classic-link-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/enable-vpc-classic-link-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.enable-vpc-classic-link-request/vpc-id] :opt-un [:portkey.aws.ec2.enable-vpc-classic-link-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/classic-link-dns-support-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/classic-link-dns-support))

(clojure.spec.alpha/def :portkey.aws.ec2/gateway-type #{:ipsec-1 "ipsec.1"})

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-iam-instance-profile/arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instances-iam-instance-profile/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-iam-instance-profile (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instances-iam-instance-profile/arn :portkey.aws.ec2.scheduled-instances-iam-instance-profile/name]))

(clojure.spec.alpha/def :portkey.aws.ec2.image/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/platform (clojure.spec.alpha/and :portkey.aws.ec2/platform-values))
(clojure.spec.alpha/def :portkey.aws.ec2.image/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/root-device-type (clojure.spec.alpha/and :portkey.aws.ec2/device-type))
(clojure.spec.alpha/def :portkey.aws.ec2.image/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/sriov-net-support (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.image/public (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.image/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/block-device-mapping-list))
(clojure.spec.alpha/def :portkey.aws.ec2.image/hypervisor (clojure.spec.alpha/and :portkey.aws.ec2/hypervisor-type))
(clojure.spec.alpha/def :portkey.aws.ec2.image/architecture (clojure.spec.alpha/and :portkey.aws.ec2/architecture-values))
(clojure.spec.alpha/def :portkey.aws.ec2.image/image-owner-alias (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/creation-date (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/product-codes (clojure.spec.alpha/and :portkey.aws.ec2/product-code-list))
(clojure.spec.alpha/def :portkey.aws.ec2.image/image-location (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/state (clojure.spec.alpha/and :portkey.aws.ec2/image-state))
(clojure.spec.alpha/def :portkey.aws.ec2.image/image-type (clojure.spec.alpha/and :portkey.aws.ec2/image-type-values))
(clojure.spec.alpha/def :portkey.aws.ec2.image/root-device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/ramdisk-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image/ena-support (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/image (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.image/kernel-id :portkey.aws.ec2.image/platform :portkey.aws.ec2.image/image-id :portkey.aws.ec2.image/root-device-type :portkey.aws.ec2.image/owner-id :portkey.aws.ec2.image/sriov-net-support :portkey.aws.ec2.image/tags :portkey.aws.ec2.image/public :portkey.aws.ec2.image/description :portkey.aws.ec2.image/block-device-mappings :portkey.aws.ec2.image/hypervisor :portkey.aws.ec2.image/architecture :portkey.aws.ec2.image/image-owner-alias :portkey.aws.ec2.image/creation-date :portkey.aws.ec2/virtualization-type :portkey.aws.ec2.image/product-codes :portkey.aws.ec2.image/image-location :portkey.aws.ec2.image/state :portkey.aws.ec2.image/image-type :portkey.aws.ec2.image/root-device-name :portkey.aws.ec2.image/ramdisk-id :portkey.aws.ec2.image/name :portkey.aws.ec2/state-reason :portkey.aws.ec2.image/ena-support]))

(clojure.spec.alpha/def :portkey.aws.ec2/report-status-type #{"impaired" :ok :impaired "ok"})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservation-offerings-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-host-reservation-offerings-result/offering-set (clojure.spec.alpha/and :portkey.aws.ec2/host-offering-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-host-reservation-offerings-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-host-reservation-offerings-result/next-token :portkey.aws.ec2.describe-host-reservation-offerings-result/offering-set]))

(clojure.spec.alpha/def :portkey.aws.ec2/transport-protocol #{:tcp "udp" :udp "tcp"})

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-capacity-reservation-request/capacity-reservation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.cancel-capacity-reservation-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-capacity-reservation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.cancel-capacity-reservation-request/capacity-reservation-id] :opt-un [:portkey.aws.ec2.cancel-capacity-reservation-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/ip-range-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/ip-range))

(clojure.spec.alpha/def :portkey.aws.ec2.replace-route-table-association-result/new-association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/replace-route-table-association-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.replace-route-table-association-result/new-association-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/image-type-values #{"kernel" :ramdisk "machine" "ramdisk" :machine :kernel})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-groups-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-groups-request/group-ids (clojure.spec.alpha/and :portkey.aws.ec2/group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-groups-request/group-names (clojure.spec.alpha/and :portkey.aws.ec2/group-name-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-groups-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-groups-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-groups-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-security-groups-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-security-groups-request/filters :portkey.aws.ec2.describe-security-groups-request/group-ids :portkey.aws.ec2.describe-security-groups-request/group-names :portkey.aws.ec2.describe-security-groups-request/dry-run :portkey.aws.ec2.describe-security-groups-request/next-token :portkey.aws.ec2.describe-security-groups-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-launch-specification/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-launch-specification/group-ids (clojure.spec.alpha/and :portkey.aws.ec2/security-group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-launch-specification/additional-info (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-launch-specification/monitoring (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-launch-specification/architecture (clojure.spec.alpha/and :portkey.aws.ec2/architecture-values))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-launch-specification/instance-initiated-shutdown-behavior (clojure.spec.alpha/and :portkey.aws.ec2/shutdown-behavior))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-launch-specification/group-names (clojure.spec.alpha/and :portkey.aws.ec2/security-group-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-launch-specification/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/import-instance-launch-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/placement :portkey.aws.ec2.import-instance-launch-specification/subnet-id :portkey.aws.ec2/instance-type :portkey.aws.ec2.import-instance-launch-specification/group-ids :portkey.aws.ec2.import-instance-launch-specification/additional-info :portkey.aws.ec2.import-instance-launch-specification/monitoring :portkey.aws.ec2.import-instance-launch-specification/architecture :portkey.aws.ec2/user-data :portkey.aws.ec2.import-instance-launch-specification/instance-initiated-shutdown-behavior :portkey.aws.ec2.import-instance-launch-specification/group-names :portkey.aws.ec2.import-instance-launch-specification/private-ip-address]))

(clojure.spec.alpha/def :portkey.aws.ec2/modify-launch-template-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/launch-template]))

(clojure.spec.alpha/def :portkey.aws.ec2.classic-link-instance/groups (clojure.spec.alpha/and :portkey.aws.ec2/group-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ec2.classic-link-instance/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.classic-link-instance/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.classic-link-instance/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/classic-link-instance (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.classic-link-instance/groups :portkey.aws.ec2.classic-link-instance/instance-id :portkey.aws.ec2.classic-link-instance/tags :portkey.aws.ec2.classic-link-instance/vpc-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.cancel-spot-instance-requests-result/cancelled-spot-instance-requests (clojure.spec.alpha/and :portkey.aws.ec2/cancelled-spot-instance-request-list))
(clojure.spec.alpha/def :portkey.aws.ec2/cancel-spot-instance-requests-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.cancel-spot-instance-requests-result/cancelled-spot-instance-requests]))

(clojure.spec.alpha/def :portkey.aws.ec2.certificate-authentication/client-root-certificate-chain (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/certificate-authentication (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.certificate-authentication/client-root-certificate-chain]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-snapshot-tasks-result/import-snapshot-tasks (clojure.spec.alpha/and :portkey.aws.ec2/import-snapshot-task-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-import-snapshot-tasks-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-import-snapshot-tasks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-import-snapshot-tasks-result/import-snapshot-tasks :portkey.aws.ec2.describe-import-snapshot-tasks-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/classic-load-balancers (clojure.spec.alpha/coll-of :portkey.aws.ec2/classic-load-balancer :min-count 1 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-attachment/resource-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-attachment/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-route-attachment/resource-type (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-attachment-resource-type))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-attachment (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-route-attachment/resource-id :portkey.aws.ec2.transit-gateway-route-attachment/transit-gateway-attachment-id :portkey.aws.ec2.transit-gateway-route-attachment/resource-type]))

(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-request/disk-images (clojure.spec.alpha/and :portkey.aws.ec2/disk-image-list))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-request/launch-specification (clojure.spec.alpha/and :portkey.aws.ec2/import-instance-launch-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.import-instance-request/platform (clojure.spec.alpha/and :portkey.aws.ec2/platform-values))
(clojure.spec.alpha/def :portkey.aws.ec2/import-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.import-instance-request/platform] :opt-un [:portkey.aws.ec2.import-instance-request/description :portkey.aws.ec2.import-instance-request/disk-images :portkey.aws.ec2.import-instance-request/dry-run :portkey.aws.ec2.import-instance-request/launch-specification]))

(clojure.spec.alpha/def :portkey.aws.ec2.security-group-identifier/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.security-group-identifier/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/security-group-identifier (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.security-group-identifier/group-id :portkey.aws.ec2.security-group-identifier/group-name]))

(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment-propagation/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.transit-gateway-attachment-propagation/state (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-propagation-state))
(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-attachment-propagation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.transit-gateway-attachment-propagation/transit-gateway-route-table-id :portkey.aws.ec2.transit-gateway-attachment-propagation/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.spot-options-request/allocation-strategy (clojure.spec.alpha/and :portkey.aws.ec2/spot-allocation-strategy))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-options-request/instance-interruption-behavior (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-interruption-behavior))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-options-request/instance-pools-to-use-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-options-request/single-instance-type (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-options-request/single-availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.spot-options-request/min-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/spot-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.spot-options-request/allocation-strategy :portkey.aws.ec2.spot-options-request/instance-interruption-behavior :portkey.aws.ec2.spot-options-request/instance-pools-to-use-count :portkey.aws.ec2.spot-options-request/single-instance-type :portkey.aws.ec2.spot-options-request/single-availability-zone :portkey.aws.ec2.spot-options-request/min-target-capacity]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-classic-link-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-classic-link-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-classic-link-request/vpc-ids (clojure.spec.alpha/and :portkey.aws.ec2/vpc-classic-link-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-classic-link-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-classic-link-request/filters :portkey.aws.ec2.describe-vpc-classic-link-request/dry-run :portkey.aws.ec2.describe-vpc-classic-link-request/vpc-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-ingress-request/source-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-ingress-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-ingress-request/to-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-ingress-request/source-security-group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-ingress-request/ip-protocol (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-ingress-request/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-ingress-request/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-ingress-request/from-port (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-ingress-request/ip-permissions (clojure.spec.alpha/and :portkey.aws.ec2/ip-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.authorize-security-group-ingress-request/cidr-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/authorize-security-group-ingress-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.authorize-security-group-ingress-request/source-security-group-owner-id :portkey.aws.ec2.authorize-security-group-ingress-request/dry-run :portkey.aws.ec2.authorize-security-group-ingress-request/to-port :portkey.aws.ec2.authorize-security-group-ingress-request/source-security-group-name :portkey.aws.ec2.authorize-security-group-ingress-request/ip-protocol :portkey.aws.ec2.authorize-security-group-ingress-request/group-name :portkey.aws.ec2.authorize-security-group-ingress-request/group-id :portkey.aws.ec2.authorize-security-group-ingress-request/from-port :portkey.aws.ec2.authorize-security-group-ingress-request/ip-permissions :portkey.aws.ec2.authorize-security-group-ingress-request/cidr-ip]))

(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-block-device-mapping-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/scheduled-instances-block-device-mapping))

(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/type (clojure.spec.alpha/and :portkey.aws.ec2/fleet-type))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/valid-from (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/excess-capacity-termination-policy (clojure.spec.alpha/and :portkey.aws.ec2/fleet-excess-capacity-termination-policy))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/spot-options (clojure.spec.alpha/and :portkey.aws.ec2/spot-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/launch-template-configs (clojure.spec.alpha/and :portkey.aws.ec2/fleet-launch-template-config-list-request))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/on-demand-options (clojure.spec.alpha/and :portkey.aws.ec2/on-demand-options-request))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/terminate-instances-with-expiration (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/target-capacity-specification (clojure.spec.alpha/and :portkey.aws.ec2/target-capacity-specification-request))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/replace-unhealthy-instances (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-fleet-request/valid-until (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/create-fleet-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-fleet-request/launch-template-configs :portkey.aws.ec2.create-fleet-request/target-capacity-specification] :opt-un [:portkey.aws.ec2.create-fleet-request/dry-run :portkey.aws.ec2.create-fleet-request/tag-specifications :portkey.aws.ec2.create-fleet-request/type :portkey.aws.ec2.create-fleet-request/valid-from :portkey.aws.ec2.create-fleet-request/excess-capacity-termination-policy :portkey.aws.ec2.create-fleet-request/spot-options :portkey.aws.ec2.create-fleet-request/on-demand-options :portkey.aws.ec2.create-fleet-request/terminate-instances-with-expiration :portkey.aws.ec2.create-fleet-request/client-token :portkey.aws.ec2.create-fleet-request/replace-unhealthy-instances :portkey.aws.ec2.create-fleet-request/valid-until]))

(clojure.spec.alpha/def :portkey.aws.ec2/cancel-spot-fleet-requests-error-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/cancel-spot-fleet-requests-error-item))

(clojure.spec.alpha/def :portkey.aws.ec2.purchase-request/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-request/purchase-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/purchase-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.purchase-request/instance-count :portkey.aws.ec2.purchase-request/purchase-token] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-request/tag-specifications (clojure.spec.alpha/and :portkey.aws.ec2/tag-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-request/encrypted (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-request/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-request/kms-key-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-request/size (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-request/iops (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-request/snapshot-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-volume-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-volume-request/availability-zone] :opt-un [:portkey.aws.ec2.create-volume-request/dry-run :portkey.aws.ec2.create-volume-request/tag-specifications :portkey.aws.ec2.create-volume-request/encrypted :portkey.aws.ec2.create-volume-request/kms-key-id :portkey.aws.ec2.create-volume-request/size :portkey.aws.ec2.create-volume-request/iops :portkey.aws.ec2/volume-type :portkey.aws.ec2.create-volume-request/snapshot-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-modification-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-modification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/reserved-instances-modification))

(clojure.spec.alpha/def :portkey.aws.ec2/network-acl-entry-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/network-acl-entry))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-dhcp-options-result/dhcp-options (clojure.spec.alpha/and :portkey.aws.ec2/dhcp-options-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-dhcp-options-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-dhcp-options-result/dhcp-options]))

(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-associations-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-associations-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-associations-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-associations-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-transit-gateway-route-table-associations-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/get-transit-gateway-route-table-associations-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.get-transit-gateway-route-table-associations-request/transit-gateway-route-table-id] :opt-un [:portkey.aws.ec2.get-transit-gateway-route-table-associations-request/filters :portkey.aws.ec2.get-transit-gateway-route-table-associations-request/max-results :portkey.aws.ec2.get-transit-gateway-route-table-associations-request/next-token :portkey.aws.ec2.get-transit-gateway-route-table-associations-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/ramdisk (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/sriov-net-support (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/source-dest-check (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/attribute (clojure.spec.alpha/and :portkey.aws.ec2/instance-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/value (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/disable-api-termination (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/groups (clojure.spec.alpha/and :portkey.aws.ec2/group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/instance-block-device-mapping-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/kernel (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/user-data (clojure.spec.alpha/and :portkey.aws.ec2/blob-attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/instance-initiated-shutdown-behavior (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-attribute-request/ena-support (clojure.spec.alpha/and :portkey.aws.ec2/attribute-boolean-value))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-instance-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-instance-attribute-request/instance-id] :opt-un [:portkey.aws.ec2.modify-instance-attribute-request/dry-run :portkey.aws.ec2.modify-instance-attribute-request/ebs-optimized :portkey.aws.ec2.modify-instance-attribute-request/instance-type :portkey.aws.ec2.modify-instance-attribute-request/ramdisk :portkey.aws.ec2.modify-instance-attribute-request/sriov-net-support :portkey.aws.ec2.modify-instance-attribute-request/source-dest-check :portkey.aws.ec2.modify-instance-attribute-request/attribute :portkey.aws.ec2.modify-instance-attribute-request/value :portkey.aws.ec2.modify-instance-attribute-request/disable-api-termination :portkey.aws.ec2.modify-instance-attribute-request/groups :portkey.aws.ec2.modify-instance-attribute-request/block-device-mappings :portkey.aws.ec2.modify-instance-attribute-request/kernel :portkey.aws.ec2.modify-instance-attribute-request/user-data :portkey.aws.ec2.modify-instance-attribute-request/instance-initiated-shutdown-behavior :portkey.aws.ec2.modify-instance-attribute-request/ena-support]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-nat-gateway-result/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-nat-gateway-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-nat-gateway-result/client-token :portkey.aws.ec2/nat-gateway]))

(clojure.spec.alpha/def :portkey.aws.ec2.release-address-request/allocation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.release-address-request/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.release-address-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/release-address-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.release-address-request/allocation-id :portkey.aws.ec2.release-address-request/public-ip :portkey.aws.ec2.release-address-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-classic-link-dns-support-request/vpc-ids (clojure.spec.alpha/and :portkey.aws.ec2/vpc-classic-link-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-classic-link-dns-support-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/max-results :portkey.aws.ec2/next-token :portkey.aws.ec2.describe-vpc-classic-link-dns-support-request/vpc-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-private-ip-address-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/network-interface-private-ip-address))

(clojure.spec.alpha/def :portkey.aws.ec2.target-group/arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/target-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.target-group/arn]))

(clojure.spec.alpha/def :portkey.aws.ec2.image-attribute/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/block-device-mapping-list))
(clojure.spec.alpha/def :portkey.aws.ec2.image-attribute/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.image-attribute/launch-permissions (clojure.spec.alpha/and :portkey.aws.ec2/launch-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.image-attribute/product-codes (clojure.spec.alpha/and :portkey.aws.ec2/product-code-list))
(clojure.spec.alpha/def :portkey.aws.ec2.image-attribute/description (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.image-attribute/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.image-attribute/ramdisk-id (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2.image-attribute/sriov-net-support (clojure.spec.alpha/and :portkey.aws.ec2/attribute-value))
(clojure.spec.alpha/def :portkey.aws.ec2/image-attribute (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.image-attribute/block-device-mappings :portkey.aws.ec2.image-attribute/image-id :portkey.aws.ec2.image-attribute/launch-permissions :portkey.aws.ec2.image-attribute/product-codes :portkey.aws.ec2.image-attribute/description :portkey.aws.ec2.image-attribute/kernel-id :portkey.aws.ec2.image-attribute/ramdisk-id :portkey.aws.ec2.image-attribute/sriov-net-support]))

(clojure.spec.alpha/def :portkey.aws.ec2/resource-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.reject-vpc-peering-connection-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/reject-vpc-peering-connection-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reject-vpc-peering-connection-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2.assign-ipv-6-addresses-request/ipv-6-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.assign-ipv-6-addresses-request/ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/ipv-6-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.assign-ipv-6-addresses-request/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/assign-ipv-6-addresses-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.assign-ipv-6-addresses-request/network-interface-id] :opt-un [:portkey.aws.ec2.assign-ipv-6-addresses-request/ipv-6-address-count :portkey.aws.ec2.assign-ipv-6-addresses-request/ipv-6-addresses]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-modifications-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-modifications-request/reserved-instances-modification-ids (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-modification-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-reserved-instances-modifications-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-reserved-instances-modifications-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-reserved-instances-modifications-request/filters :portkey.aws.ec2.describe-reserved-instances-modifications-request/reserved-instances-modification-ids :portkey.aws.ec2.describe-reserved-instances-modifications-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.on-demand-options-request/allocation-strategy (clojure.spec.alpha/and :portkey.aws.ec2/fleet-on-demand-allocation-strategy))
(clojure.spec.alpha/def :portkey.aws.ec2.on-demand-options-request/single-instance-type (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.on-demand-options-request/single-availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.on-demand-options-request/min-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/on-demand-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.on-demand-options-request/allocation-strategy :portkey.aws.ec2.on-demand-options-request/single-instance-type :portkey.aws.ec2.on-demand-options-request/single-availability-zone :portkey.aws.ec2.on-demand-options-request/min-target-capacity]))

(clojure.spec.alpha/def :portkey.aws.ec2/ipv-6-address (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-event-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ec2/conversion-task-state #{:completed "completed" "cancelling" "cancelled" :cancelled :active "active" :cancelling})

(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-request/ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/instance-ipv-6-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-request/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-request/groups (clojure.spec.alpha/and :portkey.aws.ec2/security-group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-request/private-ip-addresses (clojure.spec.alpha/and :portkey.aws.ec2/private-ip-address-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-request/secondary-private-ip-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-request/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-request/ipv-6-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/create-network-interface-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-network-interface-request/subnet-id] :opt-un [:portkey.aws.ec2.create-network-interface-request/dry-run :portkey.aws.ec2.create-network-interface-request/ipv-6-addresses :portkey.aws.ec2.create-network-interface-request/description :portkey.aws.ec2.create-network-interface-request/groups :portkey.aws.ec2.create-network-interface-request/private-ip-addresses :portkey.aws.ec2.create-network-interface-request/secondary-private-ip-address-count :portkey.aws.ec2.create-network-interface-request/private-ip-address :portkey.aws.ec2.create-network-interface-request/ipv-6-address-count]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-table-association-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/transit-gateway-route-table-association))

(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-permission-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/offering-class-type #{"standard" "convertible" :standard :convertible})

(clojure.spec.alpha/def :portkey.aws.ec2/request-host-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-error-code #{"launchTemplateVersionDoesNotExist" "launchTemplateIdDoesNotExist" "launchTemplateNameMalformed" :launch-template-name-malformed "launchTemplateNameDoesNotExist" "unexpectedError" :launch-template-id-does-not-exist :launch-template-version-does-not-exist "launchTemplateIdMalformed" :launch-template-id-malformed :launch-template-name-does-not-exist :unexpected-error})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-stale-security-groups-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-stale-security-groups-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-stale-security-groups-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-stale-security-groups-request/vpc-id] :opt-un [:portkey.aws.ec2.describe-stale-security-groups-request/dry-run :portkey.aws.ec2/max-results :portkey.aws.ec2/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-endpoints-request/client-vpn-endpoint-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-endpoints-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-client-vpn-endpoints-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-client-vpn-endpoints-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-client-vpn-endpoints-request/client-vpn-endpoint-ids :portkey.aws.ec2/max-results :portkey.aws.ec2/next-token :portkey.aws.ec2.describe-client-vpn-endpoints-request/filters :portkey.aws.ec2.describe-client-vpn-endpoints-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/nat-gateway-address-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/nat-gateway-address))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-route-table-propagation-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/transit-gateway-route-table-propagation))

(clojure.spec.alpha/def :portkey.aws.ec2.create-network-interface-permission-result/interface-permission (clojure.spec.alpha/and :portkey.aws.ec2/network-interface-permission))
(clojure.spec.alpha/def :portkey.aws.ec2/create-network-interface-permission-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-network-interface-permission-result/interface-permission]))

(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification/status-message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification/create-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification/reserved-instances-modification-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification/status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification/modification-results (clojure.spec.alpha/and :portkey.aws.ec2/reserved-instances-modification-result-list))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification/reserved-instances-ids (clojure.spec.alpha/and :portkey.aws.ec2/reserved-intances-ids))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification/update-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification/effective-date (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instances-modification/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instances-modification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.reserved-instances-modification/status-message :portkey.aws.ec2.reserved-instances-modification/create-date :portkey.aws.ec2.reserved-instances-modification/reserved-instances-modification-id :portkey.aws.ec2.reserved-instances-modification/status :portkey.aws.ec2.reserved-instances-modification/modification-results :portkey.aws.ec2.reserved-instances-modification/reserved-instances-ids :portkey.aws.ec2.reserved-instances-modification/update-date :portkey.aws.ec2.reserved-instances-modification/effective-date :portkey.aws.ec2.reserved-instances-modification/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2/listing-status #{:closed :pending "closed" "cancelled" :cancelled :active "active" "pending"})

(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-event-start-time-result/event (clojure.spec.alpha/and :portkey.aws.ec2/instance-status-event))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-instance-event-start-time-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-instance-event-start-time-result/event]))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-capacity-reservation-attributes-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-instance-capacity-reservation-attributes-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.modify-instance-capacity-reservation-attributes-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-overrides-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-overrides))

(clojure.spec.alpha/def :portkey.aws.ec2/create-spot-datafeed-subscription-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/spot-datafeed-subscription]))

(clojure.spec.alpha/def :portkey.aws.ec2/image-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/bundle-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/bundle-task]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-iam-instance-profile-specification-request/arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-iam-instance-profile-specification-request/name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-iam-instance-profile-specification-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-iam-instance-profile-specification-request/arn :portkey.aws.ec2.launch-template-iam-instance-profile-specification-request/name]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-route-table-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-route-table-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/create-route-table-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-route-table-request/vpc-id] :opt-un [:portkey.aws.ec2.create-route-table-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/instance-attribute-name #{:instance-initiated-shutdown-behavior "kernel" "groupSet" "productCodes" :group-set :ena-support "blockDeviceMapping" :source-dest-check :disable-api-termination :ramdisk :root-device-name :product-codes "disableApiTermination" :instance-type :ebs-optimized "sourceDestCheck" :user-data "userData" "ebsOptimized" :block-device-mapping "ramdisk" :sriov-net-support "instanceType" :kernel "enaSupport" "rootDeviceName" "instanceInitiatedShutdownBehavior" "sriovNetSupport"})

(clojure.spec.alpha/def :portkey.aws.ec2/classic-link-instance-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/classic-link-instance))

(clojure.spec.alpha/def :portkey.aws.ec2/import-image-task-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/import-image-task))

(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation-preference #{:open "none" "open" :none})

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-block-device-mapping-request-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/launch-template-block-device-mapping-request))

(clojure.spec.alpha/def :portkey.aws.ec2/route-table-association-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/route-table-association))

(clojure.spec.alpha/def :portkey.aws.ec2.start-instances-result/starting-instances (clojure.spec.alpha/and :portkey.aws.ec2/instance-state-change-list))
(clojure.spec.alpha/def :portkey.aws.ec2/start-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.start-instances-result/starting-instances]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-fpga-images-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fpga-images-request/fpga-image-ids (clojure.spec.alpha/and :portkey.aws.ec2/fpga-image-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fpga-images-request/owners (clojure.spec.alpha/and :portkey.aws.ec2/owner-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-fpga-images-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-fpga-images-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-fpga-images-request/dry-run :portkey.aws.ec2.describe-fpga-images-request/fpga-image-ids :portkey.aws.ec2.describe-fpga-images-request/owners :portkey.aws.ec2.describe-fpga-images-request/filters :portkey.aws.ec2/next-token :portkey.aws.ec2/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2/iam-instance-profile-association-state #{:associating "associating" :associated "disassociated" :disassociated "associated" :disassociating "disassociating"})

(clojure.spec.alpha/def :portkey.aws.ec2.disk-image-detail/bytes (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.disk-image-detail/format (clojure.spec.alpha/and :portkey.aws.ec2/disk-image-format))
(clojure.spec.alpha/def :portkey.aws.ec2.disk-image-detail/import-manifest-url (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/disk-image-detail (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.disk-image-detail/bytes :portkey.aws.ec2.disk-image-detail/format :portkey.aws.ec2.disk-image-detail/import-manifest-url] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.user-data/data (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/user-data (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.user-data/data]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-transit-gateway-route-result/route (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-transit-gateway-route-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-transit-gateway-route-result/route]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-principal-id-format-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-principal-id-format-request/resources (clojure.spec.alpha/and :portkey.aws.ec2/resource-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-principal-id-format-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-principal-id-format-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-principal-id-format-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-principal-id-format-request/dry-run :portkey.aws.ec2.describe-principal-id-format-request/resources :portkey.aws.ec2.describe-principal-id-format-request/max-results :portkey.aws.ec2.describe-principal-id-format-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connections-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connections-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connections-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpc-endpoint-connections-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpc-endpoint-connections-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpc-endpoint-connections-request/dry-run :portkey.aws.ec2.describe-vpc-endpoint-connections-request/filters :portkey.aws.ec2.describe-vpc-endpoint-connections-request/max-results :portkey.aws.ec2.describe-vpc-endpoint-connections-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.service-configuration/acceptance-required (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.service-configuration/service-type (clojure.spec.alpha/and :portkey.aws.ec2/service-type-detail-set))
(clojure.spec.alpha/def :portkey.aws.ec2.service-configuration/private-dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.service-configuration/service-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.service-configuration/base-endpoint-dns-names (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.service-configuration/network-load-balancer-arns (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.service-configuration/service-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.service-configuration/availability-zones (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/service-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.service-configuration/acceptance-required :portkey.aws.ec2.service-configuration/service-type :portkey.aws.ec2/service-state :portkey.aws.ec2.service-configuration/private-dns-name :portkey.aws.ec2.service-configuration/service-id :portkey.aws.ec2.service-configuration/base-endpoint-dns-names :portkey.aws.ec2.service-configuration/network-load-balancer-arns :portkey.aws.ec2.service-configuration/service-name :portkey.aws.ec2.service-configuration/availability-zones]))

(clojure.spec.alpha/def :portkey.aws.ec2/offering-type-values #{"All Upfront" :heavy-utilization :no-upfront :medium-utilization :all-upfront :light-utilization :partial-upfront "No Upfront" "Heavy Utilization" "Light Utilization" "Partial Upfront" "Medium Utilization"})

(clojure.spec.alpha/def :portkey.aws.ec2/float clojure.core/float?)

(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-route-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-route-request/destination-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-route-request/target-vpc-subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-route-request/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-client-vpn-route-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/create-client-vpn-route-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.create-client-vpn-route-request/client-vpn-endpoint-id :portkey.aws.ec2.create-client-vpn-route-request/destination-cidr-block :portkey.aws.ec2.create-client-vpn-route-request/target-vpc-subnet-id] :opt-un [:portkey.aws.ec2.create-client-vpn-route-request/description :portkey.aws.ec2.create-client-vpn-route-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-elastic-gpus-result/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-elastic-gpus-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-elastic-gpus-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/elastic-gpu-set :portkey.aws.ec2.describe-elastic-gpus-result/max-results :portkey.aws.ec2.describe-elastic-gpus-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-tag-specification-request/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-tag-specification-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/resource-type :portkey.aws.ec2.launch-template-tag-specification-request/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-vpn-gateways-result/vpn-gateways (clojure.spec.alpha/and :portkey.aws.ec2/vpn-gateway-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpn-gateways-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-vpn-gateways-result/vpn-gateways]))

(clojure.spec.alpha/def :portkey.aws.ec2.network-acl/associations (clojure.spec.alpha/and :portkey.aws.ec2/network-acl-association-list))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl/entries (clojure.spec.alpha/and :portkey.aws.ec2/network-acl-entry-list))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl/is-default (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl/network-acl-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-acl/owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/network-acl (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-acl/associations :portkey.aws.ec2.network-acl/entries :portkey.aws.ec2.network-acl/is-default :portkey.aws.ec2.network-acl/network-acl-id :portkey.aws.ec2.network-acl/tags :portkey.aws.ec2.network-acl/vpc-id :portkey.aws.ec2.network-acl/owner-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.target-capacity-specification/total-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.target-capacity-specification/on-demand-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.target-capacity-specification/spot-target-capacity (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/target-capacity-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.target-capacity-specification/total-target-capacity :portkey.aws.ec2.target-capacity-specification/on-demand-target-capacity :portkey.aws.ec2.target-capacity-specification/spot-target-capacity :portkey.aws.ec2/default-target-capacity-type]))

(clojure.spec.alpha/def :portkey.aws.ec2/delete-launch-template-versions-response-error-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/delete-launch-template-versions-response-error-item))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-block-device-mapping-request/device-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-block-device-mapping-request/virtual-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-block-device-mapping-request/ebs (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-ebs-block-device-request))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-block-device-mapping-request/no-device (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-block-device-mapping-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-block-device-mapping-request/device-name :portkey.aws.ec2.launch-template-block-device-mapping-request/virtual-name :portkey.aws.ec2.launch-template-block-device-mapping-request/ebs :portkey.aws.ec2.launch-template-block-device-mapping-request/no-device]))

(clojure.spec.alpha/def :portkey.aws.ec2.unsuccessful-instance-credit-specification-item-error/code (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-instance-credit-specification-error-code))
(clojure.spec.alpha/def :portkey.aws.ec2.unsuccessful-instance-credit-specification-item-error/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/unsuccessful-instance-credit-specification-item-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.unsuccessful-instance-credit-specification-item-error/code :portkey.aws.ec2.unsuccessful-instance-credit-specification-item-error/message]))

(clojure.spec.alpha/def :portkey.aws.ec2.apply-security-groups-to-client-vpn-target-network-request/client-vpn-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.apply-security-groups-to-client-vpn-target-network-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.apply-security-groups-to-client-vpn-target-network-request/security-group-ids (clojure.spec.alpha/and :portkey.aws.ec2/client-vpn-security-group-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.apply-security-groups-to-client-vpn-target-network-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/apply-security-groups-to-client-vpn-target-network-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.apply-security-groups-to-client-vpn-target-network-request/client-vpn-endpoint-id :portkey.aws.ec2.apply-security-groups-to-client-vpn-target-network-request/vpc-id :portkey.aws.ec2.apply-security-groups-to-client-vpn-target-network-request/security-group-ids] :opt-un [:portkey.aws.ec2.apply-security-groups-to-client-vpn-target-network-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.volume-attachment/attach-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-attachment/device (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-attachment/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-attachment/state (clojure.spec.alpha/and :portkey.aws.ec2/volume-attachment-state))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-attachment/volume-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.volume-attachment/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/volume-attachment (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.volume-attachment/attach-time :portkey.aws.ec2.volume-attachment/device :portkey.aws.ec2.volume-attachment/instance-id :portkey.aws.ec2.volume-attachment/state :portkey.aws.ec2.volume-attachment/volume-id :portkey.aws.ec2.volume-attachment/delete-on-termination]))

(clojure.spec.alpha/def :portkey.aws.ec2.associate-dhcp-options-request/dhcp-options-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-dhcp-options-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.associate-dhcp-options-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/associate-dhcp-options-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.associate-dhcp-options-request/dhcp-options-id :portkey.aws.ec2.associate-dhcp-options-request/vpc-id] :opt-un [:portkey.aws.ec2.associate-dhcp-options-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-attachment-changes/attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-attachment-changes/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-attachment-changes (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-interface-attachment-changes/attachment-id :portkey.aws.ec2.network-interface-attachment-changes/delete-on-termination]))

(clojure.spec.alpha/def :portkey.aws.ec2.route-table-association/main (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.route-table-association/route-table-association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route-table-association/route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.route-table-association/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/route-table-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.route-table-association/main :portkey.aws.ec2.route-table-association/route-table-association-id :portkey.aws.ec2.route-table-association/route-table-id :portkey.aws.ec2.route-table-association/subnet-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.reject-vpc-peering-connection-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.reject-vpc-peering-connection-request/vpc-peering-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/reject-vpc-peering-connection-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.reject-vpc-peering-connection-request/vpc-peering-connection-id] :opt-un [:portkey.aws.ec2.reject-vpc-peering-connection-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/private-ip-address-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.credit-specification-request/cpu-credits (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/credit-specification-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.credit-specification-request/cpu-credits] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.subnet-ipv-6-cidr-block-association/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet-ipv-6-cidr-block-association/ipv-6-cidr-block (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.subnet-ipv-6-cidr-block-association/ipv-6-cidr-block-state (clojure.spec.alpha/and :portkey.aws.ec2/subnet-cidr-block-state))
(clojure.spec.alpha/def :portkey.aws.ec2/subnet-ipv-6-cidr-block-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.subnet-ipv-6-cidr-block-association/association-id :portkey.aws.ec2.subnet-ipv-6-cidr-block-association/ipv-6-cidr-block :portkey.aws.ec2.subnet-ipv-6-cidr-block-association/ipv-6-cidr-block-state]))

(clojure.spec.alpha/def :portkey.aws.ec2.public-ipv-4-pool-range/first-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.public-ipv-4-pool-range/last-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.public-ipv-4-pool-range/address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.public-ipv-4-pool-range/available-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/public-ipv-4-pool-range (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.public-ipv-4-pool-range/first-address :portkey.aws.ec2.public-ipv-4-pool-range/last-address :portkey.aws.ec2.public-ipv-4-pool-range/address-count :portkey.aws.ec2.public-ipv-4-pool-range/available-address-count]))

(clojure.spec.alpha/def :portkey.aws.ec2.principal-id-format/arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.principal-id-format/statuses (clojure.spec.alpha/and :portkey.aws.ec2/id-format-list))
(clojure.spec.alpha/def :portkey.aws.ec2/principal-id-format (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.principal-id-format/arn :portkey.aws.ec2.principal-id-format/statuses]))

(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/transit-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/type (clojure.spec.alpha/and :portkey.aws.ec2/gateway-type))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/category (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/routes (clojure.spec.alpha/and :portkey.aws.ec2/vpn-static-route-list))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/customer-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/vpn-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/vgw-telemetry (clojure.spec.alpha/and :portkey.aws.ec2/vgw-telemetry-list))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/vpn-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/state (clojure.spec.alpha/and :portkey.aws.ec2/vpn-state))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/options (clojure.spec.alpha/and :portkey.aws.ec2/vpn-connection-options))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-connection/customer-gateway-configuration (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/vpn-connection (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpn-connection/transit-gateway-id :portkey.aws.ec2.vpn-connection/type :portkey.aws.ec2.vpn-connection/category :portkey.aws.ec2.vpn-connection/tags :portkey.aws.ec2.vpn-connection/routes :portkey.aws.ec2.vpn-connection/customer-gateway-id :portkey.aws.ec2.vpn-connection/vpn-gateway-id :portkey.aws.ec2.vpn-connection/vgw-telemetry :portkey.aws.ec2.vpn-connection/vpn-connection-id :portkey.aws.ec2.vpn-connection/state :portkey.aws.ec2.vpn-connection/options :portkey.aws.ec2.vpn-connection/customer-gateway-configuration]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-route-tables-request/transit-gateway-route-table-ids (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-route-table-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-route-tables-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-route-tables-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/transit-gateway-max-results))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-route-tables-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-transit-gateway-route-tables-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-transit-gateway-route-tables-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-transit-gateway-route-tables-request/transit-gateway-route-table-ids :portkey.aws.ec2.describe-transit-gateway-route-tables-request/filters :portkey.aws.ec2.describe-transit-gateway-route-tables-request/max-results :portkey.aws.ec2.describe-transit-gateway-route-tables-request/next-token :portkey.aws.ec2.describe-transit-gateway-route-tables-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.region/endpoint (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.region/region-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/region (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.region/endpoint :portkey.aws.ec2.region/region-name]))

(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-capacity-reservation-specification-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/capacity-reservation-preference :portkey.aws.ec2/capacity-reservation-target]))

(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image-state/code (clojure.spec.alpha/and :portkey.aws.ec2/fpga-image-state-code))
(clojure.spec.alpha/def :portkey.aws.ec2.fpga-image-state/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/fpga-image-state (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.fpga-image-state/code :portkey.aws.ec2.fpga-image-state/message]))

(clojure.spec.alpha/def :portkey.aws.ec2.export-transit-gateway-routes-request/transit-gateway-route-table-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.export-transit-gateway-routes-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.export-transit-gateway-routes-request/s-3-bucket (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.export-transit-gateway-routes-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/export-transit-gateway-routes-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.export-transit-gateway-routes-request/transit-gateway-route-table-id :portkey.aws.ec2.export-transit-gateway-routes-request/s-3-bucket] :opt-un [:portkey.aws.ec2.export-transit-gateway-routes-request/filters :portkey.aws.ec2.export-transit-gateway-routes-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.state-reason/code (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.state-reason/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/state-reason (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.state-reason/code :portkey.aws.ec2.state-reason/message]))

(clojure.spec.alpha/def :portkey.aws.ec2/associate-iam-instance-profile-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/iam-instance-profile-association]))

(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instances-ipv-6-address-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/scheduled-instances-ipv-6-address))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-capacity-reservations-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-capacity-reservations-result/capacity-reservations (clojure.spec.alpha/and :portkey.aws.ec2/capacity-reservation-set))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-capacity-reservations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-capacity-reservations-result/next-token :portkey.aws.ec2.describe-capacity-reservations-result/capacity-reservations]))

(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-state #{"ATTACHED" :attached})

(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-association-request/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-association-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.replace-network-acl-association-request/network-acl-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/replace-network-acl-association-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.replace-network-acl-association-request/association-id :portkey.aws.ec2.replace-network-acl-association-request/network-acl-id] :opt-un [:portkey.aws.ec2.replace-network-acl-association-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.iam-instance-profile/arn (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.iam-instance-profile/id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/iam-instance-profile (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.iam-instance-profile/arn :portkey.aws.ec2.iam-instance-profile/id]))

(clojure.spec.alpha/def :portkey.aws.ec2.enable-vpc-classic-link-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/enable-vpc-classic-link-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.enable-vpc-classic-link-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2/owner-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/delete-launch-template-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/launch-template]))

(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/max-term-duration-in-days (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/platform (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/network-platform (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/recurrence (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instance-recurrence))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/total-scheduled-instance-hours (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/hourly-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/purchase-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/slot-duration-in-hours (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/first-slot-start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/available-instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.scheduled-instance-availability/min-term-duration-in-days (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/scheduled-instance-availability (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.scheduled-instance-availability/max-term-duration-in-days :portkey.aws.ec2.scheduled-instance-availability/platform :portkey.aws.ec2.scheduled-instance-availability/network-platform :portkey.aws.ec2.scheduled-instance-availability/recurrence :portkey.aws.ec2.scheduled-instance-availability/instance-type :portkey.aws.ec2.scheduled-instance-availability/total-scheduled-instance-hours :portkey.aws.ec2.scheduled-instance-availability/availability-zone :portkey.aws.ec2.scheduled-instance-availability/hourly-price :portkey.aws.ec2.scheduled-instance-availability/purchase-token :portkey.aws.ec2.scheduled-instance-availability/slot-duration-in-hours :portkey.aws.ec2.scheduled-instance-availability/first-slot-start-time :portkey.aws.ec2.scheduled-instance-availability/available-instance-count :portkey.aws.ec2.scheduled-instance-availability/min-term-duration-in-days]))

(clojure.spec.alpha/def :portkey.aws.ec2.run-scheduled-instances-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.run-scheduled-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.run-scheduled-instances-request/instance-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.run-scheduled-instances-request/launch-specification (clojure.spec.alpha/and :portkey.aws.ec2/scheduled-instances-launch-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.run-scheduled-instances-request/scheduled-instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/run-scheduled-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.run-scheduled-instances-request/launch-specification :portkey.aws.ec2.run-scheduled-instances-request/scheduled-instance-id] :opt-un [:portkey.aws.ec2.run-scheduled-instances-request/client-token :portkey.aws.ec2.run-scheduled-instances-request/dry-run :portkey.aws.ec2.run-scheduled-instances-request/instance-count]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-instance-requests-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-instance-requests-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-instance-requests-request/spot-instance-request-ids (clojure.spec.alpha/and :portkey.aws.ec2/spot-instance-request-id-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-instance-requests-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-instance-requests-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-instance-requests-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-spot-instance-requests-request/filters :portkey.aws.ec2.describe-spot-instance-requests-request/dry-run :portkey.aws.ec2.describe-spot-instance-requests-request/spot-instance-request-ids :portkey.aws.ec2.describe-spot-instance-requests-request/next-token :portkey.aws.ec2.describe-spot-instance-requests-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-permission-modifications/add (clojure.spec.alpha/and :portkey.aws.ec2/create-volume-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2.create-volume-permission-modifications/remove (clojure.spec.alpha/and :portkey.aws.ec2/create-volume-permission-list))
(clojure.spec.alpha/def :portkey.aws.ec2/create-volume-permission-modifications (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-volume-permission-modifications/add :portkey.aws.ec2.create-volume-permission-modifications/remove]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-aggregate-id-format-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-aggregate-id-format-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-aggregate-id-format-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.active-instance/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.active-instance/instance-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.active-instance/spot-instance-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.active-instance/instance-health (clojure.spec.alpha/and :portkey.aws.ec2/instance-health-status))
(clojure.spec.alpha/def :portkey.aws.ec2/active-instance (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.active-instance/instance-id :portkey.aws.ec2.active-instance/instance-type :portkey.aws.ec2.active-instance/spot-instance-request-id :portkey.aws.ec2.active-instance/instance-health]))

(clojure.spec.alpha/def :portkey.aws.ec2.attach-internet-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-internet-gateway-request/internet-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.attach-internet-gateway-request/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/attach-internet-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.attach-internet-gateway-request/internet-gateway-id :portkey.aws.ec2.attach-internet-gateway-request/vpc-id] :opt-un [:portkey.aws.ec2.attach-internet-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/fleet-excess-capacity-termination-policy #{"no-termination" :termination "termination" :notermination})

(clojure.spec.alpha/def :portkey.aws.ec2.stop-instances-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ec2/instance-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.stop-instances-request/hibernate (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.stop-instances-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.stop-instances-request/force (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/stop-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.stop-instances-request/instance-ids] :opt-un [:portkey.aws.ec2.stop-instances-request/hibernate :portkey.aws.ec2.stop-instances-request/dry-run :portkey.aws.ec2.stop-instances-request/force]))

(clojure.spec.alpha/def :portkey.aws.ec2/reason-codes-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/report-instance-reason-codes))

(clojure.spec.alpha/def :portkey.aws.ec2/subnet-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/subnet))

(clojure.spec.alpha/def :portkey.aws.ec2/filter-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/filter))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-groups-result/security-groups (clojure.spec.alpha/and :portkey.aws.ec2/security-group-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-groups-result/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-security-groups-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-security-groups-result/security-groups :portkey.aws.ec2.describe-security-groups-result/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.account-attribute-value/attribute-value (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/account-attribute-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.account-attribute-value/attribute-value]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-peering-connection-state-reason-code #{:deleted :pendingacceptance "expired" "deleting" :rejected "failed" :deleting "initiating-request" "provisioning" :initiatingrequest :active "deleted" :expired :provisioning "pending-acceptance" "active" "rejected" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2/reject-transit-gateway-vpc-attachment-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/transit-gateway-vpc-attachment]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-permission/group (clojure.spec.alpha/and :portkey.aws.ec2/permission-group))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-permission/user-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-permission (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-permission/group :portkey.aws.ec2.launch-permission/user-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/elastic-gpus))

(clojure.spec.alpha/def :portkey.aws.ec2/internet-gateway-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/internet-gateway))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleet-error/code (clojure.spec.alpha/and :portkey.aws.ec2/delete-fleet-error-code))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleet-error/message (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-fleet-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-fleet-error/code :portkey.aws.ec2.delete-fleet-error/message]))

(clojure.spec.alpha/def :portkey.aws.ec2.account-attribute/attribute-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.account-attribute/attribute-values (clojure.spec.alpha/and :portkey.aws.ec2/account-attribute-value-list))
(clojure.spec.alpha/def :portkey.aws.ec2/account-attribute (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.account-attribute/attribute-name :portkey.aws.ec2.account-attribute/attribute-values]))

(clojure.spec.alpha/def :portkey.aws.ec2/history-record-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/history-record-entry))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-instance-market-options/spot-options (clojure.spec.alpha/and :portkey.aws.ec2/launch-template-spot-market-options))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-instance-market-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/market-type :portkey.aws.ec2.launch-template-instance-market-options/spot-options]))

(clojure.spec.alpha/def :portkey.aws.ec2.ipv-6-range/cidr-ipv-6 (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.ipv-6-range/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/ipv-6-range (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.ipv-6-range/cidr-ipv-6 :portkey.aws.ec2.ipv-6-range/description]))

(clojure.spec.alpha/def :portkey.aws.ec2.host/release-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.host/host-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2.host/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host/host-reservation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host/state (clojure.spec.alpha/and :portkey.aws.ec2/allocation-state))
(clojure.spec.alpha/def :portkey.aws.ec2.host/allocation-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.host/instances (clojure.spec.alpha/and :portkey.aws.ec2/host-instance-list))
(clojure.spec.alpha/def :portkey.aws.ec2.host/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/host (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.host/release-time :portkey.aws.ec2/host-properties :portkey.aws.ec2.host/host-id :portkey.aws.ec2/available-capacity :portkey.aws.ec2.host/tags :portkey.aws.ec2.host/availability-zone :portkey.aws.ec2/auto-placement :portkey.aws.ec2.host/host-reservation-id :portkey.aws.ec2.host/state :portkey.aws.ec2.host/allocation-time :portkey.aws.ec2.host/instances :portkey.aws.ec2.host/client-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-security-group-references-result/security-group-reference-set (clojure.spec.alpha/and :portkey.aws.ec2/security-group-references))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-security-group-references-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-security-group-references-result/security-group-reference-set]))

(clojure.spec.alpha/def :portkey.aws.ec2/egress-only-internet-gateway-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-capacity-reservation-attributes-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-instance-capacity-reservation-attributes-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-instance-capacity-reservation-attributes-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-instance-capacity-reservation-attributes-request/instance-id :portkey.aws.ec2/capacity-reservation-specification] :opt-un [:portkey.aws.ec2.modify-instance-capacity-reservation-attributes-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/transit-gateway-propagation-state #{:disabled "enabled" :disabling :enabling "disabling" "enabling" "disabled" :enabled})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-regions-result/regions (clojure.spec.alpha/and :portkey.aws.ec2/region-list))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-regions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-regions-result/regions]))

(clojure.spec.alpha/def :portkey.aws.ec2/provision-byoip-cidr-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/byoip-cidr]))

(clojure.spec.alpha/def :portkey.aws.ec2.detach-classic-link-vpc-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/detach-classic-link-vpc-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.detach-classic-link-vpc-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2/activity-status #{"error" "pending_termination" :pending-fulfillment :fulfilled :error "fulfilled" "pending_fulfillment" :pending-termination})

(clojure.spec.alpha/def :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request/transit-gateway-attachment-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request/add-subnet-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request/remove-subnet-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request/options (clojure.spec.alpha/and :portkey.aws.ec2/modify-transit-gateway-vpc-attachment-request-options))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-transit-gateway-vpc-attachment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request/transit-gateway-attachment-id] :opt-un [:portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request/add-subnet-ids :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request/remove-subnet-ids :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request/options :portkey.aws.ec2.modify-transit-gateway-vpc-attachment-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.placement-group/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.placement-group/state (clojure.spec.alpha/and :portkey.aws.ec2/placement-group-state))
(clojure.spec.alpha/def :portkey.aws.ec2.placement-group/strategy (clojure.spec.alpha/and :portkey.aws.ec2/placement-strategy))
(clojure.spec.alpha/def :portkey.aws.ec2.placement-group/partition-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/placement-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.placement-group/group-name :portkey.aws.ec2.placement-group/state :portkey.aws.ec2.placement-group/strategy :portkey.aws.ec2.placement-group/partition-count]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-egress-only-internet-gateway-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-egress-only-internet-gateway-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2/egress-only-internet-gateway-id] :opt-un [:portkey.aws.ec2.delete-egress-only-internet-gateway-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/vpn-gateway-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.reserved-instance-reservation-value/reserved-instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/reserved-instance-reservation-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/reservation-value :portkey.aws.ec2.reserved-instance-reservation-value/reserved-instance-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request-options/dns-support (clojure.spec.alpha/and :portkey.aws.ec2/dns-support-value))
(clojure.spec.alpha/def :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request-options/ipv-6-support (clojure.spec.alpha/and :portkey.aws.ec2/ipv-6-support-value))
(clojure.spec.alpha/def :portkey.aws.ec2/create-transit-gateway-vpc-attachment-request-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-transit-gateway-vpc-attachment-request-options/dns-support :portkey.aws.ec2.create-transit-gateway-vpc-attachment-request-options/ipv-6-support]))

(clojure.spec.alpha/def :portkey.aws.ec2.private-ip-address-specification/primary (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.private-ip-address-specification/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/private-ip-address-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.private-ip-address-specification/primary :portkey.aws.ec2.private-ip-address-specification/private-ip-address]))

(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/kernel-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/security-group-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/image-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/placement (clojure.spec.alpha/and :portkey.aws.ec2/spot-placement))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/addressing-type (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/security-groups (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/ebs-optimized (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/key-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/monitoring (clojure.spec.alpha/and :portkey.aws.ec2/run-instances-monitoring-enabled))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/block-device-mappings (clojure.spec.alpha/and :portkey.aws.ec2/block-device-mapping-list))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/ramdisk-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/user-data (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/iam-instance-profile (clojure.spec.alpha/and :portkey.aws.ec2/iam-instance-profile-specification))
(clojure.spec.alpha/def :portkey.aws.ec2.request-spot-launch-specification/network-interfaces (clojure.spec.alpha/and :portkey.aws.ec2/instance-network-interface-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2/request-spot-launch-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.request-spot-launch-specification/kernel-id :portkey.aws.ec2.request-spot-launch-specification/security-group-ids :portkey.aws.ec2.request-spot-launch-specification/image-id :portkey.aws.ec2.request-spot-launch-specification/placement :portkey.aws.ec2.request-spot-launch-specification/addressing-type :portkey.aws.ec2.request-spot-launch-specification/subnet-id :portkey.aws.ec2.request-spot-launch-specification/security-groups :portkey.aws.ec2.request-spot-launch-specification/ebs-optimized :portkey.aws.ec2/instance-type :portkey.aws.ec2.request-spot-launch-specification/key-name :portkey.aws.ec2.request-spot-launch-specification/monitoring :portkey.aws.ec2.request-spot-launch-specification/block-device-mappings :portkey.aws.ec2.request-spot-launch-specification/ramdisk-id :portkey.aws.ec2.request-spot-launch-specification/user-data :portkey.aws.ec2.request-spot-launch-specification/iam-instance-profile :portkey.aws.ec2.request-spot-launch-specification/network-interfaces]))

(clojure.spec.alpha/def :portkey.aws.ec2/reservation-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/reservation))

(clojure.spec.alpha/def :portkey.aws.ec2/delete-fleet-error-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/delete-fleet-error-item))

(clojure.spec.alpha/def :portkey.aws.ec2/vpc-ipv-6-cidr-block-association-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpc-ipv-6-cidr-block-association))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-peering-connection-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpc-peering-connection-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-vpc-peering-connection-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2/volume-modification-state #{:modifying "failed" :completed "completed" "optimizing" :optimizing "modifying" :failed})

(clojure.spec.alpha/def :portkey.aws.ec2.purchase-host-reservation-request/client-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-host-reservation-request/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-host-reservation-request/host-id-set (clojure.spec.alpha/and :portkey.aws.ec2/request-host-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-host-reservation-request/limit-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.purchase-host-reservation-request/offering-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/purchase-host-reservation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.purchase-host-reservation-request/host-id-set :portkey.aws.ec2.purchase-host-reservation-request/offering-id] :opt-un [:portkey.aws.ec2.purchase-host-reservation-request/client-token :portkey.aws.ec2.purchase-host-reservation-request/currency-code :portkey.aws.ec2.purchase-host-reservation-request/limit-price]))

(clojure.spec.alpha/def :portkey.aws.ec2.directory-service-authentication/directory-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/directory-service-authentication (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.directory-service-authentication/directory-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.get-host-reservation-purchase-preview-request/host-id-set (clojure.spec.alpha/and :portkey.aws.ec2/request-host-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.get-host-reservation-purchase-preview-request/offering-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/get-host-reservation-purchase-preview-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.get-host-reservation-purchase-preview-request/host-id-set :portkey.aws.ec2.get-host-reservation-purchase-preview-request/offering-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/remove-subnet-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/vpc-endpoint-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/private-dns-enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/add-security-group-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/policy-document (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/remove-security-group-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/add-subnet-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/remove-route-table-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/reset-policy (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.modify-vpc-endpoint-request/add-route-table-ids (clojure.spec.alpha/and :portkey.aws.ec2/value-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2/modify-vpc-endpoint-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.modify-vpc-endpoint-request/vpc-endpoint-id] :opt-un [:portkey.aws.ec2.modify-vpc-endpoint-request/dry-run :portkey.aws.ec2.modify-vpc-endpoint-request/remove-subnet-ids :portkey.aws.ec2.modify-vpc-endpoint-request/private-dns-enabled :portkey.aws.ec2.modify-vpc-endpoint-request/add-security-group-ids :portkey.aws.ec2.modify-vpc-endpoint-request/policy-document :portkey.aws.ec2.modify-vpc-endpoint-request/remove-security-group-ids :portkey.aws.ec2.modify-vpc-endpoint-request/add-subnet-ids :portkey.aws.ec2.modify-vpc-endpoint-request/remove-route-table-ids :portkey.aws.ec2.modify-vpc-endpoint-request/reset-policy :portkey.aws.ec2.modify-vpc-endpoint-request/add-route-table-ids]))

(clojure.spec.alpha/def :portkey.aws.ec2/elastic-gpu-specification-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/elastic-gpu-specification))

(clojure.spec.alpha/def :portkey.aws.ec2.user-id-group-pair/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.user-id-group-pair/group-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.user-id-group-pair/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.user-id-group-pair/peering-status (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.user-id-group-pair/user-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.user-id-group-pair/vpc-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.user-id-group-pair/vpc-peering-connection-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/user-id-group-pair (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.user-id-group-pair/description :portkey.aws.ec2.user-id-group-pair/group-id :portkey.aws.ec2.user-id-group-pair/group-name :portkey.aws.ec2.user-id-group-pair/peering-status :portkey.aws.ec2.user-id-group-pair/user-id :portkey.aws.ec2.user-id-group-pair/vpc-id :portkey.aws.ec2.user-id-group-pair/vpc-peering-connection-id]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-templates-monitoring-request/enabled (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-templates-monitoring-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-templates-monitoring-request/enabled]))

(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/currency-code (clojure.spec.alpha/and :portkey.aws.ec2/currency-code-values))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/upfront-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/host-id-set (clojure.spec.alpha/and :portkey.aws.ec2/response-host-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/start (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/end (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/hourly-price (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/offering-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/duration (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/instance-family (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/host-reservation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.host-reservation/state (clojure.spec.alpha/and :portkey.aws.ec2/reservation-state))
(clojure.spec.alpha/def :portkey.aws.ec2/host-reservation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.host-reservation/currency-code :portkey.aws.ec2.host-reservation/upfront-price :portkey.aws.ec2.host-reservation/host-id-set :portkey.aws.ec2.host-reservation/start :portkey.aws.ec2.host-reservation/end :portkey.aws.ec2.host-reservation/count :portkey.aws.ec2/payment-option :portkey.aws.ec2.host-reservation/hourly-price :portkey.aws.ec2.host-reservation/offering-id :portkey.aws.ec2.host-reservation/duration :portkey.aws.ec2.host-reservation/instance-family :portkey.aws.ec2.host-reservation/host-reservation-id :portkey.aws.ec2.host-reservation/state]))

(clojure.spec.alpha/def :portkey.aws.ec2.get-console-screenshot-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.get-console-screenshot-request/instance-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.get-console-screenshot-request/wake-up (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/get-console-screenshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.get-console-screenshot-request/instance-id] :opt-un [:portkey.aws.ec2.get-console-screenshot-request/dry-run :portkey.aws.ec2.get-console-screenshot-request/wake-up]))

(clojure.spec.alpha/def :portkey.aws.ec2/capacity-reservation-tenancy #{:default "dedicated" :dedicated "default"})

(clojure.spec.alpha/def :portkey.aws.ec2/telemetry-status #{:down "UP" "DOWN" :up})

(clojure.spec.alpha/def :portkey.aws.ec2.describe-id-format-request/resource (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-id-format-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-id-format-request/resource]))

(clojure.spec.alpha/def :portkey.aws.ec2/create-fleet-errors-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/create-fleet-error))

(clojure.spec.alpha/def :portkey.aws.ec2/delete-fleet-error-code #{:fleet-not-in-deletable-state :fleet-id-malformed "unexpectedError" "fleetNotInDeletableState" "fleetIdDoesNotExist" :fleet-id-does-not-exist "fleetIdMalformed" :unexpected-error})

(clojure.spec.alpha/def :portkey.aws.ec2.delete-fpga-image-result/return (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-fpga-image-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-fpga-image-result/return]))

(clojure.spec.alpha/def :portkey.aws.ec2/import-task-id-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2.vpn-gateway/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-gateway/state (clojure.spec.alpha/and :portkey.aws.ec2/vpn-state))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-gateway/type (clojure.spec.alpha/and :portkey.aws.ec2/gateway-type))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-gateway/vpc-attachments (clojure.spec.alpha/and :portkey.aws.ec2/vpc-attachment-list))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-gateway/vpn-gateway-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-gateway/amazon-side-asn (clojure.spec.alpha/and :portkey.aws.ec2/long))
(clojure.spec.alpha/def :portkey.aws.ec2.vpn-gateway/tags (clojure.spec.alpha/and :portkey.aws.ec2/tag-list))
(clojure.spec.alpha/def :portkey.aws.ec2/vpn-gateway (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.vpn-gateway/availability-zone :portkey.aws.ec2.vpn-gateway/state :portkey.aws.ec2.vpn-gateway/type :portkey.aws.ec2.vpn-gateway/vpc-attachments :portkey.aws.ec2.vpn-gateway/vpn-gateway-id :portkey.aws.ec2.vpn-gateway/amazon-side-asn :portkey.aws.ec2.vpn-gateway/tags]))

(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-association/allocation-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-association/association-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-association/ip-owner-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-association/public-dns-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.network-interface-association/public-ip (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/network-interface-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.network-interface-association/allocation-id :portkey.aws.ec2.network-interface-association/association-id :portkey.aws.ec2.network-interface-association/ip-owner-id :portkey.aws.ec2.network-interface-association/public-dns-name :portkey.aws.ec2.network-interface-association/public-ip]))

(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-placement/availability-zone (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-placement/affinity (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-placement/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-placement/host-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.launch-template-placement/spread-domain (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/launch-template-placement (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.launch-template-placement/availability-zone :portkey.aws.ec2.launch-template-placement/affinity :portkey.aws.ec2.launch-template-placement/group-name :portkey.aws.ec2.launch-template-placement/host-id :portkey.aws.ec2/tenancy :portkey.aws.ec2.launch-template-placement/spread-domain]))

(clojure.spec.alpha/def :portkey.aws.ec2.placement-response/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2/placement-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.placement-response/group-name]))

(clojure.spec.alpha/def :portkey.aws.ec2/describe-vpcs-max-results (clojure.spec.alpha/int-in 5 1000))

(clojure.spec.alpha/def :portkey.aws.ec2/date-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ec2.delete-vpc-endpoint-service-configurations-result/unsuccessful (clojure.spec.alpha/and :portkey.aws.ec2/unsuccessful-item-set))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-vpc-endpoint-service-configurations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.delete-vpc-endpoint-service-configurations-result/unsuccessful]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-key-pairs-request/filters (clojure.spec.alpha/and :portkey.aws.ec2/filter-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-key-pairs-request/key-names (clojure.spec.alpha/and :portkey.aws.ec2/key-name-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-key-pairs-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-key-pairs-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.describe-key-pairs-request/filters :portkey.aws.ec2.describe-key-pairs-request/key-names :portkey.aws.ec2.describe-key-pairs-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-dhcp-options-request/dhcp-options-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-dhcp-options-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-dhcp-options-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-dhcp-options-request/dhcp-options-id] :opt-un [:portkey.aws.ec2.delete-dhcp-options-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-request-history-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-request-history-request/max-results (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-request-history-request/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-request-history-request/spot-fleet-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-request-history-request/start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-fleet-request-history-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.describe-spot-fleet-request-history-request/spot-fleet-request-id :portkey.aws.ec2.describe-spot-fleet-request-history-request/start-time] :opt-un [:portkey.aws.ec2.describe-spot-fleet-request-history-request/dry-run :portkey.aws.ec2/event-type :portkey.aws.ec2.describe-spot-fleet-request-history-request/max-results :portkey.aws.ec2.describe-spot-fleet-request-history-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleets-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleets-request/fleet-ids (clojure.spec.alpha/and :portkey.aws.ec2/fleet-id-set))
(clojure.spec.alpha/def :portkey.aws.ec2.delete-fleets-request/terminate-instances (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2/delete-fleets-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ec2.delete-fleets-request/fleet-ids :portkey.aws.ec2.delete-fleets-request/terminate-instances] :opt-un [:portkey.aws.ec2.delete-fleets-request/dry-run]))

(clojure.spec.alpha/def :portkey.aws.ec2/snapshot-id-string-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/shutdown-behavior #{"stop" :terminate "terminate" :stop})

(clojure.spec.alpha/def :portkey.aws.ec2.unmonitor-instances-result/instance-monitorings (clojure.spec.alpha/and :portkey.aws.ec2/instance-monitoring-list))
(clojure.spec.alpha/def :portkey.aws.ec2/unmonitor-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.unmonitor-instances-result/instance-monitorings]))

(clojure.spec.alpha/def :portkey.aws.ec2.egress-only-internet-gateway/attachments (clojure.spec.alpha/and :portkey.aws.ec2/internet-gateway-attachment-list))
(clojure.spec.alpha/def :portkey.aws.ec2/egress-only-internet-gateway (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.egress-only-internet-gateway/attachments :portkey.aws.ec2/egress-only-internet-gateway-id]))

(clojure.spec.alpha/def :portkey.aws.ec2/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ec2.create-placement-group-request/dry-run (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.create-placement-group-request/group-name (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.create-placement-group-request/strategy (clojure.spec.alpha/and :portkey.aws.ec2/placement-strategy))
(clojure.spec.alpha/def :portkey.aws.ec2.create-placement-group-request/partition-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/create-placement-group-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.create-placement-group-request/dry-run :portkey.aws.ec2.create-placement-group-request/group-name :portkey.aws.ec2.create-placement-group-request/strategy :portkey.aws.ec2.create-placement-group-request/partition-count]))

(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/associate-public-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/ipv-6-addresses (clojure.spec.alpha/and :portkey.aws.ec2/instance-ipv-6-address-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/subnet-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/network-interface-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/device-index (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/description (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/groups (clojure.spec.alpha/and :portkey.aws.ec2/security-group-id-string-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/delete-on-termination (clojure.spec.alpha/and :portkey.aws.ec2/boolean))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/private-ip-addresses (clojure.spec.alpha/and :portkey.aws.ec2/private-ip-address-specification-list))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/secondary-private-ip-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/private-ip-address (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.instance-network-interface-specification/ipv-6-address-count (clojure.spec.alpha/and :portkey.aws.ec2/integer))
(clojure.spec.alpha/def :portkey.aws.ec2/instance-network-interface-specification (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2.instance-network-interface-specification/associate-public-ip-address :portkey.aws.ec2.instance-network-interface-specification/ipv-6-addresses :portkey.aws.ec2.instance-network-interface-specification/subnet-id :portkey.aws.ec2.instance-network-interface-specification/network-interface-id :portkey.aws.ec2.instance-network-interface-specification/device-index :portkey.aws.ec2.instance-network-interface-specification/description :portkey.aws.ec2.instance-network-interface-specification/groups :portkey.aws.ec2.instance-network-interface-specification/delete-on-termination :portkey.aws.ec2.instance-network-interface-specification/private-ip-addresses :portkey.aws.ec2.instance-network-interface-specification/secondary-private-ip-address-count :portkey.aws.ec2.instance-network-interface-specification/private-ip-address :portkey.aws.ec2.instance-network-interface-specification/ipv-6-address-count]))

(clojure.spec.alpha/def :portkey.aws.ec2/client-vpn-security-group-id-set (clojure.spec.alpha/coll-of :portkey.aws.ec2/string))

(clojure.spec.alpha/def :portkey.aws.ec2/attach-vpn-gateway-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/vpc-attachment]))

(clojure.spec.alpha/def :portkey.aws.ec2/reservation-state #{:retired :paymentfailed :paymentpending :active "payment-pending" "payment-failed" "active" "retired"})

(clojure.spec.alpha/def :portkey.aws.ec2/available-instance-capacity-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/instance-capacity))

(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-request-history-response/last-evaluated-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-request-history-response/next-token (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-request-history-response/spot-fleet-request-id (clojure.spec.alpha/and :portkey.aws.ec2/string))
(clojure.spec.alpha/def :portkey.aws.ec2.describe-spot-fleet-request-history-response/start-time (clojure.spec.alpha/and :portkey.aws.ec2/date-time))
(clojure.spec.alpha/def :portkey.aws.ec2/describe-spot-fleet-request-history-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ec2/history-records :portkey.aws.ec2.describe-spot-fleet-request-history-response/last-evaluated-time :portkey.aws.ec2.describe-spot-fleet-request-history-response/next-token :portkey.aws.ec2.describe-spot-fleet-request-history-response/spot-fleet-request-id :portkey.aws.ec2.describe-spot-fleet-request-history-response/start-time]))

(clojure.spec.alpha/def :portkey.aws.ec2/snapshot-state #{:pending :completed "error" "completed" :error "pending"})

(clojure.spec.alpha/def :portkey.aws.ec2/vpn-gateway-list (clojure.spec.alpha/coll-of :portkey.aws.ec2/vpn-gateway))

(clojure.core/defn describe-spot-fleet-instances "Describes the running instances for the specified Spot Fleet." ([describe-spot-fleet-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-spot-fleet-instances-request describe-spot-fleet-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-spot-fleet-instances-response, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-spot-fleet-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSpotFleetInstances", :http.request.configuration/output-deser-fn response-describe-spot-fleet-instances-response, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-spot-fleet-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-spot-fleet-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-spot-fleet-instances-response))

(clojure.core/defn describe-client-vpn-endpoints "Describes one or more Client VPN endpoints in the account." ([] (describe-client-vpn-endpoints {})) ([describe-client-vpn-endpoints-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-client-vpn-endpoints-request describe-client-vpn-endpoints-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-client-vpn-endpoints-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-client-vpn-endpoints-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeClientVpnEndpoints", :http.request.configuration/output-deser-fn response-describe-client-vpn-endpoints-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-client-vpn-endpoints :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-client-vpn-endpoints-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-client-vpn-endpoints-result))

(clojure.core/defn get-password-data "Retrieves the encrypted administrator password for a running Windows instance.\n The Windows password is generated at boot by the EC2Config service or EC2Launch\nscripts (Windows Server 2016 and later). This usually only happens the first\ntime an instance is launched. For more information, see EC2Config\n(https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/UsingConfig_WinAMI.html)\nand EC2Launch\n(https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2launch.html) in the\nAmazon Elastic Compute Cloud User Guide.\n For the EC2Config service, the password is not generated for rebundled AMIs\nunless Ec2SetPassword is enabled before bundling.\n The password is encrypted using the key pair that you specified when you\nlaunched the instance. You must provide the corresponding key pair file.\n When you launch an instance, password generation and encryption may take a few\nminutes. If you try to retrieve the password before it's available, the output\nreturns an empty string. We recommend that you wait up to 15 minutes after\nlaunching an instance before trying to retrieve the generated password." ([get-password-data-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-password-data-request get-password-data-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/get-password-data-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/get-password-data-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetPasswordData", :http.request.configuration/output-deser-fn response-get-password-data-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef get-password-data :args (clojure.spec.alpha/tuple :portkey.aws.ec2/get-password-data-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/get-password-data-result))

(clojure.core/defn delete-fleets "Deletes the specified EC2 Fleet.\n After you delete an EC2 Fleet, it launches no new instances. You must specify\nwhether an EC2 Fleet should also terminate its instances. If you terminate the\ninstances, the EC2 Fleet enters the deleted_terminating state. Otherwise, the\nEC2 Fleet enters the deleted_running state, and the instances continue to run\nuntil they are interrupted or you terminate them manually." ([delete-fleets-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-fleets-request delete-fleets-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-fleets-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-fleets-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteFleets", :http.request.configuration/output-deser-fn response-delete-fleets-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-fleets :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-fleets-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-fleets-result))

(clojure.core/defn describe-import-snapshot-tasks "Describes your import snapshot tasks." ([] (describe-import-snapshot-tasks {})) ([describe-import-snapshot-tasks-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-import-snapshot-tasks-request describe-import-snapshot-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-import-snapshot-tasks-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-import-snapshot-tasks-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeImportSnapshotTasks", :http.request.configuration/output-deser-fn response-describe-import-snapshot-tasks-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-import-snapshot-tasks :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-import-snapshot-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-import-snapshot-tasks-result))

(clojure.core/defn create-client-vpn-endpoint "Creates a Client VPN endpoint. A Client VPN endpoint is the resource you create\nand configure to enable and manage client VPN sessions. It is the destination\nendpoint at which all client VPN sessions are terminated." ([create-client-vpn-endpoint-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-client-vpn-endpoint-request create-client-vpn-endpoint-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-client-vpn-endpoint-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-client-vpn-endpoint-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateClientVpnEndpoint", :http.request.configuration/output-deser-fn response-create-client-vpn-endpoint-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-client-vpn-endpoint :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-client-vpn-endpoint-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-client-vpn-endpoint-result))

(clojure.core/defn modify-subnet-attribute "Modifies a subnet attribute. You can only modify one attribute at a time." ([modify-subnet-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-subnet-attribute-request modify-subnet-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-subnet-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifySubnetAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-subnet-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-subnet-attribute-request) :ret clojure.core/true?)

(clojure.core/defn create-network-acl-entry "Creates an entry (a rule) in a network ACL with the specified rule number. Each\nnetwork ACL has a set of numbered ingress rules and a separate set of numbered\negress rules. When determining whether a packet should be allowed in or out of a\nsubnet associated with the ACL, we process the entries in the ACL according to\nthe rule numbers, in ascending order. Each network ACL has a set of ingress\nrules and a separate set of egress rules.\n We recommend that you leave room between the rule numbers (for example, 100,\n110, 120, ...), and not number them one right after the other (for example, 101,\n102, 103, ...). This makes it easier to add a rule between existing ones without\nhaving to renumber the rules.\n After you add an entry, you can't modify it; you must either replace it, or\ncreate an entry and delete the old one.\n For more information about network ACLs, see Network ACLs\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html) in the\nAmazon Virtual Private Cloud User Guide." ([create-network-acl-entry-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-network-acl-entry-request create-network-acl-entry-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-network-acl-entry-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateNetworkAclEntry", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-network-acl-entry :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-network-acl-entry-request) :ret clojure.core/true?)

(clojure.core/defn modify-hosts "Modify the auto-placement setting of a Dedicated Host. When auto-placement is\nenabled, any instances that you launch with a tenancy of host but without a\nspecific host ID are placed onto any available Dedicated Host in your account\nthat has auto-placement enabled. When auto-placement is disabled, you need to\nprovide a host ID to have the instance launch onto a specific host. If no host\nID is provided, the instance is launched onto a suitable host with\nauto-placement enabled." ([modify-hosts-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-hosts-request modify-hosts-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-hosts-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-hosts-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyHosts", :http.request.configuration/output-deser-fn response-modify-hosts-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-hosts :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-hosts-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-hosts-result))

(clojure.core/defn describe-instance-status "Describes the status of one or more instances. By default, only running\ninstances are described, unless you specifically indicate to return the status\nof all instances.\n Instance status includes the following components:\n * Status checks - Amazon EC2 performs status checks on running EC2 instances to\nidentify hardware and software issues. For more information, see Status Checks\nfor Your Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/monitoring-system-instance-status-check.html)\nand Troubleshooting Instances with Failed Status Checks\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstances.html)\nin the Amazon Elastic Compute Cloud User Guide.\n * Scheduled events - Amazon EC2 can schedule events (such as reboot, stop, or\nterminate) for your instances related to hardware issues, software updates, or\nsystem maintenance. For more information, see Scheduled Events for Your\nInstances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/monitoring-instances-status-check_sched.html)\nin the Amazon Elastic Compute Cloud User Guide.\n * Instance state - You can manage your instances from the moment you launch\nthem through their termination. For more information, see Instance Lifecycle\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-lifecycle.html)\nin the Amazon Elastic Compute Cloud User Guide." ([] (describe-instance-status {})) ([describe-instance-status-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-instance-status-request describe-instance-status-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-instance-status-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-instance-status-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstanceStatus", :http.request.configuration/output-deser-fn response-describe-instance-status-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-instance-status :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-instance-status-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-instance-status-result))

(clojure.core/defn accept-vpc-peering-connection "Accept a VPC peering connection request. To accept a request, the VPC peering\nconnection must be in the pending-acceptance state, and you must be the owner of\nthe peer VPC. Use DescribeVpcPeeringConnections to view your outstanding VPC\npeering connection requests.\n For an inter-region VPC peering connection request, you must accept the VPC\npeering connection in the region of the accepter VPC." ([] (accept-vpc-peering-connection {})) ([accept-vpc-peering-connection-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-accept-vpc-peering-connection-request accept-vpc-peering-connection-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/accept-vpc-peering-connection-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/accept-vpc-peering-connection-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AcceptVpcPeeringConnection", :http.request.configuration/output-deser-fn response-accept-vpc-peering-connection-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef accept-vpc-peering-connection :args (clojure.spec.alpha/? :portkey.aws.ec2/accept-vpc-peering-connection-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/accept-vpc-peering-connection-result))

(clojure.core/defn describe-volumes "Describes the specified EBS volumes.\n If you are describing a long list of volumes, you can paginate the output to\nmake the list more manageable. The MaxResults parameter sets the maximum number\nof results returned in a single page. If the list of results exceeds your\nMaxResults value, then that number of results is returned along with a NextToken\nvalue that can be passed to a subsequent DescribeVolumes request to retrieve the\nremaining results.\n For more information about EBS volumes, see Amazon EBS Volumes\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumes.html) in the\nAmazon Elastic Compute Cloud User Guide." ([] (describe-volumes {})) ([describe-volumes-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-volumes-request describe-volumes-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-volumes-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-volumes-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVolumes", :http.request.configuration/output-deser-fn response-describe-volumes-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-volumes :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-volumes-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-volumes-result))

(clojure.core/defn create-client-vpn-route "Adds a route to a network to a Client VPN endpoint. Each Client VPN endpoint has\na route table that describes the available destination network routes. Each\nroute in the route table specifies the path for trac to specic resources or\nnetworks." ([create-client-vpn-route-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-client-vpn-route-request create-client-vpn-route-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-client-vpn-route-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-client-vpn-route-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateClientVpnRoute", :http.request.configuration/output-deser-fn response-create-client-vpn-route-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-client-vpn-route :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-client-vpn-route-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-client-vpn-route-result))

(clojure.core/defn create-launch-template-version "Creates a new version for a launch template. You can specify an existing version\nof launch template from which to base the new version.\n Launch template versions are numbered in the order in which they are created.\nYou cannot specify, change, or replace the numbering of launch template\nversions." ([create-launch-template-version-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-launch-template-version-request create-launch-template-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-launch-template-version-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-launch-template-version-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateLaunchTemplateVersion", :http.request.configuration/output-deser-fn response-create-launch-template-version-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-launch-template-version :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-launch-template-version-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-launch-template-version-result))

(clojure.core/defn modify-instance-capacity-reservation-attributes "Modifies the Capacity Reservation settings for a stopped instance. Use this\naction to configure an instance to target a specific Capacity Reservation, run\nin any open Capacity Reservation with matching attributes, or run On-Demand\nInstance capacity." ([modify-instance-capacity-reservation-attributes-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-instance-capacity-reservation-attributes-request modify-instance-capacity-reservation-attributes-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-instance-capacity-reservation-attributes-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-instance-capacity-reservation-attributes-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyInstanceCapacityReservationAttributes", :http.request.configuration/output-deser-fn response-modify-instance-capacity-reservation-attributes-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-instance-capacity-reservation-attributes :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-instance-capacity-reservation-attributes-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-instance-capacity-reservation-attributes-result))

(clojure.core/defn describe-key-pairs "Describes one or more of your key pairs.\n For more information about key pairs, see Key Pairs\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html) in the\nAmazon Elastic Compute Cloud User Guide." ([] (describe-key-pairs {})) ([describe-key-pairs-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-key-pairs-request describe-key-pairs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-key-pairs-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-key-pairs-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeKeyPairs", :http.request.configuration/output-deser-fn response-describe-key-pairs-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-key-pairs :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-key-pairs-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-key-pairs-result))

(clojure.core/defn describe-reserved-instances "Describes one or more of the Reserved Instances that you purchased.\n For more information about Reserved Instances, see Reserved Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts-on-demand-reserved-instances.html)\nin the Amazon Elastic Compute Cloud User Guide." ([] (describe-reserved-instances {})) ([describe-reserved-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-reserved-instances-request describe-reserved-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-reserved-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-reserved-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeReservedInstances", :http.request.configuration/output-deser-fn response-describe-reserved-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-reserved-instances :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-reserved-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-reserved-instances-result))

(clojure.core/defn describe-launch-templates "Describes one or more launch templates." ([] (describe-launch-templates {})) ([describe-launch-templates-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-launch-templates-request describe-launch-templates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-launch-templates-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-launch-templates-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeLaunchTemplates", :http.request.configuration/output-deser-fn response-describe-launch-templates-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-launch-templates :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-launch-templates-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-launch-templates-result))

(clojure.core/defn enable-vpc-classic-link-dns-support "Enables a VPC to support DNS hostname resolution for ClassicLink. If enabled,\nthe DNS hostname of a linked EC2-Classic instance resolves to its private IP\naddress when addressed from an instance in the VPC to which it's linked.\nSimilarly, the DNS hostname of an instance in a VPC resolves to its private IP\naddress when addressed from a linked EC2-Classic instance. For more information,\nsee ClassicLink\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([] (enable-vpc-classic-link-dns-support {})) ([enable-vpc-classic-link-dns-support-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-enable-vpc-classic-link-dns-support-request enable-vpc-classic-link-dns-support-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/enable-vpc-classic-link-dns-support-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/enable-vpc-classic-link-dns-support-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "EnableVpcClassicLinkDnsSupport", :http.request.configuration/output-deser-fn response-enable-vpc-classic-link-dns-support-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef enable-vpc-classic-link-dns-support :args (clojure.spec.alpha/? :portkey.aws.ec2/enable-vpc-classic-link-dns-support-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/enable-vpc-classic-link-dns-support-result))

(clojure.core/defn create-transit-gateway-route "Creates a static route for the specified transit gateway route table." ([create-transit-gateway-route-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-transit-gateway-route-request create-transit-gateway-route-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-transit-gateway-route-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-transit-gateway-route-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateTransitGatewayRoute", :http.request.configuration/output-deser-fn response-create-transit-gateway-route-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-transit-gateway-route :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-transit-gateway-route-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-transit-gateway-route-result))

(clojure.core/defn delete-placement-group "Deletes the specified placement group. You must terminate all instances in the\nplacement group before you can delete the placement group. For more information,\nsee Placement Groups\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([delete-placement-group-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-placement-group-request delete-placement-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-placement-group-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeletePlacementGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-placement-group :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-placement-group-request) :ret clojure.core/true?)

(clojure.core/defn create-vpc-endpoint-service-configuration "Creates a VPC endpoint service configuration to which service consumers (AWS\naccounts, IAM users, and IAM roles) can connect. Service consumers can create an\ninterface VPC endpoint to connect to your service.\n To create an endpoint service configuration, you must first create a Network\nLoad Balancer for your service. For more information, see VPC Endpoint Services\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/endpoint-service.html)\nin the Amazon Virtual Private Cloud User Guide." ([create-vpc-endpoint-service-configuration-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-vpc-endpoint-service-configuration-request create-vpc-endpoint-service-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-vpc-endpoint-service-configuration-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-vpc-endpoint-service-configuration-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVpcEndpointServiceConfiguration", :http.request.configuration/output-deser-fn response-create-vpc-endpoint-service-configuration-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-vpc-endpoint-service-configuration :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-vpc-endpoint-service-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-vpc-endpoint-service-configuration-result))

(clojure.core/defn create-dhcp-options "Creates a set of DHCP options for your VPC. After creating the set, you must\nassociate it with the VPC, causing all existing and new instances that you\nlaunch in the VPC to use this set of DHCP options. The following are the\nindividual DHCP options you can specify. For more information about the options,\nsee RFC 2132 (http://www.ietf.org/rfc/rfc2132.txt).\n * domain-name-servers - The IP addresses of up to four domain name servers, or\nAmazonProvidedDNS. The default DHCP option set specifies AmazonProvidedDNS. If\nspecifying more than one domain name server, specify the IP addresses in a\nsingle parameter, separated by commas. ITo have your instance to receive a\ncustom DNS hostname as specified in domain-name, you must set\ndomain-name-servers to a custom DNS server.\n * domain-name - If you're using AmazonProvidedDNS in us-east-1, specify\nec2.internal. If you're using AmazonProvidedDNS in another region, specify\nregion.compute.internal (for example, ap-northeast-1.compute.internal).\nOtherwise, specify a domain name (for example, MyCompany.com). This value is\nused to complete unqualified DNS hostnames. Important: Some Linux operating\nsystems accept multiple domain names separated by spaces. However, Windows and\nother Linux operating systems treat the value as a single domain, which results\nin unexpected behavior. If your DHCP options set is associated with a VPC that\nhas instances with multiple operating systems, specify only one domain name.\n * ntp-servers - The IP addresses of up to four Network Time Protocol (NTP)\nservers.\n * netbios-name-servers - The IP addresses of up to four NetBIOS name servers.\n * netbios-node-type - The NetBIOS node type (1, 2, 4, or 8). We recommend that\nyou specify 2 (broadcast and multicast are not currently supported). For more\ninformation about these node types, see RFC 2132\n(http://www.ietf.org/rfc/rfc2132.txt).\n Your VPC automatically starts out with a set of DHCP options that includes only\na DNS server that we provide (AmazonProvidedDNS). If you create a set of\noptions, and if your VPC has an internet gateway, make sure to set the\ndomain-name-servers option either to AmazonProvidedDNS or to a domain name\nserver of your choice. For more information, see DHCP Options Sets\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html)\nin the Amazon Virtual Private Cloud User Guide." ([create-dhcp-options-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-dhcp-options-request create-dhcp-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-dhcp-options-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-dhcp-options-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDhcpOptions", :http.request.configuration/output-deser-fn response-create-dhcp-options-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-dhcp-options :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-dhcp-options-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-dhcp-options-result))

(clojure.core/defn create-reserved-instances-listing "Creates a listing for Amazon EC2 Standard Reserved Instances to be sold in the\nReserved Instance Marketplace. You can submit one Standard Reserved Instance\nlisting at a time. To get a list of your Standard Reserved Instances, you can\nuse the DescribeReservedInstances operation.\n Only Standard Reserved Instances can be sold in the Reserved Instance\nMarketplace. Convertible Reserved Instances cannot be sold.\n The Reserved Instance Marketplace matches sellers who want to resell Standard\nReserved Instance capacity that they no longer need with buyers who want to\npurchase additional capacity. Reserved Instances bought and sold through the\nReserved Instance Marketplace work like any other Reserved Instances.\n To sell your Standard Reserved Instances, you must first register as a seller\nin the Reserved Instance Marketplace. After completing the registration process,\nyou can create a Reserved Instance Marketplace listing of some or all of your\nStandard Reserved Instances, and specify the upfront price to receive for them.\nYour Standard Reserved Instance listings then become available for purchase. To\nview the details of your Standard Reserved Instance listing, you can use the\nDescribeReservedInstancesListings operation.\n For more information, see Reserved Instance Marketplace\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-market-general.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([create-reserved-instances-listing-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-reserved-instances-listing-request create-reserved-instances-listing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-reserved-instances-listing-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-reserved-instances-listing-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateReservedInstancesListing", :http.request.configuration/output-deser-fn response-create-reserved-instances-listing-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-reserved-instances-listing :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-reserved-instances-listing-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-reserved-instances-listing-result))

(clojure.core/defn disassociate-route-table "Disassociates a subnet from a route table.\n After you perform this action, the subnet no longer uses the routes in the\nroute table. Instead, it uses the routes in the VPC's main route table. For more\ninformation about route tables, see Route Tables\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html)\nin the Amazon Virtual Private Cloud User Guide." ([disassociate-route-table-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disassociate-route-table-request disassociate-route-table-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disassociate-route-table-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisassociateRouteTable", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disassociate-route-table :args (clojure.spec.alpha/tuple :portkey.aws.ec2/disassociate-route-table-request) :ret clojure.core/true?)

(clojure.core/defn import-snapshot "Imports a disk into an EBS snapshot." ([] (import-snapshot {})) ([import-snapshot-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-import-snapshot-request import-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/import-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/import-snapshot-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportSnapshot", :http.request.configuration/output-deser-fn response-import-snapshot-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef import-snapshot :args (clojure.spec.alpha/? :portkey.aws.ec2/import-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/import-snapshot-result))

(clojure.core/defn create-fleet "Launches an EC2 Fleet.\n You can create a single EC2 Fleet that includes multiple launch specifications\nthat vary by instance type, AMI, Availability Zone, or subnet.\n For more information, see Launching an EC2 Fleet\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet.html) in the\nAmazon Elastic Compute Cloud User Guide." ([create-fleet-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-fleet-request create-fleet-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-fleet-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-fleet-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateFleet", :http.request.configuration/output-deser-fn response-create-fleet-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-fleet :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-fleet-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-fleet-result))

(clojure.core/defn delete-vpn-connection-route "Deletes the specified static route associated with a VPN connection between an\nexisting virtual private gateway and a VPN customer gateway. The static route\nallows traffic to be routed from the virtual private gateway to the VPN customer\ngateway." ([delete-vpn-connection-route-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-vpn-connection-route-request delete-vpn-connection-route-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-vpn-connection-route-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVpnConnectionRoute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-vpn-connection-route :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-vpn-connection-route-request) :ret clojure.core/true?)

(clojure.core/defn attach-volume "Attaches an EBS volume to a running or stopped instance and exposes it to the\ninstance with the specified device name.\n Encrypted EBS volumes may only be attached to instances that support Amazon EBS\nencryption. For more information, see Amazon EBS Encryption\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) in the\nAmazon Elastic Compute Cloud User Guide.\n For a list of supported device names, see Attaching an EBS Volume to an\nInstance\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-attaching-volume.html).\nAny device names that aren't reserved for instance store volumes can be used for\nEBS volumes. For more information, see Amazon EC2 Instance Store\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in\nthe Amazon Elastic Compute Cloud User Guide.\n If a volume has an AWS Marketplace product code:\n * The volume can be attached only to a stopped instance.\n * AWS Marketplace product codes are copied from the volume to the instance.\n * You must be subscribed to the product.\n * The instance type and operating system of the instance must support the\nproduct. For example, you can't detach a volume from a Windows instance and\nattach it to a Linux instance.\n For more information about EBS volumes, see Attaching Amazon EBS Volumes\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-attaching-volume.html)\nin the Amazon Elastic Compute Cloud User Guide." ([attach-volume-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-attach-volume-request attach-volume-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/volume-attachment, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/attach-volume-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachVolume", :http.request.configuration/output-deser-fn response-volume-attachment, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef attach-volume :args (clojure.spec.alpha/tuple :portkey.aws.ec2/attach-volume-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/volume-attachment))

(clojure.core/defn describe-byoip-cidrs "Describes the IP address ranges that were specified in calls to\nProvisionByoipCidr.\n To describe the address pools that were created when you provisioned the\naddress ranges, use DescribePublicIpv4Pools." ([describe-byoip-cidrs-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-byoip-cidrs-request describe-byoip-cidrs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-byoip-cidrs-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-byoip-cidrs-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeByoipCidrs", :http.request.configuration/output-deser-fn response-describe-byoip-cidrs-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-byoip-cidrs :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-byoip-cidrs-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-byoip-cidrs-result))

(clojure.core/defn delete-security-group "Deletes a security group.\n If you attempt to delete a security group that is associated with an instance,\nor is referenced by another security group, the operation fails with\nInvalidGroup.InUse in EC2-Classic or DependencyViolation in EC2-VPC." ([] (delete-security-group {})) ([delete-security-group-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-security-group-request delete-security-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-security-group-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSecurityGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-security-group :args (clojure.spec.alpha/? :portkey.aws.ec2/delete-security-group-request) :ret clojure.core/true?)

(clojure.core/defn delete-key-pair "Deletes the specified key pair, by removing the public key from Amazon EC2." ([delete-key-pair-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-key-pair-request delete-key-pair-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-key-pair-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteKeyPair", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-key-pair :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-key-pair-request) :ret clojure.core/true?)

(clojure.core/defn describe-host-reservations "Describes reservations that are associated with Dedicated Hosts in your account." ([] (describe-host-reservations {})) ([describe-host-reservations-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-host-reservations-request describe-host-reservations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-host-reservations-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-host-reservations-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeHostReservations", :http.request.configuration/output-deser-fn response-describe-host-reservations-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-host-reservations :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-host-reservations-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-host-reservations-result))

(clojure.core/defn describe-fleet-history "Describes the events for the specified EC2 Fleet during the specified time." ([describe-fleet-history-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-fleet-history-request describe-fleet-history-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-fleet-history-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-fleet-history-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeFleetHistory", :http.request.configuration/output-deser-fn response-describe-fleet-history-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-fleet-history :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-fleet-history-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-fleet-history-result))

(clojure.core/defn describe-egress-only-internet-gateways "Describes one or more of your egress-only internet gateways." ([] (describe-egress-only-internet-gateways {})) ([describe-egress-only-internet-gateways-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-egress-only-internet-gateways-request describe-egress-only-internet-gateways-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-egress-only-internet-gateways-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-egress-only-internet-gateways-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeEgressOnlyInternetGateways", :http.request.configuration/output-deser-fn response-describe-egress-only-internet-gateways-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-egress-only-internet-gateways :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-egress-only-internet-gateways-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-egress-only-internet-gateways-result))

(clojure.core/defn modify-volume "You can modify several parameters of an existing EBS volume, including volume\nsize, volume type, and IOPS capacity. If your EBS volume is attached to a\ncurrent-generation EC2 instance type, you may be able to apply these changes\nwithout stopping the instance or detaching the volume from it. For more\ninformation about modifying an EBS volume running Linux, see Modifying the Size,\nIOPS, or Type of an EBS Volume on Linux\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-expand-volume.html).\nFor more information about modifying an EBS volume running Windows, see\nModifying the Size, IOPS, or Type of an EBS Volume on Windows\n(https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ebs-expand-volume.html).\n When you complete a resize operation on your volume, you need to extend the\nvolume's file-system size to take advantage of the new storage capacity. For\ninformation about extending a Linux file system, see Extending a Linux File\nSystem\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-expand-volume.html#recognize-expanded-volume-linux).\nFor information about extending a Windows file system, see Extending a Windows\nFile System\n(https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ebs-expand-volume.html#recognize-expanded-volume-windows).\n You can use CloudWatch Events to check the status of a modification to an EBS\nvolume. For information about CloudWatch Events, see the Amazon CloudWatch\nEvents User Guide (https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/).\nYou can also track the status of a modification using the\nDescribeVolumesModifications API. For information about tracking status changes\nusing either method, see Monitoring Volume Modifications\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-expand-volume.html#monitoring_mods).\n With previous-generation instance types, resizing an EBS volume may require\ndetaching and reattaching the volume or stopping and restarting the instance.\nFor more information, see Modifying the Size, IOPS, or Type of an EBS Volume on\nLinux\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-expand-volume.html) and\nModifying the Size, IOPS, or Type of an EBS Volume on Windows\n(https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ebs-expand-volume.html).\n If you reach the maximum volume modification rate per volume limit, you will\nneed to wait at least six hours before applying further modifications to the\naffected EBS volume." ([modify-volume-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-volume-request modify-volume-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-volume-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-volume-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyVolume", :http.request.configuration/output-deser-fn response-modify-volume-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-volume :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-volume-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-volume-result))

(clojure.core/defn get-console-output "Gets the console output for the specified instance. For Linux instances, the\ninstance console output displays the exact console output that would normally be\ndisplayed on a physical monitor attached to a computer. For Windows instances,\nthe instance console output includes the last three system event log errors.\n By default, the console output returns buffered information that was posted\nshortly after an instance transition state (start, stop, reboot, or terminate).\nThis information is available for at least one hour after the most recent post.\nOnly the most recent 64 KB of console output is available.\n You can optionally retrieve the latest serial console output at any time during\nthe instance lifecycle. This option is supported on instance types that use the\nNitro hypervisor.\n For more information, see Instance Console Output\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-console.html#instance-console-console-output)\nin the Amazon Elastic Compute Cloud User Guide." ([get-console-output-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-console-output-request get-console-output-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/get-console-output-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/get-console-output-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetConsoleOutput", :http.request.configuration/output-deser-fn response-get-console-output-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef get-console-output :args (clojure.spec.alpha/tuple :portkey.aws.ec2/get-console-output-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/get-console-output-result))

(clojure.core/defn revoke-client-vpn-ingress "Removes an ingress authorization rule from a Client VPN endpoint." ([revoke-client-vpn-ingress-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-revoke-client-vpn-ingress-request revoke-client-vpn-ingress-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/revoke-client-vpn-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/revoke-client-vpn-ingress-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RevokeClientVpnIngress", :http.request.configuration/output-deser-fn response-revoke-client-vpn-ingress-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef revoke-client-vpn-ingress :args (clojure.spec.alpha/tuple :portkey.aws.ec2/revoke-client-vpn-ingress-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/revoke-client-vpn-ingress-result))

(clojure.core/defn reset-instance-attribute "Resets an attribute of an instance to its default value. To reset the kernel or\nramdisk, the instance must be in a stopped state. To reset the sourceDestCheck,\nthe instance can be either running or stopped.\n The sourceDestCheck attribute controls whether source/destination checking is\nenabled. The default value is true, which means checking is enabled. This value\nmust be false for a NAT instance to perform NAT. For more information, see NAT\nInstances\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html)\nin the Amazon Virtual Private Cloud User Guide." ([reset-instance-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-reset-instance-attribute-request reset-instance-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/reset-instance-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ResetInstanceAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef reset-instance-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/reset-instance-attribute-request) :ret clojure.core/true?)

(clojure.core/defn modify-vpc-attribute "Modifies the specified attribute of the specified VPC." ([modify-vpc-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-vpc-attribute-request modify-vpc-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-vpc-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyVpcAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-vpc-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-vpc-attribute-request) :ret clojure.core/true?)

(clojure.core/defn describe-volume-status "Describes the status of the specified volumes. Volume status provides the result\nof the checks performed on your volumes to determine events that can impair the\nperformance of your volumes. The performance of a volume can be affected if an\nissue occurs on the volume's underlying host. If the volume's underlying host\nexperiences a power outage or system issue, after the system is restored, there\ncould be data inconsistencies on the volume. Volume events notify you if this\noccurs. Volume actions notify you if any action needs to be taken in response to\nthe event.\n The DescribeVolumeStatus operation provides the following information about the\nspecified volumes:\n Status: Reflects the current status of the volume. The possible values are ok,\nimpaired , warning, or insufficient-data. If all checks pass, the overall status\nof the volume is ok. If the check fails, the overall status is impaired. If the\nstatus is insufficient-data, then the checks may still be taking place on your\nvolume at the time. We recommend that you retry the request. For more\ninformation about volume status, see Monitoring the Status of Your Volumes\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/monitoring-volume-status.html)\nin the Amazon Elastic Compute Cloud User Guide.\n Events: Reflect the cause of a volume status and may require you to take\naction. For example, if your volume returns an impaired status, then the volume\nevent might be potential-data-inconsistency. This means that your volume has\nbeen affected by an issue with the underlying host, has all I/O operations\ndisabled, and may have inconsistent data.\n Actions: Reflect the actions you may have to take in response to an event. For\nexample, if the status of the volume is impaired and the volume event shows\npotential-data-inconsistency, then the action shows enable-volume-io. This means\nthat you may want to enable the I/O operations for the volume by calling the\nEnableVolumeIO action and then check the volume for data consistency.\n Volume status is based on the volume status checks, and does not reflect the\nvolume state. Therefore, volume status does not indicate volumes in the error\nstate (for example, when a volume is incapable of accepting I/O.)" ([] (describe-volume-status {})) ([describe-volume-status-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-volume-status-request describe-volume-status-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-volume-status-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-volume-status-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVolumeStatus", :http.request.configuration/output-deser-fn response-describe-volume-status-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-volume-status :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-volume-status-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-volume-status-result))

(clojure.core/defn describe-conversion-tasks "Describes one or more of your conversion tasks. For more information, see the VM\nImport/Export User Guide\n(https://docs.aws.amazon.com/vm-import/latest/userguide/).\n For information about the import manifest referenced by this API action, see VM\nImport Manifest\n(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html)." ([] (describe-conversion-tasks {})) ([describe-conversion-tasks-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-conversion-tasks-request describe-conversion-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-conversion-tasks-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-conversion-tasks-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeConversionTasks", :http.request.configuration/output-deser-fn response-describe-conversion-tasks-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-conversion-tasks :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-conversion-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-conversion-tasks-result))

(clojure.core/defn delete-network-acl-entry "Deletes the specified ingress or egress entry (rule) from the specified network\nACL." ([delete-network-acl-entry-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-network-acl-entry-request delete-network-acl-entry-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-network-acl-entry-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteNetworkAclEntry", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-network-acl-entry :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-network-acl-entry-request) :ret clojure.core/true?)

(clojure.core/defn create-volume "Creates an EBS volume that can be attached to an instance in the same\nAvailability Zone. The volume is created in the regional endpoint that you send\nthe HTTP request to. For more information see Regions and Endpoints\n(https://docs.aws.amazon.com/general/latest/gr/rande.html).\n You can create a new empty volume or restore a volume from an EBS snapshot. Any\nAWS Marketplace product codes from the snapshot are propagated to the volume.\n You can create encrypted volumes with the Encrypted parameter. Encrypted\nvolumes may only be attached to instances that support Amazon EBS encryption.\nVolumes that are created from encrypted snapshots are also automatically\nencrypted. For more information, see Amazon EBS Encryption\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) in the\nAmazon Elastic Compute Cloud User Guide.\n You can tag your volumes during creation. For more information, see Tagging\nYour Amazon EC2 Resources\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html) in the\nAmazon Elastic Compute Cloud User Guide.\n For more information, see Creating an Amazon EBS Volume\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-creating-volume.html)\nin the Amazon Elastic Compute Cloud User Guide." ([create-volume-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-volume-request create-volume-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/volume, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-volume-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVolume", :http.request.configuration/output-deser-fn response-volume, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-volume :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-volume-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/volume))

(clojure.core/defn copy-fpga-image "Copies the specified Amazon FPGA Image (AFI) to the current region." ([copy-fpga-image-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-copy-fpga-image-request copy-fpga-image-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/copy-fpga-image-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/copy-fpga-image-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CopyFpgaImage", :http.request.configuration/output-deser-fn response-copy-fpga-image-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef copy-fpga-image :args (clojure.spec.alpha/tuple :portkey.aws.ec2/copy-fpga-image-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/copy-fpga-image-result))

(clojure.core/defn enable-vgw-route-propagation "Enables a virtual private gateway (VGW) to propagate routes to the specified\nroute table of a VPC." ([enable-vgw-route-propagation-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-enable-vgw-route-propagation-request enable-vgw-route-propagation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/enable-vgw-route-propagation-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "EnableVgwRoutePropagation", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef enable-vgw-route-propagation :args (clojure.spec.alpha/tuple :portkey.aws.ec2/enable-vgw-route-propagation-request) :ret clojure.core/true?)

(clojure.core/defn create-default-subnet "Creates a default subnet with a size /20 IPv4 CIDR block in the specified\nAvailability Zone in your default VPC. You can have only one default subnet per\nAvailability Zone. For more information, see Creating a Default Subnet\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/default-vpc.html#create-default-subnet)\nin the Amazon Virtual Private Cloud User Guide." ([create-default-subnet-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-default-subnet-request create-default-subnet-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-default-subnet-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-default-subnet-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDefaultSubnet", :http.request.configuration/output-deser-fn response-create-default-subnet-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-default-subnet :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-default-subnet-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-default-subnet-result))

(clojure.core/defn replace-network-acl-association "Changes which network ACL a subnet is associated with. By default when you\ncreate a subnet, it's automatically associated with the default network ACL. For\nmore information, see Network ACLs\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html) in the\nAmazon Virtual Private Cloud User Guide.\n This is an idempotent operation." ([replace-network-acl-association-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-replace-network-acl-association-request replace-network-acl-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/replace-network-acl-association-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/replace-network-acl-association-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReplaceNetworkAclAssociation", :http.request.configuration/output-deser-fn response-replace-network-acl-association-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef replace-network-acl-association :args (clojure.spec.alpha/tuple :portkey.aws.ec2/replace-network-acl-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/replace-network-acl-association-result))

(clojure.core/defn modify-reserved-instances "Modifies the Availability Zone, instance count, instance type, or network\nplatform (EC2-Classic or EC2-VPC) of your Reserved Instances. The Reserved\nInstances to be modified must be identical, except for Availability Zone,\nnetwork platform, and instance type.\n For more information, see Modifying Reserved Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-modifying.html) in the\nAmazon Elastic Compute Cloud User Guide." ([modify-reserved-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-reserved-instances-request modify-reserved-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-reserved-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-reserved-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyReservedInstances", :http.request.configuration/output-deser-fn response-modify-reserved-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-reserved-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-reserved-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-reserved-instances-result))

(clojure.core/defn export-client-vpn-client-certificate-revocation-list "Downloads the client certificate revocation list for the specified Client VPN\nendpoint." ([export-client-vpn-client-certificate-revocation-list-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-export-client-vpn-client-certificate-revocation-list-request export-client-vpn-client-certificate-revocation-list-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/export-client-vpn-client-certificate-revocation-list-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/export-client-vpn-client-certificate-revocation-list-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ExportClientVpnClientCertificateRevocationList", :http.request.configuration/output-deser-fn response-export-client-vpn-client-certificate-revocation-list-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef export-client-vpn-client-certificate-revocation-list :args (clojure.spec.alpha/tuple :portkey.aws.ec2/export-client-vpn-client-certificate-revocation-list-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/export-client-vpn-client-certificate-revocation-list-result))

(clojure.core/defn describe-capacity-reservations "Describes one or more of your Capacity Reservations. The results describe only\nthe Capacity Reservations in the AWS Region that you're currently using." ([] (describe-capacity-reservations {})) ([describe-capacity-reservations-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-capacity-reservations-request describe-capacity-reservations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-capacity-reservations-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-capacity-reservations-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeCapacityReservations", :http.request.configuration/output-deser-fn response-describe-capacity-reservations-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-capacity-reservations :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-capacity-reservations-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-capacity-reservations-result))

(clojure.core/defn describe-reserved-instances-modifications "Describes the modifications made to your Reserved Instances. If no parameter is\nspecified, information about all your Reserved Instances modification requests\nis returned. If a modification ID is specified, only information about the\nspecific modification is returned.\n For more information, see Modifying Reserved Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-modifying.html) in the\nAmazon Elastic Compute Cloud User Guide." ([] (describe-reserved-instances-modifications {})) ([describe-reserved-instances-modifications-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-reserved-instances-modifications-request describe-reserved-instances-modifications-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-reserved-instances-modifications-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-reserved-instances-modifications-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeReservedInstancesModifications", :http.request.configuration/output-deser-fn response-describe-reserved-instances-modifications-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-reserved-instances-modifications :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-reserved-instances-modifications-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-reserved-instances-modifications-result))

(clojure.core/defn modify-client-vpn-endpoint "Modifies the specified Client VPN endpoint. You can only modify an endpoint's\nserver certificate information, client connection logging information, DNS\nserver, and description. Modifying the DNS server resets existing client\nconnections." ([modify-client-vpn-endpoint-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-client-vpn-endpoint-request modify-client-vpn-endpoint-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-client-vpn-endpoint-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-client-vpn-endpoint-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyClientVpnEndpoint", :http.request.configuration/output-deser-fn response-modify-client-vpn-endpoint-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-client-vpn-endpoint :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-client-vpn-endpoint-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-client-vpn-endpoint-result))

(clojure.core/defn create-route-table "Creates a route table for the specified VPC. After you create a route table, you\ncan add routes and associate the table with a subnet.\n For more information, see Route Tables\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html)\nin the Amazon Virtual Private Cloud User Guide." ([create-route-table-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-route-table-request create-route-table-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-route-table-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-route-table-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRouteTable", :http.request.configuration/output-deser-fn response-create-route-table-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-route-table :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-route-table-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-route-table-result))

(clojure.core/defn create-launch-template "Creates a launch template. A launch template contains the parameters to launch\nan instance. When you launch an instance using RunInstances, you can specify a\nlaunch template instead of providing the launch parameters in the request." ([create-launch-template-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-launch-template-request create-launch-template-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-launch-template-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-launch-template-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateLaunchTemplate", :http.request.configuration/output-deser-fn response-create-launch-template-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-launch-template :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-launch-template-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-launch-template-result))

(clojure.core/defn disassociate-address "Disassociates an Elastic IP address from the instance or network interface it's\nassociated with.\n An Elastic IP address is for use in either the EC2-Classic platform or in a\nVPC. For more information, see Elastic IP Addresses\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)\nin the Amazon Elastic Compute Cloud User Guide.\n This is an idempotent operation. If you perform the operation more than once,\nAmazon EC2 doesn't return an error." ([] (disassociate-address {})) ([disassociate-address-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disassociate-address-request disassociate-address-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disassociate-address-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisassociateAddress", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disassociate-address :args (clojure.spec.alpha/? :portkey.aws.ec2/disassociate-address-request) :ret clojure.core/true?)

(clojure.core/defn describe-network-interface-attribute "Describes a network interface attribute. You can specify only one attribute at a\ntime." ([describe-network-interface-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-network-interface-attribute-request describe-network-interface-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-network-interface-attribute-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-network-interface-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeNetworkInterfaceAttribute", :http.request.configuration/output-deser-fn response-describe-network-interface-attribute-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-network-interface-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-network-interface-attribute-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-network-interface-attribute-result))

(clojure.core/defn describe-prefix-lists "Describes available AWS services in a prefix list format, which includes the\nprefix list name and prefix list ID of the service and the IP address range for\nthe service. A prefix list ID is required for creating an outbound security\ngroup rule that allows traffic from a VPC to access an AWS service through a\ngateway VPC endpoint. Currently, the services that support this action are\nAmazon S3 and Amazon DynamoDB." ([] (describe-prefix-lists {})) ([describe-prefix-lists-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-prefix-lists-request describe-prefix-lists-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-prefix-lists-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-prefix-lists-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribePrefixLists", :http.request.configuration/output-deser-fn response-describe-prefix-lists-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-prefix-lists :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-prefix-lists-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-prefix-lists-result))

(clojure.core/defn describe-availability-zones "Describes one or more of the Availability Zones that are available to you. The\nresults include zones only for the region you're currently using. If there is an\nevent impacting an Availability Zone, you can use this request to view the state\nand any provided message for that Availability Zone.\n For more information, see Regions and Availability Zones\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html)\nin the Amazon Elastic Compute Cloud User Guide." ([] (describe-availability-zones {})) ([describe-availability-zones-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-availability-zones-request describe-availability-zones-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-availability-zones-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-availability-zones-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAvailabilityZones", :http.request.configuration/output-deser-fn response-describe-availability-zones-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-availability-zones :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-availability-zones-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-availability-zones-result))

(clojure.core/defn create-route "Creates a route in a route table within a VPC.\n You must specify one of the following targets: internet gateway or virtual\nprivate gateway, NAT instance, NAT gateway, VPC peering connection, network\ninterface, or egress-only internet gateway.\n When determining how to route traffic, we use the route with the most specific\nmatch. For example, traffic is destined for the IPv4 address 192.0.2.3, and the\nroute table includes the following two IPv4 routes:\n * 192.0.2.0/24 (goes to some target A)\n * 192.0.2.0/28 (goes to some target B)\n Both routes apply to the traffic destined for 192.0.2.3. However, the second\nroute in the list covers a smaller number of IP addresses and is therefore more\nspecific, so we use that route to determine where to target the traffic.\n For more information about route tables, see Route Tables\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html)\nin the Amazon Virtual Private Cloud User Guide." ([create-route-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-route-request create-route-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-route-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-route-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRoute", :http.request.configuration/output-deser-fn response-create-route-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-route :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-route-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-route-result))

(clojure.core/defn create-nat-gateway "Creates a NAT gateway in the specified public subnet. This action creates a\nnetwork interface in the specified subnet with a private IP address from the IP\naddress range of the subnet. Internet-bound traffic from a private subnet can be\nrouted to the NAT gateway, therefore enabling instances in the private subnet to\nconnect to the internet. For more information, see NAT Gateways\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html) in\nthe Amazon Virtual Private Cloud User Guide." ([create-nat-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-nat-gateway-request create-nat-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-nat-gateway-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-nat-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateNatGateway", :http.request.configuration/output-deser-fn response-create-nat-gateway-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-nat-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-nat-gateway-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-nat-gateway-result))

(clojure.core/defn describe-snapshot-attribute "Describes the specified attribute of the specified snapshot. You can specify\nonly one attribute at a time.\n For more information about EBS snapshots, see Amazon EBS Snapshots\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSSnapshots.html) in the\nAmazon Elastic Compute Cloud User Guide." ([describe-snapshot-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-snapshot-attribute-request describe-snapshot-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-snapshot-attribute-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-snapshot-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSnapshotAttribute", :http.request.configuration/output-deser-fn response-describe-snapshot-attribute-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-snapshot-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-snapshot-attribute-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-snapshot-attribute-result))

(clojure.core/defn delete-customer-gateway "Deletes the specified customer gateway. You must delete the VPN connection\nbefore you can delete the customer gateway." ([delete-customer-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-customer-gateway-request delete-customer-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-customer-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteCustomerGateway", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-customer-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-customer-gateway-request) :ret clojure.core/true?)

(clojure.core/defn describe-client-vpn-routes "Describes the routes for the specified Client VPN endpoint." ([describe-client-vpn-routes-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-client-vpn-routes-request describe-client-vpn-routes-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-client-vpn-routes-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-client-vpn-routes-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeClientVpnRoutes", :http.request.configuration/output-deser-fn response-describe-client-vpn-routes-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-client-vpn-routes :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-client-vpn-routes-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-client-vpn-routes-result))

(clojure.core/defn detach-network-interface "Detaches a network interface from an instance." ([detach-network-interface-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-detach-network-interface-request detach-network-interface-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/detach-network-interface-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachNetworkInterface", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef detach-network-interface :args (clojure.spec.alpha/tuple :portkey.aws.ec2/detach-network-interface-request) :ret clojure.core/true?)

(clojure.core/defn attach-internet-gateway "Attaches an internet gateway to a VPC, enabling connectivity between the\ninternet and the VPC. For more information about your VPC and internet gateway,\nsee the Amazon Virtual Private Cloud User Guide\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/)." ([attach-internet-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-attach-internet-gateway-request attach-internet-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/attach-internet-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachInternetGateway", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef attach-internet-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/attach-internet-gateway-request) :ret clojure.core/true?)

(clojure.core/defn associate-address "Associates an Elastic IP address with an instance or a network interface. Before\nyou can use an Elastic IP address, you must allocate it to your account.\n An Elastic IP address is for use in either the EC2-Classic platform or in a\nVPC. For more information, see Elastic IP Addresses\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)\nin the Amazon Elastic Compute Cloud User Guide.\n [EC2-Classic, VPC in an EC2-VPC-only account] If the Elastic IP address is\nalready associated with a different instance, it is disassociated from that\ninstance and associated with the specified instance. If you associate an Elastic\nIP address with an instance that has an existing Elastic IP address, the\nexisting address is disassociated from the instance, but remains allocated to\nyour account.\n [VPC in an EC2-Classic account] If you don't specify a private IP address, the\nElastic IP address is associated with the primary IP address. If the Elastic IP\naddress is already associated with a different instance or a network interface,\nyou get an error unless you allow reassociation. You cannot associate an Elastic\nIP address with an instance or network interface that has an existing Elastic IP\naddress.\n This is an idempotent operation. If you perform the operation more than once,\nAmazon EC2 doesn't return an error, and you may be charged for each time the\nElastic IP address is remapped to the same instance. For more information, see\nthe Elastic IP Addresses section of Amazon EC2 Pricing\n(http://aws.amazon.com/ec2/pricing/)." ([] (associate-address {})) ([associate-address-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-associate-address-request associate-address-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/associate-address-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/associate-address-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssociateAddress", :http.request.configuration/output-deser-fn response-associate-address-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef associate-address :args (clojure.spec.alpha/? :portkey.aws.ec2/associate-address-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/associate-address-result))

(clojure.core/defn delete-tags "Deletes the specified set of tags from the specified set of resources.\n To list the current tags, use DescribeTags. For more information about tags,\nsee Tagging Your Resources\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html) in the\nAmazon Elastic Compute Cloud User Guide." ([delete-tags-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-tags-request delete-tags-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-tags-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteTags", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-tags :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-tags-request) :ret clojure.core/true?)

(clojure.core/defn associate-iam-instance-profile "Associates an IAM instance profile with a running or stopped instance. You\ncannot associate more than one IAM instance profile with an instance." ([associate-iam-instance-profile-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-associate-iam-instance-profile-request associate-iam-instance-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/associate-iam-instance-profile-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/associate-iam-instance-profile-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssociateIamInstanceProfile", :http.request.configuration/output-deser-fn response-associate-iam-instance-profile-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef associate-iam-instance-profile :args (clojure.spec.alpha/tuple :portkey.aws.ec2/associate-iam-instance-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/associate-iam-instance-profile-result))

(clojure.core/defn delete-transit-gateway-vpc-attachment "Deletes the specified VPC attachment." ([delete-transit-gateway-vpc-attachment-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-transit-gateway-vpc-attachment-request delete-transit-gateway-vpc-attachment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-transit-gateway-vpc-attachment-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-transit-gateway-vpc-attachment-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteTransitGatewayVpcAttachment", :http.request.configuration/output-deser-fn response-delete-transit-gateway-vpc-attachment-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-transit-gateway-vpc-attachment :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-transit-gateway-vpc-attachment-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-transit-gateway-vpc-attachment-result))

(clojure.core/defn describe-moving-addresses "Describes your Elastic IP addresses that are being moved to the EC2-VPC\nplatform, or that are being restored to the EC2-Classic platform. This request\ndoes not return information about any other Elastic IP addresses in your\naccount." ([] (describe-moving-addresses {})) ([describe-moving-addresses-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-moving-addresses-request describe-moving-addresses-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-moving-addresses-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-moving-addresses-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMovingAddresses", :http.request.configuration/output-deser-fn response-describe-moving-addresses-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-moving-addresses :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-moving-addresses-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-moving-addresses-result))

(clojure.core/defn enable-transit-gateway-route-table-propagation "Enables the specified attachment to propagate routes to the specified\npropagation route table." ([enable-transit-gateway-route-table-propagation-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-enable-transit-gateway-route-table-propagation-request enable-transit-gateway-route-table-propagation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/enable-transit-gateway-route-table-propagation-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/enable-transit-gateway-route-table-propagation-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "EnableTransitGatewayRouteTablePropagation", :http.request.configuration/output-deser-fn response-enable-transit-gateway-route-table-propagation-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef enable-transit-gateway-route-table-propagation :args (clojure.spec.alpha/tuple :portkey.aws.ec2/enable-transit-gateway-route-table-propagation-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/enable-transit-gateway-route-table-propagation-result))

(clojure.core/defn deprovision-byoip-cidr "Releases the specified address range that you provisioned for use with your AWS\nresources through bring your own IP addresses (BYOIP) and deletes the\ncorresponding address pool.\n Before you can release an address range, you must stop advertising it using\nWithdrawByoipCidr and you must not have any IP addresses allocated from its\naddress range." ([deprovision-byoip-cidr-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-deprovision-byoip-cidr-request deprovision-byoip-cidr-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/deprovision-byoip-cidr-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/deprovision-byoip-cidr-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeprovisionByoipCidr", :http.request.configuration/output-deser-fn response-deprovision-byoip-cidr-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef deprovision-byoip-cidr :args (clojure.spec.alpha/tuple :portkey.aws.ec2/deprovision-byoip-cidr-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/deprovision-byoip-cidr-result))

(clojure.core/defn modify-instance-attribute "Modifies the specified attribute of the specified instance. You can specify only\none attribute at a time.\n Note: Using this action to change the security groups associated with an\nelastic network interface (ENI) attached to an instance in a VPC can result in\nan error if the instance has more than one ENI. To change the security groups\nassociated with an ENI attached to an instance that has multiple ENIs, we\nrecommend that you use the ModifyNetworkInterfaceAttribute action.\n To modify some attributes, the instance must be stopped. For more information,\nsee Modifying Attributes of a Stopped Instance\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_ChangingAttributesWhileInstanceStopped.html)\nin the Amazon Elastic Compute Cloud User Guide." ([modify-instance-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-instance-attribute-request modify-instance-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-instance-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyInstanceAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-instance-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-instance-attribute-request) :ret clojure.core/true?)

(clojure.core/defn delete-fpga-image "Deletes the specified Amazon FPGA Image (AFI)." ([delete-fpga-image-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-fpga-image-request delete-fpga-image-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-fpga-image-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-fpga-image-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteFpgaImage", :http.request.configuration/output-deser-fn response-delete-fpga-image-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-fpga-image :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-fpga-image-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-fpga-image-result))

(clojure.core/defn cancel-export-task "Cancels an active export task. The request removes all artifacts of the export,\nincluding any partially-created Amazon S3 objects. If the export task is\ncomplete or is in the process of transferring the final disk image, the command\nfails and returns an error." ([cancel-export-task-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-cancel-export-task-request cancel-export-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/cancel-export-task-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelExportTask", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef cancel-export-task :args (clojure.spec.alpha/tuple :portkey.aws.ec2/cancel-export-task-request) :ret clojure.core/true?)

(clojure.core/defn modify-capacity-reservation "Modifies a Capacity Reservation's capacity and the conditions under which it is\nto be released. You cannot change a Capacity Reservation's instance type, EBS\noptimization, instance store settings, platform, Availability Zone, or instance\neligibility. If you need to modify any of these attributes, we recommend that\nyou cancel the Capacity Reservation, and then create a new one with the required\nattributes." ([modify-capacity-reservation-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-capacity-reservation-request modify-capacity-reservation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-capacity-reservation-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-capacity-reservation-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyCapacityReservation", :http.request.configuration/output-deser-fn response-modify-capacity-reservation-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-capacity-reservation :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-capacity-reservation-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-capacity-reservation-result))

(clojure.core/defn describe-images "Describes one or more of the images (AMIs, AKIs, and ARIs) available to you.\nImages available to you include public images, private images that you own, and\nprivate images owned by other AWS accounts but for which you have explicit\nlaunch permissions.\n Deregistered images are included in the returned results for an unspecified\ninterval after deregistration." ([] (describe-images {})) ([describe-images-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-images-request describe-images-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-images-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-images-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeImages", :http.request.configuration/output-deser-fn response-describe-images-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-images :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-images-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-images-result))

(clojure.core/defn describe-instance-attribute "Describes the specified attribute of the specified instance. You can specify\nonly one attribute at a time. Valid attribute values are: instanceType | kernel\n| ramdisk | userData | disableApiTermination | instanceInitiatedShutdownBehavior\n| rootDeviceName | blockDeviceMapping | productCodes | sourceDestCheck |\ngroupSet | ebsOptimized | sriovNetSupport" ([describe-instance-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-instance-attribute-request describe-instance-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/instance-attribute, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-instance-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstanceAttribute", :http.request.configuration/output-deser-fn response-instance-attribute, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-instance-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-instance-attribute-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/instance-attribute))

(clojure.core/defn describe-id-format "Describes the ID format settings for your resources on a per-region basis, for\nexample, to view which resource types are enabled for longer IDs. This request\nonly returns information about resource types whose ID formats can be modified;\nit does not return information about other resource types.\n The following resource types support longer IDs: bundle | conversion-task |\ncustomer-gateway | dhcp-options | elastic-ip-allocation | elastic-ip-association\n| export-task | flow-log | image | import-task | instance | internet-gateway |\nnetwork-acl | network-acl-association | network-interface |\nnetwork-interface-attachment | prefix-list | reservation | route-table |\nroute-table-association | security-group | snapshot | subnet |\nsubnet-cidr-block-association | volume | vpc | vpc-cidr-block-association |\nvpc-endpoint | vpc-peering-connection | vpn-connection | vpn-gateway.\n These settings apply to the IAM user who makes the request; they do not apply\nto the entire AWS account. By default, an IAM user defaults to the same settings\nas the root user, unless they explicitly override the settings by running the\nModifyIdFormat command. Resources created with longer IDs are visible to all IAM\nusers, regardless of these settings and provided that they have permission to\nuse the relevant Describe command for the resource type." ([] (describe-id-format {})) ([describe-id-format-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-id-format-request describe-id-format-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-id-format-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-id-format-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeIdFormat", :http.request.configuration/output-deser-fn response-describe-id-format-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-id-format :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-id-format-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-id-format-result))

(clojure.core/defn modify-instance-credit-specification "Modifies the credit option for CPU usage on a running or stopped T2 or T3\ninstance. The credit options are standard and unlimited.\n For more information, see Burstable Performance Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html)\nin the Amazon Elastic Compute Cloud User Guide." ([modify-instance-credit-specification-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-instance-credit-specification-request modify-instance-credit-specification-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-instance-credit-specification-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-instance-credit-specification-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyInstanceCreditSpecification", :http.request.configuration/output-deser-fn response-modify-instance-credit-specification-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-instance-credit-specification :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-instance-credit-specification-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-instance-credit-specification-result))

(clojure.core/defn reset-network-interface-attribute "Resets a network interface attribute. You can specify only one attribute at a\ntime." ([reset-network-interface-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-reset-network-interface-attribute-request reset-network-interface-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/reset-network-interface-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ResetNetworkInterfaceAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef reset-network-interface-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/reset-network-interface-attribute-request) :ret clojure.core/true?)

(clojure.core/defn describe-reserved-instances-listings "Describes your account's Reserved Instance listings in the Reserved Instance\nMarketplace.\n The Reserved Instance Marketplace matches sellers who want to resell Reserved\nInstance capacity that they no longer need with buyers who want to purchase\nadditional capacity. Reserved Instances bought and sold through the Reserved\nInstance Marketplace work like any other Reserved Instances.\n As a seller, you choose to list some or all of your Reserved Instances, and you\nspecify the upfront price to receive for them. Your Reserved Instances are then\nlisted in the Reserved Instance Marketplace and are available for purchase.\n As a buyer, you specify the configuration of the Reserved Instance to purchase,\nand the Marketplace matches what you're searching for with what's available. The\nMarketplace first sells the lowest priced Reserved Instances to you, and\ncontinues to sell available Reserved Instance listings to you until your demand\nis met. You are charged based on the total price of all of the listings that you\npurchase.\n For more information, see Reserved Instance Marketplace\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-market-general.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([] (describe-reserved-instances-listings {})) ([describe-reserved-instances-listings-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-reserved-instances-listings-request describe-reserved-instances-listings-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-reserved-instances-listings-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-reserved-instances-listings-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeReservedInstancesListings", :http.request.configuration/output-deser-fn response-describe-reserved-instances-listings-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-reserved-instances-listings :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-reserved-instances-listings-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-reserved-instances-listings-result))

(clojure.core/defn describe-security-group-references "[EC2-VPC only] Describes the VPCs on the other side of a VPC peering connection\nthat are referencing the security groups you've specified in this request." ([describe-security-group-references-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-security-group-references-request describe-security-group-references-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-security-group-references-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-security-group-references-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSecurityGroupReferences", :http.request.configuration/output-deser-fn response-describe-security-group-references-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-security-group-references :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-security-group-references-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-security-group-references-result))

(clojure.core/defn associate-dhcp-options "Associates a set of DHCP options (that you've previously created) with the\nspecified VPC, or associates no DHCP options with the VPC.\n After you associate the options with the VPC, any existing instances and all\nnew instances that you launch in that VPC use the options. You don't need to\nrestart or relaunch the instances. They automatically pick up the changes within\na few hours, depending on how frequently the instance renews its DHCP lease. You\ncan explicitly renew the lease using the operating system on the instance.\n For more information, see DHCP Options Sets\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html)\nin the Amazon Virtual Private Cloud User Guide." ([associate-dhcp-options-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-associate-dhcp-options-request associate-dhcp-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/associate-dhcp-options-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssociateDhcpOptions", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef associate-dhcp-options :args (clojure.spec.alpha/tuple :portkey.aws.ec2/associate-dhcp-options-request) :ret clojure.core/true?)

(clojure.core/defn create-tags "Adds or overwrites one or more tags for the specified Amazon EC2 resource or\nresources. Each resource can have a maximum of 50 tags. Each tag consists of a\nkey and optional value. Tag keys must be unique per resource.\n For more information about tags, see Tagging Your Resources\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html) in the\nAmazon Elastic Compute Cloud User Guide. For more information about creating IAM\npolicies that control users' access to resources based on tags, see Supported\nResource-Level Permissions for Amazon EC2 API Actions\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-iam-actions-resources.html)\nin the Amazon Elastic Compute Cloud User Guide." ([create-tags-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-tags-request create-tags-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-tags-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateTags", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-tags :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-tags-request) :ret clojure.core/true?)

(clojure.core/defn disassociate-client-vpn-target-network "Disassociates a target network from the specified Client VPN endpoint. When you\ndisassociate the last target network from a Client VPN, the following happens:\n * The route that was automatically added for the VPC is deleted\n * All active client connections are terminated\n * New client connections are disallowed\n * The Client VPN endpoint's status changes to pending-associate" ([disassociate-client-vpn-target-network-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disassociate-client-vpn-target-network-request disassociate-client-vpn-target-network-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/disassociate-client-vpn-target-network-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disassociate-client-vpn-target-network-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisassociateClientVpnTargetNetwork", :http.request.configuration/output-deser-fn response-disassociate-client-vpn-target-network-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disassociate-client-vpn-target-network :args (clojure.spec.alpha/tuple :portkey.aws.ec2/disassociate-client-vpn-target-network-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/disassociate-client-vpn-target-network-result))

(clojure.core/defn revoke-security-group-ingress "Removes one or more ingress rules from a security group. To remove a rule, the\nvalues that you specify (for example, ports) must match the existing rule's\nvalues exactly.\n [EC2-Classic security groups only] If the values you specify do not match the\nexisting rule's values, no error is returned. Use DescribeSecurityGroups to\nverify that the rule has been removed.\n Each rule consists of the protocol and the CIDR range or source security group.\nFor the TCP and UDP protocols, you must also specify the destination port or\nrange of ports. For the ICMP protocol, you must also specify the ICMP type and\ncode. If the security group rule has a description, you do not have to specify\nthe description to revoke the rule.\n Rule changes are propagated to instances within the security group as quickly\nas possible. However, a small delay might occur." ([] (revoke-security-group-ingress {})) ([revoke-security-group-ingress-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-revoke-security-group-ingress-request revoke-security-group-ingress-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/revoke-security-group-ingress-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RevokeSecurityGroupIngress", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef revoke-security-group-ingress :args (clojure.spec.alpha/? :portkey.aws.ec2/revoke-security-group-ingress-request) :ret clojure.core/true?)

(clojure.core/defn authorize-security-group-ingress "Adds one or more ingress rules to a security group.\n Rule changes are propagated to instances within the security group as quickly\nas possible. However, a small delay might occur.\n [EC2-Classic] This action gives one or more IPv4 CIDR address ranges permission\nto access a security group in your account, or gives one or more security groups\n(called the source groups) permission to access a security group for your\naccount. A source group can be for your own AWS account, or another. You can\nhave up to 100 rules per group.\n [EC2-VPC] This action gives one or more IPv4 or IPv6 CIDR address ranges\npermission to access a security group in your VPC, or gives one or more other\nsecurity groups (called the source groups) permission to access a security group\nfor your VPC. The security groups must all be for the same VPC or a peer VPC in\na VPC peering connection. For more information about VPC security group limits,\nsee Amazon VPC Limits\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Appendix_Limits.html).\n You can optionally specify a description for the security group rule." ([] (authorize-security-group-ingress {})) ([authorize-security-group-ingress-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-authorize-security-group-ingress-request authorize-security-group-ingress-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/authorize-security-group-ingress-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AuthorizeSecurityGroupIngress", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef authorize-security-group-ingress :args (clojure.spec.alpha/? :portkey.aws.ec2/authorize-security-group-ingress-request) :ret clojure.core/true?)

(clojure.core/defn describe-transit-gateway-route-tables "Describes one or more transit gateway route tables. By default, all transit\ngateway route tables are described. Alternatively, you can filter the results." ([] (describe-transit-gateway-route-tables {})) ([describe-transit-gateway-route-tables-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-transit-gateway-route-tables-request describe-transit-gateway-route-tables-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-transit-gateway-route-tables-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-transit-gateway-route-tables-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeTransitGatewayRouteTables", :http.request.configuration/output-deser-fn response-describe-transit-gateway-route-tables-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-transit-gateway-route-tables :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-transit-gateway-route-tables-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-transit-gateway-route-tables-result))

(clojure.core/defn describe-client-vpn-target-networks "Describes the target networks associated with the specified Client VPN endpoint." ([describe-client-vpn-target-networks-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-client-vpn-target-networks-request describe-client-vpn-target-networks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-client-vpn-target-networks-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-client-vpn-target-networks-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeClientVpnTargetNetworks", :http.request.configuration/output-deser-fn response-describe-client-vpn-target-networks-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-client-vpn-target-networks :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-client-vpn-target-networks-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-client-vpn-target-networks-result))

(clojure.core/defn describe-vpc-endpoint-services "Describes available services to which you can create a VPC endpoint." ([] (describe-vpc-endpoint-services {})) ([describe-vpc-endpoint-services-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpc-endpoint-services-request describe-vpc-endpoint-services-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpc-endpoint-services-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpc-endpoint-services-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcEndpointServices", :http.request.configuration/output-deser-fn response-describe-vpc-endpoint-services-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpc-endpoint-services :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpc-endpoint-services-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-endpoint-services-result))

(clojure.core/defn create-snapshot "Creates a snapshot of an EBS volume and stores it in Amazon S3. You can use\nsnapshots for backups, to make copies of EBS volumes, and to save data before\nshutting down an instance.\n When a snapshot is created, any AWS Marketplace product codes that are\nassociated with the source volume are propagated to the snapshot.\n You can take a snapshot of an attached volume that is in use. However,\nsnapshots only capture data that has been written to your EBS volume at the time\nthe snapshot command is issued; this may exclude any data that has been cached\nby any applications or the operating system. If you can pause any file systems\non the volume long enough to take a snapshot, your snapshot should be complete.\nHowever, if you cannot pause all file writes to the volume, you should unmount\nthe volume from within the instance, issue the snapshot command, and then\nremount the volume to ensure a consistent and complete snapshot. You may remount\nand use your volume while the snapshot status is pending.\n To create a snapshot for EBS volumes that serve as root devices, you should\nstop the instance before taking the snapshot.\n Snapshots that are taken from encrypted volumes are automatically encrypted.\nVolumes that are created from encrypted snapshots are also automatically\nencrypted. Your encrypted volumes and any associated snapshots always remain\nprotected.\n You can tag your snapshots during creation. For more information, see Tagging\nYour Amazon EC2 Resources\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html) in the\nAmazon Elastic Compute Cloud User Guide.\n For more information, see Amazon Elastic Block Store\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AmazonEBS.html) and Amazon\nEBS Encryption\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) in the\nAmazon Elastic Compute Cloud User Guide." ([create-snapshot-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-snapshot-request create-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/snapshot, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-snapshot-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateSnapshot", :http.request.configuration/output-deser-fn response-snapshot, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/snapshot))

(clojure.core/defn search-transit-gateway-routes "Searches for routes in the specified transit gateway route table." ([search-transit-gateway-routes-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-search-transit-gateway-routes-request search-transit-gateway-routes-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/search-transit-gateway-routes-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/search-transit-gateway-routes-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SearchTransitGatewayRoutes", :http.request.configuration/output-deser-fn response-search-transit-gateway-routes-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef search-transit-gateway-routes :args (clojure.spec.alpha/tuple :portkey.aws.ec2/search-transit-gateway-routes-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/search-transit-gateway-routes-result))

(clojure.core/defn import-key-pair "Imports the public key from an RSA key pair that you created with a third-party\ntool. Compare this with CreateKeyPair, in which AWS creates the key pair and\ngives the keys to you (AWS keeps a copy of the public key). With ImportKeyPair,\nyou create the key pair and give AWS just the public key. The private key is\nnever transferred between you and AWS.\n For more information about key pairs, see Key Pairs\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html) in the\nAmazon Elastic Compute Cloud User Guide." ([import-key-pair-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-import-key-pair-request import-key-pair-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/import-key-pair-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/import-key-pair-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportKeyPair", :http.request.configuration/output-deser-fn response-import-key-pair-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef import-key-pair :args (clojure.spec.alpha/tuple :portkey.aws.ec2/import-key-pair-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/import-key-pair-result))

(clojure.core/defn describe-export-tasks "Describes one or more of your export tasks." ([] (describe-export-tasks {})) ([describe-export-tasks-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-export-tasks-request describe-export-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-export-tasks-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-export-tasks-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeExportTasks", :http.request.configuration/output-deser-fn response-describe-export-tasks-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-export-tasks :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-export-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-export-tasks-result))

(clojure.core/defn describe-volume-attribute "Describes the specified attribute of the specified volume. You can specify only\none attribute at a time.\n For more information about EBS volumes, see Amazon EBS Volumes\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumes.html) in the\nAmazon Elastic Compute Cloud User Guide." ([describe-volume-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-volume-attribute-request describe-volume-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-volume-attribute-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-volume-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVolumeAttribute", :http.request.configuration/output-deser-fn response-describe-volume-attribute-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-volume-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-volume-attribute-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-volume-attribute-result))

(clojure.core/defn describe-scheduled-instances "Describes one or more of your Scheduled Instances." ([] (describe-scheduled-instances {})) ([describe-scheduled-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-scheduled-instances-request describe-scheduled-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-scheduled-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-scheduled-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeScheduledInstances", :http.request.configuration/output-deser-fn response-describe-scheduled-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-scheduled-instances :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-scheduled-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-scheduled-instances-result))

(clojure.core/defn describe-spot-datafeed-subscription "Describes the data feed for Spot Instances. For more information, see Spot\nInstance Data Feed\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-data-feeds.html) in\nthe Amazon EC2 User Guide for Linux Instances." ([] (describe-spot-datafeed-subscription {})) ([describe-spot-datafeed-subscription-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-spot-datafeed-subscription-request describe-spot-datafeed-subscription-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-spot-datafeed-subscription-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-spot-datafeed-subscription-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSpotDatafeedSubscription", :http.request.configuration/output-deser-fn response-describe-spot-datafeed-subscription-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-spot-datafeed-subscription :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-spot-datafeed-subscription-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-spot-datafeed-subscription-result))

(clojure.core/defn describe-volumes-modifications "Reports the current modification status of EBS volumes.\n Current-generation EBS volumes support modification of attributes including\ntype, size, and (for io1 volumes) IOPS provisioning while either attached to or\ndetached from an instance. Following an action from the API or the console to\nmodify a volume, the status of the modification may be modifying, optimizing,\ncompleted, or failed. If a volume has never been modified, then certain elements\nof the returned VolumeModification objects are null.\n You can also use CloudWatch Events to check the status of a modification to an\nEBS volume. For information about CloudWatch Events, see the Amazon CloudWatch\nEvents User Guide (https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/).\nFor more information, see Monitoring Volume Modifications\"\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-expand-volume.html#monitoring_mods)\nin the Amazon Elastic Compute Cloud User Guide." ([] (describe-volumes-modifications {})) ([describe-volumes-modifications-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-volumes-modifications-request describe-volumes-modifications-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-volumes-modifications-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-volumes-modifications-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVolumesModifications", :http.request.configuration/output-deser-fn response-describe-volumes-modifications-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-volumes-modifications :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-volumes-modifications-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-volumes-modifications-result))

(clojure.core/defn assign-ipv-6-addresses "Assigns one or more IPv6 addresses to the specified network interface. You can\nspecify one or more specific IPv6 addresses, or you can specify the number of\nIPv6 addresses to be automatically assigned from within the subnet's IPv6 CIDR\nblock range. You can assign as many IPv6 addresses to a network interface as you\ncan assign private IPv4 addresses, and the limit varies per instance type. For\ninformation, see IP Addresses Per Network Interface Per Instance Type\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI)\nin the Amazon Elastic Compute Cloud User Guide." ([assign-ipv-6-addresses-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-assign-ipv-6-addresses-request assign-ipv-6-addresses-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/assign-ipv-6-addresses-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/assign-ipv-6-addresses-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssignIpv6Addresses", :http.request.configuration/output-deser-fn response-assign-ipv-6-addresses-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef assign-ipv-6-addresses :args (clojure.spec.alpha/tuple :portkey.aws.ec2/assign-ipv-6-addresses-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/assign-ipv-6-addresses-result))

(clojure.core/defn reject-transit-gateway-vpc-attachment "Rejects a request to attach a VPC to a transit gateway.\n The VPC attachment must be in the pendingAcceptance state. Use\nDescribeTransitGatewayVpcAttachments to view your pending VPC attachment\nrequests. Use AcceptTransitGatewayVpcAttachment to accept a VPC attachment\nrequest." ([reject-transit-gateway-vpc-attachment-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-reject-transit-gateway-vpc-attachment-request reject-transit-gateway-vpc-attachment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/reject-transit-gateway-vpc-attachment-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/reject-transit-gateway-vpc-attachment-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RejectTransitGatewayVpcAttachment", :http.request.configuration/output-deser-fn response-reject-transit-gateway-vpc-attachment-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef reject-transit-gateway-vpc-attachment :args (clojure.spec.alpha/tuple :portkey.aws.ec2/reject-transit-gateway-vpc-attachment-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/reject-transit-gateway-vpc-attachment-result))

(clojure.core/defn delete-vpn-gateway "Deletes the specified virtual private gateway. We recommend that before you\ndelete a virtual private gateway, you detach it from the VPC and delete the VPN\nconnection. Note that you don't need to delete the virtual private gateway if\nyou plan to delete and recreate the VPN connection between your VPC and your\nnetwork." ([delete-vpn-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-vpn-gateway-request delete-vpn-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-vpn-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVpnGateway", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-vpn-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-vpn-gateway-request) :ret clojure.core/true?)

(clojure.core/defn disassociate-iam-instance-profile "Disassociates an IAM instance profile from a running or stopped instance.\n Use DescribeIamInstanceProfileAssociations to get the association ID." ([disassociate-iam-instance-profile-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disassociate-iam-instance-profile-request disassociate-iam-instance-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/disassociate-iam-instance-profile-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disassociate-iam-instance-profile-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisassociateIamInstanceProfile", :http.request.configuration/output-deser-fn response-disassociate-iam-instance-profile-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disassociate-iam-instance-profile :args (clojure.spec.alpha/tuple :portkey.aws.ec2/disassociate-iam-instance-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/disassociate-iam-instance-profile-result))

(clojure.core/defn purchase-host-reservation "Purchase a reservation with configurations that match those of your Dedicated\nHost. You must have active Dedicated Hosts in your account before you purchase a\nreservation. This action results in the specified reservation being purchased\nand charged to your account." ([purchase-host-reservation-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-purchase-host-reservation-request purchase-host-reservation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/purchase-host-reservation-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/purchase-host-reservation-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PurchaseHostReservation", :http.request.configuration/output-deser-fn response-purchase-host-reservation-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef purchase-host-reservation :args (clojure.spec.alpha/tuple :portkey.aws.ec2/purchase-host-reservation-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/purchase-host-reservation-result))

(clojure.core/defn describe-vpc-endpoint-service-configurations "Describes the VPC endpoint service configurations in your account (your\nservices)." ([] (describe-vpc-endpoint-service-configurations {})) ([describe-vpc-endpoint-service-configurations-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpc-endpoint-service-configurations-request describe-vpc-endpoint-service-configurations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpc-endpoint-service-configurations-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpc-endpoint-service-configurations-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcEndpointServiceConfigurations", :http.request.configuration/output-deser-fn response-describe-vpc-endpoint-service-configurations-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpc-endpoint-service-configurations :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpc-endpoint-service-configurations-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-endpoint-service-configurations-result))

(clojure.core/defn reject-vpc-peering-connection "Rejects a VPC peering connection request. The VPC peering connection must be in\nthe pending-acceptance state. Use the DescribeVpcPeeringConnections request to\nview your outstanding VPC peering connection requests. To delete an active VPC\npeering connection, or to delete a VPC peering connection request that you\ninitiated, use DeleteVpcPeeringConnection." ([reject-vpc-peering-connection-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-reject-vpc-peering-connection-request reject-vpc-peering-connection-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/reject-vpc-peering-connection-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/reject-vpc-peering-connection-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RejectVpcPeeringConnection", :http.request.configuration/output-deser-fn response-reject-vpc-peering-connection-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef reject-vpc-peering-connection :args (clojure.spec.alpha/tuple :portkey.aws.ec2/reject-vpc-peering-connection-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/reject-vpc-peering-connection-result))

(clojure.core/defn reboot-instances "Requests a reboot of one or more instances. This operation is asynchronous; it\nonly queues a request to reboot the specified instances. The operation succeeds\nif the instances are valid and belong to you. Requests to reboot terminated\ninstances are ignored.\n If an instance does not cleanly shut down within four minutes, Amazon EC2\nperforms a hard reboot.\n For more information about troubleshooting, see Getting Console Output and\nRebooting Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-console.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([reboot-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-reboot-instances-request reboot-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/reboot-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RebootInstances", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef reboot-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/reboot-instances-request) :ret clojure.core/true?)

(clojure.core/defn describe-dhcp-options "Describes one or more of your DHCP options sets.\n For more information, see DHCP Options Sets\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html)\nin the Amazon Virtual Private Cloud User Guide." ([] (describe-dhcp-options {})) ([describe-dhcp-options-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-dhcp-options-request describe-dhcp-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-dhcp-options-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-dhcp-options-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeDhcpOptions", :http.request.configuration/output-deser-fn response-describe-dhcp-options-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-dhcp-options :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-dhcp-options-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-dhcp-options-result))

(clojure.core/defn disassociate-transit-gateway-route-table "Disassociates a resource attachment from a transit gateway route table." ([disassociate-transit-gateway-route-table-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disassociate-transit-gateway-route-table-request disassociate-transit-gateway-route-table-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/disassociate-transit-gateway-route-table-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disassociate-transit-gateway-route-table-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisassociateTransitGatewayRouteTable", :http.request.configuration/output-deser-fn response-disassociate-transit-gateway-route-table-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disassociate-transit-gateway-route-table :args (clojure.spec.alpha/tuple :portkey.aws.ec2/disassociate-transit-gateway-route-table-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/disassociate-transit-gateway-route-table-result))

(clojure.core/defn delete-volume "Deletes the specified EBS volume. The volume must be in the available state (not\nattached to an instance).\n The volume can remain in the deleting state for several minutes.\n For more information, see Deleting an Amazon EBS Volume\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-deleting-volume.html)\nin the Amazon Elastic Compute Cloud User Guide." ([delete-volume-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-volume-request delete-volume-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-volume-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVolume", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-volume :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-volume-request) :ret clojure.core/true?)

(clojure.core/defn allocate-hosts "Allocates a Dedicated Host to your account. At a minimum, specify the instance\nsize type, Availability Zone, and quantity of hosts to allocate." ([allocate-hosts-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-allocate-hosts-request allocate-hosts-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/allocate-hosts-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/allocate-hosts-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AllocateHosts", :http.request.configuration/output-deser-fn response-allocate-hosts-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef allocate-hosts :args (clojure.spec.alpha/tuple :portkey.aws.ec2/allocate-hosts-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/allocate-hosts-result))

(clojure.core/defn describe-spot-fleet-request-history "Describes the events for the specified Spot Fleet request during the specified\ntime.\n Spot Fleet events are delayed by up to 30 seconds before they can be described.\nThis ensures that you can query by the last evaluated time and not miss a\nrecorded event. Spot Fleet events are available for 48 hours." ([describe-spot-fleet-request-history-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-spot-fleet-request-history-request describe-spot-fleet-request-history-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-spot-fleet-request-history-response, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-spot-fleet-request-history-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSpotFleetRequestHistory", :http.request.configuration/output-deser-fn response-describe-spot-fleet-request-history-response, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-spot-fleet-request-history :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-spot-fleet-request-history-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-spot-fleet-request-history-response))

(clojure.core/defn terminate-client-vpn-connections "Terminates active Client VPN endpoint connections. This action can be used to\nterminate a specific client connection, or up to five connections established by\na specific user." ([terminate-client-vpn-connections-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-terminate-client-vpn-connections-request terminate-client-vpn-connections-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/terminate-client-vpn-connections-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/terminate-client-vpn-connections-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TerminateClientVpnConnections", :http.request.configuration/output-deser-fn response-terminate-client-vpn-connections-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef terminate-client-vpn-connections :args (clojure.spec.alpha/tuple :portkey.aws.ec2/terminate-client-vpn-connections-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/terminate-client-vpn-connections-result))

(clojure.core/defn associate-subnet-cidr-block "Associates a CIDR block with your subnet. You can only associate a single IPv6\nCIDR block with your subnet. An IPv6 CIDR block must have a prefix length of\n/64." ([associate-subnet-cidr-block-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-associate-subnet-cidr-block-request associate-subnet-cidr-block-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/associate-subnet-cidr-block-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/associate-subnet-cidr-block-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssociateSubnetCidrBlock", :http.request.configuration/output-deser-fn response-associate-subnet-cidr-block-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef associate-subnet-cidr-block :args (clojure.spec.alpha/tuple :portkey.aws.ec2/associate-subnet-cidr-block-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/associate-subnet-cidr-block-result))

(clojure.core/defn register-image "Registers an AMI. When you're creating an AMI, this is the final step you must\ncomplete before you can launch an instance from the AMI. For more information\nabout creating AMIs, see Creating Your Own AMIs\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/creating-an-ami.html) in\nthe Amazon Elastic Compute Cloud User Guide.\n For Amazon EBS-backed instances, CreateImage creates and registers the AMI in a\nsingle request, so you don't have to register the AMI yourself.\n You can also use RegisterImage to create an Amazon EBS-backed Linux AMI from a\nsnapshot of a root device volume. You specify the snapshot using the block\ndevice mapping. For more information, see Launching a Linux Instance from a\nBackup\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-launch-snapshot.html)\nin the Amazon Elastic Compute Cloud User Guide.\n You can't register an image where a secondary (non-root) snapshot has AWS\nMarketplace product codes.\n Some Linux distributions, such as Red Hat Enterprise Linux (RHEL) and SUSE\nLinux Enterprise Server (SLES), use the EC2 billing product code associated with\nan AMI to verify the subscription status for package updates. Creating an AMI\nfrom an EBS snapshot does not maintain this billing code, and instances launched\nfrom such an AMI are not able to connect to package update infrastructure. If\nyou purchase a Reserved Instance offering for one of these Linux distributions\nand launch instances using an AMI that does not contain the required billing\ncode, your Reserved Instance is not applied to these instances.\n To create an AMI for operating systems that require a billing code, see\nCreateImage.\n If needed, you can deregister an AMI at any time. Any modifications you make to\nan AMI backed by an instance store volume invalidates its registration. If you\nmake changes to an image, deregister the previous image and register the new\nimage." ([register-image-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-register-image-request register-image-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/register-image-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/register-image-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterImage", :http.request.configuration/output-deser-fn response-register-image-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef register-image :args (clojure.spec.alpha/tuple :portkey.aws.ec2/register-image-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/register-image-result))

(clojure.core/defn create-vpc-endpoint-connection-notification "Creates a connection notification for a specified VPC endpoint or VPC endpoint\nservice. A connection notification notifies you of specific endpoint events. You\nmust create an SNS topic to receive notifications. For more information, see\nCreate a Topic (https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html) in\nthe Amazon Simple Notification Service Developer Guide.\n You can create a connection notification for interface endpoints only." ([create-vpc-endpoint-connection-notification-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-vpc-endpoint-connection-notification-request create-vpc-endpoint-connection-notification-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-vpc-endpoint-connection-notification-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-vpc-endpoint-connection-notification-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVpcEndpointConnectionNotification", :http.request.configuration/output-deser-fn response-create-vpc-endpoint-connection-notification-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-vpc-endpoint-connection-notification :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-vpc-endpoint-connection-notification-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-vpc-endpoint-connection-notification-result))

(clojure.core/defn associate-client-vpn-target-network "Associates a target network with a Client VPN endpoint. A target network is a\nsubnet in a VPC. You can associate multiple subnets from the same VPC with a\nClient VPN endpoint. You can associate only one subnet in each Availability\nZone. We recommend that you associate at least two subnets to provide\nAvailability Zone redundancy." ([associate-client-vpn-target-network-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-associate-client-vpn-target-network-request associate-client-vpn-target-network-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/associate-client-vpn-target-network-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/associate-client-vpn-target-network-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssociateClientVpnTargetNetwork", :http.request.configuration/output-deser-fn response-associate-client-vpn-target-network-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef associate-client-vpn-target-network :args (clojure.spec.alpha/tuple :portkey.aws.ec2/associate-client-vpn-target-network-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/associate-client-vpn-target-network-result))

(clojure.core/defn assign-private-ip-addresses "Assigns one or more secondary private IP addresses to the specified network\ninterface.\n You can specify one or more specific secondary IP addresses, or you can specify\nthe number of secondary IP addresses to be automatically assigned within the\nsubnet's CIDR block range. The number of secondary IP addresses that you can\nassign to an instance varies by instance type. For information about instance\ntypes, see Instance Types\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the\nAmazon Elastic Compute Cloud User Guide. For more information about Elastic IP\naddresses, see Elastic IP Addresses\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)\nin the Amazon Elastic Compute Cloud User Guide.\n When you move a secondary private IP address to another network interface, any\nElastic IP address that is associated with the IP address is also moved.\n Remapping an IP address is an asynchronous operation. When you move an IP\naddress from one network interface to another, check\nnetwork/interfaces/macs/mac/local-ipv4s in the instance metadata to confirm that\nthe remapping is complete." ([assign-private-ip-addresses-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-assign-private-ip-addresses-request assign-private-ip-addresses-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/assign-private-ip-addresses-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssignPrivateIpAddresses", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef assign-private-ip-addresses :args (clojure.spec.alpha/tuple :portkey.aws.ec2/assign-private-ip-addresses-request) :ret clojure.core/true?)

(clojure.core/defn describe-vpn-gateways "Describes one or more of your virtual private gateways.\n For more information, see AWS Site-to-Site VPN\n(https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the AWS\nSite-to-Site VPN User Guide." ([] (describe-vpn-gateways {})) ([describe-vpn-gateways-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpn-gateways-request describe-vpn-gateways-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpn-gateways-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpn-gateways-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpnGateways", :http.request.configuration/output-deser-fn response-describe-vpn-gateways-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpn-gateways :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpn-gateways-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpn-gateways-result))

(clojure.core/defn delete-internet-gateway "Deletes the specified internet gateway. You must detach the internet gateway\nfrom the VPC before you can delete it." ([delete-internet-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-internet-gateway-request delete-internet-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-internet-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteInternetGateway", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-internet-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-internet-gateway-request) :ret clojure.core/true?)

(clojure.core/defn create-internet-gateway "Creates an internet gateway for use with a VPC. After creating the internet\ngateway, you attach it to a VPC using AttachInternetGateway.\n For more information about your VPC and internet gateway, see the Amazon\nVirtual Private Cloud User Guide\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/)." ([] (create-internet-gateway {})) ([create-internet-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-internet-gateway-request create-internet-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-internet-gateway-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-internet-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateInternetGateway", :http.request.configuration/output-deser-fn response-create-internet-gateway-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-internet-gateway :args (clojure.spec.alpha/? :portkey.aws.ec2/create-internet-gateway-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-internet-gateway-result))

(clojure.core/defn describe-network-interfaces "Describes one or more of your network interfaces." ([] (describe-network-interfaces {})) ([describe-network-interfaces-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-network-interfaces-request describe-network-interfaces-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-network-interfaces-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-network-interfaces-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeNetworkInterfaces", :http.request.configuration/output-deser-fn response-describe-network-interfaces-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-network-interfaces :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-network-interfaces-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-network-interfaces-result))

(clojure.core/defn import-image "Import single or multi-volume disk images or EBS snapshots into an Amazon\nMachine Image (AMI). For more information, see Importing a VM as an Image Using\nVM Import/Export\n(https://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html)\nin the VM Import/Export User Guide." ([] (import-image {})) ([import-image-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-import-image-request import-image-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/import-image-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/import-image-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportImage", :http.request.configuration/output-deser-fn response-import-image-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef import-image :args (clojure.spec.alpha/? :portkey.aws.ec2/import-image-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/import-image-result))

(clojure.core/defn modify-network-interface-attribute "Modifies the specified network interface attribute. You can specify only one\nattribute at a time." ([modify-network-interface-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-network-interface-attribute-request modify-network-interface-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-network-interface-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyNetworkInterfaceAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-network-interface-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-network-interface-attribute-request) :ret clojure.core/true?)

(clojure.core/defn describe-transit-gateway-vpc-attachments "Describes one or more VPC attachments. By default, all VPC attachments are\ndescribed. Alternatively, you can filter the results." ([] (describe-transit-gateway-vpc-attachments {})) ([describe-transit-gateway-vpc-attachments-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-transit-gateway-vpc-attachments-request describe-transit-gateway-vpc-attachments-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-transit-gateway-vpc-attachments-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-transit-gateway-vpc-attachments-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeTransitGatewayVpcAttachments", :http.request.configuration/output-deser-fn response-describe-transit-gateway-vpc-attachments-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-transit-gateway-vpc-attachments :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-transit-gateway-vpc-attachments-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-transit-gateway-vpc-attachments-result))

(clojure.core/defn delete-vpc "Deletes the specified VPC. You must detach or delete all gateways and resources\nthat are associated with the VPC before you can delete it. For example, you must\nterminate all instances running in the VPC, delete all security groups\nassociated with the VPC (except the default one), delete all route tables\nassociated with the VPC (except the default one), and so on." ([delete-vpc-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-vpc-request delete-vpc-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-vpc-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVpc", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-vpc :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-vpc-request) :ret clojure.core/true?)

(clojure.core/defn describe-network-acls "Describes one or more of your network ACLs.\n For more information, see Network ACLs\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html) in the\nAmazon Virtual Private Cloud User Guide." ([] (describe-network-acls {})) ([describe-network-acls-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-network-acls-request describe-network-acls-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-network-acls-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-network-acls-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeNetworkAcls", :http.request.configuration/output-deser-fn response-describe-network-acls-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-network-acls :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-network-acls-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-network-acls-result))

(clojure.core/defn describe-vpc-classic-link "Describes the ClassicLink status of one or more VPCs." ([] (describe-vpc-classic-link {})) ([describe-vpc-classic-link-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpc-classic-link-request describe-vpc-classic-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpc-classic-link-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpc-classic-link-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcClassicLink", :http.request.configuration/output-deser-fn response-describe-vpc-classic-link-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpc-classic-link :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpc-classic-link-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-classic-link-result))

(clojure.core/defn describe-subnets "Describes one or more of your subnets.\n For more information, see Your VPC and Subnets\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html) in the\nAmazon Virtual Private Cloud User Guide." ([] (describe-subnets {})) ([describe-subnets-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-subnets-request describe-subnets-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-subnets-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-subnets-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSubnets", :http.request.configuration/output-deser-fn response-describe-subnets-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-subnets :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-subnets-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-subnets-result))

(clojure.core/defn describe-bundle-tasks "Describes one or more of your bundling tasks.\n Completed bundle tasks are listed for only a limited time. If your bundle task\nis no longer in the list, you can still register an AMI from it. Just use\nRegisterImage with the Amazon S3 bucket name and image manifest name you\nprovided to the bundle task." ([] (describe-bundle-tasks {})) ([describe-bundle-tasks-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-bundle-tasks-request describe-bundle-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-bundle-tasks-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-bundle-tasks-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeBundleTasks", :http.request.configuration/output-deser-fn response-describe-bundle-tasks-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-bundle-tasks :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-bundle-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-bundle-tasks-result))

(clojure.core/defn describe-scheduled-instance-availability "Finds available schedules that meet the specified criteria.\n You can search for an available schedule no more than 3 months in advance. You\nmust meet the minimum required duration of 1,200 hours per year. For example,\nthe minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours,\nand the minimum monthly schedule is 100 hours.\n After you find a schedule that meets your needs, call\nPurchaseScheduledInstances to purchase Scheduled Instances with that schedule." ([describe-scheduled-instance-availability-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-scheduled-instance-availability-request describe-scheduled-instance-availability-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-scheduled-instance-availability-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-scheduled-instance-availability-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeScheduledInstanceAvailability", :http.request.configuration/output-deser-fn response-describe-scheduled-instance-availability-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-scheduled-instance-availability :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-scheduled-instance-availability-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-scheduled-instance-availability-result))

(clojure.core/defn delete-nat-gateway "Deletes the specified NAT gateway. Deleting a NAT gateway disassociates its\nElastic IP address, but does not release the address from your account. Deleting\na NAT gateway does not delete any NAT gateway routes in your route tables." ([delete-nat-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-nat-gateway-request delete-nat-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-nat-gateway-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-nat-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteNatGateway", :http.request.configuration/output-deser-fn response-delete-nat-gateway-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-nat-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-nat-gateway-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-nat-gateway-result))

(clojure.core/defn report-instance-status "Submits feedback about the status of an instance. The instance must be in the\nrunning state. If your experience with the instance differs from the instance\nstatus returned by DescribeInstanceStatus, use ReportInstanceStatus to report\nyour experience with the instance. Amazon EC2 collects this information to\nimprove the accuracy of status checks.\n Use of this action does not change the value returned by\nDescribeInstanceStatus." ([report-instance-status-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-report-instance-status-request report-instance-status-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/report-instance-status-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReportInstanceStatus", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef report-instance-status :args (clojure.spec.alpha/tuple :portkey.aws.ec2/report-instance-status-request) :ret clojure.core/true?)

(clojure.core/defn enable-vpc-classic-link "Enables a VPC for ClassicLink. You can then link EC2-Classic instances to your\nClassicLink-enabled VPC to allow communication over private IP addresses. You\ncannot enable your VPC for ClassicLink if any of your VPC route tables have\nexisting routes for address ranges within the 10.0.0.0/8 IP address range,\nexcluding local routes for VPCs in the 10.0.0.0/16 and 10.1.0.0/16 IP address\nranges. For more information, see ClassicLink\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([enable-vpc-classic-link-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-enable-vpc-classic-link-request enable-vpc-classic-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/enable-vpc-classic-link-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/enable-vpc-classic-link-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "EnableVpcClassicLink", :http.request.configuration/output-deser-fn response-enable-vpc-classic-link-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef enable-vpc-classic-link :args (clojure.spec.alpha/tuple :portkey.aws.ec2/enable-vpc-classic-link-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/enable-vpc-classic-link-result))

(clojure.core/defn describe-spot-price-history "Describes the Spot price history. For more information, see Spot Instance\nPricing History\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances-history.html)\nin the Amazon EC2 User Guide for Linux Instances.\n When you specify a start and end time, this operation returns the prices of the\ninstance types within the time range that you specified and the time when the\nprice changed. The price is valid within the time period that you specified; the\nresponse merely indicates the last time that the price changed." ([] (describe-spot-price-history {})) ([describe-spot-price-history-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-spot-price-history-request describe-spot-price-history-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-spot-price-history-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-spot-price-history-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSpotPriceHistory", :http.request.configuration/output-deser-fn response-describe-spot-price-history-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-spot-price-history :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-spot-price-history-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-spot-price-history-result))

(clojure.core/defn create-subnet "Creates a subnet in an existing VPC.\n When you create each subnet, you provide the VPC ID and IPv4 CIDR block for the\nsubnet. After you create a subnet, you can't change its CIDR block. The size of\nthe subnet's IPv4 CIDR block can be the same as a VPC's IPv4 CIDR block, or a\nsubset of a VPC's IPv4 CIDR block. If you create more than one subnet in a VPC,\nthe subnets' CIDR blocks must not overlap. The smallest IPv4 subnet (and VPC)\nyou can create uses a /28 netmask (16 IPv4 addresses), and the largest uses a\n/16 netmask (65,536 IPv4 addresses).\n If you've associated an IPv6 CIDR block with your VPC, you can create a subnet\nwith an IPv6 CIDR block that uses a /64 prefix length.\n AWS reserves both the first four and the last IPv4 address in each subnet's\nCIDR block. They're not available for use.\n If you add more than one subnet to a VPC, they're set up in a star topology\nwith a logical router in the middle.\n If you launch an instance in a VPC using an Amazon EBS-backed AMI, the IP\naddress doesn't change if you stop and restart the instance (unlike a similar\ninstance launched outside a VPC, which gets a new IP address when restarted).\nIt's therefore possible to have a subnet with no running instances (they're all\nstopped), but no remaining IP addresses available.\n For more information about subnets, see Your VPC and Subnets\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html) in the\nAmazon Virtual Private Cloud User Guide." ([create-subnet-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-subnet-request create-subnet-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-subnet-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-subnet-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateSubnet", :http.request.configuration/output-deser-fn response-create-subnet-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-subnet :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-subnet-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-subnet-result))

(clojure.core/defn create-vpn-gateway "Creates a virtual private gateway. A virtual private gateway is the endpoint on\nthe VPC side of your VPN connection. You can create a virtual private gateway\nbefore creating the VPC itself.\n For more information, see AWS Site-to-Site VPN\n(https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the AWS\nSite-to-Site VPN User Guide." ([create-vpn-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-vpn-gateway-request create-vpn-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-vpn-gateway-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-vpn-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVpnGateway", :http.request.configuration/output-deser-fn response-create-vpn-gateway-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-vpn-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-vpn-gateway-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-vpn-gateway-result))

(clojure.core/defn modify-vpc-endpoint-connection-notification "Modifies a connection notification for VPC endpoint or VPC endpoint service. You\ncan change the SNS topic for the notification, or the events for which to be\nnotified." ([modify-vpc-endpoint-connection-notification-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-vpc-endpoint-connection-notification-request modify-vpc-endpoint-connection-notification-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-vpc-endpoint-connection-notification-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-vpc-endpoint-connection-notification-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyVpcEndpointConnectionNotification", :http.request.configuration/output-deser-fn response-modify-vpc-endpoint-connection-notification-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-vpc-endpoint-connection-notification :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-vpc-endpoint-connection-notification-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-vpc-endpoint-connection-notification-result))

(clojure.core/defn create-transit-gateway-vpc-attachment "Attaches the specified VPC to the specified transit gateway.\n If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC\nthat is already attached, the new VPC CIDR range is not propagated to the\ndefault propagation route table.\n To send VPC traffic to an attached transit gateway, add a route to the VPC\nroute table using CreateRoute." ([create-transit-gateway-vpc-attachment-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-transit-gateway-vpc-attachment-request create-transit-gateway-vpc-attachment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-transit-gateway-vpc-attachment-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-transit-gateway-vpc-attachment-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateTransitGatewayVpcAttachment", :http.request.configuration/output-deser-fn response-create-transit-gateway-vpc-attachment-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-transit-gateway-vpc-attachment :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-transit-gateway-vpc-attachment-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-transit-gateway-vpc-attachment-result))

(clojure.core/defn modify-launch-template "Modifies a launch template. You can specify which version of the launch template\nto set as the default version. When launching an instance, the default version\napplies when a launch template version is not specified." ([] (modify-launch-template {})) ([modify-launch-template-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-launch-template-request modify-launch-template-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-launch-template-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-launch-template-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyLaunchTemplate", :http.request.configuration/output-deser-fn response-modify-launch-template-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-launch-template :args (clojure.spec.alpha/? :portkey.aws.ec2/modify-launch-template-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-launch-template-result))

(clojure.core/defn disable-vgw-route-propagation "Disables a virtual private gateway (VGW) from propagating routes to a specified\nroute table of a VPC." ([disable-vgw-route-propagation-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disable-vgw-route-propagation-request disable-vgw-route-propagation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disable-vgw-route-propagation-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisableVgwRoutePropagation", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disable-vgw-route-propagation :args (clojure.spec.alpha/tuple :portkey.aws.ec2/disable-vgw-route-propagation-request) :ret clojure.core/true?)

(clojure.core/defn reset-image-attribute "Resets an attribute of an AMI to its default value.\n The productCodes attribute can't be reset." ([reset-image-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-reset-image-attribute-request reset-image-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/reset-image-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ResetImageAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef reset-image-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/reset-image-attribute-request) :ret clojure.core/true?)

(clojure.core/defn describe-fpga-images "Describes one or more available Amazon FPGA Images (AFIs). These include public\nAFIs, private AFIs that you own, and AFIs owned by other AWS accounts for which\nyou have load permissions." ([] (describe-fpga-images {})) ([describe-fpga-images-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-fpga-images-request describe-fpga-images-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-fpga-images-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-fpga-images-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeFpgaImages", :http.request.configuration/output-deser-fn response-describe-fpga-images-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-fpga-images :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-fpga-images-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-fpga-images-result))

(clojure.core/defn allocate-address "Allocates an Elastic IP address to your AWS account. After you allocate the\nElastic IP address you can associate it with an instance or network interface.\nAfter you release an Elastic IP address, it is released to the IP address pool\nand can be allocated to a different AWS account.\n You can allocate an Elastic IP address from an address pool owned by AWS or\nfrom an address pool created from a public IPv4 address range that you have\nbrought to AWS for use with your AWS resources using bring your own IP addresses\n(BYOIP). For more information, see Bring Your Own IP Addresses (BYOIP)\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html) in the\nAmazon Elastic Compute Cloud User Guide.\n [EC2-VPC] If you release an Elastic IP address, you might be able to recover\nit. You cannot recover an Elastic IP address that you released after it is\nallocated to another AWS account. You cannot recover an Elastic IP address for\nEC2-Classic. To attempt to recover an Elastic IP address that you released,\nspecify it in this operation.\n An Elastic IP address is for use either in the EC2-Classic platform or in a\nVPC. By default, you can allocate 5 Elastic IP addresses for EC2-Classic per\nregion and 5 Elastic IP addresses for EC2-VPC per region.\n For more information, see Elastic IP Addresses\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)\nin the Amazon Elastic Compute Cloud User Guide." ([] (allocate-address {})) ([allocate-address-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-allocate-address-request allocate-address-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/allocate-address-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/allocate-address-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AllocateAddress", :http.request.configuration/output-deser-fn response-allocate-address-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef allocate-address :args (clojure.spec.alpha/? :portkey.aws.ec2/allocate-address-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/allocate-address-result))

(clojure.core/defn modify-instance-placement "Modifies the placement attributes for a specified instance. You can do the\nfollowing:\n * Modify the affinity between an instance and a Dedicated Host\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-overview.html).\nWhen affinity is set to host and the instance is not associated with a specific\nDedicated Host, the next time the instance is launched, it is automatically\nassociated with the host on which it lands. If the instance is restarted or\nrebooted, this relationship persists.\n * Change the Dedicated Host with which an instance is associated.\n * Change the instance tenancy of an instance from host to dedicated, or from\ndedicated to host.\n * Move an instance to or from a placement group\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html).\n At least one attribute for affinity, host ID, tenancy, or placement group name\nmust be specified in the request. Affinity and tenancy can be modified in the\nsame request.\n To modify the host ID, tenancy, placement group, or partition for an instance,\nthe instance must be in the stopped state." ([modify-instance-placement-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-instance-placement-request modify-instance-placement-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-instance-placement-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-instance-placement-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyInstancePlacement", :http.request.configuration/output-deser-fn response-modify-instance-placement-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-instance-placement :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-instance-placement-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-instance-placement-result))

(clojure.core/defn create-image "Creates an Amazon EBS-backed AMI from an Amazon EBS-backed instance that is\neither running or stopped.\n If you customized your instance with instance store volumes or EBS volumes in\naddition to the root device volume, the new AMI contains block device mapping\ninformation for those volumes. When you launch an instance from this new AMI,\nthe instance automatically launches with those additional volumes.\n For more information, see Creating Amazon EBS-Backed Linux AMIs\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/creating-an-ami-ebs.html)\nin the Amazon Elastic Compute Cloud User Guide." ([create-image-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-image-request create-image-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-image-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-image-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateImage", :http.request.configuration/output-deser-fn response-create-image-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-image :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-image-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-image-result))

(clojure.core/defn describe-principal-id-format "Describes the ID format settings for the root user and all IAM roles and IAM\nusers that have explicitly specified a longer ID (17-character ID) preference.\n By default, all IAM roles and IAM users default to the same ID settings as the\nroot user, unless they explicitly override the settings. This request is useful\nfor identifying those IAM users and IAM roles that have overridden the default\nID settings.\n The following resource types support longer IDs: bundle | conversion-task |\ncustomer-gateway | dhcp-options | elastic-ip-allocation | elastic-ip-association\n| export-task | flow-log | image | import-task | instance | internet-gateway |\nnetwork-acl | network-acl-association | network-interface |\nnetwork-interface-attachment | prefix-list | reservation | route-table |\nroute-table-association | security-group | snapshot | subnet |\nsubnet-cidr-block-association | volume | vpc | vpc-cidr-block-association |\nvpc-endpoint | vpc-peering-connection | vpn-connection | vpn-gateway." ([] (describe-principal-id-format {})) ([describe-principal-id-format-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-principal-id-format-request describe-principal-id-format-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-principal-id-format-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-principal-id-format-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribePrincipalIdFormat", :http.request.configuration/output-deser-fn response-describe-principal-id-format-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-principal-id-format :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-principal-id-format-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-principal-id-format-result))

(clojure.core/defn export-transit-gateway-routes "Exports routes from the specified transit gateway route table to the specified\nS3 bucket. By default, all routes are exported. Alternatively, you can filter by\nCIDR range." ([export-transit-gateway-routes-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-export-transit-gateway-routes-request export-transit-gateway-routes-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/export-transit-gateway-routes-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/export-transit-gateway-routes-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ExportTransitGatewayRoutes", :http.request.configuration/output-deser-fn response-export-transit-gateway-routes-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef export-transit-gateway-routes :args (clojure.spec.alpha/tuple :portkey.aws.ec2/export-transit-gateway-routes-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/export-transit-gateway-routes-result))

(clojure.core/defn purchase-reserved-instances-offering "Purchases a Reserved Instance for use with your account. With Reserved\nInstances, you pay a lower hourly rate compared to On-Demand instance pricing.\n Use DescribeReservedInstancesOfferings to get a list of Reserved Instance\nofferings that match your specifications. After you've purchased a Reserved\nInstance, you can check for your new Reserved Instance with\nDescribeReservedInstances.\n For more information, see Reserved Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts-on-demand-reserved-instances.html)\nand Reserved Instance Marketplace\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-market-general.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([purchase-reserved-instances-offering-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-purchase-reserved-instances-offering-request purchase-reserved-instances-offering-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/purchase-reserved-instances-offering-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/purchase-reserved-instances-offering-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PurchaseReservedInstancesOffering", :http.request.configuration/output-deser-fn response-purchase-reserved-instances-offering-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef purchase-reserved-instances-offering :args (clojure.spec.alpha/tuple :portkey.aws.ec2/purchase-reserved-instances-offering-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/purchase-reserved-instances-offering-result))

(clojure.core/defn delete-egress-only-internet-gateway "Deletes an egress-only internet gateway." ([delete-egress-only-internet-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-egress-only-internet-gateway-request delete-egress-only-internet-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-egress-only-internet-gateway-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-egress-only-internet-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteEgressOnlyInternetGateway", :http.request.configuration/output-deser-fn response-delete-egress-only-internet-gateway-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-egress-only-internet-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-egress-only-internet-gateway-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-egress-only-internet-gateway-result))

(clojure.core/defn describe-fleets "Describes one or more of your EC2 Fleets." ([] (describe-fleets {})) ([describe-fleets-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-fleets-request describe-fleets-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-fleets-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-fleets-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeFleets", :http.request.configuration/output-deser-fn response-describe-fleets-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-fleets :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-fleets-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-fleets-result))

(clojure.core/defn delete-vpc-endpoint-connection-notifications "Deletes one or more VPC endpoint connection notifications." ([delete-vpc-endpoint-connection-notifications-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-vpc-endpoint-connection-notifications-request delete-vpc-endpoint-connection-notifications-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-vpc-endpoint-connection-notifications-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-vpc-endpoint-connection-notifications-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVpcEndpointConnectionNotifications", :http.request.configuration/output-deser-fn response-delete-vpc-endpoint-connection-notifications-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-vpc-endpoint-connection-notifications :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-vpc-endpoint-connection-notifications-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-vpc-endpoint-connection-notifications-result))

(clojure.core/defn create-vpc "Creates a VPC with the specified IPv4 CIDR block. The smallest VPC you can\ncreate uses a /28 netmask (16 IPv4 addresses), and the largest uses a /16\nnetmask (65,536 IPv4 addresses). For more information about how large to make\nyour VPC, see Your VPC and Subnets\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html) in the\nAmazon Virtual Private Cloud User Guide.\n You can optionally request an Amazon-provided IPv6 CIDR block for the VPC. The\nIPv6 CIDR block uses a /56 prefix length, and is allocated from Amazon's pool of\nIPv6 addresses. You cannot choose the IPv6 range for your VPC.\n By default, each instance you launch in the VPC has the default DHCP options,\nwhich include only a default DNS server that we provide (AmazonProvidedDNS). For\nmore information, see DHCP Options Sets\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html)\nin the Amazon Virtual Private Cloud User Guide.\n You can specify the instance tenancy value for the VPC when you create it. You\ncan't change this value for the VPC after you create it. For more information,\nsee Dedicated Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-instance.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([create-vpc-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-vpc-request create-vpc-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-vpc-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-vpc-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVpc", :http.request.configuration/output-deser-fn response-create-vpc-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-vpc :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-vpc-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-vpc-result))

(clojure.core/defn delete-launch-template "Deletes a launch template. Deleting a launch template deletes all of its\nversions." ([] (delete-launch-template {})) ([delete-launch-template-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-launch-template-request delete-launch-template-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-launch-template-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-launch-template-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteLaunchTemplate", :http.request.configuration/output-deser-fn response-delete-launch-template-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-launch-template :args (clojure.spec.alpha/? :portkey.aws.ec2/delete-launch-template-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-launch-template-result))

(clojure.core/defn describe-internet-gateways "Describes one or more of your internet gateways." ([] (describe-internet-gateways {})) ([describe-internet-gateways-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-internet-gateways-request describe-internet-gateways-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-internet-gateways-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-internet-gateways-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInternetGateways", :http.request.configuration/output-deser-fn response-describe-internet-gateways-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-internet-gateways :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-internet-gateways-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-internet-gateways-result))

(clojure.core/defn describe-tags "Describes one or more of the tags for your EC2 resources.\n For more information about tags, see Tagging Your Resources\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html) in the\nAmazon Elastic Compute Cloud User Guide." ([] (describe-tags {})) ([describe-tags-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-tags-request describe-tags-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-tags-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-tags-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeTags", :http.request.configuration/output-deser-fn response-describe-tags-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-tags :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-tags-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-tags-result))

(clojure.core/defn modify-instance-event-start-time "Modifies the start time for a scheduled Amazon EC2 instance event." ([modify-instance-event-start-time-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-instance-event-start-time-request modify-instance-event-start-time-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-instance-event-start-time-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-instance-event-start-time-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyInstanceEventStartTime", :http.request.configuration/output-deser-fn response-modify-instance-event-start-time-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-instance-event-start-time :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-instance-event-start-time-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-instance-event-start-time-result))

(clojure.core/defn authorize-client-vpn-ingress "Adds an ingress authorization rule to a Client VPN endpoint. Ingress\nauthorization rules act as firewall rules that grant access to networks. You\nmust configure ingress authorization rules to enable clients to access resources\nin AWS or on-premises networks." ([authorize-client-vpn-ingress-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-authorize-client-vpn-ingress-request authorize-client-vpn-ingress-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/authorize-client-vpn-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/authorize-client-vpn-ingress-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AuthorizeClientVpnIngress", :http.request.configuration/output-deser-fn response-authorize-client-vpn-ingress-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef authorize-client-vpn-ingress :args (clojure.spec.alpha/tuple :portkey.aws.ec2/authorize-client-vpn-ingress-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/authorize-client-vpn-ingress-result))

(clojure.core/defn request-spot-instances "Creates a Spot Instance request.\n For more information, see Spot Instance Requests\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-requests.html) in the\nAmazon EC2 User Guide for Linux Instances." ([] (request-spot-instances {})) ([request-spot-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-request-spot-instances-request request-spot-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/request-spot-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/request-spot-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RequestSpotInstances", :http.request.configuration/output-deser-fn response-request-spot-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef request-spot-instances :args (clojure.spec.alpha/? :portkey.aws.ec2/request-spot-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/request-spot-instances-result))

(clojure.core/defn describe-security-groups "Describes one or more of your security groups.\n A security group is for use with instances either in the EC2-Classic platform\nor in a specific VPC. For more information, see Amazon EC2 Security Groups\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html)\nin the Amazon Elastic Compute Cloud User Guide and Security Groups for Your VPC\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html)\nin the Amazon Virtual Private Cloud User Guide." ([] (describe-security-groups {})) ([describe-security-groups-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-security-groups-request describe-security-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-security-groups-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-security-groups-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSecurityGroups", :http.request.configuration/output-deser-fn response-describe-security-groups-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-security-groups :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-security-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-security-groups-result))

(clojure.core/defn accept-vpc-endpoint-connections "Accepts one or more interface VPC endpoint connection requests to your VPC\nendpoint service." ([accept-vpc-endpoint-connections-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-accept-vpc-endpoint-connections-request accept-vpc-endpoint-connections-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/accept-vpc-endpoint-connections-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/accept-vpc-endpoint-connections-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AcceptVpcEndpointConnections", :http.request.configuration/output-deser-fn response-accept-vpc-endpoint-connections-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef accept-vpc-endpoint-connections :args (clojure.spec.alpha/tuple :portkey.aws.ec2/accept-vpc-endpoint-connections-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/accept-vpc-endpoint-connections-result))

(clojure.core/defn modify-vpc-endpoint-service-permissions "Modifies the permissions for your VPC endpoint service\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/endpoint-service.html).\nYou can add or remove permissions for service consumers (IAM users, IAM roles,\nand AWS accounts) to connect to your endpoint service.\n If you grant permissions to all principals, the service is public. Any users\nwho know the name of a public service can send a request to attach an endpoint.\nIf the service does not require manual approval, attachments are automatically\napproved." ([modify-vpc-endpoint-service-permissions-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-vpc-endpoint-service-permissions-request modify-vpc-endpoint-service-permissions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-vpc-endpoint-service-permissions-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-vpc-endpoint-service-permissions-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyVpcEndpointServicePermissions", :http.request.configuration/output-deser-fn response-modify-vpc-endpoint-service-permissions-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-vpc-endpoint-service-permissions :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-vpc-endpoint-service-permissions-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-vpc-endpoint-service-permissions-result))

(clojure.core/defn disable-vpc-classic-link-dns-support "Disables ClassicLink DNS support for a VPC. If disabled, DNS hostnames resolve\nto public IP addresses when addressed between a linked EC2-Classic instance and\ninstances in the VPC to which it's linked. For more information, see ClassicLink\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([] (disable-vpc-classic-link-dns-support {})) ([disable-vpc-classic-link-dns-support-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disable-vpc-classic-link-dns-support-request disable-vpc-classic-link-dns-support-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/disable-vpc-classic-link-dns-support-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disable-vpc-classic-link-dns-support-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisableVpcClassicLinkDnsSupport", :http.request.configuration/output-deser-fn response-disable-vpc-classic-link-dns-support-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disable-vpc-classic-link-dns-support :args (clojure.spec.alpha/? :portkey.aws.ec2/disable-vpc-classic-link-dns-support-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/disable-vpc-classic-link-dns-support-result))

(clojure.core/defn accept-reserved-instances-exchange-quote "Accepts the Convertible Reserved Instance exchange quote described in the\nGetReservedInstancesExchangeQuote call." ([accept-reserved-instances-exchange-quote-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-accept-reserved-instances-exchange-quote-request accept-reserved-instances-exchange-quote-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/accept-reserved-instances-exchange-quote-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/accept-reserved-instances-exchange-quote-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AcceptReservedInstancesExchangeQuote", :http.request.configuration/output-deser-fn response-accept-reserved-instances-exchange-quote-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef accept-reserved-instances-exchange-quote :args (clojure.spec.alpha/tuple :portkey.aws.ec2/accept-reserved-instances-exchange-quote-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/accept-reserved-instances-exchange-quote-result))

(clojure.core/defn describe-vpcs "Describes one or more of your VPCs." ([] (describe-vpcs {})) ([describe-vpcs-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpcs-request describe-vpcs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpcs-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpcs-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcs", :http.request.configuration/output-deser-fn response-describe-vpcs-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpcs :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpcs-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpcs-result))

(clojure.core/defn delete-subnet "Deletes the specified subnet. You must terminate all running instances in the\nsubnet before you can delete the subnet." ([delete-subnet-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-subnet-request delete-subnet-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-subnet-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSubnet", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-subnet :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-subnet-request) :ret clojure.core/true?)

(clojure.core/defn accept-transit-gateway-vpc-attachment "Accepts a request to attach a VPC to a transit gateway.\n The VPC attachment must be in the pendingAcceptance state. Use\nDescribeTransitGatewayVpcAttachments to view your pending VPC attachment\nrequests. Use RejectTransitGatewayVpcAttachment to reject a VPC attachment\nrequest." ([accept-transit-gateway-vpc-attachment-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-accept-transit-gateway-vpc-attachment-request accept-transit-gateway-vpc-attachment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/accept-transit-gateway-vpc-attachment-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/accept-transit-gateway-vpc-attachment-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AcceptTransitGatewayVpcAttachment", :http.request.configuration/output-deser-fn response-accept-transit-gateway-vpc-attachment-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef accept-transit-gateway-vpc-attachment :args (clojure.spec.alpha/tuple :portkey.aws.ec2/accept-transit-gateway-vpc-attachment-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/accept-transit-gateway-vpc-attachment-result))

(clojure.core/defn describe-classic-link-instances "Describes one or more of your linked EC2-Classic instances. This request only\nreturns information about EC2-Classic instances linked to a VPC through\nClassicLink. You cannot use this request to return information about other\ninstances." ([] (describe-classic-link-instances {})) ([describe-classic-link-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-classic-link-instances-request describe-classic-link-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-classic-link-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-classic-link-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeClassicLinkInstances", :http.request.configuration/output-deser-fn response-describe-classic-link-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-classic-link-instances :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-classic-link-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-classic-link-instances-result))

(clojure.core/defn modify-spot-fleet-request "Modifies the specified Spot Fleet request.\n While the Spot Fleet request is being modified, it is in the modifying state.\n To scale up your Spot Fleet, increase its target capacity. The Spot Fleet\nlaunches the additional Spot Instances according to the allocation strategy for\nthe Spot Fleet request. If the allocation strategy is lowestPrice, the Spot\nFleet launches instances using the Spot pool with the lowest price. If the\nallocation strategy is diversified, the Spot Fleet distributes the instances\nacross the Spot pools.\n To scale down your Spot Fleet, decrease its target capacity. First, the Spot\nFleet cancels any open requests that exceed the new target capacity. You can\nrequest that the Spot Fleet terminate Spot Instances until the size of the fleet\nno longer exceeds the new target capacity. If the allocation strategy is\nlowestPrice, the Spot Fleet terminates the instances with the highest price per\nunit. If the allocation strategy is diversified, the Spot Fleet terminates\ninstances across the Spot pools. Alternatively, you can request that the Spot\nFleet keep the fleet at its current size, but not replace any Spot Instances\nthat are interrupted or that you terminate manually.\n If you are finished with your Spot Fleet for now, but will use it again later,\nyou can set the target capacity to 0." ([modify-spot-fleet-request-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-spot-fleet-request-request modify-spot-fleet-request-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-spot-fleet-request-response, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-spot-fleet-request-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifySpotFleetRequest", :http.request.configuration/output-deser-fn response-modify-spot-fleet-request-response, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-spot-fleet-request :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-spot-fleet-request-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-spot-fleet-request-response))

(clojure.core/defn get-reserved-instances-exchange-quote "Returns a quote and exchange information for exchanging one or more specified\nConvertible Reserved Instances for a new Convertible Reserved Instance. If the\nexchange cannot be performed, the reason is returned in the response. Use\nAcceptReservedInstancesExchangeQuote to perform the exchange." ([get-reserved-instances-exchange-quote-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-reserved-instances-exchange-quote-request get-reserved-instances-exchange-quote-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/get-reserved-instances-exchange-quote-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/get-reserved-instances-exchange-quote-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetReservedInstancesExchangeQuote", :http.request.configuration/output-deser-fn response-get-reserved-instances-exchange-quote-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef get-reserved-instances-exchange-quote :args (clojure.spec.alpha/tuple :portkey.aws.ec2/get-reserved-instances-exchange-quote-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/get-reserved-instances-exchange-quote-result))

(clojure.core/defn delete-transit-gateway-route "Deletes the specified route from the specified transit gateway route table." ([delete-transit-gateway-route-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-transit-gateway-route-request delete-transit-gateway-route-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-transit-gateway-route-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-transit-gateway-route-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteTransitGatewayRoute", :http.request.configuration/output-deser-fn response-delete-transit-gateway-route-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-transit-gateway-route :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-transit-gateway-route-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-transit-gateway-route-result))

(clojure.core/defn attach-network-interface "Attaches a network interface to an instance." ([attach-network-interface-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-attach-network-interface-request attach-network-interface-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/attach-network-interface-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/attach-network-interface-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachNetworkInterface", :http.request.configuration/output-deser-fn response-attach-network-interface-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef attach-network-interface :args (clojure.spec.alpha/tuple :portkey.aws.ec2/attach-network-interface-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/attach-network-interface-result))

(clojure.core/defn withdraw-byoip-cidr "Stops advertising an IPv4 address range that is provisioned as an address pool.\n You can perform this operation at most once every 10 seconds, even if you\nspecify different address ranges each time.\n It can take a few minutes before traffic to the specified addresses stops\nrouting to AWS because of BGP propagation delays." ([withdraw-byoip-cidr-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-withdraw-byoip-cidr-request withdraw-byoip-cidr-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/withdraw-byoip-cidr-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/withdraw-byoip-cidr-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "WithdrawByoipCidr", :http.request.configuration/output-deser-fn response-withdraw-byoip-cidr-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef withdraw-byoip-cidr :args (clojure.spec.alpha/tuple :portkey.aws.ec2/withdraw-byoip-cidr-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/withdraw-byoip-cidr-result))

(clojure.core/defn delete-snapshot "Deletes the specified snapshot.\n When you make periodic snapshots of a volume, the snapshots are incremental,\nand only the blocks on the device that have changed since your last snapshot are\nsaved in the new snapshot. When you delete a snapshot, only the data not needed\nfor any other snapshot is removed. So regardless of which prior snapshots have\nbeen deleted, all active snapshots will have access to all the information\nneeded to restore the volume.\n You cannot delete a snapshot of the root device of an EBS volume used by a\nregistered AMI. You must first de-register the AMI before you can delete the\nsnapshot.\n For more information, see Deleting an Amazon EBS Snapshot\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-deleting-snapshot.html)\nin the Amazon Elastic Compute Cloud User Guide." ([delete-snapshot-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-snapshot-request delete-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-snapshot-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSnapshot", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-snapshot-request) :ret clojure.core/true?)

(clojure.core/defn describe-stale-security-groups "[EC2-VPC only] Describes the stale security group rules for security groups in a\nspecified VPC. Rules are stale when they reference a deleted security group in a\npeer VPC, or a security group in a peer VPC for which the VPC peering connection\nhas been deleted." ([describe-stale-security-groups-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-stale-security-groups-request describe-stale-security-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-stale-security-groups-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-stale-security-groups-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeStaleSecurityGroups", :http.request.configuration/output-deser-fn response-describe-stale-security-groups-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-stale-security-groups :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-stale-security-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-stale-security-groups-result))

(clojure.core/defn cancel-conversion-task "Cancels an active conversion task. The task can be the import of an instance or\nvolume. The action removes all artifacts of the conversion, including a\npartially uploaded volume or instance. If the conversion is complete or is in\nthe process of transferring the final disk image, the command fails and returns\nan exception.\n For more information, see Importing a Virtual Machine Using the Amazon EC2 CLI\n(https://docs.aws.amazon.com/AWSEC2/latest/CommandLineReference/ec2-cli-vmimport-export.html)." ([cancel-conversion-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-cancel-conversion-request cancel-conversion-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/cancel-conversion-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelConversionTask", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef cancel-conversion-task :args (clojure.spec.alpha/tuple :portkey.aws.ec2/cancel-conversion-request) :ret clojure.core/true?)

(clojure.core/defn get-transit-gateway-attachment-propagations "Lists the route tables to which the specified resource attachment propagates\nroutes." ([get-transit-gateway-attachment-propagations-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-transit-gateway-attachment-propagations-request get-transit-gateway-attachment-propagations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/get-transit-gateway-attachment-propagations-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/get-transit-gateway-attachment-propagations-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetTransitGatewayAttachmentPropagations", :http.request.configuration/output-deser-fn response-get-transit-gateway-attachment-propagations-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef get-transit-gateway-attachment-propagations :args (clojure.spec.alpha/tuple :portkey.aws.ec2/get-transit-gateway-attachment-propagations-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/get-transit-gateway-attachment-propagations-result))

(clojure.core/defn describe-fpga-image-attribute "Describes the specified attribute of the specified Amazon FPGA Image (AFI)." ([describe-fpga-image-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-fpga-image-attribute-request describe-fpga-image-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-fpga-image-attribute-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-fpga-image-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeFpgaImageAttribute", :http.request.configuration/output-deser-fn response-describe-fpga-image-attribute-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-fpga-image-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-fpga-image-attribute-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-fpga-image-attribute-result))

(clojure.core/defn describe-public-ipv-4-pools "Describes the specified IPv4 address pools." ([] (describe-public-ipv-4-pools {})) ([describe-public-ipv-4-pools-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-public-ipv-4-pools-request describe-public-ipv-4-pools-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-public-ipv-4-pools-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-public-ipv-4-pools-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribePublicIpv4Pools", :http.request.configuration/output-deser-fn response-describe-public-ipv-4-pools-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-public-ipv-4-pools :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-public-ipv-4-pools-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-public-ipv-4-pools-result))

(clojure.core/defn describe-customer-gateways "Describes one or more of your VPN customer gateways.\n For more information, see AWS Site-to-Site VPN\n(https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the AWS\nSite-to-Site VPN User Guide." ([] (describe-customer-gateways {})) ([describe-customer-gateways-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-customer-gateways-request describe-customer-gateways-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-customer-gateways-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-customer-gateways-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeCustomerGateways", :http.request.configuration/output-deser-fn response-describe-customer-gateways-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-customer-gateways :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-customer-gateways-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-customer-gateways-result))

(clojure.core/defn delete-vpc-endpoints "Deletes one or more specified VPC endpoints. Deleting a gateway endpoint also\ndeletes the endpoint routes in the route tables that were associated with the\nendpoint. Deleting an interface endpoint deletes the endpoint network\ninterfaces." ([delete-vpc-endpoints-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-vpc-endpoints-request delete-vpc-endpoints-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-vpc-endpoints-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-vpc-endpoints-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVpcEndpoints", :http.request.configuration/output-deser-fn response-delete-vpc-endpoints-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-vpc-endpoints :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-vpc-endpoints-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-vpc-endpoints-result))

(clojure.core/defn describe-spot-instance-requests "Describes the specified Spot Instance requests.\n You can use DescribeSpotInstanceRequests to find a running Spot Instance by\nexamining the response. If the status of the Spot Instance is fulfilled, the\ninstance ID appears in the response and contains the identifier of the instance.\nAlternatively, you can use DescribeInstances with a filter to look for instances\nwhere the instance lifecycle is spot.\n We recommend that you set MaxResults to a value between 5 and 1000 to limit the\nnumber of results returned. This paginates the output, which makes the list more\nmanageable and returns the results faster. If the list of results exceeds your\nMaxResults value, then that number of results is returned along with a NextToken\nvalue that can be passed to a subsequent DescribeSpotInstanceRequests request to\nretrieve the remaining results.\n Spot Instance requests are deleted four hours after they are canceled and their\ninstances are terminated." ([] (describe-spot-instance-requests {})) ([describe-spot-instance-requests-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-spot-instance-requests-request describe-spot-instance-requests-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-spot-instance-requests-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-spot-instance-requests-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSpotInstanceRequests", :http.request.configuration/output-deser-fn response-describe-spot-instance-requests-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-spot-instance-requests :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-spot-instance-requests-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-spot-instance-requests-result))

(clojure.core/defn delete-route "Deletes the specified route from the specified route table." ([delete-route-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-route-request delete-route-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-route-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRoute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-route :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-route-request) :ret clojure.core/true?)

(clojure.core/defn describe-addresses "Describes one or more of your Elastic IP addresses.\n An Elastic IP address is for use in either the EC2-Classic platform or in a\nVPC. For more information, see Elastic IP Addresses\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)\nin the Amazon Elastic Compute Cloud User Guide." ([] (describe-addresses {})) ([describe-addresses-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-addresses-request describe-addresses-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-addresses-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-addresses-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAddresses", :http.request.configuration/output-deser-fn response-describe-addresses-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-addresses :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-addresses-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-addresses-result))

(clojure.core/defn describe-route-tables "Describes one or more of your route tables.\n Each subnet in your VPC must be associated with a route table. If a subnet is\nnot explicitly associated with any route table, it is implicitly associated with\nthe main route table. This command does not return the subnet ID for implicit\nassociations.\n For more information, see Route Tables\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html)\nin the Amazon Virtual Private Cloud User Guide." ([] (describe-route-tables {})) ([describe-route-tables-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-route-tables-request describe-route-tables-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-route-tables-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-route-tables-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeRouteTables", :http.request.configuration/output-deser-fn response-describe-route-tables-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-route-tables :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-route-tables-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-route-tables-result))

(clojure.core/defn run-scheduled-instances "Launches the specified Scheduled Instances.\n Before you can launch a Scheduled Instance, you must purchase it and obtain an\nidentifier using PurchaseScheduledInstances.\n You must launch a Scheduled Instance during its scheduled time period. You\ncan't stop or reboot a Scheduled Instance, but you can terminate it as needed.\nIf you terminate a Scheduled Instance before the current scheduled time period\nends, you can launch it again after a few minutes. For more information, see\nScheduled Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-scheduled-instances.html)\nin the Amazon Elastic Compute Cloud User Guide." ([run-scheduled-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-run-scheduled-instances-request run-scheduled-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/run-scheduled-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/run-scheduled-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RunScheduledInstances", :http.request.configuration/output-deser-fn response-run-scheduled-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef run-scheduled-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/run-scheduled-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/run-scheduled-instances-result))

(clojure.core/defn release-address "Releases the specified Elastic IP address.\n [EC2-Classic, default VPC] Releasing an Elastic IP address automatically\ndisassociates it from any instance that it's associated with. To disassociate an\nElastic IP address without releasing it, use DisassociateAddress.\n [Nondefault VPC] You must use DisassociateAddress to disassociate the Elastic\nIP address before you can release it. Otherwise, Amazon EC2 returns an error\n(InvalidIPAddress.InUse).\n After releasing an Elastic IP address, it is released to the IP address pool.\nBe sure to update your DNS records and any servers or devices that communicate\nwith the address. If you attempt to release an Elastic IP address that you\nalready released, you'll get an AuthFailure error if the address is already\nallocated to another AWS account.\n [EC2-VPC] After you release an Elastic IP address for use in a VPC, you might\nbe able to recover it. For more information, see AllocateAddress." ([] (release-address {})) ([release-address-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-release-address-request release-address-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/release-address-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReleaseAddress", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef release-address :args (clojure.spec.alpha/? :portkey.aws.ec2/release-address-request) :ret clojure.core/true?)

(clojure.core/defn delete-route-table "Deletes the specified route table. You must disassociate the route table from\nany subnets before you can delete it. You can't delete the main route table." ([delete-route-table-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-route-table-request delete-route-table-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-route-table-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRouteTable", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-route-table :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-route-table-request) :ret clojure.core/true?)

(clojure.core/defn describe-client-vpn-authorization-rules "Describes the authorization rules for a specified Client VPN endpoint." ([describe-client-vpn-authorization-rules-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-client-vpn-authorization-rules-request describe-client-vpn-authorization-rules-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-client-vpn-authorization-rules-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-client-vpn-authorization-rules-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeClientVpnAuthorizationRules", :http.request.configuration/output-deser-fn response-describe-client-vpn-authorization-rules-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-client-vpn-authorization-rules :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-client-vpn-authorization-rules-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-client-vpn-authorization-rules-result))

(clojure.core/defn describe-reserved-instances-offerings "Describes Reserved Instance offerings that are available for purchase. With\nReserved Instances, you purchase the right to launch instances for a period of\ntime. During that time period, you do not receive insufficient capacity errors,\nand you pay a lower usage rate than the rate charged for On-Demand instances for\nthe actual time used.\n If you have listed your own Reserved Instances for sale in the Reserved\nInstance Marketplace, they will be excluded from these results. This is to\nensure that you do not purchase your own Reserved Instances.\n For more information, see Reserved Instance Marketplace\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-market-general.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([] (describe-reserved-instances-offerings {})) ([describe-reserved-instances-offerings-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-reserved-instances-offerings-request describe-reserved-instances-offerings-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-reserved-instances-offerings-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-reserved-instances-offerings-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeReservedInstancesOfferings", :http.request.configuration/output-deser-fn response-describe-reserved-instances-offerings-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-reserved-instances-offerings :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-reserved-instances-offerings-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-reserved-instances-offerings-result))

(clojure.core/defn modify-transit-gateway-vpc-attachment "Modifies the specified VPC attachment." ([modify-transit-gateway-vpc-attachment-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-transit-gateway-vpc-attachment-request modify-transit-gateway-vpc-attachment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-transit-gateway-vpc-attachment-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-transit-gateway-vpc-attachment-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyTransitGatewayVpcAttachment", :http.request.configuration/output-deser-fn response-modify-transit-gateway-vpc-attachment-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-transit-gateway-vpc-attachment :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-transit-gateway-vpc-attachment-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-transit-gateway-vpc-attachment-result))

(clojure.core/defn delete-client-vpn-route "Deletes a route from a Client VPN endpoint. You can only delete routes that you\nmanually added using the CreateClientVpnRoute action. You cannot delete routes\nthat were automatically added when associating a subnet. To remove routes that\nhave been automatically added, disassociate the target subnet from the Client\nVPN endpoint." ([delete-client-vpn-route-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-client-vpn-route-request delete-client-vpn-route-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-client-vpn-route-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-client-vpn-route-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteClientVpnRoute", :http.request.configuration/output-deser-fn response-delete-client-vpn-route-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-client-vpn-route :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-client-vpn-route-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-client-vpn-route-result))

(clojure.core/defn import-volume "Creates an import volume task using metadata from the specified disk image.For\nmore information, see Importing Disks to Amazon EBS\n(https://docs.aws.amazon.com/AWSEC2/latest/CommandLineReference/importing-your-volumes-into-amazon-ebs.html).\n For information about the import manifest referenced by this API action, see VM\nImport Manifest\n(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html)." ([import-volume-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-import-volume-request import-volume-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/import-volume-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/import-volume-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportVolume", :http.request.configuration/output-deser-fn response-import-volume-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef import-volume :args (clojure.spec.alpha/tuple :portkey.aws.ec2/import-volume-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/import-volume-result))

(clojure.core/defn create-network-acl "Creates a network ACL in a VPC. Network ACLs provide an optional layer of\nsecurity (in addition to security groups) for the instances in your VPC.\n For more information, see Network ACLs\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html) in the\nAmazon Virtual Private Cloud User Guide." ([create-network-acl-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-network-acl-request create-network-acl-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-network-acl-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-network-acl-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateNetworkAcl", :http.request.configuration/output-deser-fn response-create-network-acl-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-network-acl :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-network-acl-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-network-acl-result))

(clojure.core/defn describe-nat-gateways "Describes one or more of your NAT gateways." ([] (describe-nat-gateways {})) ([describe-nat-gateways-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-nat-gateways-request describe-nat-gateways-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-nat-gateways-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-nat-gateways-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeNatGateways", :http.request.configuration/output-deser-fn response-describe-nat-gateways-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-nat-gateways :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-nat-gateways-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-nat-gateways-result))

(clojure.core/defn modify-image-attribute "Modifies the specified attribute of the specified AMI. You can specify only one\nattribute at a time. You can use the Attribute parameter to specify the\nattribute or one of the following parameters: Description, LaunchPermission, or\nProductCode.\n AWS Marketplace product codes cannot be modified. Images with an AWS\nMarketplace product code cannot be made public.\n To enable the SriovNetSupport enhanced networking attribute of an image, enable\nSriovNetSupport on an instance and create an AMI from the instance." ([modify-image-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-image-attribute-request modify-image-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-image-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyImageAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-image-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-image-attribute-request) :ret clojure.core/true?)

(clojure.core/defn describe-transit-gateways "Describes one or more transit gateways. By default, all transit gateways are\ndescribed. Alternatively, you can filter the results." ([] (describe-transit-gateways {})) ([describe-transit-gateways-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-transit-gateways-request describe-transit-gateways-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-transit-gateways-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-transit-gateways-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeTransitGateways", :http.request.configuration/output-deser-fn response-describe-transit-gateways-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-transit-gateways :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-transit-gateways-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-transit-gateways-result))

(clojure.core/defn delete-network-acl "Deletes the specified network ACL. You can't delete the ACL if it's associated\nwith any subnets. You can't delete the default network ACL." ([delete-network-acl-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-network-acl-request delete-network-acl-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-network-acl-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteNetworkAcl", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-network-acl :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-network-acl-request) :ret clojure.core/true?)

(clojure.core/defn update-security-group-rule-descriptions-egress "[EC2-VPC only] Updates the description of an egress (outbound) security group\nrule. You can replace an existing description, or add a description to a rule\nthat did not have one previously.\n You specify the description as part of the IP permissions structure. You can\nremove a description for a security group rule by omitting the description\nparameter in the request." ([update-security-group-rule-descriptions-egress-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-update-security-group-rule-descriptions-egress-request update-security-group-rule-descriptions-egress-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/update-security-group-rule-descriptions-egress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/update-security-group-rule-descriptions-egress-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateSecurityGroupRuleDescriptionsEgress", :http.request.configuration/output-deser-fn response-update-security-group-rule-descriptions-egress-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef update-security-group-rule-descriptions-egress :args (clojure.spec.alpha/tuple :portkey.aws.ec2/update-security-group-rule-descriptions-egress-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/update-security-group-rule-descriptions-egress-result))

(clojure.core/defn describe-spot-fleet-requests "Describes your Spot Fleet requests.\n Spot Fleet requests are deleted 48 hours after they are canceled and their\ninstances are terminated." ([] (describe-spot-fleet-requests {})) ([describe-spot-fleet-requests-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-spot-fleet-requests-request describe-spot-fleet-requests-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-spot-fleet-requests-response, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-spot-fleet-requests-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSpotFleetRequests", :http.request.configuration/output-deser-fn response-describe-spot-fleet-requests-response, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-spot-fleet-requests :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-spot-fleet-requests-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-spot-fleet-requests-response))

(clojure.core/defn describe-launch-template-versions "Describes one or more versions of a specified launch template. You can describe\nall versions, individual versions, or a range of versions." ([] (describe-launch-template-versions {})) ([describe-launch-template-versions-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-launch-template-versions-request describe-launch-template-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-launch-template-versions-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-launch-template-versions-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeLaunchTemplateVersions", :http.request.configuration/output-deser-fn response-describe-launch-template-versions-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-launch-template-versions :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-launch-template-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-launch-template-versions-result))

(clojure.core/defn cancel-import-task "Cancels an in-process import virtual machine or import snapshot task." ([] (cancel-import-task {})) ([cancel-import-task-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-cancel-import-task-request cancel-import-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/cancel-import-task-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/cancel-import-task-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelImportTask", :http.request.configuration/output-deser-fn response-cancel-import-task-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef cancel-import-task :args (clojure.spec.alpha/? :portkey.aws.ec2/cancel-import-task-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/cancel-import-task-result))

(clojure.core/defn create-vpn-connection-route "Creates a static route associated with a VPN connection between an existing\nvirtual private gateway and a VPN customer gateway. The static route allows\ntraffic to be routed from the virtual private gateway to the VPN customer\ngateway.\n For more information, see AWS Site-to-Site VPN\n(https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the AWS\nSite-to-Site VPN User Guide." ([create-vpn-connection-route-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-vpn-connection-route-request create-vpn-connection-route-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-vpn-connection-route-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVpnConnectionRoute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-vpn-connection-route :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-vpn-connection-route-request) :ret clojure.core/true?)

(clojure.core/defn describe-transit-gateway-attachments "Describes one or more attachments between resources and transit gateways. By\ndefault, all attachments are described. Alternatively, you can filter the\nresults by attachment ID, attachment state, resource ID, or resource owner." ([] (describe-transit-gateway-attachments {})) ([describe-transit-gateway-attachments-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-transit-gateway-attachments-request describe-transit-gateway-attachments-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-transit-gateway-attachments-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-transit-gateway-attachments-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeTransitGatewayAttachments", :http.request.configuration/output-deser-fn response-describe-transit-gateway-attachments-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-transit-gateway-attachments :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-transit-gateway-attachments-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-transit-gateway-attachments-result))

(clojure.core/defn get-host-reservation-purchase-preview "Preview a reservation purchase with configurations that match those of your\nDedicated Host. You must have active Dedicated Hosts in your account before you\npurchase a reservation.\n This is a preview of the PurchaseHostReservation action and does not result in\nthe offering being purchased." ([get-host-reservation-purchase-preview-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-host-reservation-purchase-preview-request get-host-reservation-purchase-preview-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/get-host-reservation-purchase-preview-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/get-host-reservation-purchase-preview-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetHostReservationPurchasePreview", :http.request.configuration/output-deser-fn response-get-host-reservation-purchase-preview-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef get-host-reservation-purchase-preview :args (clojure.spec.alpha/tuple :portkey.aws.ec2/get-host-reservation-purchase-preview-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/get-host-reservation-purchase-preview-result))

(clojure.core/defn unassign-ipv-6-addresses "Unassigns one or more IPv6 addresses from a network interface." ([unassign-ipv-6-addresses-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-unassign-ipv-6-addresses-request unassign-ipv-6-addresses-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/unassign-ipv-6-addresses-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/unassign-ipv-6-addresses-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UnassignIpv6Addresses", :http.request.configuration/output-deser-fn response-unassign-ipv-6-addresses-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef unassign-ipv-6-addresses :args (clojure.spec.alpha/tuple :portkey.aws.ec2/unassign-ipv-6-addresses-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/unassign-ipv-6-addresses-result))

(clojure.core/defn import-client-vpn-client-certificate-revocation-list "Uploads a client certificate revocation list to the specified Client VPN\nendpoint. Uploading a client certificate revocation list overwrites the existing\nclient certificate revocation list.\n Uploading a client certificate revocation list resets existing client\nconnections." ([import-client-vpn-client-certificate-revocation-list-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-import-client-vpn-client-certificate-revocation-list-request import-client-vpn-client-certificate-revocation-list-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/import-client-vpn-client-certificate-revocation-list-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/import-client-vpn-client-certificate-revocation-list-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportClientVpnClientCertificateRevocationList", :http.request.configuration/output-deser-fn response-import-client-vpn-client-certificate-revocation-list-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef import-client-vpn-client-certificate-revocation-list :args (clojure.spec.alpha/tuple :portkey.aws.ec2/import-client-vpn-client-certificate-revocation-list-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/import-client-vpn-client-certificate-revocation-list-result))

(clojure.core/defn describe-vpc-attribute "Describes the specified attribute of the specified VPC. You can specify only one\nattribute at a time." ([describe-vpc-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpc-attribute-request describe-vpc-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpc-attribute-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpc-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcAttribute", :http.request.configuration/output-deser-fn response-describe-vpc-attribute-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpc-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-vpc-attribute-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-attribute-result))

(clojure.core/defn describe-identity-id-format "Describes the ID format settings for resources for the specified IAM user, IAM\nrole, or root user. For example, you can view the resource types that are\nenabled for longer IDs. This request only returns information about resource\ntypes whose ID formats can be modified; it does not return information about\nother resource types. For more information, see Resource IDs\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/resource-ids.html) in the\nAmazon Elastic Compute Cloud User Guide.\n The following resource types support longer IDs: bundle | conversion-task |\ncustomer-gateway | dhcp-options | elastic-ip-allocation | elastic-ip-association\n| export-task | flow-log | image | import-task | instance | internet-gateway |\nnetwork-acl | network-acl-association | network-interface |\nnetwork-interface-attachment | prefix-list | reservation | route-table |\nroute-table-association | security-group | snapshot | subnet |\nsubnet-cidr-block-association | volume | vpc | vpc-cidr-block-association |\nvpc-endpoint | vpc-peering-connection | vpn-connection | vpn-gateway.\n These settings apply to the principal specified in the request. They do not\napply to the principal that makes the request." ([describe-identity-id-format-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-identity-id-format-request describe-identity-id-format-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-identity-id-format-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-identity-id-format-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeIdentityIdFormat", :http.request.configuration/output-deser-fn response-describe-identity-id-format-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-identity-id-format :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-identity-id-format-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-identity-id-format-result))

(clojure.core/defn get-console-screenshot "Retrieve a JPG-format screenshot of a running instance to help with\ntroubleshooting.\n The returned content is Base64-encoded." ([get-console-screenshot-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-console-screenshot-request get-console-screenshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/get-console-screenshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/get-console-screenshot-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetConsoleScreenshot", :http.request.configuration/output-deser-fn response-get-console-screenshot-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef get-console-screenshot :args (clojure.spec.alpha/tuple :portkey.aws.ec2/get-console-screenshot-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/get-console-screenshot-result))

(clojure.core/defn delete-vpc-endpoint-service-configurations "Deletes one or more VPC endpoint service configurations in your account. Before\nyou delete the endpoint service configuration, you must reject any Available or\nPendingAcceptance interface endpoint connections that are attached to the\nservice." ([delete-vpc-endpoint-service-configurations-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-vpc-endpoint-service-configurations-request delete-vpc-endpoint-service-configurations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-vpc-endpoint-service-configurations-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-vpc-endpoint-service-configurations-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVpcEndpointServiceConfigurations", :http.request.configuration/output-deser-fn response-delete-vpc-endpoint-service-configurations-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-vpc-endpoint-service-configurations :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-vpc-endpoint-service-configurations-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-vpc-endpoint-service-configurations-result))

(clojure.core/defn revoke-security-group-egress "[EC2-VPC only] Removes one or more egress rules from a security group for\nEC2-VPC. This action doesn't apply to security groups for use in EC2-Classic. To\nremove a rule, the values that you specify (for example, ports) must match the\nexisting rule's values exactly.\n Each rule consists of the protocol and the IPv4 or IPv6 CIDR range or source\nsecurity group. For the TCP and UDP protocols, you must also specify the\ndestination port or range of ports. For the ICMP protocol, you must also specify\nthe ICMP type and code. If the security group rule has a description, you do not\nhave to specify the description to revoke the rule.\n Rule changes are propagated to instances within the security group as quickly\nas possible. However, a small delay might occur." ([revoke-security-group-egress-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-revoke-security-group-egress-request revoke-security-group-egress-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/revoke-security-group-egress-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RevokeSecurityGroupEgress", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef revoke-security-group-egress :args (clojure.spec.alpha/tuple :portkey.aws.ec2/revoke-security-group-egress-request) :ret clojure.core/true?)

(clojure.core/defn create-default-vpc "Creates a default VPC with a size /16 IPv4 CIDR block and a default subnet in\neach Availability Zone. For more information about the components of a default\nVPC, see Default VPC and Default Subnets\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/default-vpc.html) in the\nAmazon Virtual Private Cloud User Guide. You cannot specify the components of\nthe default VPC yourself.\n If you deleted your previous default VPC, you can create a default VPC. You\ncannot have more than one default VPC per Region.\n If your account supports EC2-Classic, you cannot use this action to create a\ndefault VPC in a Region that supports EC2-Classic. If you want a default VPC in\na Region that supports EC2-Classic, see \"I really want a default VPC for my\nexisting EC2 account. Is that possible?\" in the Default VPCs FAQ\n(http://aws.amazon.com/vpc/faqs/#Default_VPCs)." ([] (create-default-vpc {})) ([create-default-vpc-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-default-vpc-request create-default-vpc-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-default-vpc-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-default-vpc-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDefaultVpc", :http.request.configuration/output-deser-fn response-create-default-vpc-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-default-vpc :args (clojure.spec.alpha/? :portkey.aws.ec2/create-default-vpc-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-default-vpc-result))

(clojure.core/defn create-instance-export-task "Exports a running or stopped instance to an S3 bucket.\n For information about the supported operating systems, image formats, and known\nlimitations for the types of instances you can export, see Exporting an Instance\nas a VM Using VM Import/Export\n(https://docs.aws.amazon.com/vm-import/latest/userguide/vmexport.html) in the VM\nImport/Export User Guide." ([create-instance-export-task-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-instance-export-task-request create-instance-export-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-instance-export-task-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-instance-export-task-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateInstanceExportTask", :http.request.configuration/output-deser-fn response-create-instance-export-task-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-instance-export-task :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-instance-export-task-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-instance-export-task-result))

(clojure.core/defn disable-vpc-classic-link "Disables ClassicLink for a VPC. You cannot disable ClassicLink for a VPC that\nhas EC2-Classic instances linked to it." ([disable-vpc-classic-link-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disable-vpc-classic-link-request disable-vpc-classic-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/disable-vpc-classic-link-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disable-vpc-classic-link-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisableVpcClassicLink", :http.request.configuration/output-deser-fn response-disable-vpc-classic-link-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disable-vpc-classic-link :args (clojure.spec.alpha/tuple :portkey.aws.ec2/disable-vpc-classic-link-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/disable-vpc-classic-link-result))

(clojure.core/defn import-instance "Creates an import instance task using metadata from the specified disk image.\nImportInstance only supports single-volume VMs. To import multi-volume VMs, use\nImportImage. For more information, see Importing a Virtual Machine Using the\nAmazon EC2 CLI\n(https://docs.aws.amazon.com/AWSEC2/latest/CommandLineReference/ec2-cli-vmimport-export.html).\n For information about the import manifest referenced by this API action, see VM\nImport Manifest\n(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html)." ([import-instance-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-import-instance-request import-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/import-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/import-instance-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportInstance", :http.request.configuration/output-deser-fn response-import-instance-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef import-instance :args (clojure.spec.alpha/tuple :portkey.aws.ec2/import-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/import-instance-result))

(clojure.core/defn describe-instances "Describes one or more of your instances.\n If you specify one or more instance IDs, Amazon EC2 returns information for\nthose instances. If you do not specify instance IDs, Amazon EC2 returns\ninformation for all relevant instances. If you specify an instance ID that is\nnot valid, an error is returned. If you specify an instance that you do not own,\nit is not included in the returned results.\n Recently terminated instances might appear in the returned results. This\ninterval is usually less than one hour.\n If you describe instances in the rare case where an Availability Zone is\nexperiencing a service disruption and you specify instance IDs that are in the\naffected zone, or do not specify any instance IDs at all, the call fails. If you\ndescribe instances and specify only instance IDs that are in an unaffected zone,\nthe call works normally." ([] (describe-instances {})) ([describe-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-instances-request describe-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstances", :http.request.configuration/output-deser-fn response-describe-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-instances :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-instances-result))

(clojure.core/defn delete-dhcp-options "Deletes the specified set of DHCP options. You must disassociate the set of DHCP\noptions before you can delete it. You can disassociate the set of DHCP options\nby associating either a new set of options or the default set of options with\nthe VPC." ([delete-dhcp-options-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-dhcp-options-request delete-dhcp-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-dhcp-options-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDhcpOptions", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-dhcp-options :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-dhcp-options-request) :ret clojure.core/true?)

(clojure.core/defn describe-account-attributes "Describes attributes of your AWS account. The following are the supported\naccount attributes:\n * supported-platforms: Indicates whether your account can launch instances into\nEC2-Classic and EC2-VPC, or only into EC2-VPC.\n * default-vpc: The ID of the default VPC for your account, or none.\n * max-instances: The maximum number of On-Demand Instances that you can run.\n * vpc-max-security-groups-per-interface: The maximum number of security groups\nthat you can assign to a network interface.\n * max-elastic-ips: The maximum number of Elastic IP addresses that you can\nallocate for use with EC2-Classic.\n * vpc-max-elastic-ips: The maximum number of Elastic IP addresses that you can\nallocate for use with EC2-VPC." ([] (describe-account-attributes {})) ([describe-account-attributes-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-account-attributes-request describe-account-attributes-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-account-attributes-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-account-attributes-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAccountAttributes", :http.request.configuration/output-deser-fn response-describe-account-attributes-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-account-attributes :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-account-attributes-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-account-attributes-result))

(clojure.core/defn describe-vpc-endpoint-connections "Describes the VPC endpoint connections to your VPC endpoint services, including\nany endpoints that are pending your acceptance." ([] (describe-vpc-endpoint-connections {})) ([describe-vpc-endpoint-connections-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpc-endpoint-connections-request describe-vpc-endpoint-connections-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpc-endpoint-connections-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpc-endpoint-connections-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcEndpointConnections", :http.request.configuration/output-deser-fn response-describe-vpc-endpoint-connections-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpc-endpoint-connections :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpc-endpoint-connections-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-endpoint-connections-result))

(clojure.core/defn describe-vpc-endpoint-connection-notifications "Describes the connection notifications for VPC endpoints and VPC endpoint\nservices." ([] (describe-vpc-endpoint-connection-notifications {})) ([describe-vpc-endpoint-connection-notifications-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpc-endpoint-connection-notifications-request describe-vpc-endpoint-connection-notifications-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpc-endpoint-connection-notifications-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpc-endpoint-connection-notifications-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcEndpointConnectionNotifications", :http.request.configuration/output-deser-fn response-describe-vpc-endpoint-connection-notifications-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpc-endpoint-connection-notifications :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpc-endpoint-connection-notifications-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-endpoint-connection-notifications-result))

(clojure.core/defn associate-vpc-cidr-block "Associates a CIDR block with your VPC. You can associate a secondary IPv4 CIDR\nblock, or you can associate an Amazon-provided IPv6 CIDR block. The IPv6 CIDR\nblock size is fixed at /56.\n For more information about associating CIDR blocks with your VPC and applicable\nrestrictions, see VPC and Subnet Sizing\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html#VPC_Sizing)\nin the Amazon Virtual Private Cloud User Guide." ([associate-vpc-cidr-block-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-associate-vpc-cidr-block-request associate-vpc-cidr-block-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/associate-vpc-cidr-block-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/associate-vpc-cidr-block-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssociateVpcCidrBlock", :http.request.configuration/output-deser-fn response-associate-vpc-cidr-block-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef associate-vpc-cidr-block :args (clojure.spec.alpha/tuple :portkey.aws.ec2/associate-vpc-cidr-block-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/associate-vpc-cidr-block-result))

(clojure.core/defn describe-elastic-gpus "Describes the Elastic Graphics accelerator associated with your instances. For\nmore information about Elastic Graphics, see Amazon Elastic Graphics\n(https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html)." ([] (describe-elastic-gpus {})) ([describe-elastic-gpus-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-elastic-gpus-request describe-elastic-gpus-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-elastic-gpus-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-elastic-gpus-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeElasticGpus", :http.request.configuration/output-deser-fn response-describe-elastic-gpus-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-elastic-gpus :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-elastic-gpus-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-elastic-gpus-result))

(clojure.core/defn create-spot-datafeed-subscription "Creates a data feed for Spot Instances, enabling you to view Spot Instance usage\nlogs. You can create one data feed per AWS account. For more information, see\nSpot Instance Data Feed\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-data-feeds.html) in\nthe Amazon EC2 User Guide for Linux Instances." ([create-spot-datafeed-subscription-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-spot-datafeed-subscription-request create-spot-datafeed-subscription-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-spot-datafeed-subscription-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-spot-datafeed-subscription-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateSpotDatafeedSubscription", :http.request.configuration/output-deser-fn response-create-spot-datafeed-subscription-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-spot-datafeed-subscription :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-spot-datafeed-subscription-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-spot-datafeed-subscription-result))

(clojure.core/defn reset-fpga-image-attribute "Resets the specified attribute of the specified Amazon FPGA Image (AFI) to its\ndefault value. You can only reset the load permission attribute." ([reset-fpga-image-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-reset-fpga-image-attribute-request reset-fpga-image-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/reset-fpga-image-attribute-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/reset-fpga-image-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ResetFpgaImageAttribute", :http.request.configuration/output-deser-fn response-reset-fpga-image-attribute-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef reset-fpga-image-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/reset-fpga-image-attribute-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/reset-fpga-image-attribute-result))

(clojure.core/defn create-customer-gateway "Provides information to AWS about your VPN customer gateway device. The customer\ngateway is the appliance at your end of the VPN connection. (The device on the\nAWS side of the VPN connection is the virtual private gateway.) You must provide\nthe Internet-routable IP address of the customer gateway's external interface.\nThe IP address must be static and may be behind a device performing network\naddress translation (NAT).\n For devices that use Border Gateway Protocol (BGP), you can also provide the\ndevice's BGP Autonomous System Number (ASN). You can use an existing ASN\nassigned to your network. If you don't have an ASN already, you can use a\nprivate ASN (in the 64512 - 65534 range).\n Amazon EC2 supports all 2-byte ASN numbers in the range of 1 - 65534, with the\nexception of 7224, which is reserved in the us-east-1 region, and 9059, which is\nreserved in the eu-west-1 region.\n For more information, see AWS Site-to-Site VPN\n(https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the AWS\nSite-to-Site VPN User Guide.\n You cannot create more than one customer gateway with the same VPN type, IP\naddress, and BGP ASN parameter values. If you run an identical request more than\none time, the first request creates the customer gateway, and subsequent\nrequests return information about the existing customer gateway. The subsequent\nrequests do not create new customer gateway resources." ([create-customer-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-customer-gateway-request create-customer-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-customer-gateway-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-customer-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateCustomerGateway", :http.request.configuration/output-deser-fn response-create-customer-gateway-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-customer-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-customer-gateway-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-customer-gateway-result))

(clojure.core/defn replace-network-acl-entry "Replaces an entry (rule) in a network ACL. For more information, see Network\nACLs (https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html) in\nthe Amazon Virtual Private Cloud User Guide." ([replace-network-acl-entry-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-replace-network-acl-entry-request replace-network-acl-entry-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/replace-network-acl-entry-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReplaceNetworkAclEntry", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef replace-network-acl-entry :args (clojure.spec.alpha/tuple :portkey.aws.ec2/replace-network-acl-entry-request) :ret clojure.core/true?)

(clojure.core/defn create-egress-only-internet-gateway "[IPv6 only] Creates an egress-only internet gateway for your VPC. An egress-only\ninternet gateway is used to enable outbound communication over IPv6 from\ninstances in your VPC to the internet, and prevents hosts outside of your VPC\nfrom initiating an IPv6 connection with your instance." ([create-egress-only-internet-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-egress-only-internet-gateway-request create-egress-only-internet-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-egress-only-internet-gateway-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-egress-only-internet-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateEgressOnlyInternetGateway", :http.request.configuration/output-deser-fn response-create-egress-only-internet-gateway-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-egress-only-internet-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-egress-only-internet-gateway-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-egress-only-internet-gateway-result))

(clojure.core/defn delete-client-vpn-endpoint "Deletes the specified Client VPN endpoint. You must disassociate all target\nnetworks before you can delete a Client VPN endpoint." ([delete-client-vpn-endpoint-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-client-vpn-endpoint-request delete-client-vpn-endpoint-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-client-vpn-endpoint-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-client-vpn-endpoint-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteClientVpnEndpoint", :http.request.configuration/output-deser-fn response-delete-client-vpn-endpoint-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-client-vpn-endpoint :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-client-vpn-endpoint-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-client-vpn-endpoint-result))

(clojure.core/defn describe-host-reservation-offerings "Describes the Dedicated Host reservations that are available to purchase.\n The results describe all the Dedicated Host reservation offerings, including\nofferings that may not match the instance family and Region of your Dedicated\nHosts. When purchasing an offering, ensure that the instance family and Region\nof the offering matches that of the Dedicated Hosts with which it is to be\nassociated. For more information about supported instance types, see Dedicated\nHosts Overview\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-overview.html)\nin the Amazon Elastic Compute Cloud User Guide." ([] (describe-host-reservation-offerings {})) ([describe-host-reservation-offerings-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-host-reservation-offerings-request describe-host-reservation-offerings-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-host-reservation-offerings-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-host-reservation-offerings-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeHostReservationOfferings", :http.request.configuration/output-deser-fn response-describe-host-reservation-offerings-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-host-reservation-offerings :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-host-reservation-offerings-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-host-reservation-offerings-result))

(clojure.core/defn modify-vpc-tenancy "Modifies the instance tenancy attribute of the specified VPC. You can change the\ninstance tenancy attribute of a VPC to default only. You cannot change the\ninstance tenancy attribute to dedicated.\n After you modify the tenancy of the VPC, any new instances that you launch into\nthe VPC have a tenancy of default, unless you specify otherwise during launch.\nThe tenancy of any existing instances in the VPC is not affected.\n For more information, see Dedicated Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-instance.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([modify-vpc-tenancy-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-vpc-tenancy-request modify-vpc-tenancy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-vpc-tenancy-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-vpc-tenancy-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyVpcTenancy", :http.request.configuration/output-deser-fn response-modify-vpc-tenancy-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-vpc-tenancy :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-vpc-tenancy-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-vpc-tenancy-result))

(clojure.core/defn modify-vpc-peering-connection-options "Modifies the VPC peering connection options on one side of a VPC peering\nconnection. You can do the following:\n * Enable/disable communication over the peering connection between an\nEC2-Classic instance that's linked to your VPC (using ClassicLink) and instances\nin the peer VPC.\n * Enable/disable communication over the peering connection between instances in\nyour VPC and an EC2-Classic instance that's linked to the peer VPC.\n * Enable/disable the ability to resolve public DNS hostnames to private IP\naddresses when queried from instances in the peer VPC.\n If the peered VPCs are in the same AWS account, you can enable DNS resolution\nfor queries from the local VPC. This ensures that queries from the local VPC\nresolve to private IP addresses in the peer VPC. This option is not available if\nthe peered VPCs are in different AWS accounts or different regions. For peered\nVPCs in different AWS accounts, each AWS account owner must initiate a separate\nrequest to modify the peering connection options. For inter-region peering\nconnections, you must use the region for the requester VPC to modify the\nrequester VPC peering options and the region for the accepter VPC to modify the\naccepter VPC peering options. To verify which VPCs are the accepter and the\nrequester for a VPC peering connection, use the DescribeVpcPeeringConnections\ncommand." ([modify-vpc-peering-connection-options-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-vpc-peering-connection-options-request modify-vpc-peering-connection-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-vpc-peering-connection-options-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-vpc-peering-connection-options-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyVpcPeeringConnectionOptions", :http.request.configuration/output-deser-fn response-modify-vpc-peering-connection-options-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-vpc-peering-connection-options :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-vpc-peering-connection-options-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-vpc-peering-connection-options-result))

(clojure.core/defn replace-route "Replaces an existing route within a route table in a VPC. You must provide only\none of the following: internet gateway or virtual private gateway, NAT instance,\nNAT gateway, VPC peering connection, network interface, or egress-only internet\ngateway.\n For more information, see Route Tables\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html)\nin the Amazon Virtual Private Cloud User Guide." ([replace-route-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-replace-route-request replace-route-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/replace-route-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReplaceRoute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef replace-route :args (clojure.spec.alpha/tuple :portkey.aws.ec2/replace-route-request) :ret clojure.core/true?)

(clojure.core/defn describe-placement-groups "Describes one or more of your placement groups. For more information, see\nPlacement Groups\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([] (describe-placement-groups {})) ([describe-placement-groups-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-placement-groups-request describe-placement-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-placement-groups-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-placement-groups-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribePlacementGroups", :http.request.configuration/output-deser-fn response-describe-placement-groups-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-placement-groups :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-placement-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-placement-groups-result))

(clojure.core/defn describe-import-image-tasks "Displays details about an import virtual machine or import snapshot tasks that\nare already created." ([] (describe-import-image-tasks {})) ([describe-import-image-tasks-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-import-image-tasks-request describe-import-image-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-import-image-tasks-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-import-image-tasks-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeImportImageTasks", :http.request.configuration/output-deser-fn response-describe-import-image-tasks-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-import-image-tasks :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-import-image-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-import-image-tasks-result))

(clojure.core/defn modify-identity-id-format "Modifies the ID format of a resource for a specified IAM user, IAM role, or the\nroot user for an account; or all IAM users, IAM roles, and the root user for an\naccount. You can specify that resources should receive longer IDs (17-character\nIDs) when they are created.\n This request can only be used to modify longer ID settings for resource types\nthat are within the opt-in period. Resources currently in their opt-in period\ninclude: bundle | conversion-task | customer-gateway | dhcp-options |\nelastic-ip-allocation | elastic-ip-association | export-task | flow-log | image\n| import-task | internet-gateway | network-acl | network-acl-association |\nnetwork-interface | network-interface-attachment | prefix-list | route-table |\nroute-table-association | security-group | subnet |\nsubnet-cidr-block-association | vpc | vpc-cidr-block-association | vpc-endpoint\n| vpc-peering-connection | vpn-connection | vpn-gateway.\n For more information, see Resource IDs\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/resource-ids.html) in the\nAmazon Elastic Compute Cloud User Guide.\n This setting applies to the principal specified in the request; it does not\napply to the principal that makes the request.\n Resources created with longer IDs are visible to all IAM roles and users,\nregardless of these settings and provided that they have permission to use the\nrelevant Describe command for the resource type." ([modify-identity-id-format-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-identity-id-format-request modify-identity-id-format-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-identity-id-format-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyIdentityIdFormat", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-identity-id-format :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-identity-id-format-request) :ret clojure.core/true?)

(clojure.core/defn copy-image "Initiates the copy of an AMI from the specified source region to the current\nregion. You specify the destination region by using its endpoint when making the\nrequest.\n Copies of encrypted backing snapshots for the AMI are encrypted. Copies of\nunencrypted backing snapshots remain unencrypted, unless you set Encrypted\nduring the copy operation. You cannot create an unencrypted copy of an encrypted\nbacking snapshot.\n For more information about the prerequisites and limits when copying an AMI,\nsee Copying an AMI\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/CopyingAMIs.html) in the\nAmazon Elastic Compute Cloud User Guide." ([copy-image-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-copy-image-request copy-image-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/copy-image-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/copy-image-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CopyImage", :http.request.configuration/output-deser-fn response-copy-image-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef copy-image :args (clojure.spec.alpha/tuple :portkey.aws.ec2/copy-image-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/copy-image-result))

(clojure.core/defn create-flow-logs "Creates one or more flow logs to capture information about IP traffic for a\nspecific network interface, subnet, or VPC.\n Flow log data for a monitored network interface is recorded as flow log\nrecords, which are log events consisting of fields that describe the traffic\nflow. For more information, see Flow Log Records\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/flow-logs.html#flow-log-records)\nin the Amazon Virtual Private Cloud User Guide.\n When publishing to CloudWatch Logs, flow log records are published to a log\ngroup, and each network interface has a unique log stream in the log group. When\npublishing to Amazon S3, flow log records for all of the monitored network\ninterfaces are published to a single log file object that is stored in the\nspecified bucket.\n For more information, see VPC Flow Logs\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/flow-logs.html) in the\nAmazon Virtual Private Cloud User Guide." ([create-flow-logs-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-flow-logs-request create-flow-logs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-flow-logs-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-flow-logs-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateFlowLogs", :http.request.configuration/output-deser-fn response-create-flow-logs-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-flow-logs :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-flow-logs-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-flow-logs-result))

(clojure.core/defn associate-route-table "Associates a subnet with a route table. The subnet and route table must be in\nthe same VPC. This association causes traffic originating from the subnet to be\nrouted according to the routes in the route table. The action returns an\nassociation ID, which you need in order to disassociate the route table from the\nsubnet later. A route table can be associated with multiple subnets.\n For more information, see Route Tables\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html)\nin the Amazon Virtual Private Cloud User Guide." ([associate-route-table-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-associate-route-table-request associate-route-table-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/associate-route-table-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/associate-route-table-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssociateRouteTable", :http.request.configuration/output-deser-fn response-associate-route-table-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef associate-route-table :args (clojure.spec.alpha/tuple :portkey.aws.ec2/associate-route-table-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/associate-route-table-result))

(clojure.core/defn describe-snapshots "Describes one or more of the EBS snapshots available to you. Available snapshots\ninclude public snapshots available for use by any AWS account, private snapshots\nthat you own, and private snapshots owned by another AWS account for which\nyou've been given explicit create volume permissions.\n The create volume permissions fall into the following categories:\n * public: The owner of the snapshot granted create volume permissions for the\nsnapshot to the all group. All AWS accounts have create volume permissions for\nthese snapshots.\n * explicit: The owner of the snapshot granted create volume permissions to a\nspecific AWS account.\n * implicit: An AWS account has implicit create volume permissions for all\nsnapshots it owns.\n The list of snapshots returned can be modified by specifying snapshot IDs,\nsnapshot owners, or AWS accounts with create volume permissions. If no options\nare specified, Amazon EC2 returns all snapshots for which you have create volume\npermissions.\n If you specify one or more snapshot IDs, only snapshots that have the specified\nIDs are returned. If you specify an invalid snapshot ID, an error is returned.\nIf you specify a snapshot ID for which you do not have access, it is not\nincluded in the returned results.\n If you specify one or more snapshot owners using the OwnerIds option, only\nsnapshots from the specified owners and for which you have access are returned.\nThe results can include the AWS account IDs of the specified owners, amazon for\nsnapshots owned by Amazon, or self for snapshots that you own.\n If you specify a list of restorable users, only snapshots with create snapshot\npermissions for those users are returned. You can specify AWS account IDs (if\nyou own the snapshots), self for snapshots for which you own or have explicit\npermissions, or all for public snapshots.\n If you are describing a long list of snapshots, you can paginate the output to\nmake the list more manageable. The MaxResults parameter sets the maximum number\nof results returned in a single page. If the list of results exceeds your\nMaxResults value, then that number of results is returned along with a NextToken\nvalue that can be passed to a subsequent DescribeSnapshots request to retrieve\nthe remaining results.\n For more information about EBS snapshots, see Amazon EBS Snapshots\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSSnapshots.html) in the\nAmazon Elastic Compute Cloud User Guide." ([] (describe-snapshots {})) ([describe-snapshots-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-snapshots-request describe-snapshots-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-snapshots-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-snapshots-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSnapshots", :http.request.configuration/output-deser-fn response-describe-snapshots-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-snapshots :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-snapshots-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-snapshots-result))

(clojure.core/defn create-fpga-image "Creates an Amazon FPGA Image (AFI) from the specified design checkpoint (DCP).\n The create operation is asynchronous. To verify that the AFI is ready for use,\ncheck the output logs.\n An AFI contains the FPGA bitstream that is ready to download to an FPGA. You\ncan securely deploy an AFI on one or more FPGA-accelerated instances. For more\ninformation, see the AWS FPGA Hardware Development Kit\n(https://github.com/aws/aws-fpga/)." ([create-fpga-image-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-fpga-image-request create-fpga-image-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-fpga-image-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-fpga-image-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateFpgaImage", :http.request.configuration/output-deser-fn response-create-fpga-image-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-fpga-image :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-fpga-image-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-fpga-image-result))

(clojure.core/defn cancel-capacity-reservation "Cancels the specified Capacity Reservation, releases the reserved capacity, and\nchanges the Capacity Reservation's state to cancelled.\n Instances running in the reserved capacity continue running until you stop\nthem. Stopped instances that target the Capacity Reservation can no longer\nlaunch. Modify these instances to either target a different Capacity\nReservation, launch On-Demand Instance capacity, or run in any open Capacity\nReservation that has matching attributes and sufficient capacity." ([cancel-capacity-reservation-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-cancel-capacity-reservation-request cancel-capacity-reservation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/cancel-capacity-reservation-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/cancel-capacity-reservation-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelCapacityReservation", :http.request.configuration/output-deser-fn response-cancel-capacity-reservation-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef cancel-capacity-reservation :args (clojure.spec.alpha/tuple :portkey.aws.ec2/cancel-capacity-reservation-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/cancel-capacity-reservation-result))

(clojure.core/defn create-transit-gateway "Creates a transit gateway.\n You can use a transit gateway to interconnect your virtual private clouds (VPC)\nand on-premises networks. After the transit gateway enters the available state,\nyou can attach your VPCs and VPN connections to the transit gateway.\n To attach your VPCs, use CreateTransitGatewayVpcAttachment.\n To attach a VPN connection, use CreateCustomerGateway to create a customer\ngateway and specify the ID of the customer gateway and the ID of the transit\ngateway in a call to CreateVpnConnection.\n When you create a transit gateway, we create a default transit gateway route\ntable and use it as the default association route table and the default\npropagation route table. You can use CreateTransitGatewayRouteTable to create\nadditional transit gateway route tables. If you disable automatic route\npropagation, we do not create a default transit gateway route table. You can use\nEnableTransitGatewayRouteTablePropagation to propagate routes from a resource\nattachment to a transit gateway route table. If you disable automatic\nassociations, you can use AssociateTransitGatewayRouteTable to associate a\nresource attachment with a transit gateway route table." ([] (create-transit-gateway {})) ([create-transit-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-transit-gateway-request create-transit-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-transit-gateway-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-transit-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateTransitGateway", :http.request.configuration/output-deser-fn response-create-transit-gateway-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-transit-gateway :args (clojure.spec.alpha/? :portkey.aws.ec2/create-transit-gateway-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-transit-gateway-result))

(clojure.core/defn bundle-instance "Bundles an Amazon instance store-backed Windows instance.\n During bundling, only the root device volume (C:\\) is bundled. Data on other\ninstance store volumes is not preserved.\n This action is not applicable for Linux/Unix instances or Windows instances\nthat are backed by Amazon EBS." ([bundle-instance-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-bundle-instance-request bundle-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/bundle-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/bundle-instance-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "BundleInstance", :http.request.configuration/output-deser-fn response-bundle-instance-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef bundle-instance :args (clojure.spec.alpha/tuple :portkey.aws.ec2/bundle-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/bundle-instance-result))

(clojure.core/defn replace-route-table-association "Changes the route table associated with a given subnet in a VPC. After the\noperation completes, the subnet uses the routes in the new route table it's\nassociated with. For more information about route tables, see Route Tables\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html)\nin the Amazon Virtual Private Cloud User Guide.\n You can also use ReplaceRouteTableAssociation to change which table is the main\nroute table in the VPC. You just specify the main route table's association ID\nand the route table to be the new main route table." ([replace-route-table-association-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-replace-route-table-association-request replace-route-table-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/replace-route-table-association-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/replace-route-table-association-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReplaceRouteTableAssociation", :http.request.configuration/output-deser-fn response-replace-route-table-association-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef replace-route-table-association :args (clojure.spec.alpha/tuple :portkey.aws.ec2/replace-route-table-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/replace-route-table-association-result))

(clojure.core/defn modify-vpc-endpoint-service-configuration "Modifies the attributes of your VPC endpoint service configuration. You can\nchange the Network Load Balancers for your service, and you can specify whether\nacceptance is required for requests to connect to your endpoint service through\nan interface VPC endpoint." ([modify-vpc-endpoint-service-configuration-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-vpc-endpoint-service-configuration-request modify-vpc-endpoint-service-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-vpc-endpoint-service-configuration-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-vpc-endpoint-service-configuration-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyVpcEndpointServiceConfiguration", :http.request.configuration/output-deser-fn response-modify-vpc-endpoint-service-configuration-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-vpc-endpoint-service-configuration :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-vpc-endpoint-service-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-vpc-endpoint-service-configuration-result))

(clojure.core/defn release-hosts "When you no longer want to use an On-Demand Dedicated Host it can be released.\nOn-Demand billing is stopped and the host goes into released state. The host ID\nof Dedicated Hosts that have been released can no longer be specified in another\nrequest, for example, to modify the host. You must stop or terminate all\ninstances on a host before it can be released.\n When Dedicated Hosts are released, it may take some time for them to stop\ncounting toward your limit and you may receive capacity errors when trying to\nallocate new Dedicated Hosts. Wait a few minutes and then try again.\n Released hosts still appear in a DescribeHosts response." ([release-hosts-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-release-hosts-request release-hosts-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/release-hosts-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/release-hosts-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReleaseHosts", :http.request.configuration/output-deser-fn response-release-hosts-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef release-hosts :args (clojure.spec.alpha/tuple :portkey.aws.ec2/release-hosts-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/release-hosts-result))

(clojure.core/defn copy-snapshot "Copies a point-in-time snapshot of an EBS volume and stores it in Amazon S3. You\ncan copy the snapshot within the same Region or from one Region to another. You\ncan use the snapshot to create EBS volumes or Amazon Machine Images (AMIs). The\nsnapshot is copied to the regional endpoint that you send the HTTP request to.\n Copies of encrypted EBS snapshots remain encrypted. Copies of unencrypted\nsnapshots remain unencrypted, unless the Encrypted flag is specified during the\nsnapshot copy operation. By default, encrypted snapshot copies use the default\nAWS Key Management Service (AWS KMS) customer master key (CMK); however, you can\nspecify a non-default CMK with the KmsKeyId parameter.\n To copy an encrypted snapshot that has been shared from another account, you\nmust have permissions for the CMK used to encrypt the snapshot.\n Snapshots created by copying another snapshot have an arbitrary volume ID that\nshould not be used for any purpose.\n For more information, see Copying an Amazon EBS Snapshot\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-copy-snapshot.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([copy-snapshot-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-copy-snapshot-request copy-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/copy-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/copy-snapshot-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CopySnapshot", :http.request.configuration/output-deser-fn response-copy-snapshot-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef copy-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.ec2/copy-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/copy-snapshot-result))

(clojure.core/defn stop-instances "Stops an Amazon EBS-backed instance.\n You can use the Stop action to hibernate an instance if the instance is enabled\nfor hibernation\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#enabling-hibernation)\nand it meets the hibernation prerequisites\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites).\nFor more information, see Hibernate Your Instance\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the\nAmazon Elastic Compute Cloud User Guide.\n We don't charge usage for a stopped instance, or data transfer fees; however,\nyour root partition Amazon EBS volume remains and continues to persist your\ndata, and you are charged for Amazon EBS volume usage. Every time you start your\nWindows instance, Amazon EC2 charges you for a full instance hour. If you stop\nand restart your Windows instance, a new instance hour begins and Amazon EC2\ncharges you for another full instance hour even if you are still within the same\n60-minute period when it was stopped. Every time you start your Linux instance,\nAmazon EC2 charges a one-minute minimum for instance usage, and thereafter\ncharges per second for instance usage.\n You can't start, stop, or hibernate Spot Instances, and you can't stop or\nhibernate instance store-backed instances. For information about using\nhibernation for Spot Instances, see Hibernating Interrupted Spot Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-interruptions.html#hibernate-spot-instances)\nin the Amazon Elastic Compute Cloud User Guide.\n When you stop or hibernate an instance, we shut it down. You can restart your\ninstance at any time. Before stopping or hibernating an instance, make sure it\nis in a state from which it can be restarted. Stopping an instance does not\npreserve data stored in RAM, but hibernating an instance does preserve data\nstored in RAM. If an instance cannot hibernate successfully, a normal shutdown\noccurs.\n Stopping and hibernating an instance is different to rebooting or terminating\nit. For example, when you stop or hibernate an instance, the root device and any\nother devices attached to the instance persist. When you terminate an instance,\nthe root device and any other devices attached during the instance launch are\nautomatically deleted. For more information about the differences between\nrebooting, stopping, hibernating, and terminating instances, see Instance\nLifecycle\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-lifecycle.html)\nin the Amazon Elastic Compute Cloud User Guide.\n When you stop an instance, we attempt to shut it down forcibly after a short\nwhile. If your instance appears stuck in the stopping state after a period of\ntime, there may be an issue with the underlying host computer. For more\ninformation, see Troubleshooting Stopping Your Instance\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstancesStopping.html)\nin the Amazon Elastic Compute Cloud User Guide." ([stop-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-stop-instances-request stop-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/stop-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/stop-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StopInstances", :http.request.configuration/output-deser-fn response-stop-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef stop-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/stop-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/stop-instances-result))

(clojure.core/defn modify-fpga-image-attribute "Modifies the specified attribute of the specified Amazon FPGA Image (AFI)." ([modify-fpga-image-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-fpga-image-attribute-request modify-fpga-image-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-fpga-image-attribute-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-fpga-image-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyFpgaImageAttribute", :http.request.configuration/output-deser-fn response-modify-fpga-image-attribute-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-fpga-image-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-fpga-image-attribute-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-fpga-image-attribute-result))

(clojure.core/defn describe-vpn-connections "Describes one or more of your VPN connections.\n For more information, see AWS Site-to-Site VPN\n(https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the AWS\nSite-to-Site VPN User Guide." ([] (describe-vpn-connections {})) ([describe-vpn-connections-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpn-connections-request describe-vpn-connections-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpn-connections-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpn-connections-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpnConnections", :http.request.configuration/output-deser-fn response-describe-vpn-connections-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpn-connections :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpn-connections-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpn-connections-result))

(clojure.core/defn detach-internet-gateway "Detaches an internet gateway from a VPC, disabling connectivity between the\ninternet and the VPC. The VPC must not contain any running instances with\nElastic IP addresses or public IPv4 addresses." ([detach-internet-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-detach-internet-gateway-request detach-internet-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/detach-internet-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachInternetGateway", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef detach-internet-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/detach-internet-gateway-request) :ret clojure.core/true?)

(clojure.core/defn advertise-byoip-cidr "Advertises an IPv4 address range that is provisioned for use with your AWS\nresources through bring your own IP addresses (BYOIP).\n You can perform this operation at most once every 10 seconds, even if you\nspecify different address ranges each time.\n We recommend that you stop advertising the BYOIP CIDR from other locations when\nyou advertise it from AWS. To minimize down time, you can configure your AWS\nresources to use an address from a BYOIP CIDR before it is advertised, and then\nsimultaneously stop advertising it from the current location and start\nadvertising it through AWS.\n It can take a few minutes before traffic to the specified addresses starts\nrouting to AWS because of BGP propagation delays.\n To stop advertising the BYOIP CIDR, use WithdrawByoipCidr." ([advertise-byoip-cidr-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-advertise-byoip-cidr-request advertise-byoip-cidr-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/advertise-byoip-cidr-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/advertise-byoip-cidr-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AdvertiseByoipCidr", :http.request.configuration/output-deser-fn response-advertise-byoip-cidr-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef advertise-byoip-cidr :args (clojure.spec.alpha/tuple :portkey.aws.ec2/advertise-byoip-cidr-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/advertise-byoip-cidr-result))

(clojure.core/defn get-transit-gateway-route-table-propagations "Gets information about the route table propagations for the specified transit\ngateway route table." ([get-transit-gateway-route-table-propagations-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-transit-gateway-route-table-propagations-request get-transit-gateway-route-table-propagations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/get-transit-gateway-route-table-propagations-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/get-transit-gateway-route-table-propagations-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetTransitGatewayRouteTablePropagations", :http.request.configuration/output-deser-fn response-get-transit-gateway-route-table-propagations-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef get-transit-gateway-route-table-propagations :args (clojure.spec.alpha/tuple :portkey.aws.ec2/get-transit-gateway-route-table-propagations-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/get-transit-gateway-route-table-propagations-result))

(clojure.core/defn disassociate-vpc-cidr-block "Disassociates a CIDR block from a VPC. To disassociate the CIDR block, you must\nspecify its association ID. You can get the association ID by using\nDescribeVpcs. You must detach or delete all gateways and resources that are\nassociated with the CIDR block before you can disassociate it.\n You cannot disassociate the CIDR block with which you originally created the\nVPC (the primary CIDR block)." ([disassociate-vpc-cidr-block-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disassociate-vpc-cidr-block-request disassociate-vpc-cidr-block-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/disassociate-vpc-cidr-block-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disassociate-vpc-cidr-block-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisassociateVpcCidrBlock", :http.request.configuration/output-deser-fn response-disassociate-vpc-cidr-block-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disassociate-vpc-cidr-block :args (clojure.spec.alpha/tuple :portkey.aws.ec2/disassociate-vpc-cidr-block-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/disassociate-vpc-cidr-block-result))

(clojure.core/defn get-transit-gateway-route-table-associations "Gets information about the associations for the specified transit gateway route\ntable." ([get-transit-gateway-route-table-associations-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-transit-gateway-route-table-associations-request get-transit-gateway-route-table-associations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/get-transit-gateway-route-table-associations-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/get-transit-gateway-route-table-associations-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetTransitGatewayRouteTableAssociations", :http.request.configuration/output-deser-fn response-get-transit-gateway-route-table-associations-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef get-transit-gateway-route-table-associations :args (clojure.spec.alpha/tuple :portkey.aws.ec2/get-transit-gateway-route-table-associations-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/get-transit-gateway-route-table-associations-result))

(clojure.core/defn describe-vpc-classic-link-dns-support "Describes the ClassicLink DNS support status of one or more VPCs. If enabled,\nthe DNS hostname of a linked EC2-Classic instance resolves to its private IP\naddress when addressed from an instance in the VPC to which it's linked.\nSimilarly, the DNS hostname of an instance in a VPC resolves to its private IP\naddress when addressed from a linked EC2-Classic instance. For more information,\nsee ClassicLink\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([] (describe-vpc-classic-link-dns-support {})) ([describe-vpc-classic-link-dns-support-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpc-classic-link-dns-support-request describe-vpc-classic-link-dns-support-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpc-classic-link-dns-support-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpc-classic-link-dns-support-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcClassicLinkDnsSupport", :http.request.configuration/output-deser-fn response-describe-vpc-classic-link-dns-support-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpc-classic-link-dns-support :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpc-classic-link-dns-support-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-classic-link-dns-support-result))

(clojure.core/defn move-address-to-vpc "Moves an Elastic IP address from the EC2-Classic platform to the EC2-VPC\nplatform. The Elastic IP address must be allocated to your account for more than\n24 hours, and it must not be associated with an instance. After the Elastic IP\naddress is moved, it is no longer available for use in the EC2-Classic platform,\nunless you move it back using the RestoreAddressToClassic request. You cannot\nmove an Elastic IP address that was originally allocated for use in the EC2-VPC\nplatform to the EC2-Classic platform." ([move-address-to-vpc-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-move-address-to-vpc-request move-address-to-vpc-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/move-address-to-vpc-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/move-address-to-vpc-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "MoveAddressToVpc", :http.request.configuration/output-deser-fn response-move-address-to-vpc-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef move-address-to-vpc :args (clojure.spec.alpha/tuple :portkey.aws.ec2/move-address-to-vpc-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/move-address-to-vpc-result))

(clojure.core/defn deregister-image "Deregisters the specified AMI. After you deregister an AMI, it can't be used to\nlaunch new instances; however, it doesn't affect any instances that you've\nalready launched from the AMI. You'll continue to incur usage costs for those\ninstances until you terminate them.\n When you deregister an Amazon EBS-backed AMI, it doesn't affect the snapshot\nthat was created for the root volume of the instance during the AMI creation\nprocess. When you deregister an instance store-backed AMI, it doesn't affect the\nfiles that you uploaded to Amazon S3 when you created the AMI." ([deregister-image-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-deregister-image-request deregister-image-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/deregister-image-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeregisterImage", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef deregister-image :args (clojure.spec.alpha/tuple :portkey.aws.ec2/deregister-image-request) :ret clojure.core/true?)

(clojure.core/defn associate-transit-gateway-route-table "Associates the specified attachment with the specified transit gateway route\ntable. You can associate only one route table with an attachment." ([associate-transit-gateway-route-table-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-associate-transit-gateway-route-table-request associate-transit-gateway-route-table-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/associate-transit-gateway-route-table-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/associate-transit-gateway-route-table-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssociateTransitGatewayRouteTable", :http.request.configuration/output-deser-fn response-associate-transit-gateway-route-table-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef associate-transit-gateway-route-table :args (clojure.spec.alpha/tuple :portkey.aws.ec2/associate-transit-gateway-route-table-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/associate-transit-gateway-route-table-result))

(clojure.core/defn unmonitor-instances "Disables detailed monitoring for a running instance. For more information, see\nMonitoring Your Instances and Volumes\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([unmonitor-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-unmonitor-instances-request unmonitor-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/unmonitor-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/unmonitor-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UnmonitorInstances", :http.request.configuration/output-deser-fn response-unmonitor-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef unmonitor-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/unmonitor-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/unmonitor-instances-result))

(clojure.core/defn disassociate-subnet-cidr-block "Disassociates a CIDR block from a subnet. Currently, you can disassociate an\nIPv6 CIDR block only. You must detach or delete all gateways and resources that\nare associated with the CIDR block before you can disassociate it." ([disassociate-subnet-cidr-block-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disassociate-subnet-cidr-block-request disassociate-subnet-cidr-block-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/disassociate-subnet-cidr-block-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disassociate-subnet-cidr-block-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisassociateSubnetCidrBlock", :http.request.configuration/output-deser-fn response-disassociate-subnet-cidr-block-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disassociate-subnet-cidr-block :args (clojure.spec.alpha/tuple :portkey.aws.ec2/disassociate-subnet-cidr-block-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/disassociate-subnet-cidr-block-result))

(clojure.core/defn create-network-interface-permission "Grants an AWS-authorized account permission to attach the specified network\ninterface to an instance in their account.\n You can grant permission to a single AWS account only, and only one account at\na time." ([create-network-interface-permission-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-network-interface-permission-request create-network-interface-permission-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-network-interface-permission-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-network-interface-permission-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateNetworkInterfacePermission", :http.request.configuration/output-deser-fn response-create-network-interface-permission-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-network-interface-permission :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-network-interface-permission-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-network-interface-permission-result))

(clojure.core/defn reset-snapshot-attribute "Resets permission settings for the specified snapshot.\n For more information about modifying snapshot permissions, see Sharing\nSnapshots\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-modifying-snapshot-permissions.html)\nin the Amazon Elastic Compute Cloud User Guide." ([reset-snapshot-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-reset-snapshot-attribute-request reset-snapshot-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/reset-snapshot-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ResetSnapshotAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef reset-snapshot-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/reset-snapshot-attribute-request) :ret clojure.core/true?)

(clojure.core/defn replace-transit-gateway-route "Replaces the specified route in the specified transit gateway route table." ([replace-transit-gateway-route-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-replace-transit-gateway-route-request replace-transit-gateway-route-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/replace-transit-gateway-route-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/replace-transit-gateway-route-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReplaceTransitGatewayRoute", :http.request.configuration/output-deser-fn response-replace-transit-gateway-route-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef replace-transit-gateway-route :args (clojure.spec.alpha/tuple :portkey.aws.ec2/replace-transit-gateway-route-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/replace-transit-gateway-route-result))

(clojure.core/defn create-capacity-reservation "Creates a new Capacity Reservation with the specified attributes.\n Capacity Reservations enable you to reserve capacity for your Amazon EC2\ninstances in a specific Availability Zone for any duration. This gives you the\nflexibility to selectively add capacity reservations and still get the Regional\nRI discounts for that usage. By creating Capacity Reservations, you ensure that\nyou always have access to Amazon EC2 capacity when you need it, for as long as\nyou need it. For more information, see Capacity Reservations\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html)\nin the Amazon Elastic Compute Cloud User Guide.\n Your request to create a Capacity Reservation could fail if Amazon EC2 does not\nhave sufficient capacity to fulfill the request. If your request fails due to\nAmazon EC2 capacity constraints, either try again at a later time, try in a\ndifferent Availability Zone, or request a smaller capacity reservation. If your\napplication is flexible across instance types and sizes, try to create a\nCapacity Reservation with different instance attributes.\n Your request could also fail if the requested quantity exceeds your On-Demand\nInstance limit for the selected instance type. If your request fails due to\nlimit constraints, increase your On-Demand Instance limit for the required\ninstance type and try again. For more information about increasing your instance\nlimits, see Amazon EC2 Service Limits\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-resource-limits.html)\nin the Amazon Elastic Compute Cloud User Guide." ([create-capacity-reservation-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-capacity-reservation-request create-capacity-reservation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-capacity-reservation-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-capacity-reservation-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateCapacityReservation", :http.request.configuration/output-deser-fn response-create-capacity-reservation-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-capacity-reservation :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-capacity-reservation-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-capacity-reservation-result))

(clojure.core/defn delete-flow-logs "Deletes one or more flow logs." ([delete-flow-logs-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-flow-logs-request delete-flow-logs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-flow-logs-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-flow-logs-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteFlowLogs", :http.request.configuration/output-deser-fn response-delete-flow-logs-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-flow-logs :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-flow-logs-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-flow-logs-result))

(clojure.core/defn authorize-security-group-egress "[EC2-VPC only] Adds one or more egress rules to a security group for use with a\nVPC. Specifically, this action permits instances to send traffic to one or more\ndestination IPv4 or IPv6 CIDR address ranges, or to one or more destination\nsecurity groups for the same VPC. This action doesn't apply to security groups\nfor use in EC2-Classic. For more information, see Security Groups for Your VPC\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html)\nin the Amazon Virtual Private Cloud User Guide. For more information about\nsecurity group limits, see Amazon VPC Limits\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Appendix_Limits.html).\n Each rule consists of the protocol (for example, TCP), plus either a CIDR range\nor a source group. For the TCP and UDP protocols, you must also specify the\ndestination port or port range. For the ICMP protocol, you must also specify the\nICMP type and code. You can use -1 for the type or code to mean all types or all\ncodes. You can optionally specify a description for the rule.\n Rule changes are propagated to affected instances as quickly as possible.\nHowever, a small delay might occur." ([authorize-security-group-egress-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-authorize-security-group-egress-request authorize-security-group-egress-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/authorize-security-group-egress-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AuthorizeSecurityGroupEgress", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef authorize-security-group-egress :args (clojure.spec.alpha/tuple :portkey.aws.ec2/authorize-security-group-egress-request) :ret clojure.core/true?)

(clojure.core/defn unassign-private-ip-addresses "Unassigns one or more secondary private IP addresses from a network interface." ([unassign-private-ip-addresses-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-unassign-private-ip-addresses-request unassign-private-ip-addresses-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/unassign-private-ip-addresses-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UnassignPrivateIpAddresses", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef unassign-private-ip-addresses :args (clojure.spec.alpha/tuple :portkey.aws.ec2/unassign-private-ip-addresses-request) :ret clojure.core/true?)

(clojure.core/defn describe-vpc-peering-connections "Describes one or more of your VPC peering connections." ([] (describe-vpc-peering-connections {})) ([describe-vpc-peering-connections-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpc-peering-connections-request describe-vpc-peering-connections-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpc-peering-connections-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpc-peering-connections-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcPeeringConnections", :http.request.configuration/output-deser-fn response-describe-vpc-peering-connections-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpc-peering-connections :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpc-peering-connections-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-peering-connections-result))

(clojure.core/defn delete-transit-gateway "Deletes the specified transit gateway." ([delete-transit-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-transit-gateway-request delete-transit-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-transit-gateway-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-transit-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteTransitGateway", :http.request.configuration/output-deser-fn response-delete-transit-gateway-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-transit-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-transit-gateway-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-transit-gateway-result))

(clojure.core/defn reject-vpc-endpoint-connections "Rejects one or more VPC endpoint connection requests to your VPC endpoint\nservice." ([reject-vpc-endpoint-connections-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-reject-vpc-endpoint-connections-request reject-vpc-endpoint-connections-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/reject-vpc-endpoint-connections-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/reject-vpc-endpoint-connections-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RejectVpcEndpointConnections", :http.request.configuration/output-deser-fn response-reject-vpc-endpoint-connections-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef reject-vpc-endpoint-connections :args (clojure.spec.alpha/tuple :portkey.aws.ec2/reject-vpc-endpoint-connections-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/reject-vpc-endpoint-connections-result))

(clojure.core/defn monitor-instances "Enables detailed monitoring for a running instance. Otherwise, basic monitoring\nis enabled. For more information, see Monitoring Your Instances and Volumes\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch.html) in\nthe Amazon Elastic Compute Cloud User Guide.\n To disable detailed monitoring, see ." ([monitor-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-monitor-instances-request monitor-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/monitor-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/monitor-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "MonitorInstances", :http.request.configuration/output-deser-fn response-monitor-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef monitor-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/monitor-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/monitor-instances-result))

(clojure.core/defn describe-instance-credit-specifications "Describes the credit option for CPU usage of one or more of your T2 or T3\ninstances. The credit options are standard and unlimited.\n If you do not specify an instance ID, Amazon EC2 returns T2 and T3 instances\nwith the unlimited credit option, as well as instances that were previously\nconfigured as T2 or T3 with the unlimited credit option. For example, if you\nresize a T2 instance, while it is configured as unlimited, to an M4 instance,\nAmazon EC2 returns the M4 instance.\n If you specify one or more instance IDs, Amazon EC2 returns the credit option\n(standard or unlimited) of those instances. If you specify an instance ID that\nis not valid, such as an instance that is not a T2 or T3 instance, an error is\nreturned.\n Recently terminated instances might appear in the returned results. This\ninterval is usually less than one hour.\n If an Availability Zone is experiencing a service disruption and you specify\ninstance IDs in the affected zone, or do not specify any instance IDs at all,\nthe call fails. If you specify only instance IDs in an unaffected zone, the call\nworks normally.\n For more information, see Burstable Performance Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html)\nin the Amazon Elastic Compute Cloud User Guide." ([] (describe-instance-credit-specifications {})) ([describe-instance-credit-specifications-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-instance-credit-specifications-request describe-instance-credit-specifications-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-instance-credit-specifications-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-instance-credit-specifications-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstanceCreditSpecifications", :http.request.configuration/output-deser-fn response-describe-instance-credit-specifications-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-instance-credit-specifications :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-instance-credit-specifications-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-instance-credit-specifications-result))

(clojure.core/defn describe-iam-instance-profile-associations "Describes your IAM instance profile associations." ([] (describe-iam-instance-profile-associations {})) ([describe-iam-instance-profile-associations-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-iam-instance-profile-associations-request describe-iam-instance-profile-associations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-iam-instance-profile-associations-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-iam-instance-profile-associations-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeIamInstanceProfileAssociations", :http.request.configuration/output-deser-fn response-describe-iam-instance-profile-associations-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-iam-instance-profile-associations :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-iam-instance-profile-associations-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-iam-instance-profile-associations-result))

(clojure.core/defn describe-flow-logs "Describes one or more flow logs. To view the information in your flow logs (the\nlog streams for the network interfaces), you must use the CloudWatch Logs\nconsole or the CloudWatch Logs API." ([] (describe-flow-logs {})) ([describe-flow-logs-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-flow-logs-request describe-flow-logs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-flow-logs-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-flow-logs-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeFlowLogs", :http.request.configuration/output-deser-fn response-describe-flow-logs-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-flow-logs :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-flow-logs-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-flow-logs-result))

(clojure.core/defn detach-vpn-gateway "Detaches a virtual private gateway from a VPC. You do this if you're planning to\nturn off the VPC and not use it anymore. You can confirm a virtual private\ngateway has been completely detached from a VPC by describing the virtual\nprivate gateway (any attachments to the virtual private gateway are also\ndescribed).\n You must wait for the attachment's state to switch to detached before you can\ndelete the VPC or attach a different VPC to the virtual private gateway." ([detach-vpn-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-detach-vpn-gateway-request detach-vpn-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/detach-vpn-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachVpnGateway", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef detach-vpn-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/detach-vpn-gateway-request) :ret clojure.core/true?)

(clojure.core/defn cancel-spot-fleet-requests "Cancels the specified Spot Fleet requests.\n After you cancel a Spot Fleet request, the Spot Fleet launches no new Spot\nInstances. You must specify whether the Spot Fleet should also terminate its\nSpot Instances. If you terminate the instances, the Spot Fleet request enters\nthe cancelled_terminating state. Otherwise, the Spot Fleet request enters the\ncancelled_running state and the instances continue to run until they are\ninterrupted or you terminate them manually." ([cancel-spot-fleet-requests-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-cancel-spot-fleet-requests-request cancel-spot-fleet-requests-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/cancel-spot-fleet-requests-response, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/cancel-spot-fleet-requests-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelSpotFleetRequests", :http.request.configuration/output-deser-fn response-cancel-spot-fleet-requests-response, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef cancel-spot-fleet-requests :args (clojure.spec.alpha/tuple :portkey.aws.ec2/cancel-spot-fleet-requests-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/cancel-spot-fleet-requests-response))

(clojure.core/defn cancel-reserved-instances-listing "Cancels the specified Reserved Instance listing in the Reserved Instance\nMarketplace.\n For more information, see Reserved Instance Marketplace\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-market-general.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([cancel-reserved-instances-listing-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-cancel-reserved-instances-listing-request cancel-reserved-instances-listing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/cancel-reserved-instances-listing-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/cancel-reserved-instances-listing-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelReservedInstancesListing", :http.request.configuration/output-deser-fn response-cancel-reserved-instances-listing-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef cancel-reserved-instances-listing :args (clojure.spec.alpha/tuple :portkey.aws.ec2/cancel-reserved-instances-listing-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/cancel-reserved-instances-listing-result))

(clojure.core/defn modify-volume-attribute "Modifies a volume attribute.\n By default, all I/O operations for the volume are suspended when the data on\nthe volume is determined to be potentially inconsistent, to prevent\nundetectable, latent data corruption. The I/O access to the volume can be\nresumed by first enabling I/O access and then checking the data consistency on\nyour volume.\n You can change the default behavior to resume I/O operations. We recommend that\nyou change this only for boot volumes or for volumes that are stateless or\ndisposable." ([modify-volume-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-volume-attribute-request modify-volume-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-volume-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyVolumeAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-volume-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-volume-attribute-request) :ret clojure.core/true?)

(clojure.core/defn modify-snapshot-attribute "Adds or removes permission settings for the specified snapshot. You may add or\nremove specified AWS account IDs from a snapshot's list of create volume\npermissions, but you cannot do both in a single API call. If you need to both\nadd and remove account IDs for a snapshot, you must use multiple API calls.\n Encrypted snapshots and snapshots with AWS Marketplace product codes cannot be\nmade public. Snapshots encrypted with your default CMK cannot be shared with\nother accounts.\n For more information about modifying snapshot permissions, see Sharing\nSnapshots\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-modifying-snapshot-permissions.html)\nin the Amazon Elastic Compute Cloud User Guide." ([modify-snapshot-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-snapshot-attribute-request modify-snapshot-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-snapshot-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifySnapshotAttribute", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-snapshot-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-snapshot-attribute-request) :ret clojure.core/true?)

(clojure.core/defn attach-vpn-gateway "Attaches a virtual private gateway to a VPC. You can attach one virtual private\ngateway to one VPC at a time.\n For more information, see AWS Site-to-Site VPN\n(https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the AWS\nSite-to-Site VPN User Guide." ([attach-vpn-gateway-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-attach-vpn-gateway-request attach-vpn-gateway-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/attach-vpn-gateway-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/attach-vpn-gateway-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachVpnGateway", :http.request.configuration/output-deser-fn response-attach-vpn-gateway-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef attach-vpn-gateway :args (clojure.spec.alpha/tuple :portkey.aws.ec2/attach-vpn-gateway-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/attach-vpn-gateway-result))

(clojure.core/defn purchase-scheduled-instances "Purchases one or more Scheduled Instances with the specified schedule.\n Scheduled Instances enable you to purchase Amazon EC2 compute capacity by the\nhour for a one-year term. Before you can purchase a Scheduled Instance, you must\ncall DescribeScheduledInstanceAvailability to check for available schedules and\nobtain a purchase token. After you purchase a Scheduled Instance, you must call\nRunScheduledInstances during each scheduled time period.\n After you purchase a Scheduled Instance, you can't cancel, modify, or resell\nyour purchase." ([purchase-scheduled-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-purchase-scheduled-instances-request purchase-scheduled-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/purchase-scheduled-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/purchase-scheduled-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PurchaseScheduledInstances", :http.request.configuration/output-deser-fn response-purchase-scheduled-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef purchase-scheduled-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/purchase-scheduled-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/purchase-scheduled-instances-result))

(clojure.core/defn export-client-vpn-client-configuration "Downloads the contents of the Client VPN endpoint configuration file for the\nspecified Client VPN endpoint. The Client VPN endpoint configuration file\nincludes the Client VPN endpoint and certificate information clients need to\nestablish a connection with the Client VPN endpoint." ([export-client-vpn-client-configuration-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-export-client-vpn-client-configuration-request export-client-vpn-client-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/export-client-vpn-client-configuration-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/export-client-vpn-client-configuration-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ExportClientVpnClientConfiguration", :http.request.configuration/output-deser-fn response-export-client-vpn-client-configuration-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef export-client-vpn-client-configuration :args (clojure.spec.alpha/tuple :portkey.aws.ec2/export-client-vpn-client-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/export-client-vpn-client-configuration-result))

(clojure.core/defn create-security-group "Creates a security group.\n A security group is for use with instances either in the EC2-Classic platform\nor in a specific VPC. For more information, see Amazon EC2 Security Groups\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html)\nin the Amazon Elastic Compute Cloud User Guide and Security Groups for Your VPC\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html)\nin the Amazon Virtual Private Cloud User Guide.\n EC2-Classic: You can have up to 500 security groups.\n EC2-VPC: You can create up to 500 security groups per VPC.\n When you create a security group, you specify a friendly name of your choice.\nYou can have a security group for use in EC2-Classic with the same name as a\nsecurity group for use in a VPC. However, you can't have two security groups for\nuse in EC2-Classic with the same name or two security groups for use in a VPC\nwith the same name.\n You have a default security group for use in EC2-Classic and a default security\ngroup for use in your VPC. If you don't specify a security group when you launch\nan instance, the instance is launched into the appropriate default security\ngroup. A default security group includes a default rule that grants instances\nunrestricted network access to each other.\n You can add or remove rules from your security groups using\nAuthorizeSecurityGroupIngress, AuthorizeSecurityGroupEgress,\nRevokeSecurityGroupIngress, and RevokeSecurityGroupEgress." ([create-security-group-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-security-group-request create-security-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-security-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-security-group-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateSecurityGroup", :http.request.configuration/output-deser-fn response-create-security-group-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-security-group :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-security-group-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-security-group-result))

(clojure.core/defn cancel-bundle-task "Cancels a bundling operation for an instance store-backed Windows instance." ([cancel-bundle-task-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-cancel-bundle-task-request cancel-bundle-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/cancel-bundle-task-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/cancel-bundle-task-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelBundleTask", :http.request.configuration/output-deser-fn response-cancel-bundle-task-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef cancel-bundle-task :args (clojure.spec.alpha/tuple :portkey.aws.ec2/cancel-bundle-task-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/cancel-bundle-task-result))

(clojure.core/defn provision-byoip-cidr "Provisions an address range for use with your AWS resources through bring your\nown IP addresses (BYOIP) and creates a corresponding address pool. After the\naddress range is provisioned, it is ready to be advertised using\nAdvertiseByoipCidr.\n AWS verifies that you own the address range and are authorized to advertise it.\nYou must ensure that the address range is registered to you and that you created\nan RPKI ROA to authorize Amazon ASNs 16509 and 14618 to advertise the address\nrange. For more information, see Bring Your Own IP Addresses (BYOIP)\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html) in the\nAmazon Elastic Compute Cloud User Guide.\n Provisioning an address range is an asynchronous operation, so the call returns\nimmediately, but the address range is not ready to use until its status changes\nfrom pending-provision to provisioned. To monitor the status of an address\nrange, use DescribeByoipCidrs. To allocate an Elastic IP address from your\naddress pool, use AllocateAddress with either the specific address from the\naddress pool or the ID of the address pool." ([provision-byoip-cidr-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-provision-byoip-cidr-request provision-byoip-cidr-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/provision-byoip-cidr-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/provision-byoip-cidr-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ProvisionByoipCidr", :http.request.configuration/output-deser-fn response-provision-byoip-cidr-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef provision-byoip-cidr :args (clojure.spec.alpha/tuple :portkey.aws.ec2/provision-byoip-cidr-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/provision-byoip-cidr-result))

(clojure.core/defn restore-address-to-classic "Restores an Elastic IP address that was previously moved to the EC2-VPC platform\nback to the EC2-Classic platform. You cannot move an Elastic IP address that was\noriginally allocated for use in EC2-VPC. The Elastic IP address must not be\nassociated with an instance or network interface." ([restore-address-to-classic-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-restore-address-to-classic-request restore-address-to-classic-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/restore-address-to-classic-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/restore-address-to-classic-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RestoreAddressToClassic", :http.request.configuration/output-deser-fn response-restore-address-to-classic-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef restore-address-to-classic :args (clojure.spec.alpha/tuple :portkey.aws.ec2/restore-address-to-classic-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/restore-address-to-classic-result))

(clojure.core/defn terminate-instances "Shuts down one or more instances. This operation is idempotent; if you terminate\nan instance more than once, each call succeeds.\n If you specify multiple instances and the request fails (for example, because\nof a single incorrect instance ID), none of the instances are terminated.\n Terminated instances remain visible after termination (for approximately one\nhour).\n By default, Amazon EC2 deletes all EBS volumes that were attached when the\ninstance launched. Volumes attached after instance launch continue running.\n You can stop, start, and terminate EBS-backed instances. You can only terminate\ninstance store-backed instances. What happens to an instance differs if you stop\nit or terminate it. For example, when you stop an instance, the root device and\nany other devices attached to the instance persist. When you terminate an\ninstance, any attached EBS volumes with the DeleteOnTermination block device\nmapping parameter set to true are automatically deleted. For more information\nabout the differences between stopping and terminating instances, see Instance\nLifecycle\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-lifecycle.html)\nin the Amazon Elastic Compute Cloud User Guide.\n For more information about troubleshooting, see Troubleshooting Terminating\nYour Instance\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstancesShuttingDown.html)\nin the Amazon Elastic Compute Cloud User Guide." ([terminate-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-terminate-instances-request terminate-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/terminate-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/terminate-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TerminateInstances", :http.request.configuration/output-deser-fn response-terminate-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef terminate-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/terminate-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/terminate-instances-result))

(clojure.core/defn describe-regions "Describes one or more regions that are currently available to you.\n For a list of the regions supported by Amazon EC2, see Regions and Endpoints\n(https://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)." ([] (describe-regions {})) ([describe-regions-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-regions-request describe-regions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-regions-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-regions-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeRegions", :http.request.configuration/output-deser-fn response-describe-regions-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-regions :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-regions-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-regions-result))

(clojure.core/defn create-network-interface "Creates a network interface in the specified subnet.\n For more information about network interfaces, see Elastic Network Interfaces\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html) in the\nAmazon Virtual Private Cloud User Guide." ([create-network-interface-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-network-interface-request create-network-interface-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-network-interface-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-network-interface-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateNetworkInterface", :http.request.configuration/output-deser-fn response-create-network-interface-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-network-interface :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-network-interface-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-network-interface-result))

(clojure.core/defn create-vpc-peering-connection "Requests a VPC peering connection between two VPCs: a requester VPC that you own\nand an accepter VPC with which to create the connection. The accepter VPC can\nbelong to another AWS account and can be in a different Region to the requester\nVPC. The requester VPC and accepter VPC cannot have overlapping CIDR blocks.\n Limitations and rules apply to a VPC peering connection. For more information,\nsee the limitations\n(https://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide/vpc-peering-basics.html#vpc-peering-limitations)\nsection in the VPC Peering Guide.\n The owner of the accepter VPC must accept the peering request to activate the\npeering connection. The VPC peering connection request expires after 7 days,\nafter which it cannot be accepted or rejected.\n If you create a VPC peering connection request between VPCs with overlapping\nCIDR blocks, the VPC peering connection has a status of failed." ([] (create-vpc-peering-connection {})) ([create-vpc-peering-connection-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-vpc-peering-connection-request create-vpc-peering-connection-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-vpc-peering-connection-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-vpc-peering-connection-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVpcPeeringConnection", :http.request.configuration/output-deser-fn response-create-vpc-peering-connection-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-vpc-peering-connection :args (clojure.spec.alpha/? :portkey.aws.ec2/create-vpc-peering-connection-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-vpc-peering-connection-result))

(clojure.core/defn create-vpc-endpoint "Creates a VPC endpoint for a specified service. An endpoint enables you to\ncreate a private connection between your VPC and the service. The service may be\nprovided by AWS, an AWS Marketplace partner, or another AWS account. For more\ninformation, see VPC Endpoints\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-endpoints.html) in\nthe Amazon Virtual Private Cloud User Guide.\n A gateway endpoint serves as a target for a route in your route table for\ntraffic destined for the AWS service. You can specify an endpoint policy to\nattach to the endpoint that will control access to the service from your VPC.\nYou can also specify the VPC route tables that use the endpoint.\n An interface endpoint is a network interface in your subnet that serves as an\nendpoint for communicating with the specified service. You can specify the\nsubnets in which to create an endpoint, and the security groups to associate\nwith the endpoint network interface.\n Use DescribeVpcEndpointServices to get a list of supported services." ([create-vpc-endpoint-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-vpc-endpoint-request create-vpc-endpoint-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-vpc-endpoint-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-vpc-endpoint-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVpcEndpoint", :http.request.configuration/output-deser-fn response-create-vpc-endpoint-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-vpc-endpoint :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-vpc-endpoint-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-vpc-endpoint-result))

(clojure.core/defn create-placement-group "Creates a placement group in which to launch instances. The strategy of the\nplacement group determines how the instances are organized within the group.\n A cluster placement group is a logical grouping of instances within a single\nAvailability Zone that benefit from low network latency, high network\nthroughput. A spread placement group places instances on distinct hardware. A\npartition placement group places groups of instances in different partitions,\nwhere instances in one partition do not share the same hardware with instances\nin another partition.\n For more information, see Placement Groups\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html) in\nthe Amazon Elastic Compute Cloud User Guide." ([] (create-placement-group {})) ([create-placement-group-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-placement-group-request create-placement-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-placement-group-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreatePlacementGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-placement-group :args (clojure.spec.alpha/? :portkey.aws.ec2/create-placement-group-request) :ret clojure.core/true?)

(clojure.core/defn delete-network-interface-permission "Deletes a permission for a network interface. By default, you cannot delete the\npermission if the account for which you're removing the permission has attached\nthe network interface to an instance. However, you can force delete the\npermission, regardless of any attachment." ([delete-network-interface-permission-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-network-interface-permission-request delete-network-interface-permission-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-network-interface-permission-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-network-interface-permission-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteNetworkInterfacePermission", :http.request.configuration/output-deser-fn response-delete-network-interface-permission-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-network-interface-permission :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-network-interface-permission-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-network-interface-permission-result))

(clojure.core/defn attach-classic-link-vpc "Links an EC2-Classic instance to a ClassicLink-enabled VPC through one or more\nof the VPC's security groups. You cannot link an EC2-Classic instance to more\nthan one VPC at a time. You can only link an instance that's in the running\nstate. An instance is automatically unlinked from a VPC when it's stopped - you\ncan link it to the VPC again when you restart it.\n After you've linked an instance, you cannot change the VPC security groups that\nare associated with it. To change the security groups, you must first unlink the\ninstance, and then link it again.\n Linking your instance to a VPC is sometimes referred to as attaching your\ninstance." ([attach-classic-link-vpc-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-attach-classic-link-vpc-request attach-classic-link-vpc-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/attach-classic-link-vpc-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/attach-classic-link-vpc-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachClassicLinkVpc", :http.request.configuration/output-deser-fn response-attach-classic-link-vpc-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef attach-classic-link-vpc :args (clojure.spec.alpha/tuple :portkey.aws.ec2/attach-classic-link-vpc-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/attach-classic-link-vpc-result))

(clojure.core/defn describe-aggregate-id-format "Describes the longer ID format settings for all resource types in a specific\nregion. This request is useful for performing a quick audit to determine whether\na specific region is fully opted in for longer IDs (17-character IDs).\n This request only returns information about resource types that support longer\nIDs.\n The following resource types support longer IDs: bundle | conversion-task |\ncustomer-gateway | dhcp-options | elastic-ip-allocation | elastic-ip-association\n| export-task | flow-log | image | import-task | instance | internet-gateway |\nnetwork-acl | network-acl-association | network-interface |\nnetwork-interface-attachment | prefix-list | reservation | route-table |\nroute-table-association | security-group | snapshot | subnet |\nsubnet-cidr-block-association | volume | vpc | vpc-cidr-block-association |\nvpc-endpoint | vpc-peering-connection | vpn-connection | vpn-gateway." ([] (describe-aggregate-id-format {})) ([describe-aggregate-id-format-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-aggregate-id-format-request describe-aggregate-id-format-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-aggregate-id-format-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-aggregate-id-format-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAggregateIdFormat", :http.request.configuration/output-deser-fn response-describe-aggregate-id-format-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-aggregate-id-format :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-aggregate-id-format-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-aggregate-id-format-result))

(clojure.core/defn replace-iam-instance-profile-association "Replaces an IAM instance profile for the specified running instance. You can use\nthis action to change the IAM instance profile that's associated with an\ninstance without having to disassociate the existing IAM instance profile first.\n Use DescribeIamInstanceProfileAssociations to get the association ID." ([replace-iam-instance-profile-association-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-replace-iam-instance-profile-association-request replace-iam-instance-profile-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/replace-iam-instance-profile-association-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/replace-iam-instance-profile-association-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReplaceIamInstanceProfileAssociation", :http.request.configuration/output-deser-fn response-replace-iam-instance-profile-association-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef replace-iam-instance-profile-association :args (clojure.spec.alpha/tuple :portkey.aws.ec2/replace-iam-instance-profile-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/replace-iam-instance-profile-association-result))

(clojure.core/defn modify-fleet "Modifies the specified EC2 Fleet.\n While the EC2 Fleet is being modified, it is in the modifying state." ([modify-fleet-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-fleet-request modify-fleet-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-fleet-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-fleet-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyFleet", :http.request.configuration/output-deser-fn response-modify-fleet-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-fleet :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-fleet-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-fleet-result))

(clojure.core/defn update-security-group-rule-descriptions-ingress "Updates the description of an ingress (inbound) security group rule. You can\nreplace an existing description, or add a description to a rule that did not\nhave one previously.\n You specify the description as part of the IP permissions structure. You can\nremove a description for a security group rule by omitting the description\nparameter in the request." ([update-security-group-rule-descriptions-ingress-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-update-security-group-rule-descriptions-ingress-request update-security-group-rule-descriptions-ingress-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/update-security-group-rule-descriptions-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/update-security-group-rule-descriptions-ingress-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateSecurityGroupRuleDescriptionsIngress", :http.request.configuration/output-deser-fn response-update-security-group-rule-descriptions-ingress-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef update-security-group-rule-descriptions-ingress :args (clojure.spec.alpha/tuple :portkey.aws.ec2/update-security-group-rule-descriptions-ingress-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/update-security-group-rule-descriptions-ingress-result))

(clojure.core/defn request-spot-fleet "Creates a Spot Fleet request.\n The Spot Fleet request specifies the total target capacity and the On-Demand\ntarget capacity. Amazon EC2 calculates the difference between the total capacity\nand On-Demand capacity, and launches the difference as Spot capacity.\n You can submit a single request that includes multiple launch specifications\nthat vary by instance type, AMI, Availability Zone, or subnet.\n By default, the Spot Fleet requests Spot Instances in the Spot pool where the\nprice per unit is the lowest. Each launch specification can include its own\ninstance weighting that reflects the value of the instance type to your\napplication workload.\n Alternatively, you can specify that the Spot Fleet distribute the target\ncapacity across the Spot pools included in its launch specifications. By\nensuring that the Spot Instances in your Spot Fleet are in different Spot pools,\nyou can improve the availability of your fleet.\n You can specify tags for the Spot Instances. You cannot tag other resource\ntypes in a Spot Fleet request because only the instance resource type is\nsupported.\n For more information, see Spot Fleet Requests\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html)\nin the Amazon EC2 User Guide for Linux Instances." ([request-spot-fleet-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-request-spot-fleet-request request-spot-fleet-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/request-spot-fleet-response, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/request-spot-fleet-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RequestSpotFleet", :http.request.configuration/output-deser-fn response-request-spot-fleet-response, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef request-spot-fleet :args (clojure.spec.alpha/tuple :portkey.aws.ec2/request-spot-fleet-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/request-spot-fleet-response))

(clojure.core/defn detach-classic-link-vpc "Unlinks (detaches) a linked EC2-Classic instance from a VPC. After the instance\nhas been unlinked, the VPC security groups are no longer associated with it. An\ninstance is automatically unlinked from a VPC when it's stopped." ([detach-classic-link-vpc-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-detach-classic-link-vpc-request detach-classic-link-vpc-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/detach-classic-link-vpc-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/detach-classic-link-vpc-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachClassicLinkVpc", :http.request.configuration/output-deser-fn response-detach-classic-link-vpc-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef detach-classic-link-vpc :args (clojure.spec.alpha/tuple :portkey.aws.ec2/detach-classic-link-vpc-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/detach-classic-link-vpc-result))

(clojure.core/defn describe-vpc-endpoint-service-permissions "Describes the principals (service consumers) that are permitted to discover your\nVPC endpoint service." ([describe-vpc-endpoint-service-permissions-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpc-endpoint-service-permissions-request describe-vpc-endpoint-service-permissions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpc-endpoint-service-permissions-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpc-endpoint-service-permissions-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcEndpointServicePermissions", :http.request.configuration/output-deser-fn response-describe-vpc-endpoint-service-permissions-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpc-endpoint-service-permissions :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-vpc-endpoint-service-permissions-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-endpoint-service-permissions-result))

(clojure.core/defn create-transit-gateway-route-table "Creates a route table for the specified transit gateway." ([create-transit-gateway-route-table-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-transit-gateway-route-table-request create-transit-gateway-route-table-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-transit-gateway-route-table-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-transit-gateway-route-table-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateTransitGatewayRouteTable", :http.request.configuration/output-deser-fn response-create-transit-gateway-route-table-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-transit-gateway-route-table :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-transit-gateway-route-table-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-transit-gateway-route-table-result))

(clojure.core/defn describe-network-interface-permissions "Describes the permissions for your network interfaces." ([] (describe-network-interface-permissions {})) ([describe-network-interface-permissions-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-network-interface-permissions-request describe-network-interface-permissions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-network-interface-permissions-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-network-interface-permissions-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeNetworkInterfacePermissions", :http.request.configuration/output-deser-fn response-describe-network-interface-permissions-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-network-interface-permissions :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-network-interface-permissions-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-network-interface-permissions-result))

(clojure.core/defn create-vpn-connection "Creates a VPN connection between an existing virtual private gateway and a VPN\ncustomer gateway. The only supported connection type is ipsec.1.\n The response includes information that you need to give to your network\nadministrator to configure your customer gateway.\n We strongly recommend that you use HTTPS when calling this operation because\nthe response contains sensitive cryptographic information for configuring your\ncustomer gateway.\n If you decide to shut down your VPN connection for any reason and later create\na new VPN connection, you must reconfigure your customer gateway with the new\ninformation returned from this call.\n This is an idempotent operation. If you perform the operation more than once,\nAmazon EC2 doesn't return an error.\n For more information, see AWS Site-to-Site VPN\n(https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the AWS\nSite-to-Site VPN User Guide." ([create-vpn-connection-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-vpn-connection-request create-vpn-connection-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/create-vpn-connection-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-vpn-connection-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVpnConnection", :http.request.configuration/output-deser-fn response-create-vpn-connection-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-vpn-connection :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-vpn-connection-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/create-vpn-connection-result))

(clojure.core/defn disable-transit-gateway-route-table-propagation "Disables the specified resource attachment from propagating routes to the\nspecified propagation route table." ([disable-transit-gateway-route-table-propagation-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-disable-transit-gateway-route-table-propagation-request disable-transit-gateway-route-table-propagation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/disable-transit-gateway-route-table-propagation-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/disable-transit-gateway-route-table-propagation-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisableTransitGatewayRouteTablePropagation", :http.request.configuration/output-deser-fn response-disable-transit-gateway-route-table-propagation-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef disable-transit-gateway-route-table-propagation :args (clojure.spec.alpha/tuple :portkey.aws.ec2/disable-transit-gateway-route-table-propagation-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/disable-transit-gateway-route-table-propagation-result))

(clojure.core/defn describe-fleet-instances "Describes the running instances for the specified EC2 Fleet." ([describe-fleet-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-fleet-instances-request describe-fleet-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-fleet-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-fleet-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeFleetInstances", :http.request.configuration/output-deser-fn response-describe-fleet-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-fleet-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-fleet-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-fleet-instances-result))

(clojure.core/defn describe-client-vpn-connections "Describes active client connections and connections that have been terminated\nwithin the last 60 minutes for the specified Client VPN endpoint." ([describe-client-vpn-connections-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-client-vpn-connections-request describe-client-vpn-connections-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-client-vpn-connections-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-client-vpn-connections-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeClientVpnConnections", :http.request.configuration/output-deser-fn response-describe-client-vpn-connections-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-client-vpn-connections :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-client-vpn-connections-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-client-vpn-connections-result))

(clojure.core/defn delete-launch-template-versions "Deletes one or more versions of a launch template. You cannot delete the default\nversion of a launch template; you must first assign a different version as the\ndefault. If the default version is the only version for the launch template, you\nmust delete the entire launch template using DeleteLaunchTemplate." ([delete-launch-template-versions-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-launch-template-versions-request delete-launch-template-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-launch-template-versions-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-launch-template-versions-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteLaunchTemplateVersions", :http.request.configuration/output-deser-fn response-delete-launch-template-versions-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-launch-template-versions :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-launch-template-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-launch-template-versions-result))

(clojure.core/defn modify-vpc-endpoint "Modifies attributes of a specified VPC endpoint. The attributes that you can\nmodify depend on the type of VPC endpoint (interface or gateway). For more\ninformation, see VPC Endpoints\n(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-endpoints.html) in\nthe Amazon Virtual Private Cloud User Guide." ([modify-vpc-endpoint-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-vpc-endpoint-request modify-vpc-endpoint-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/modify-vpc-endpoint-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-vpc-endpoint-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyVpcEndpoint", :http.request.configuration/output-deser-fn response-modify-vpc-endpoint-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-vpc-endpoint :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-vpc-endpoint-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/modify-vpc-endpoint-result))

(clojure.core/defn enable-volume-io "Enables I/O operations for a volume that had I/O operations disabled because the\ndata on the volume was potentially inconsistent." ([enable-volume-io-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-enable-volume-io-request enable-volume-io-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/enable-volume-io-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "EnableVolumeIO", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef enable-volume-io :args (clojure.spec.alpha/tuple :portkey.aws.ec2/enable-volume-io-request) :ret clojure.core/true?)

(clojure.core/defn modify-id-format "Modifies the ID format for the specified resource on a per-region basis. You can\nspecify that resources should receive longer IDs (17-character IDs) when they\nare created.\n This request can only be used to modify longer ID settings for resource types\nthat are within the opt-in period. Resources currently in their opt-in period\ninclude: bundle | conversion-task | customer-gateway | dhcp-options |\nelastic-ip-allocation | elastic-ip-association | export-task | flow-log | image\n| import-task | internet-gateway | network-acl | network-acl-association |\nnetwork-interface | network-interface-attachment | prefix-list | route-table |\nroute-table-association | security-group | subnet |\nsubnet-cidr-block-association | vpc | vpc-cidr-block-association | vpc-endpoint\n| vpc-peering-connection | vpn-connection | vpn-gateway.\n This setting applies to the IAM user who makes the request; it does not apply\nto the entire AWS account. By default, an IAM user defaults to the same settings\nas the root user. If you're using this action as the root user, then these\nsettings apply to the entire account, unless an IAM user explicitly overrides\nthese settings for themselves. For more information, see Resource IDs\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/resource-ids.html) in the\nAmazon Elastic Compute Cloud User Guide.\n Resources created with longer IDs are visible to all IAM roles and users,\nregardless of these settings and provided that they have permission to use the\nrelevant Describe command for the resource type." ([modify-id-format-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-id-format-request modify-id-format-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/modify-id-format-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyIdFormat", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef modify-id-format :args (clojure.spec.alpha/tuple :portkey.aws.ec2/modify-id-format-request) :ret clojure.core/true?)

(clojure.core/defn delete-transit-gateway-route-table "Deletes the specified transit gateway route table. You must disassociate the\nroute table from any transit gateway route tables before you can delete it." ([delete-transit-gateway-route-table-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-transit-gateway-route-table-request delete-transit-gateway-route-table-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-transit-gateway-route-table-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-transit-gateway-route-table-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteTransitGatewayRouteTable", :http.request.configuration/output-deser-fn response-delete-transit-gateway-route-table-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-transit-gateway-route-table :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-transit-gateway-route-table-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-transit-gateway-route-table-result))

(clojure.core/defn run-instances "Launches the specified number of instances using an AMI for which you have\npermissions.\n You can specify a number of options, or leave the default options. The\nfollowing rules apply:\n * [EC2-VPC] If you don't specify a subnet ID, we choose a default subnet from\nyour default VPC for you. If you don't have a default VPC, you must specify a\nsubnet ID in the request.\n * [EC2-Classic] If don't specify an Availability Zone, we choose one for you.\n * Some instance types must be launched into a VPC. If you do not have a default\nVPC, or if you do not specify a subnet ID, the request fails. For more\ninformation, see Instance Types Available Only in a VPC\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-vpc.html#vpc-only-instance-types).\n * [EC2-VPC] All instances have a network interface with a primary private IPv4\naddress. If you don't specify this address, we choose one from the IPv4 range of\nyour subnet.\n * Not all instance types support IPv6 addresses. For more information, see\nInstance Types\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html).\n * If you don't specify a security group ID, we use the default security group.\nFor more information, see Security Groups\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html).\n * If any of the AMIs have a product code attached for which the user has not\nsubscribed, the request fails.\n You can create a launch template\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html),\nwhich is a resource that contains the parameters to launch an instance. When you\nlaunch an instance using RunInstances, you can specify the launch template\ninstead of specifying the launch parameters.\n To ensure faster instance launches, break up large requests into smaller\nbatches. For example, create five separate launch requests for 100 instances\neach instead of one launch request for 500 instances.\n An instance is ready for you to use when it's in the running state. You can\ncheck the state of your instance using DescribeInstances. You can tag instances\nand EBS volumes during launch, after launch, or both. For more information, see\nCreateTags and Tagging Your Amazon EC2 Resources\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html).\n Linux instances have access to the public key of the key pair at boot. You can\nuse this key to provide secure access to the instance. Amazon EC2 public images\nuse this feature to provide secure access without passwords. For more\ninformation, see Key Pairs\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html) in the\nAmazon Elastic Compute Cloud User Guide.\n For troubleshooting, see What To Do If An Instance Immediately Terminates\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_InstanceStraightToTerminated.html),\nand Troubleshooting Connecting to Your Instance\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstancesConnecting.html)\nin the Amazon Elastic Compute Cloud User Guide." ([run-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-run-instances-request run-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/reservation, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/run-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RunInstances", :http.request.configuration/output-deser-fn response-reservation, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef run-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/run-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/reservation))

(clojure.core/defn create-key-pair "Creates a 2048-bit RSA key pair with the specified name. Amazon EC2 stores the\npublic key and displays the private key for you to save to a file. The private\nkey is returned as an unencrypted PEM encoded PKCS#1 private key. If a key with\nthe specified name already exists, Amazon EC2 returns an error.\n You can have up to five thousand key pairs per region.\n The key pair returned to you is available only in the region in which you\ncreate it. If you prefer, you can create your own key pair using a third-party\ntool and upload it to any region using ImportKeyPair.\n For more information, see Key Pairs\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html) in the\nAmazon Elastic Compute Cloud User Guide." ([create-key-pair-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-key-pair-request create-key-pair-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/key-pair, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/create-key-pair-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateKeyPair", :http.request.configuration/output-deser-fn response-key-pair, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef create-key-pair :args (clojure.spec.alpha/tuple :portkey.aws.ec2/create-key-pair-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/key-pair))

(clojure.core/defn delete-network-interface "Deletes the specified network interface. You must detach the network interface\nbefore you can delete it." ([delete-network-interface-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-network-interface-request delete-network-interface-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-network-interface-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteNetworkInterface", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-network-interface :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-network-interface-request) :ret clojure.core/true?)

(clojure.core/defn delete-spot-datafeed-subscription "Deletes the data feed for Spot Instances." ([] (delete-spot-datafeed-subscription {})) ([delete-spot-datafeed-subscription-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-spot-datafeed-subscription-request delete-spot-datafeed-subscription-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-spot-datafeed-subscription-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSpotDatafeedSubscription", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-spot-datafeed-subscription :args (clojure.spec.alpha/? :portkey.aws.ec2/delete-spot-datafeed-subscription-request) :ret clojure.core/true?)

(clojure.core/defn describe-vpc-endpoints "Describes one or more of your VPC endpoints." ([] (describe-vpc-endpoints {})) ([describe-vpc-endpoints-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-vpc-endpoints-request describe-vpc-endpoints-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-vpc-endpoints-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-vpc-endpoints-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeVpcEndpoints", :http.request.configuration/output-deser-fn response-describe-vpc-endpoints-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-vpc-endpoints :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-vpc-endpoints-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-vpc-endpoints-result))

(clojure.core/defn apply-security-groups-to-client-vpn-target-network "Applies a security group to the association between the target network and the\nClient VPN endpoint. This action replaces the existing security groups with the\nspecified security groups." ([apply-security-groups-to-client-vpn-target-network-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-apply-security-groups-to-client-vpn-target-network-request apply-security-groups-to-client-vpn-target-network-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/apply-security-groups-to-client-vpn-target-network-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/apply-security-groups-to-client-vpn-target-network-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ApplySecurityGroupsToClientVpnTargetNetwork", :http.request.configuration/output-deser-fn response-apply-security-groups-to-client-vpn-target-network-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef apply-security-groups-to-client-vpn-target-network :args (clojure.spec.alpha/tuple :portkey.aws.ec2/apply-security-groups-to-client-vpn-target-network-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/apply-security-groups-to-client-vpn-target-network-result))

(clojure.core/defn describe-hosts "Describes one or more of your Dedicated Hosts.\n The results describe only the Dedicated Hosts in the Region you're currently\nusing. All listed instances consume capacity on your Dedicated Host. Dedicated\nHosts that have recently been released are listed with the state released." ([] (describe-hosts {})) ([describe-hosts-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-hosts-request describe-hosts-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/describe-hosts-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-hosts-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeHosts", :http.request.configuration/output-deser-fn response-describe-hosts-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-hosts :args (clojure.spec.alpha/? :portkey.aws.ec2/describe-hosts-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/describe-hosts-result))

(clojure.core/defn delete-vpn-connection "Deletes the specified VPN connection.\n If you're deleting the VPC and its associated components, we recommend that you\ndetach the virtual private gateway from the VPC and delete the VPC before\ndeleting the VPN connection. If you believe that the tunnel credentials for your\nVPN connection have been compromised, you can delete the VPN connection and\ncreate a new one that has new keys, without needing to delete the VPC or virtual\nprivate gateway. If you create a new VPN connection, you must reconfigure the\ncustomer gateway using the new configuration information returned with the new\nVPN connection ID." ([delete-vpn-connection-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-vpn-connection-request delete-vpn-connection-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-vpn-connection-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVpnConnection", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-vpn-connection :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-vpn-connection-request) :ret clojure.core/true?)

(clojure.core/defn start-instances "Starts an Amazon EBS-backed instance that you've previously stopped.\n Instances that use Amazon EBS volumes as their root devices can be quickly\nstopped and started. When an instance is stopped, the compute resources are\nreleased and you are not billed for instance usage. However, your root partition\nAmazon EBS volume remains and continues to persist your data, and you are\ncharged for Amazon EBS volume usage. You can restart your instance at any time.\nEvery time you start your Windows instance, Amazon EC2 charges you for a full\ninstance hour. If you stop and restart your Windows instance, a new instance\nhour begins and Amazon EC2 charges you for another full instance hour even if\nyou are still within the same 60-minute period when it was stopped. Every time\nyou start your Linux instance, Amazon EC2 charges a one-minute minimum for\ninstance usage, and thereafter charges per second for instance usage.\n Before stopping an instance, make sure it is in a state from which it can be\nrestarted. Stopping an instance does not preserve data stored in RAM.\n Performing this operation on an instance that uses an instance store as its\nroot device returns an error.\n For more information, see Stopping Instances\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Stop_Start.html) in the\nAmazon Elastic Compute Cloud User Guide." ([start-instances-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-start-instances-request start-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/start-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/start-instances-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartInstances", :http.request.configuration/output-deser-fn response-start-instances-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef start-instances :args (clojure.spec.alpha/tuple :portkey.aws.ec2/start-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/start-instances-result))

(clojure.core/defn detach-volume "Detaches an EBS volume from an instance. Make sure to unmount any file systems\non the device within your operating system before detaching the volume. Failure\nto do so can result in the volume becoming stuck in the busy state while\ndetaching. If this happens, detachment can be delayed indefinitely until you\nunmount the volume, force detachment, reboot the instance, or all three. If an\nEBS volume is the root device of an instance, it can't be detached while the\ninstance is running. To detach the root volume, stop the instance first.\n When a volume with an AWS Marketplace product code is detached from an\ninstance, the product code is no longer associated with the instance.\n For more information, see Detaching an Amazon EBS Volume\n(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-detaching-volume.html)\nin the Amazon Elastic Compute Cloud User Guide." ([detach-volume-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-detach-volume-request detach-volume-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/volume-attachment, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/detach-volume-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachVolume", :http.request.configuration/output-deser-fn response-volume-attachment, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef detach-volume :args (clojure.spec.alpha/tuple :portkey.aws.ec2/detach-volume-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/volume-attachment))

(clojure.core/defn confirm-product-instance "Determines whether a product code is associated with an instance. This action\ncan only be used by the owner of the product code. It is useful when a product\ncode owner must verify whether another user's instance is eligible for support." ([confirm-product-instance-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-confirm-product-instance-request confirm-product-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/confirm-product-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/confirm-product-instance-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ConfirmProductInstance", :http.request.configuration/output-deser-fn response-confirm-product-instance-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef confirm-product-instance :args (clojure.spec.alpha/tuple :portkey.aws.ec2/confirm-product-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/confirm-product-instance-result))

(clojure.core/defn delete-vpc-peering-connection "Deletes a VPC peering connection. Either the owner of the requester VPC or the\nowner of the accepter VPC can delete the VPC peering connection if it's in the\nactive state. The owner of the requester VPC can delete a VPC peering connection\nin the pending-acceptance state. You cannot delete a VPC peering connection\nthat's in the failed state." ([delete-vpc-peering-connection-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-vpc-peering-connection-request delete-vpc-peering-connection-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/delete-vpc-peering-connection-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/delete-vpc-peering-connection-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVpcPeeringConnection", :http.request.configuration/output-deser-fn response-delete-vpc-peering-connection-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef delete-vpc-peering-connection :args (clojure.spec.alpha/tuple :portkey.aws.ec2/delete-vpc-peering-connection-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/delete-vpc-peering-connection-result))

(clojure.core/defn get-launch-template-data "Retrieves the configuration data of the specified instance. You can use this\ndata to create a launch template." ([get-launch-template-data-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-launch-template-data-request get-launch-template-data-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/get-launch-template-data-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/get-launch-template-data-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetLaunchTemplateData", :http.request.configuration/output-deser-fn response-get-launch-template-data-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef get-launch-template-data :args (clojure.spec.alpha/tuple :portkey.aws.ec2/get-launch-template-data-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/get-launch-template-data-result))

(clojure.core/defn describe-image-attribute "Describes the specified attribute of the specified AMI. You can specify only one\nattribute at a time." ([describe-image-attribute-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-image-attribute-request describe-image-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/image-attribute, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/describe-image-attribute-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeImageAttribute", :http.request.configuration/output-deser-fn response-image-attribute, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-image-attribute :args (clojure.spec.alpha/tuple :portkey.aws.ec2/describe-image-attribute-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/image-attribute))

(clojure.core/defn cancel-spot-instance-requests "Cancels one or more Spot Instance requests.\n Canceling a Spot Instance request does not terminate running Spot Instances\nassociated with the request." ([cancel-spot-instance-requests-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-cancel-spot-instance-requests-request cancel-spot-instance-requests-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.ec2/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.ec2/cancel-spot-instance-requests-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-15", :http.request.configuration/service-id "EC2", :http.request.spec/input-spec :portkey.aws.ec2/cancel-spot-instance-requests-request, :http.request.configuration/protocol "ec2", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelSpotInstanceRequests", :http.request.configuration/output-deser-fn response-cancel-spot-instance-requests-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef cancel-spot-instance-requests :args (clojure.spec.alpha/tuple :portkey.aws.ec2/cancel-spot-instance-requests-request) :ret (clojure.spec.alpha/and :portkey.aws.ec2/cancel-spot-instance-requests-result))
