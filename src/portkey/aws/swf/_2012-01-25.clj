(ns portkey.aws.swf.-2012-01-25 (:require [portkey.aws]))

(def
 endpoints
 '{"ap-northeast-1"
   {:credential-scope {:service "swf", :region "ap-northeast-1"},
    :ssl-common-name "swf.ap-northeast-1.amazonaws.com",
    :endpoint "https://swf.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "swf", :region "eu-west-1"},
    :ssl-common-name "swf.eu-west-1.amazonaws.com",
    :endpoint "https://swf.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "swf", :region "us-east-2"},
    :ssl-common-name "swf.us-east-2.amazonaws.com",
    :endpoint "https://swf.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope {:service "swf", :region "ap-southeast-2"},
    :ssl-common-name "swf.ap-southeast-2.amazonaws.com",
    :endpoint "https://swf.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "swf", :region "cn-north-1"},
    :ssl-common-name "swf.cn-north-1.amazonaws.com.cn",
    :endpoint "https://swf.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "sa-east-1"
   {:credential-scope {:service "swf", :region "sa-east-1"},
    :ssl-common-name "swf.sa-east-1.amazonaws.com",
    :endpoint "https://swf.sa-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope {:service "swf", :region "ap-southeast-1"},
    :ssl-common-name "swf.ap-southeast-1.amazonaws.com",
    :endpoint "https://swf.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "cn-northwest-1"
   {:credential-scope {:service "swf", :region "cn-northwest-1"},
    :ssl-common-name "swf.cn-northwest-1.amazonaws.com.cn",
    :endpoint "https://swf.cn-northwest-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope {:service "swf", :region "ap-northeast-2"},
    :ssl-common-name "swf.ap-northeast-2.amazonaws.com",
    :endpoint "https://swf.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "swf", :region "eu-west-3"},
    :ssl-common-name "swf.eu-west-3.amazonaws.com",
    :endpoint "https://swf.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "swf", :region "ca-central-1"},
    :ssl-common-name "swf.ca-central-1.amazonaws.com",
    :endpoint "https://swf.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "swf", :region "eu-central-1"},
    :ssl-common-name "swf.eu-central-1.amazonaws.com",
    :endpoint "https://swf.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "swf", :region "eu-west-2"},
    :ssl-common-name "swf.eu-west-2.amazonaws.com",
    :endpoint "https://swf.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope {:service "swf", :region "us-gov-west-1"},
    :ssl-common-name "swf.us-gov-west-1.amazonaws.com",
    :endpoint "https://swf.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "swf", :region "us-west-2"},
    :ssl-common-name "swf.us-west-2.amazonaws.com",
    :endpoint "https://swf.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "swf", :region "us-east-1"},
    :ssl-common-name "swf.us-east-1.amazonaws.com",
    :endpoint "https://swf.us-east-1.amazonaws.com",
    :signature-version :v4},
   "us-west-1"
   {:credential-scope {:service "swf", :region "us-west-1"},
    :ssl-common-name "swf.us-west-1.amazonaws.com",
    :endpoint "https://swf.us-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "swf", :region "ap-south-1"},
    :ssl-common-name "swf.ap-south-1.amazonaws.com",
    :endpoint "https://swf.ap-south-1.amazonaws.com",
    :signature-version :v4}})

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/execution-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/continued-execution-run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/tag-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/parent-initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/lambda-role (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/arn))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/parent-workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-started-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/childPolicy :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/taskList :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/workflowType] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/executionStartToCloseTimeout :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/taskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/continuedExecutionRunId :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/tagList :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/parentInitiatedEventId :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/taskPriority :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/lambdaRole :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/input :portkey.aws.swf.-2012-01-25.workflow-execution-started-event-attributes/parentWorkflowExecution] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/start-timer-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"TIMER_ID_ALREADY_IN_USE" "TIMER_ID_ALREADY_IN_USE", :timer-id-already-in-use "TIMER_ID_ALREADY_IN_USE", "OPEN_TIMERS_LIMIT_EXCEEDED" "OPEN_TIMERS_LIMIT_EXCEEDED", :open-timers-limit-exceeded "OPEN_TIMERS_LIMIT_EXCEEDED", "TIMER_CREATION_RATE_EXCEEDED" "TIMER_CREATION_RATE_EXCEEDED", :timer-creation-rate-exceeded "TIMER_CREATION_RATE_EXCEEDED", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :operation-not-permitted "OPERATION_NOT_PERMITTED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/fail-workflow-execution-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"UNHANDLED_DECISION" "UNHANDLED_DECISION", :unhandled-decision "UNHANDLED_DECISION", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :operation-not-permitted "OPERATION_NOT_PERMITTED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type/version (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/version))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-type (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-type/name :portkey.aws.swf.-2012-01-25.workflow-type/version] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-signaled-event-attributes/signal-name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/signal-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-signaled-event-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-signaled-event-attributes/external-workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-signaled-event-attributes/external-initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-signaled-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-signaled-event-attributes/signalName] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-signaled-event-attributes/input :portkey.aws.swf.-2012-01-25.workflow-execution-signaled-event-attributes/externalWorkflowExecution :portkey.aws.swf.-2012-01-25.workflow-execution-signaled-event-attributes/externalInitiatedEventId] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/signal-external-workflow-execution-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/signal-external-workflow-execution-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/workflowId :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/initiatedEventId :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/runId :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-failed-event-attributes/control] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/cancel-workflow-execution-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/cancel-workflow-execution-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/record-marker-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/record-marker-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/fail-workflow-execution-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/fail-workflow-execution-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/continue-as-new-workflow-execution-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/continue-as-new-workflow-execution-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/complete-workflow-execution-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/complete-workflow-execution-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/request-cancel-activity-task-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/request-cancel-activity-task-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/start-child-workflow-execution-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/start-child-workflow-execution-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/request-cancel-external-workflow-execution-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/request-cancel-external-workflow-execution-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/schedule-lambda-function-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/schedule-lambda-function-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/signal-external-workflow-execution-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/signal-external-workflow-execution-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/schedule-activity-task-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/schedule-activity-task-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/decision-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/decision-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/cancel-timer-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/cancel-timer-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision/start-timer-decision-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/start-timer-decision-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/decision (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.decision/decisionType] :opt-un [:portkey.aws.swf.-2012-01-25.decision/cancelWorkflowExecutionDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/recordMarkerDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/failWorkflowExecutionDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/continueAsNewWorkflowExecutionDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/completeWorkflowExecutionDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/requestCancelActivityTaskDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/startChildWorkflowExecutionDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/requestCancelExternalWorkflowExecutionDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/scheduleLambdaFunctionDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/signalExternalWorkflowExecutionDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/scheduleActivityTaskDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/cancelTimerDecisionAttributes :portkey.aws.swf.-2012-01-25.decision/startTimerDecisionAttributes] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-open-workflow-executions-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-open-workflow-executions-input/start-time-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/execution-time-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-open-workflow-executions-input/type-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-open-workflow-executions-input/tag-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-open-workflow-executions-input/execution-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/count-open-workflow-executions-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.count-open-workflow-executions-input/domain :portkey.aws.swf.-2012-01-25.count-open-workflow-executions-input/startTimeFilter] :opt-un [:portkey.aws.swf.-2012-01-25.count-open-workflow-executions-input/typeFilter :portkey.aws.swf.-2012-01-25.count-open-workflow-executions-input/tagFilter :portkey.aws.swf.-2012-01-25.count-open-workflow-executions-input/executionFilter] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.external-workflow-execution-signaled-event-attributes/workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.external-workflow-execution-signaled-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/external-workflow-execution-signaled-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.external-workflow-execution-signaled-event-attributes/workflowExecution :portkey.aws.swf.-2012-01-25.external-workflow-execution-signaled-event-attributes/initiatedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.deprecate-domain-input/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/deprecate-domain-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.deprecate-domain-input/name] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-detail/type-info (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type-info))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-detail/configuration (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type-configuration))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-type-detail (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-type-detail/typeInfo :portkey.aws.swf.-2012-01-25.workflow-type-detail/configuration] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-lambda-function-failed-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-lambda-function-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/start-lambda-function-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-lambda-function-failed-event-attributes/message (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/cause-message))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/start-lambda-function-failed-event-attributes (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.start-lambda-function-failed-event-attributes/scheduledEventId :portkey.aws.swf.-2012-01-25.start-lambda-function-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.start-lambda-function-failed-event-attributes/message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.record-marker-failed-event-attributes/marker-name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/marker-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.record-marker-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/record-marker-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.record-marker-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/record-marker-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.record-marker-failed-event-attributes/markerName :portkey.aws.swf.-2012-01-25.record-marker-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.record-marker-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.run/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/run (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.run/runId] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-lambda-function-failed-event-attributes/id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/function-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-lambda-function-failed-event-attributes/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/function-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-lambda-function-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/schedule-lambda-function-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-lambda-function-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/schedule-lambda-function-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.schedule-lambda-function-failed-event-attributes/id :portkey.aws.swf.-2012-01-25.schedule-lambda-function-failed-event-attributes/name :portkey.aws.swf.-2012-01-25.schedule-lambda-function-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.schedule-lambda-function-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/request-cancel-activity-task-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"ACTIVITY_ID_UNKNOWN" "ACTIVITY_ID_UNKNOWN", :activity-id-unknown "ACTIVITY_ID_UNKNOWN", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :operation-not-permitted "OPERATION_NOT_PERMITTED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-run-id-optional (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-info/activity-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-info/status (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/registration-status))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-info/description (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/description))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-info/creation-date (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timestamp))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-info/deprecation-date (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timestamp))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-type-info (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-type-info/activityType :portkey.aws.swf.-2012-01-25.activity-type-info/status :portkey.aws.swf.-2012-01-25.activity-type-info/creationDate] :opt-un [:portkey.aws.swf.-2012-01-25.activity-type-info/description :portkey.aws.swf.-2012-01-25.activity-type-info/deprecationDate] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.marker-recorded-event-attributes/marker-name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/marker-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.marker-recorded-event-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.marker-recorded-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/marker-recorded-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.marker-recorded-event-attributes/markerName :portkey.aws.swf.-2012-01-25.marker-recorded-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.marker-recorded-event-attributes/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-infos/type-infos (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type-info-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-infos/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-type-infos (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-type-infos/typeInfos] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-type-infos/nextPageToken] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/lambda-function-timeout-type (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"START_TO_CLOSE" "START_TO_CLOSE", :start-to-close "START_TO_CLOSE"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/limited-data (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/function-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-type-info-list (clojure.spec.alpha/and (clojure.spec.alpha/coll-of :portkey.aws.swf.-2012-01-25/workflow-type-info) (clojure.spec.alpha/conformer clojure.core/identity (fn* [p1__13687__13688__auto__] (if (clojure.core/sequential? p1__13687__13688__auto__) p1__13687__13688__auto__ [p1__13687__13688__auto__])))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-completed-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-completed-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-completed-event-attributes/result (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/lambda-function-completed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.lambda-function-completed-event-attributes/scheduledEventId :portkey.aws.swf.-2012-01-25.lambda-function-completed-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.lambda-function-completed-event-attributes/result] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-activity-task-decision-attributes/activity-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/request-cancel-activity-task-decision-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.request-cancel-activity-task-decision-attributes/activityId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/page-size (clojure.spec.alpha/and clojure.core/int? (fn* [p1__13828__13829__auto__] (clojure.core/<= 0 p1__13828__13829__auto__)) (fn* [p1__13830__13831__auto__] (clojure.core/<= p1__13830__13831__auto__ 1000))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution/workflowId :portkey.aws.swf.-2012-01-25.workflow-execution/runId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-filter/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-filter/version (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/version-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-type-filter (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-type-filter/name] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-type-filter/version] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.operation-not-permitted-fault/message (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/error-message))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.operation-not-permitted-fault/message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/request-cancel-external-workflow-execution-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION" "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION", :unknown-external-workflow-execution "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION", "REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED" "REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED", :request-cancel-external-workflow-execution-rate-exceeded "REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :operation-not-permitted "OPERATION_NOT_PERMITTED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.default-undefined-fault/message (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/error-message))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/default-undefined-fault (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.default-undefined-fault/message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-failed-event-attributes/reason (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/failure-reason))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-failed-event-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-failed-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-failed-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-task-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-task-failed-event-attributes/scheduledEventId :portkey.aws.swf.-2012-01-25.activity-task-failed-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.activity-task-failed-event-attributes/reason :portkey.aws.swf.-2012-01-25.activity-task-failed-event-attributes/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/start-child-workflow-execution-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/start-child-workflow-execution-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/workflowType :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/workflowId :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/initiatedEventId :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.start-child-workflow-execution-failed-event-attributes/control] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.timer-started-event-attributes/timer-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timer-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.timer-started-event-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.timer-started-event-attributes/start-to-fire-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.timer-started-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/timer-started-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.timer-started-event-attributes/timerId :portkey.aws.swf.-2012-01-25.timer-started-event-attributes/startToFireTimeout :portkey.aws.swf.-2012-01-25.timer-started-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.timer-started-event-attributes/control] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.record-marker-decision-attributes/marker-name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/marker-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.record-marker-decision-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/record-marker-decision-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.record-marker-decision-attributes/markerName] :opt-un [:portkey.aws.swf.-2012-01-25.record-marker-decision-attributes/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task/task-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task/activity-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task/workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task/activity-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-task (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-task/taskToken :portkey.aws.swf.-2012-01-25.activity-task/activityId :portkey.aws.swf.-2012-01-25.activity-task/startedEventId :portkey.aws.swf.-2012-01-25.activity-task/workflowExecution :portkey.aws.swf.-2012-01-25.activity-task/activityType] :opt-un [:portkey.aws.swf.-2012-01-25.activity-task/input] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/open-decision-tasks-count (clojure.spec.alpha/and clojure.core/int? (fn* [p1__13828__13829__auto__] (clojure.core/<= 0 p1__13828__13829__auto__)) (fn* [p1__13830__13831__auto__] (clojure.core/<= p1__13830__13831__auto__ 1))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-canceled-event-attributes/workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-canceled-event-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-canceled-event-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-canceled-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-canceled-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/child-workflow-execution-canceled-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.child-workflow-execution-canceled-event-attributes/workflowExecution :portkey.aws.swf.-2012-01-25.child-workflow-execution-canceled-event-attributes/workflowType :portkey.aws.swf.-2012-01-25.child-workflow-execution-canceled-event-attributes/initiatedEventId :portkey.aws.swf.-2012-01-25.child-workflow-execution-canceled-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.child-workflow-execution-canceled-event-attributes/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/schedule-activity-task-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"DEFAULT_HEARTBEAT_TIMEOUT_UNDEFINED" "DEFAULT_HEARTBEAT_TIMEOUT_UNDEFINED", :default-heartbeat-timeout-undefined "DEFAULT_HEARTBEAT_TIMEOUT_UNDEFINED", :activity-type-does-not-exist "ACTIVITY_TYPE_DOES_NOT_EXIST", :activity-type-deprecated "ACTIVITY_TYPE_DEPRECATED", :default-task-list-undefined "DEFAULT_TASK_LIST_UNDEFINED", :default-start-to-close-timeout-undefined "DEFAULT_START_TO_CLOSE_TIMEOUT_UNDEFINED", "ACTIVITY_TYPE_DEPRECATED" "ACTIVITY_TYPE_DEPRECATED", "OPEN_ACTIVITIES_LIMIT_EXCEEDED" "OPEN_ACTIVITIES_LIMIT_EXCEEDED", :default-schedule-to-start-timeout-undefined "DEFAULT_SCHEDULE_TO_START_TIMEOUT_UNDEFINED", "DEFAULT_START_TO_CLOSE_TIMEOUT_UNDEFINED" "DEFAULT_START_TO_CLOSE_TIMEOUT_UNDEFINED", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :open-activities-limit-exceeded "OPEN_ACTIVITIES_LIMIT_EXCEEDED", :activity-creation-rate-exceeded "ACTIVITY_CREATION_RATE_EXCEEDED", "ACTIVITY_TYPE_DOES_NOT_EXIST" "ACTIVITY_TYPE_DOES_NOT_EXIST", "ACTIVITY_CREATION_RATE_EXCEEDED" "ACTIVITY_CREATION_RATE_EXCEEDED", :activity-id-already-in-use "ACTIVITY_ID_ALREADY_IN_USE", "DEFAULT_SCHEDULE_TO_START_TIMEOUT_UNDEFINED" "DEFAULT_SCHEDULE_TO_START_TIMEOUT_UNDEFINED", :default-schedule-to-close-timeout-undefined "DEFAULT_SCHEDULE_TO_CLOSE_TIMEOUT_UNDEFINED", "ACTIVITY_ID_ALREADY_IN_USE" "ACTIVITY_ID_ALREADY_IN_USE", "DEFAULT_SCHEDULE_TO_CLOSE_TIMEOUT_UNDEFINED" "DEFAULT_SCHEDULE_TO_CLOSE_TIMEOUT_UNDEFINED", :operation-not-permitted "OPERATION_NOT_PERMITTED", "DEFAULT_TASK_LIST_UNDEFINED" "DEFAULT_TASK_LIST_UNDEFINED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/continue-as-new-workflow-execution-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/continue-as-new-workflow-execution-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/registration-status (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"REGISTERED" "REGISTERED", :registered "REGISTERED", "DEPRECATED" "DEPRECATED", :deprecated "DEPRECATED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-canceled-event-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-canceled-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-canceled-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-canceled-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-canceled-event-attributes/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-timed-out-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-timed-out-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-timed-out-event-attributes/timeout-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/lambda-function-timeout-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/lambda-function-timed-out-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.lambda-function-timed-out-event-attributes/scheduledEventId :portkey.aws.swf.-2012-01-25.lambda-function-timed-out-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.lambda-function-timed-out-event-attributes/timeoutType] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-workflow-execution-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-workflow-execution-input/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-workflow-execution-input/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/request-cancel-workflow-execution-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.request-cancel-workflow-execution-input/domain :portkey.aws.swf.-2012-01-25.request-cancel-workflow-execution-input/workflowId] :opt-un [:portkey.aws.swf.-2012-01-25.request-cancel-workflow-execution-input/runId] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task/task-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task/workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task/events (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/history-event-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task/previous-started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/decision-task (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.decision-task/taskToken :portkey.aws.swf.-2012-01-25.decision-task/startedEventId :portkey.aws.swf.-2012-01-25.decision-task/workflowExecution :portkey.aws.swf.-2012-01-25.decision-task/workflowType :portkey.aws.swf.-2012-01-25.decision-task/events] :opt-un [:portkey.aws.swf.-2012-01-25.decision-task/nextPageToken :portkey.aws.swf.-2012-01-25.decision-task/previousStartedEventId] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.domain-infos/domain-infos (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-info-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.domain-infos/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/domain-infos (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.domain-infos/domainInfos] :opt-un [:portkey.aws.swf.-2012-01-25.domain-infos/nextPageToken] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/truncated clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-completed-event-attributes/result (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-completed-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-completed-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-task-completed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-task-completed-event-attributes/scheduledEventId :portkey.aws.swf.-2012-01-25.activity-task-completed-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.activity-task-completed-event-attributes/result] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/cancel-workflow-execution-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"UNHANDLED_DECISION" "UNHANDLED_DECISION", :unhandled-decision "UNHANDLED_DECISION", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :operation-not-permitted "OPERATION_NOT_PERMITTED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/history-event-list (clojure.spec.alpha/and (clojure.spec.alpha/coll-of :portkey.aws.swf.-2012-01-25/history-event) (clojure.spec.alpha/conformer clojure.core/identity (fn* [p1__13687__13688__auto__] (if (clojure.core/sequential? p1__13687__13688__auto__) p1__13687__13688__auto__ [p1__13687__13688__auto__])))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-failed-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-failed-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-failed-event-attributes/reason (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/failure-reason))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-failed-event-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/lambda-function-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.lambda-function-failed-event-attributes/scheduledEventId :portkey.aws.swf.-2012-01-25.lambda-function-failed-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.lambda-function-failed-event-attributes/reason :portkey.aws.swf.-2012-01-25.lambda-function-failed-event-attributes/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-configuration/task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-configuration/execution-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-configuration/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-configuration/task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-configuration/child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-configuration/lambda-role (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/arn))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-configuration (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-configuration/taskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.workflow-execution-configuration/executionStartToCloseTimeout :portkey.aws.swf.-2012-01-25.workflow-execution-configuration/taskList :portkey.aws.swf.-2012-01-25.workflow-execution-configuration/childPolicy] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-configuration/taskPriority :portkey.aws.swf.-2012-01-25.workflow-execution-configuration/lambdaRole] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-decision-attributes/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-decision-attributes/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-decision-attributes/signal-name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/signal-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-decision-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-decision-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/signal-external-workflow-execution-decision-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-decision-attributes/workflowId :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-decision-attributes/signalName] :opt-un [:portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-decision-attributes/runId :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-decision-attributes/input :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-decision-attributes/control] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/start-child-workflow-execution-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"CHILD_CREATION_RATE_EXCEEDED" "CHILD_CREATION_RATE_EXCEEDED", "DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED" "DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED", :default-task-list-undefined "DEFAULT_TASK_LIST_UNDEFINED", :workflow-type-deprecated "WORKFLOW_TYPE_DEPRECATED", "WORKFLOW_TYPE_DEPRECATED" "WORKFLOW_TYPE_DEPRECATED", :workflow-type-does-not-exist "WORKFLOW_TYPE_DOES_NOT_EXIST", :default-execution-start-to-close-timeout-undefined "DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED", :default-task-start-to-close-timeout-undefined "DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED", "DEFAULT_CHILD_POLICY_UNDEFINED" "DEFAULT_CHILD_POLICY_UNDEFINED", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :workflow-already-running "WORKFLOW_ALREADY_RUNNING", :open-workflows-limit-exceeded "OPEN_WORKFLOWS_LIMIT_EXCEEDED", "WORKFLOW_ALREADY_RUNNING" "WORKFLOW_ALREADY_RUNNING", :default-child-policy-undefined "DEFAULT_CHILD_POLICY_UNDEFINED", :child-creation-rate-exceeded "CHILD_CREATION_RATE_EXCEEDED", :open-children-limit-exceeded "OPEN_CHILDREN_LIMIT_EXCEEDED", "OPEN_WORKFLOWS_LIMIT_EXCEEDED" "OPEN_WORKFLOWS_LIMIT_EXCEEDED", "OPEN_CHILDREN_LIMIT_EXCEEDED" "OPEN_CHILDREN_LIMIT_EXCEEDED", "WORKFLOW_TYPE_DOES_NOT_EXIST" "WORKFLOW_TYPE_DOES_NOT_EXIST", "DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED" "DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED", :operation-not-permitted "OPERATION_NOT_PERMITTED", "DEFAULT_TASK_LIST_UNDEFINED" "DEFAULT_TASK_LIST_UNDEFINED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-lambda-function-decision-attributes/id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/function-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-lambda-function-decision-attributes/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/function-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-lambda-function-decision-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-lambda-function-decision-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/function-input))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-lambda-function-decision-attributes/start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/schedule-lambda-function-decision-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.schedule-lambda-function-decision-attributes/id :portkey.aws.swf.-2012-01-25.schedule-lambda-function-decision-attributes/name] :opt-un [:portkey.aws.swf.-2012-01-25.schedule-lambda-function-decision-attributes/control :portkey.aws.swf.-2012-01-25.schedule-lambda-function-decision-attributes/input :portkey.aws.swf.-2012-01-25.schedule-lambda-function-decision-attributes/startToCloseTimeout] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-activity-task-failed-event-attributes/activity-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-activity-task-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/request-cancel-activity-task-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-activity-task-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/request-cancel-activity-task-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.request-cancel-activity-task-failed-event-attributes/activityId :portkey.aws.swf.-2012-01-25.request-cancel-activity-task-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.request-cancel-activity-task-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-task-timeout-type (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"START_TO_CLOSE" "START_TO_CLOSE", :start-to-close "START_TO_CLOSE", "SCHEDULE_TO_START" "SCHEDULE_TO_START", :schedule-to-start "SCHEDULE_TO_START", "SCHEDULE_TO_CLOSE" "SCHEDULE_TO_CLOSE", :schedule-to-close "SCHEDULE_TO_CLOSE", "HEARTBEAT" "HEARTBEAT", :heartbeat "HEARTBEAT"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/count (clojure.spec.alpha/and clojure.core/int? (fn* [p1__13828__13829__auto__] (clojure.core/<= 0 p1__13828__13829__auto__))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/domain-info-list (clojure.spec.alpha/and (clojure.spec.alpha/coll-of :portkey.aws.swf.-2012-01-25/domain-info) (clojure.spec.alpha/conformer clojure.core/identity (fn* [p1__13687__13688__auto__] (if (clojure.core/sequential? p1__13687__13688__auto__) p1__13687__13688__auto__ [p1__13687__13688__auto__])))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.describe-workflow-execution-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.describe-workflow-execution-input/execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/describe-workflow-execution-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.describe-workflow-execution-input/domain :portkey.aws.swf.-2012-01-25.describe-workflow-execution-input/execution] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/cause-message (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 1728))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-pending-activity-tasks-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-pending-activity-tasks-input/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/count-pending-activity-tasks-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.count-pending-activity-tasks-input/domain :portkey.aws.swf.-2012-01-25.count-pending-activity-tasks-input/taskList] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/child-policy (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"TERMINATE" "TERMINATE", :terminate "TERMINATE", "REQUEST_CANCEL" "REQUEST_CANCEL", :request-cancel "REQUEST_CANCEL", "ABANDON" "ABANDON", :abandon "ABANDON"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/identity (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/identity))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/maximum-page-size (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-size))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/reverse-order (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/reverse-order))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/poll-for-decision-task-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/domain :portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/taskList] :opt-un [:portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/identity :portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/nextPageToken :portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/maximumPageSize :portkey.aws.swf.-2012-01-25.poll-for-decision-task-input/reverseOrder] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-timeout-type (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"START_TO_CLOSE" "START_TO_CLOSE", :start-to-close "START_TO_CLOSE"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/duration-in-days (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 8))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.execution-time-filter/oldest-date (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timestamp))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.execution-time-filter/latest-date (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timestamp))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/execution-time-filter (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.execution-time-filter/oldestDate] :opt-un [:portkey.aws.swf.-2012-01-25.execution-time-filter/latestDate] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-activity-type-input/default-task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-activity-type-input/default-task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-activity-type-input/default-task-heartbeat-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-activity-type-input/default-task-schedule-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-activity-type-input/default-task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-activity-type-input/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-activity-type-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-activity-type-input/default-task-schedule-to-start-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-activity-type-input/version (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/version))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-activity-type-input/description (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/description))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/register-activity-type-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.register-activity-type-input/domain :portkey.aws.swf.-2012-01-25.register-activity-type-input/name :portkey.aws.swf.-2012-01-25.register-activity-type-input/version] :opt-un [:portkey.aws.swf.-2012-01-25.register-activity-type-input/defaultTaskPriority :portkey.aws.swf.-2012-01-25.register-activity-type-input/defaultTaskList :portkey.aws.swf.-2012-01-25.register-activity-type-input/defaultTaskHeartbeatTimeout :portkey.aws.swf.-2012-01-25.register-activity-type-input/defaultTaskScheduleToCloseTimeout :portkey.aws.swf.-2012-01-25.register-activity-type-input/defaultTaskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.register-activity-type-input/defaultTaskScheduleToStartTimeout :portkey.aws.swf.-2012-01-25.register-activity-type-input/description] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.task-list/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/task-list (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.task-list/name] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/execution-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/tag-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/lambda-role (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/arn))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/new-execution-run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-continued-as-new-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/decisionTaskCompletedEventId :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/newExecutionRunId :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/taskList :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/childPolicy :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/workflowType] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/executionStartToCloseTimeout :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/taskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/tagList :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/taskPriority :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/lambdaRole :portkey.aws.swf.-2012-01-25.workflow-execution-continued-as-new-event-attributes/input] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-failed-event-attributes/activity-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-failed-event-attributes/activity-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/schedule-activity-task-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/schedule-activity-task-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.schedule-activity-task-failed-event-attributes/activityType :portkey.aws.swf.-2012-01-25.schedule-activity-task-failed-event-attributes/activityId :portkey.aws.swf.-2012-01-25.schedule-activity-task-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.schedule-activity-task-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-workflow-types-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-workflow-types-input/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-workflow-types-input/registration-status (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/registration-status))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-workflow-types-input/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-workflow-types-input/maximum-page-size (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-size))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-workflow-types-input/reverse-order (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/reverse-order))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/list-workflow-types-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.list-workflow-types-input/domain :portkey.aws.swf.-2012-01-25.list-workflow-types-input/registrationStatus] :opt-un [:portkey.aws.swf.-2012-01-25.list-workflow-types-input/name :portkey.aws.swf.-2012-01-25.list-workflow-types-input/nextPageToken :portkey.aws.swf.-2012-01-25.list-workflow-types-input/maximumPageSize :portkey.aws.swf.-2012-01-25.list-workflow-types-input/reverseOrder] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.respond-decision-task-completed-input/task-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.respond-decision-task-completed-input/decisions (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/decision-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.respond-decision-task-completed-input/execution-context (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/respond-decision-task-completed-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.respond-decision-task-completed-input/taskToken] :opt-un [:portkey.aws.swf.-2012-01-25.respond-decision-task-completed-input/decisions :portkey.aws.swf.-2012-01-25.respond-decision-task-completed-input/executionContext] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-canceled-event-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-canceled-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-canceled-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-canceled-event-attributes/latest-cancel-requested-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-task-canceled-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-task-canceled-event-attributes/scheduledEventId :portkey.aws.swf.-2012-01-25.activity-task-canceled-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.activity-task-canceled-event-attributes/details :portkey.aws.swf.-2012-01-25.activity-task-canceled-event-attributes/latestCancelRequestedEventId] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/event-type (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"WorkflowExecutionStarted" "WorkflowExecutionStarted", "CompleteWorkflowExecutionFailed" "CompleteWorkflowExecutionFailed", :lambda-function-timed-out "LambdaFunctionTimedOut", :workflow-execution-completed "WorkflowExecutionCompleted", :workflow-execution-started "WorkflowExecutionStarted", :cancel-timer-failed "CancelTimerFailed", :signal-external-workflow-execution-initiated "SignalExternalWorkflowExecutionInitiated", "SignalExternalWorkflowExecutionInitiated" "SignalExternalWorkflowExecutionInitiated", "StartTimerFailed" "StartTimerFailed", :child-workflow-execution-completed "ChildWorkflowExecutionCompleted", "StartChildWorkflowExecutionInitiated" "StartChildWorkflowExecutionInitiated", "DecisionTaskCompleted" "DecisionTaskCompleted", "DecisionTaskStarted" "DecisionTaskStarted", :start-child-workflow-execution-initiated "StartChildWorkflowExecutionInitiated", "TimerFired" "TimerFired", :external-workflow-execution-signaled "ExternalWorkflowExecutionSignaled", "ChildWorkflowExecutionTerminated" "ChildWorkflowExecutionTerminated", "ChildWorkflowExecutionFailed" "ChildWorkflowExecutionFailed", "ActivityTaskFailed" "ActivityTaskFailed", "ChildWorkflowExecutionCanceled" "ChildWorkflowExecutionCanceled", "DecisionTaskTimedOut" "DecisionTaskTimedOut", "StartLambdaFunctionFailed" "StartLambdaFunctionFailed", :workflow-execution-terminated "WorkflowExecutionTerminated", "WorkflowExecutionCanceled" "WorkflowExecutionCanceled", "ChildWorkflowExecutionCompleted" "ChildWorkflowExecutionCompleted", :timer-started "TimerStarted", :external-workflow-execution-cancel-requested "ExternalWorkflowExecutionCancelRequested", "ExternalWorkflowExecutionCancelRequested" "ExternalWorkflowExecutionCancelRequested", :workflow-execution-continued-as-new "WorkflowExecutionContinuedAsNew", :signal-external-workflow-execution-failed "SignalExternalWorkflowExecutionFailed", "LambdaFunctionScheduled" "LambdaFunctionScheduled", :activity-task-cancel-requested "ActivityTaskCancelRequested", "ScheduleActivityTaskFailed" "ScheduleActivityTaskFailed", "ActivityTaskScheduled" "ActivityTaskScheduled", "WorkflowExecutionTimedOut" "WorkflowExecutionTimedOut", :timer-fired "TimerFired", "ActivityTaskCanceled" "ActivityTaskCanceled", :start-lambda-function-failed "StartLambdaFunctionFailed", "StartChildWorkflowExecutionFailed" "StartChildWorkflowExecutionFailed", :decision-task-completed "DecisionTaskCompleted", "ActivityTaskCancelRequested" "ActivityTaskCancelRequested", "ChildWorkflowExecutionStarted" "ChildWorkflowExecutionStarted", :child-workflow-execution-failed "ChildWorkflowExecutionFailed", "LambdaFunctionCompleted" "LambdaFunctionCompleted", :schedule-activity-task-failed "ScheduleActivityTaskFailed", :request-cancel-external-workflow-execution-failed "RequestCancelExternalWorkflowExecutionFailed", :workflow-execution-failed "WorkflowExecutionFailed", "TimerCanceled" "TimerCanceled", :decision-task-timed-out "DecisionTaskTimedOut", :activity-task-failed "ActivityTaskFailed", :child-workflow-execution-started "ChildWorkflowExecutionStarted", "CancelWorkflowExecutionFailed" "CancelWorkflowExecutionFailed", "RequestCancelExternalWorkflowExecutionFailed" "RequestCancelExternalWorkflowExecutionFailed", :lambda-function-failed "LambdaFunctionFailed", :workflow-execution-canceled "WorkflowExecutionCanceled", "WorkflowExecutionFailed" "WorkflowExecutionFailed", :activity-task-canceled "ActivityTaskCanceled", "FailWorkflowExecutionFailed" "FailWorkflowExecutionFailed", "MarkerRecorded" "MarkerRecorded", :activity-task-scheduled "ActivityTaskScheduled", "WorkflowExecutionContinuedAsNew" "WorkflowExecutionContinuedAsNew", "LambdaFunctionFailed" "LambdaFunctionFailed", :continue-as-new-workflow-execution-failed "ContinueAsNewWorkflowExecutionFailed", :fail-workflow-execution-failed "FailWorkflowExecutionFailed", :activity-task-completed "ActivityTaskCompleted", :complete-workflow-execution-failed "CompleteWorkflowExecutionFailed", "ScheduleLambdaFunctionFailed" "ScheduleLambdaFunctionFailed", :activity-task-timed-out "ActivityTaskTimedOut", :request-cancel-activity-task-failed "RequestCancelActivityTaskFailed", "TimerStarted" "TimerStarted", :child-workflow-execution-timed-out "ChildWorkflowExecutionTimedOut", "WorkflowExecutionTerminated" "WorkflowExecutionTerminated", "CancelTimerFailed" "CancelTimerFailed", "ExternalWorkflowExecutionSignaled" "ExternalWorkflowExecutionSignaled", :start-timer-failed "StartTimerFailed", "ContinueAsNewWorkflowExecutionFailed" "ContinueAsNewWorkflowExecutionFailed", "LambdaFunctionTimedOut" "LambdaFunctionTimedOut", :schedule-lambda-function-failed "ScheduleLambdaFunctionFailed", "LambdaFunctionStarted" "LambdaFunctionStarted", "SignalExternalWorkflowExecutionFailed" "SignalExternalWorkflowExecutionFailed", :decision-task-started "DecisionTaskStarted", :start-child-workflow-execution-failed "StartChildWorkflowExecutionFailed", :lambda-function-started "LambdaFunctionStarted", :lambda-function-completed "LambdaFunctionCompleted", "DecisionTaskScheduled" "DecisionTaskScheduled", :child-workflow-execution-canceled "ChildWorkflowExecutionCanceled", :child-workflow-execution-terminated "ChildWorkflowExecutionTerminated", :activity-task-started "ActivityTaskStarted", :workflow-execution-timed-out "WorkflowExecutionTimedOut", "ActivityTaskCompleted" "ActivityTaskCompleted", :record-marker-failed "RecordMarkerFailed", "ChildWorkflowExecutionTimedOut" "ChildWorkflowExecutionTimedOut", :timer-canceled "TimerCanceled", :cancel-workflow-execution-failed "CancelWorkflowExecutionFailed", "RequestCancelActivityTaskFailed" "RequestCancelActivityTaskFailed", :workflow-execution-signaled "WorkflowExecutionSignaled", "RequestCancelExternalWorkflowExecutionInitiated" "RequestCancelExternalWorkflowExecutionInitiated", "WorkflowExecutionSignaled" "WorkflowExecutionSignaled", "WorkflowExecutionCompleted" "WorkflowExecutionCompleted", :lambda-function-scheduled "LambdaFunctionScheduled", :marker-recorded "MarkerRecorded", "ActivityTaskStarted" "ActivityTaskStarted", :request-cancel-external-workflow-execution-initiated "RequestCancelExternalWorkflowExecutionInitiated", "WorkflowExecutionCancelRequested" "WorkflowExecutionCancelRequested", :workflow-execution-cancel-requested "WorkflowExecutionCancelRequested", "RecordMarkerFailed" "RecordMarkerFailed", "ActivityTaskTimedOut" "ActivityTaskTimedOut", :decision-task-scheduled "DecisionTaskScheduled"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-domain-input/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-domain-input/description (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/description))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-domain-input/workflow-execution-retention-period-in-days (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-days))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/register-domain-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.register-domain-input/name :portkey.aws.swf.-2012-01-25.register-domain-input/workflowExecutionRetentionPeriodInDays] :opt-un [:portkey.aws.swf.-2012-01-25.register-domain-input/description] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-run-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.domain-deprecated-fault/message (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/error-message))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/domain-deprecated-fault (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.domain-deprecated-fault/message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/error-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/execution-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/tag-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/lambda-role (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/arn))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/start-workflow-execution-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.start-workflow-execution-input/domain :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/workflowId :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/workflowType] :opt-un [:portkey.aws.swf.-2012-01-25.start-workflow-execution-input/executionStartToCloseTimeout :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/taskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/tagList :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/taskList :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/taskPriority :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/lambdaRole :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/input :portkey.aws.swf.-2012-01-25.start-workflow-execution-input/childPolicy] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-info-list (clojure.spec.alpha/and (clojure.spec.alpha/coll-of :portkey.aws.swf.-2012-01-25/workflow-execution-info) (clojure.spec.alpha/conformer clojure.core/identity (fn* [p1__13687__13688__auto__] (if (clojure.core/sequential? p1__13687__13688__auto__) p1__13687__13688__auto__ [p1__13687__13688__auto__])))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/task-priority (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.poll-for-activity-task-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.poll-for-activity-task-input/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.poll-for-activity-task-input/identity (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/identity))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/poll-for-activity-task-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.poll-for-activity-task-input/domain :portkey.aws.swf.-2012-01-25.poll-for-activity-task-input/taskList] :opt-un [:portkey.aws.swf.-2012-01-25.poll-for-activity-task-input/identity] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.deprecate-activity-type-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.deprecate-activity-type-input/activity-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/deprecate-activity-type-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.deprecate-activity-type-input/domain :portkey.aws.swf.-2012-01-25.deprecate-activity-type-input/activityType] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-workflow-execution-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-workflow-execution-input/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-workflow-execution-input/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-workflow-execution-input/signal-name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/signal-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-workflow-execution-input/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/signal-workflow-execution-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.signal-workflow-execution-input/domain :portkey.aws.swf.-2012-01-25.signal-workflow-execution-input/workflowId :portkey.aws.swf.-2012-01-25.signal-workflow-execution-input/signalName] :opt-un [:portkey.aws.swf.-2012-01-25.signal-workflow-execution-input/runId :portkey.aws.swf.-2012-01-25.signal-workflow-execution-input/input] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.deprecate-workflow-type-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.deprecate-workflow-type-input/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/deprecate-workflow-type-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.deprecate-workflow-type-input/domain :portkey.aws.swf.-2012-01-25.deprecate-workflow-type-input/workflowType] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history/events (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/history-event-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/history (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.history/events] :opt-un [:portkey.aws.swf.-2012-01-25.history/nextPageToken] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-timed-out-event-attributes/timeout-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/decision-task-timeout-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-timed-out-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-timed-out-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/decision-task-timed-out-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.decision-task-timed-out-event-attributes/timeoutType :portkey.aws.swf.-2012-01-25.decision-task-timed-out-event-attributes/scheduledEventId :portkey.aws.swf.-2012-01-25.decision-task-timed-out-event-attributes/startedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.pending-task-count/count (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/count))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.pending-task-count/truncated (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/truncated))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/pending-task-count (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.pending-task-count/count] :opt-un [:portkey.aws.swf.-2012-01-25.pending-task-count/truncated] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-configuration/default-task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-configuration/default-task-heartbeat-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-configuration/default-task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-configuration/default-task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-configuration/default-task-schedule-to-start-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-configuration/default-task-schedule-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-type-configuration (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.activity-type-configuration/defaultTaskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.activity-type-configuration/defaultTaskHeartbeatTimeout :portkey.aws.swf.-2012-01-25.activity-type-configuration/defaultTaskList :portkey.aws.swf.-2012-01-25.activity-type-configuration/defaultTaskPriority :portkey.aws.swf.-2012-01-25.activity-type-configuration/defaultTaskScheduleToStartTimeout :portkey.aws.swf.-2012-01-25.activity-type-configuration/defaultTaskScheduleToCloseTimeout] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-timed-out-event-attributes/workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-timed-out-event-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-timed-out-event-attributes/timeout-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-timeout-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-timed-out-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-timed-out-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/child-workflow-execution-timed-out-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.child-workflow-execution-timed-out-event-attributes/workflowExecution :portkey.aws.swf.-2012-01-25.child-workflow-execution-timed-out-event-attributes/workflowType :portkey.aws.swf.-2012-01-25.child-workflow-execution-timed-out-event-attributes/timeoutType :portkey.aws.swf.-2012-01-25.child-workflow-execution-timed-out-event-attributes/initiatedEventId :portkey.aws.swf.-2012-01-25.child-workflow-execution-timed-out-event-attributes/startedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/tag-list (clojure.spec.alpha/and (clojure.spec.alpha/coll-of :portkey.aws.swf.-2012-01-25/tag :max-count 5) (clojure.spec.alpha/conformer clojure.core/identity (fn* [p1__13687__13688__auto__] (if (clojure.core/sequential? p1__13687__13688__auto__) p1__13687__13688__auto__ [p1__13687__13688__auto__])))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/duration-in-seconds (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 8))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.respond-activity-task-canceled-input/task-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.respond-activity-task-canceled-input/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/respond-activity-task-canceled-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.respond-activity-task-canceled-input/taskToken] :opt-un [:portkey.aws.swf.-2012-01-25.respond-activity-task-canceled-input/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 8))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-filter/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-filter (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-filter/workflowId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/continue-as-new-workflow-execution-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED" "DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED", :default-task-list-undefined "DEFAULT_TASK_LIST_UNDEFINED", :workflow-type-deprecated "WORKFLOW_TYPE_DEPRECATED", "WORKFLOW_TYPE_DEPRECATED" "WORKFLOW_TYPE_DEPRECATED", :workflow-type-does-not-exist "WORKFLOW_TYPE_DOES_NOT_EXIST", "UNHANDLED_DECISION" "UNHANDLED_DECISION", :default-execution-start-to-close-timeout-undefined "DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED", :default-task-start-to-close-timeout-undefined "DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED", "DEFAULT_CHILD_POLICY_UNDEFINED" "DEFAULT_CHILD_POLICY_UNDEFINED", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", "CONTINUE_AS_NEW_WORKFLOW_EXECUTION_RATE_EXCEEDED" "CONTINUE_AS_NEW_WORKFLOW_EXECUTION_RATE_EXCEEDED", :default-child-policy-undefined "DEFAULT_CHILD_POLICY_UNDEFINED", :continue-as-new-workflow-execution-rate-exceeded "CONTINUE_AS_NEW_WORKFLOW_EXECUTION_RATE_EXCEEDED", "WORKFLOW_TYPE_DOES_NOT_EXIST" "WORKFLOW_TYPE_DOES_NOT_EXIST", "DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED" "DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED", :operation-not-permitted "OPERATION_NOT_PERMITTED", "DEFAULT_TASK_LIST_UNDEFINED" "DEFAULT_TASK_LIST_UNDEFINED", :unhandled-decision "UNHANDLED_DECISION"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-completed-event-attributes/workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-completed-event-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-completed-event-attributes/result (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-completed-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-completed-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/child-workflow-execution-completed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.child-workflow-execution-completed-event-attributes/workflowExecution :portkey.aws.swf.-2012-01-25.child-workflow-execution-completed-event-attributes/workflowType :portkey.aws.swf.-2012-01-25.child-workflow-execution-completed-event-attributes/initiatedEventId :portkey.aws.swf.-2012-01-25.child-workflow-execution-completed-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.child-workflow-execution-completed-event-attributes/result] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-cancel-requested-event-attributes/external-workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-cancel-requested-event-attributes/external-initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-cancel-requested-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-cancel-requested-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-cancel-requested-event-attributes (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-cancel-requested-event-attributes/externalWorkflowExecution :portkey.aws.swf.-2012-01-25.workflow-execution-cancel-requested-event-attributes/externalInitiatedEventId :portkey.aws.swf.-2012-01-25.workflow-execution-cancel-requested-event-attributes/cause] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-cancel-requested-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-cancel-requested-event-attributes/activity-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-task-cancel-requested-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-task-cancel-requested-event-attributes/decisionTaskCompletedEventId :portkey.aws.swf.-2012-01-25.activity-task-cancel-requested-event-attributes/activityId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-count/count (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/count))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-count/truncated (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/truncated))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-count (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-count/count] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-count/truncated] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type/version (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/version))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-type (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-type/name :portkey.aws.swf.-2012-01-25.activity-type/version] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.fail-workflow-execution-decision-attributes/reason (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/failure-reason))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.fail-workflow-execution-decision-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/fail-workflow-execution-decision-attributes (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.fail-workflow-execution-decision-attributes/reason :portkey.aws.swf.-2012-01-25.fail-workflow-execution-decision-attributes/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.limit-exceeded-fault/message (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/error-message))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/limit-exceeded-fault (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.limit-exceeded-fault/message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/execution-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/tag-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/lambda-role (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/arn))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/start-child-workflow-execution-initiated-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/workflowId :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/workflowType :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/taskList :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/decisionTaskCompletedEventId :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/childPolicy] :opt-un [:portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/executionStartToCloseTimeout :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/taskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/tagList :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/taskPriority :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/control :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/lambdaRole :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-initiated-event-attributes/input] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.respond-activity-task-completed-input/task-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.respond-activity-task-completed-input/result (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/respond-activity-task-completed-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.respond-activity-task-completed-input/taskToken] :opt-un [:portkey.aws.swf.-2012-01-25.respond-activity-task-completed-input/result] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.type-already-exists-fault/message (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/error-message))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/type-already-exists-fault (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.type-already-exists-fault/message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.complete-workflow-execution-decision-attributes/result (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/complete-workflow-execution-decision-attributes (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.complete-workflow-execution-decision-attributes/result] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-info/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-info/close-timestamp (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timestamp))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-info/parent (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-info/execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-info/cancel-requested (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/canceled))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-info/close-status (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/close-status))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-info/tag-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-info/start-timestamp (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timestamp))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-info/execution-status (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/execution-status))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-info (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-info/execution :portkey.aws.swf.-2012-01-25.workflow-execution-info/workflowType :portkey.aws.swf.-2012-01-25.workflow-execution-info/startTimestamp :portkey.aws.swf.-2012-01-25.workflow-execution-info/executionStatus] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-info/closeTimestamp :portkey.aws.swf.-2012-01-25.workflow-execution-info/parent :portkey.aws.swf.-2012-01-25.workflow-execution-info/cancelRequested :portkey.aws.swf.-2012-01-25.workflow-execution-info/closeStatus :portkey.aws.swf.-2012-01-25.workflow-execution-info/tagList] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/decision-task-timeout-type (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"START_TO_CLOSE" "START_TO_CLOSE", :start-to-close "START_TO_CLOSE"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-terminated-event-attributes/workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-terminated-event-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-terminated-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-terminated-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/child-workflow-execution-terminated-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.child-workflow-execution-terminated-event-attributes/workflowExecution :portkey.aws.swf.-2012-01-25.child-workflow-execution-terminated-event-attributes/workflowType :portkey.aws.swf.-2012-01-25.child-workflow-execution-terminated-event-attributes/initiatedEventId :portkey.aws.swf.-2012-01-25.child-workflow-execution-terminated-event-attributes/startedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-detail/type-info (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type-info))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-detail/configuration (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type-configuration))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-type-detail (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-type-detail/typeInfo :portkey.aws.swf.-2012-01-25.activity-type-detail/configuration] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.cancel-timer-decision-attributes/timer-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timer-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/cancel-timer-decision-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.cancel-timer-decision-attributes/timerId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/failure-reason (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-timed-out-event-attributes/timeout-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-timeout-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-timed-out-event-attributes/child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-timed-out-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-timed-out-event-attributes/timeoutType :portkey.aws.swf.-2012-01-25.workflow-execution-timed-out-event-attributes/childPolicy] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.record-activity-task-heartbeat-input/task-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.record-activity-task-heartbeat-input/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/limited-data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/record-activity-task-heartbeat-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.record-activity-task-heartbeat-input/taskToken] :opt-un [:portkey.aws.swf.-2012-01-25.record-activity-task-heartbeat-input/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/execution-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/tag-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/lambda-role (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/arn))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/start-child-workflow-execution-decision-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/workflowType :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/workflowId] :opt-un [:portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/executionStartToCloseTimeout :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/taskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/tagList :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/taskList :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/taskPriority :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/control :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/lambdaRole :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/input :portkey.aws.swf.-2012-01-25.start-child-workflow-execution-decision-attributes/childPolicy] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/version-optional (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/reason (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/terminate-reason))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/terminate-workflow-execution-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/domain :portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/workflowId] :opt-un [:portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/runId :portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/reason :portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/details :portkey.aws.swf.-2012-01-25.terminate-workflow-execution-input/childPolicy] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/schedule-lambda-function-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"ID_ALREADY_IN_USE" "ID_ALREADY_IN_USE", :id-already-in-use "ID_ALREADY_IN_USE", "OPEN_LAMBDA_FUNCTIONS_LIMIT_EXCEEDED" "OPEN_LAMBDA_FUNCTIONS_LIMIT_EXCEEDED", :open-lambda-functions-limit-exceeded "OPEN_LAMBDA_FUNCTIONS_LIMIT_EXCEEDED", "LAMBDA_FUNCTION_CREATION_RATE_EXCEEDED" "LAMBDA_FUNCTION_CREATION_RATE_EXCEEDED", :lambda-function-creation-rate-exceeded "LAMBDA_FUNCTION_CREATION_RATE_EXCEEDED", "LAMBDA_SERVICE_NOT_AVAILABLE_IN_REGION" "LAMBDA_SERVICE_NOT_AVAILABLE_IN_REGION", :lambda-service-not-available-in-region "LAMBDA_SERVICE_NOT_AVAILABLE_IN_REGION"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.domain-configuration/workflow-execution-retention-period-in-days (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-days))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/domain-configuration (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.domain-configuration/workflowExecutionRetentionPeriodInDays] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.unknown-resource-fault/message (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/error-message))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/unknown-resource-fault (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.unknown-resource-fault/message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/reason (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/failure-reason))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/child-workflow-execution-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/workflowExecution :portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/workflowType :portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/initiatedEventId :portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/reason :portkey.aws.swf.-2012-01-25.child-workflow-execution-failed-event-attributes/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/marker-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/canceled clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/function-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/timer-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-started-event-attributes/identity (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/identity))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-started-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/decision-task-started-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.decision-task-started-event-attributes/scheduledEventId] :opt-un [:portkey.aws.swf.-2012-01-25.decision-task-started-event-attributes/identity] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.cancel-workflow-execution-decision-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/cancel-workflow-execution-decision-attributes (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.cancel-workflow-execution-decision-attributes/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-scheduled-event-attributes/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-scheduled-event-attributes/task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-scheduled-event-attributes/start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/decision-task-scheduled-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.decision-task-scheduled-event-attributes/taskList] :opt-un [:portkey.aws.swf.-2012-01-25.decision-task-scheduled-event-attributes/taskPriority :portkey.aws.swf.-2012-01-25.decision-task-scheduled-event-attributes/startToCloseTimeout] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-terminated-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"CHILD_POLICY_APPLIED" "CHILD_POLICY_APPLIED", :child-policy-applied "CHILD_POLICY_APPLIED", "EVENT_LIMIT_EXCEEDED" "EVENT_LIMIT_EXCEEDED", :event-limit-exceeded "EVENT_LIMIT_EXCEEDED", "OPERATOR_INITIATED" "OPERATOR_INITIATED", :operator-initiated "OPERATOR_INITIATED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.fail-workflow-execution-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/fail-workflow-execution-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.fail-workflow-execution-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/fail-workflow-execution-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.fail-workflow-execution-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.fail-workflow-execution-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.describe-domain-input/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/describe-domain-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.describe-domain-input/name] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-detail/execution-info (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-info))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-detail/execution-configuration (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-configuration))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-detail/open-counts (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-open-counts))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-detail/latest-activity-task-timestamp (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timestamp))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-detail/latest-execution-context (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-detail (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-detail/executionInfo :portkey.aws.swf.-2012-01-25.workflow-execution-detail/executionConfiguration :portkey.aws.swf.-2012-01-25.workflow-execution-detail/openCounts] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-detail/latestActivityTaskTimestamp :portkey.aws.swf.-2012-01-25.workflow-execution-detail/latestExecutionContext] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/start-time-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/execution-time-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/type-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/tag-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/maximum-page-size (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-size))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/reverse-order (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/reverse-order))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/execution-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/list-open-workflow-executions-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/domain :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/startTimeFilter] :opt-un [:portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/typeFilter :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/tagFilter :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/nextPageToken :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/maximumPageSize :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/reverseOrder :portkey.aws.swf.-2012-01-25.list-open-workflow-executions-input/executionFilter] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/request-cancel-external-workflow-execution-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/request-cancel-external-workflow-execution-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/workflowId :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/initiatedEventId :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/runId :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-failed-event-attributes/control] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/data (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 32768))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.describe-activity-type-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.describe-activity-type-input/activity-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/describe-activity-type-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.describe-activity-type-input/domain :portkey.aws.swf.-2012-01-25.describe-activity-type-input/activityType] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/identity (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.describe-workflow-type-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.describe-workflow-type-input/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/describe-workflow-type-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.describe-workflow-type-input/domain :portkey.aws.swf.-2012-01-25.describe-workflow-type-input/workflowType] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.tag-filter/tag (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/tag-filter (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.tag-filter/tag] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/arn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 1600))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-already-started-fault/message (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/error-message))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-already-started-fault (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-already-started-fault/message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/workflow-type-version (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/version))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/execution-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/tag-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/lambda-role (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/arn))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/continue-as-new-workflow-execution-decision-attributes (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/workflowTypeVersion :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/executionStartToCloseTimeout :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/taskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/tagList :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/taskList :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/taskPriority :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/lambdaRole :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/input :portkey.aws.swf.-2012-01-25.continue-as-new-workflow-execution-decision-attributes/childPolicy] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-completed-event-attributes/execution-context (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-completed-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.decision-task-completed-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/decision-task-completed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.decision-task-completed-event-attributes/scheduledEventId :portkey.aws.swf.-2012-01-25.decision-task-completed-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.decision-task-completed-event-attributes/executionContext] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-timer-failed-event-attributes/timer-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timer-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-timer-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/start-timer-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-timer-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/start-timer-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.start-timer-failed-event-attributes/timerId :portkey.aws.swf.-2012-01-25.start-timer-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.start-timer-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.timer-fired-event-attributes/timer-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timer-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.timer-fired-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/timer-fired-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.timer-fired-event-attributes/timerId :portkey.aws.swf.-2012-01-25.timer-fired-event-attributes/startedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.close-status-filter/status (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/close-status))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/close-status-filter (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.close-status-filter/status] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/timestamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.domain-detail/domain-info (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-info))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.domain-detail/configuration (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-configuration))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/domain-detail (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.domain-detail/domainInfo :portkey.aws.swf.-2012-01-25.domain-detail/configuration] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.external-workflow-execution-cancel-requested-event-attributes/workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.external-workflow-execution-cancel-requested-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/external-workflow-execution-cancel-requested-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.external-workflow-execution-cancel-requested-event-attributes/workflowExecution :portkey.aws.swf.-2012-01-25.external-workflow-execution-cancel-requested-event-attributes/initiatedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/execution-status (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"OPEN" "OPEN", :open "OPEN", "CLOSED" "CLOSED", :closed "CLOSED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/schedule-to-start-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/activity-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/schedule-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/activity-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/heartbeat-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-task-scheduled-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/activityType :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/activityId :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/taskList :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/scheduleToStartTimeout :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/startToCloseTimeout :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/scheduleToCloseTimeout :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/taskPriority :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/control :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/input :portkey.aws.swf.-2012-01-25.activity-task-scheduled-event-attributes/heartbeatTimeout] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-workflow-type-input/default-execution-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-workflow-type-input/default-task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-workflow-type-input/default-task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-workflow-type-input/default-task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-workflow-type-input/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-workflow-type-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-workflow-type-input/default-child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-workflow-type-input/default-lambda-role (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/arn))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-workflow-type-input/version (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/version))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.register-workflow-type-input/description (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/description))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/register-workflow-type-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.register-workflow-type-input/domain :portkey.aws.swf.-2012-01-25.register-workflow-type-input/name :portkey.aws.swf.-2012-01-25.register-workflow-type-input/version] :opt-un [:portkey.aws.swf.-2012-01-25.register-workflow-type-input/defaultExecutionStartToCloseTimeout :portkey.aws.swf.-2012-01-25.register-workflow-type-input/defaultTaskPriority :portkey.aws.swf.-2012-01-25.register-workflow-type-input/defaultTaskList :portkey.aws.swf.-2012-01-25.register-workflow-type-input/defaultTaskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.register-workflow-type-input/defaultChildPolicy :portkey.aws.swf.-2012-01-25.register-workflow-type-input/defaultLambdaRole :portkey.aws.swf.-2012-01-25.register-workflow-type-input/description] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/decision-list (clojure.spec.alpha/and (clojure.spec.alpha/coll-of :portkey.aws.swf.-2012-01-25/decision) (clojure.spec.alpha/conformer clojure.core/identity (fn* [p1__13687__13688__auto__] (if (clojure.core/sequential? p1__13687__13688__auto__) p1__13687__13688__auto__ [p1__13687__13688__auto__])))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.timer-canceled-event-attributes/timer-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timer-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.timer-canceled-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.timer-canceled-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/timer-canceled-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.timer-canceled-event-attributes/timerId :portkey.aws.swf.-2012-01-25.timer-canceled-event-attributes/startedEventId :portkey.aws.swf.-2012-01-25.timer-canceled-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/record-marker-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :operation-not-permitted "OPERATION_NOT_PERMITTED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/tag (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 0 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/decision-type (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {:request-cancel-external-workflow-execution "RequestCancelExternalWorkflowExecution", :complete-workflow-execution "CompleteWorkflowExecution", "CancelWorkflowExecution" "CancelWorkflowExecution", "StartChildWorkflowExecution" "StartChildWorkflowExecution", :request-cancel-activity-task "RequestCancelActivityTask", "ScheduleLambdaFunction" "ScheduleLambdaFunction", :record-marker "RecordMarker", :cancel-timer "CancelTimer", "RequestCancelExternalWorkflowExecution" "RequestCancelExternalWorkflowExecution", :schedule-activity-task "ScheduleActivityTask", "CancelTimer" "CancelTimer", :fail-workflow-execution "FailWorkflowExecution", "ContinueAsNewWorkflowExecution" "ContinueAsNewWorkflowExecution", "FailWorkflowExecution" "FailWorkflowExecution", "ScheduleActivityTask" "ScheduleActivityTask", "StartTimer" "StartTimer", "RecordMarker" "RecordMarker", :schedule-lambda-function "ScheduleLambdaFunction", :start-timer "StartTimer", "RequestCancelActivityTask" "RequestCancelActivityTask", :cancel-workflow-execution "CancelWorkflowExecution", :continue-as-new-workflow-execution "ContinueAsNewWorkflowExecution", "SignalExternalWorkflowExecution" "SignalExternalWorkflowExecution", "CompleteWorkflowExecution" "CompleteWorkflowExecution", :start-child-workflow-execution "StartChildWorkflowExecution", :signal-external-workflow-execution "SignalExternalWorkflowExecution"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-configuration/default-task-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-configuration/default-execution-start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-configuration/default-task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-configuration/default-task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-configuration/default-child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-configuration/default-lambda-role (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/arn))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-type-configuration (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-type-configuration/defaultTaskStartToCloseTimeout :portkey.aws.swf.-2012-01-25.workflow-type-configuration/defaultExecutionStartToCloseTimeout :portkey.aws.swf.-2012-01-25.workflow-type-configuration/defaultTaskList :portkey.aws.swf.-2012-01-25.workflow-type-configuration/defaultTaskPriority :portkey.aws.swf.-2012-01-25.workflow-type-configuration/defaultChildPolicy :portkey.aws.swf.-2012-01-25.workflow-type-configuration/defaultLambdaRole] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/task-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/type-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/close-status-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/close-status-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/maximum-page-size (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-size))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/execution-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/reverse-order (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/reverse-order))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/start-time-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/execution-time-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/tag-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/close-time-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/execution-time-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/list-closed-workflow-executions-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/domain] :opt-un [:portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/typeFilter :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/closeStatusFilter :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/maximumPageSize :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/executionFilter :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/reverseOrder :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/startTimeFilter :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/nextPageToken :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/tagFilter :portkey.aws.swf.-2012-01-25.list-closed-workflow-executions-input/closeTimeFilter] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-failed-event-attributes/reason (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/failure-reason))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-failed-event-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-failed-event-attributes/reason :portkey.aws.swf.-2012-01-25.workflow-execution-failed-event-attributes/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.cancel-timer-failed-event-attributes/timer-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timer-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.cancel-timer-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/cancel-timer-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.cancel-timer-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/cancel-timer-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.cancel-timer-failed-event-attributes/timerId :portkey.aws.swf.-2012-01-25.cancel-timer-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.cancel-timer-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-started-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/lambda-function-started-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.lambda-function-started-event-attributes/scheduledEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-pending-decision-tasks-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-pending-decision-tasks-input/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/count-pending-decision-tasks-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.count-pending-decision-tasks-input/domain :portkey.aws.swf.-2012-01-25.count-pending-decision-tasks-input/taskList] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.respond-activity-task-failed-input/task-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.respond-activity-task-failed-input/reason (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/failure-reason))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.respond-activity-task-failed-input/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/respond-activity-task-failed-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.respond-activity-task-failed-input/taskToken] :opt-un [:portkey.aws.swf.-2012-01-25.respond-activity-task-failed-input/reason :portkey.aws.swf.-2012-01-25.respond-activity-task-failed-input/details] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/domain-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-info/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-info/status (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/registration-status))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-info/description (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/description))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-info/creation-date (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timestamp))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-type-info/deprecation-date (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timestamp))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-type-info (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-type-info/workflowType :portkey.aws.swf.-2012-01-25.workflow-type-info/status :portkey.aws.swf.-2012-01-25.workflow-type-info/creationDate] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-type-info/description :portkey.aws.swf.-2012-01-25.workflow-type-info/deprecationDate] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/start-time-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/execution-time-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/close-time-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/execution-time-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/execution-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/type-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/tag-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/tag-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/close-status-filter (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/close-status-filter))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/count-closed-workflow-executions-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/domain] :opt-un [:portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/startTimeFilter :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/closeTimeFilter :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/executionFilter :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/typeFilter :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/tagFilter :portkey.aws.swf.-2012-01-25.count-closed-workflow-executions-input/closeStatusFilter] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/event-id clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/activity-task-canceled-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-task-canceled-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/continue-as-new-workflow-execution-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/continue-as-new-workflow-execution-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/activity-task-started-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-task-started-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/workflow-execution-cancel-requested-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-cancel-requested-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/decision-task-timed-out-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/decision-task-timed-out-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/timer-fired-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timer-fired-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/workflow-execution-completed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-completed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/event-timestamp (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timestamp))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/cancel-timer-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/cancel-timer-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/activity-task-completed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-task-completed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/child-workflow-execution-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-workflow-execution-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/workflow-execution-started-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-started-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/cancel-workflow-execution-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/cancel-workflow-execution-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/activity-task-scheduled-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-task-scheduled-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/request-cancel-external-workflow-execution-initiated-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/request-cancel-external-workflow-execution-initiated-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/activity-task-cancel-requested-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-task-cancel-requested-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/schedule-lambda-function-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/schedule-lambda-function-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/workflow-execution-continued-as-new-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-continued-as-new-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/workflow-execution-signaled-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-signaled-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/child-workflow-execution-timed-out-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-workflow-execution-timed-out-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/decision-task-scheduled-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/decision-task-scheduled-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/child-workflow-execution-terminated-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-workflow-execution-terminated-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/decision-task-started-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/decision-task-started-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/workflow-execution-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/event-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/child-workflow-execution-started-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-workflow-execution-started-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/complete-workflow-execution-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/complete-workflow-execution-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/child-workflow-execution-canceled-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-workflow-execution-canceled-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/decision-task-completed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/decision-task-completed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/lambda-function-completed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/lambda-function-completed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/record-marker-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/record-marker-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/start-child-workflow-execution-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/start-child-workflow-execution-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/lambda-function-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/lambda-function-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/signal-external-workflow-execution-initiated-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/signal-external-workflow-execution-initiated-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/fail-workflow-execution-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/fail-workflow-execution-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/start-timer-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/start-timer-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/schedule-activity-task-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/schedule-activity-task-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/timer-canceled-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timer-canceled-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/request-cancel-activity-task-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/request-cancel-activity-task-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/timer-started-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timer-started-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/start-child-workflow-execution-initiated-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/start-child-workflow-execution-initiated-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/child-workflow-execution-completed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-workflow-execution-completed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/lambda-function-scheduled-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/lambda-function-scheduled-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/lambda-function-timed-out-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/lambda-function-timed-out-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/request-cancel-external-workflow-execution-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/request-cancel-external-workflow-execution-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/lambda-function-started-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/lambda-function-started-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/external-workflow-execution-cancel-requested-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/external-workflow-execution-cancel-requested-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/workflow-execution-canceled-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-canceled-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/start-lambda-function-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/start-lambda-function-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/marker-recorded-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/marker-recorded-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/activity-task-timed-out-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-task-timed-out-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/activity-task-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-task-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/external-workflow-execution-signaled-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/external-workflow-execution-signaled-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/signal-external-workflow-execution-failed-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/signal-external-workflow-execution-failed-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/workflow-execution-timed-out-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-timed-out-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/workflow-execution-terminated-event-attributes (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-terminated-event-attributes))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.history-event/event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/history-event (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.history-event/eventTimestamp :portkey.aws.swf.-2012-01-25.history-event/eventType :portkey.aws.swf.-2012-01-25.history-event/eventId] :opt-un [:portkey.aws.swf.-2012-01-25.history-event/activityTaskCanceledEventAttributes :portkey.aws.swf.-2012-01-25.history-event/continueAsNewWorkflowExecutionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/activityTaskStartedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/workflowExecutionCancelRequestedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/decisionTaskTimedOutEventAttributes :portkey.aws.swf.-2012-01-25.history-event/timerFiredEventAttributes :portkey.aws.swf.-2012-01-25.history-event/workflowExecutionCompletedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/cancelTimerFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/activityTaskCompletedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/childWorkflowExecutionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/workflowExecutionStartedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/cancelWorkflowExecutionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/activityTaskScheduledEventAttributes :portkey.aws.swf.-2012-01-25.history-event/requestCancelExternalWorkflowExecutionInitiatedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/activityTaskCancelRequestedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/scheduleLambdaFunctionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/workflowExecutionContinuedAsNewEventAttributes :portkey.aws.swf.-2012-01-25.history-event/workflowExecutionSignaledEventAttributes :portkey.aws.swf.-2012-01-25.history-event/childWorkflowExecutionTimedOutEventAttributes :portkey.aws.swf.-2012-01-25.history-event/decisionTaskScheduledEventAttributes :portkey.aws.swf.-2012-01-25.history-event/childWorkflowExecutionTerminatedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/decisionTaskStartedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/workflowExecutionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/childWorkflowExecutionStartedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/completeWorkflowExecutionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/childWorkflowExecutionCanceledEventAttributes :portkey.aws.swf.-2012-01-25.history-event/decisionTaskCompletedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/lambdaFunctionCompletedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/recordMarkerFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/startChildWorkflowExecutionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/lambdaFunctionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/signalExternalWorkflowExecutionInitiatedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/failWorkflowExecutionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/startTimerFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/scheduleActivityTaskFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/timerCanceledEventAttributes :portkey.aws.swf.-2012-01-25.history-event/requestCancelActivityTaskFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/timerStartedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/startChildWorkflowExecutionInitiatedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/childWorkflowExecutionCompletedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/lambdaFunctionScheduledEventAttributes :portkey.aws.swf.-2012-01-25.history-event/lambdaFunctionTimedOutEventAttributes :portkey.aws.swf.-2012-01-25.history-event/requestCancelExternalWorkflowExecutionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/lambdaFunctionStartedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/externalWorkflowExecutionCancelRequestedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/workflowExecutionCanceledEventAttributes :portkey.aws.swf.-2012-01-25.history-event/startLambdaFunctionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/markerRecordedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/activityTaskTimedOutEventAttributes :portkey.aws.swf.-2012-01-25.history-event/activityTaskFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/externalWorkflowExecutionSignaledEventAttributes :portkey.aws.swf.-2012-01-25.history-event/signalExternalWorkflowExecutionFailedEventAttributes :portkey.aws.swf.-2012-01-25.history-event/workflowExecutionTimedOutEventAttributes :portkey.aws.swf.-2012-01-25.history-event/workflowExecutionTerminatedEventAttributes] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/function-input (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 0 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 32768))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/close-status (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"COMPLETED" "COMPLETED", "CANCELED" "CANCELED", :timed-out "TIMED_OUT", :continued-as-new "CONTINUED_AS_NEW", "TIMED_OUT" "TIMED_OUT", :completed "COMPLETED", "TERMINATED" "TERMINATED", :canceled "CANCELED", :terminated "TERMINATED", "FAILED" "FAILED", "CONTINUED_AS_NEW" "CONTINUED_AS_NEW", :failed "FAILED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-infos/execution-infos (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-info-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-infos/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-infos (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-infos/executionInfos] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-infos/nextPageToken] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-terminated-event-attributes/reason (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/terminate-reason))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-terminated-event-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-terminated-event-attributes/child-policy (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/child-policy))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-terminated-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-terminated-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-terminated-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-terminated-event-attributes/childPolicy] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-terminated-event-attributes/reason :portkey.aws.swf.-2012-01-25.workflow-execution-terminated-event-attributes/details :portkey.aws.swf.-2012-01-25.workflow-execution-terminated-event-attributes/cause] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.domain-info/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.domain-info/status (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/registration-status))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.domain-info/description (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/description))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/domain-info (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.domain-info/name :portkey.aws.swf.-2012-01-25.domain-info/status] :opt-un [:portkey.aws.swf.-2012-01-25.domain-info/description] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/signal-external-workflow-execution-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION" "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION", :unknown-external-workflow-execution "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION", "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED" "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED", :signal-external-workflow-execution-rate-exceeded "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :operation-not-permitted "OPERATION_NOT_PERMITTED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-started-event-attributes/workflow-execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-started-event-attributes/workflow-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.child-workflow-execution-started-event-attributes/initiated-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/child-workflow-execution-started-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.child-workflow-execution-started-event-attributes/workflowExecution :portkey.aws.swf.-2012-01-25.child-workflow-execution-started-event-attributes/workflowType :portkey.aws.swf.-2012-01-25.child-workflow-execution-started-event-attributes/initiatedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.domain-already-exists-fault/message (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/error-message))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/domain-already-exists-fault (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.domain-already-exists-fault/message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/function-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/function-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/function-input))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/lambda-function-scheduled-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/id :portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/name :portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/control :portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/input :portkey.aws.swf.-2012-01-25.lambda-function-scheduled-event-attributes/startToCloseTimeout] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.complete-workflow-execution-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/complete-workflow-execution-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.complete-workflow-execution-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/complete-workflow-execution-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.complete-workflow-execution-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.complete-workflow-execution-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/complete-workflow-execution-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"UNHANDLED_DECISION" "UNHANDLED_DECISION", :unhandled-decision "UNHANDLED_DECISION", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :operation-not-permitted "OPERATION_NOT_PERMITTED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/signal-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/signal-name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/signal-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/signal-external-workflow-execution-initiated-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/workflowId :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/signalName :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/runId :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/input :portkey.aws.swf.-2012-01-25.signal-external-workflow-execution-initiated-event-attributes/control] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-activity-types-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-activity-types-input/name (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-activity-types-input/registration-status (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/registration-status))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-activity-types-input/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-activity-types-input/maximum-page-size (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-size))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-activity-types-input/reverse-order (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/reverse-order))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/list-activity-types-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.list-activity-types-input/domain :portkey.aws.swf.-2012-01-25.list-activity-types-input/registrationStatus] :opt-un [:portkey.aws.swf.-2012-01-25.list-activity-types-input/name :portkey.aws.swf.-2012-01-25.list-activity-types-input/nextPageToken :portkey.aws.swf.-2012-01-25.list-activity-types-input/maximumPageSize :portkey.aws.swf.-2012-01-25.list-activity-types-input/reverseOrder] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-type-info-list (clojure.spec.alpha/and (clojure.spec.alpha/coll-of :portkey.aws.swf.-2012-01-25/activity-type-info) (clojure.spec.alpha/conformer clojure.core/identity (fn* [p1__13687__13688__auto__] (if (clojure.core/sequential? p1__13687__13688__auto__) p1__13687__13688__auto__ [p1__13687__13688__auto__])))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/cancel-timer-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"TIMER_ID_UNKNOWN" "TIMER_ID_UNKNOWN", :timer-id-unknown "TIMER_ID_UNKNOWN", "OPERATION_NOT_PERMITTED" "OPERATION_NOT_PERMITTED", :operation-not-permitted "OPERATION_NOT_PERMITTED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/reverse-order clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/terminate-reason (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13768__auto__] (clojure.core/<= 1 (clojure.core/count s__13768__auto__))) (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-started-event-attributes/identity (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/identity))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-started-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-task-started-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-task-started-event-attributes/scheduledEventId] :opt-un [:portkey.aws.swf.-2012-01-25.activity-task-started-event-attributes/identity] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-cancel-requested-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"CHILD_POLICY_APPLIED" "CHILD_POLICY_APPLIED", :child-policy-applied "CHILD_POLICY_APPLIED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.type-deprecated-fault/message (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/error-message))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/type-deprecated-fault (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.swf.-2012-01-25.type-deprecated-fault/message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/page-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__13769__auto__] (clojure.core/< (clojure.core/count s__13769__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-status/cancel-requested (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/canceled))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-task-status (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-task-status/cancelRequested] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-infos/type-infos (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type-info-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-type-infos/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-type-infos (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-type-infos/typeInfos] :opt-un [:portkey.aws.swf.-2012-01-25.activity-type-infos/nextPageToken] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-domains-input/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-domains-input/registration-status (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/registration-status))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-domains-input/maximum-page-size (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-size))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.list-domains-input/reverse-order (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/reverse-order))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/list-domains-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.list-domains-input/registrationStatus] :opt-un [:portkey.aws.swf.-2012-01-25.list-domains-input/nextPageToken :portkey.aws.swf.-2012-01-25.list-domains-input/maximumPageSize :portkey.aws.swf.-2012-01-25.list-domains-input/reverseOrder] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/start-lambda-function-failed-cause (clojure.spec.alpha/conformer (clojure.core/let [m__13766__auto__ {"ASSUME_ROLE_FAILED" "ASSUME_ROLE_FAILED", :assume-role-failed "ASSUME_ROLE_FAILED"}] (clojure.core/fn [s__13767__auto__] (m__13766__auto__ s__13767__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-decision-attributes/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-decision-attributes/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-decision-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/request-cancel-external-workflow-execution-decision-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-decision-attributes/workflowId] :opt-un [:portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-decision-attributes/runId :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-decision-attributes/control] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/schedule-to-start-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/start-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/activity-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/schedule-to-close-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/task-list (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-list))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/task-priority (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/task-priority))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/input (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/activity-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/heartbeat-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/schedule-activity-task-decision-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/activityType :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/activityId] :opt-un [:portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/scheduleToStartTimeout :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/startToCloseTimeout :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/scheduleToCloseTimeout :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/taskList :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/taskPriority :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/control :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/input :portkey.aws.swf.-2012-01-25.schedule-activity-task-decision-attributes/heartbeatTimeout] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-initiated-event-attributes/workflow-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-initiated-event-attributes/run-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-run-id-optional))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-initiated-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-initiated-event-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/request-cancel-external-workflow-execution-initiated-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-initiated-event-attributes/workflowId :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-initiated-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-initiated-event-attributes/runId :portkey.aws.swf.-2012-01-25.request-cancel-external-workflow-execution-initiated-event-attributes/control] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.cancel-workflow-execution-failed-event-attributes/cause (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/cancel-workflow-execution-failed-cause))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.cancel-workflow-execution-failed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/cancel-workflow-execution-failed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.cancel-workflow-execution-failed-event-attributes/cause :portkey.aws.swf.-2012-01-25.cancel-workflow-execution-failed-event-attributes/decisionTaskCompletedEventId] :opt-un [] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-open-counts/open-activity-tasks (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/count))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-open-counts/open-decision-tasks (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/open-decision-tasks-count))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-open-counts/open-timers (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/count))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-open-counts/open-child-workflow-executions (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/count))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-open-counts/open-lambda-functions (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/count))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-open-counts (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-open-counts/openActivityTasks :portkey.aws.swf.-2012-01-25.workflow-execution-open-counts/openDecisionTasks :portkey.aws.swf.-2012-01-25.workflow-execution-open-counts/openTimers :portkey.aws.swf.-2012-01-25.workflow-execution-open-counts/openChildWorkflowExecutions] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-open-counts/openLambdaFunctions] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-completed-event-attributes/result (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.workflow-execution-completed-event-attributes/decision-task-completed-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/workflow-execution-completed-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.workflow-execution-completed-event-attributes/decisionTaskCompletedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.workflow-execution-completed-event-attributes/result] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.get-workflow-execution-history-input/domain (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-name))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.get-workflow-execution-history-input/execution (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.get-workflow-execution-history-input/next-page-token (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-token))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.get-workflow-execution-history-input/maximum-page-size (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/page-size))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.get-workflow-execution-history-input/reverse-order (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/reverse-order))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/get-workflow-execution-history-input (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.get-workflow-execution-history-input/domain :portkey.aws.swf.-2012-01-25.get-workflow-execution-history-input/execution] :opt-un [:portkey.aws.swf.-2012-01-25.get-workflow-execution-history-input/nextPageToken :portkey.aws.swf.-2012-01-25.get-workflow-execution-history-input/maximumPageSize :portkey.aws.swf.-2012-01-25.get-workflow-execution-history-input/reverseOrder] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-timer-decision-attributes/timer-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/timer-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-timer-decision-attributes/control (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.start-timer-decision-attributes/start-to-fire-timeout (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/duration-in-seconds))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/start-timer-decision-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.start-timer-decision-attributes/timerId :portkey.aws.swf.-2012-01-25.start-timer-decision-attributes/startToFireTimeout] :opt-un [:portkey.aws.swf.-2012-01-25.start-timer-decision-attributes/control] :locations {}))

(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-timed-out-event-attributes/timeout-type (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-task-timeout-type))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-timed-out-event-attributes/scheduled-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-timed-out-event-attributes/started-event-id (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/event-id))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25.activity-task-timed-out-event-attributes/details (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/limited-data))
(clojure.spec.alpha/def :portkey.aws.swf.-2012-01-25/activity-task-timed-out-event-attributes (portkey.aws/json-keys :req-un [:portkey.aws.swf.-2012-01-25.activity-task-timed-out-event-attributes/timeoutType :portkey.aws.swf.-2012-01-25.activity-task-timed-out-event-attributes/scheduledEventId :portkey.aws.swf.-2012-01-25.activity-task-timed-out-event-attributes/startedEventId] :opt-un [:portkey.aws.swf.-2012-01-25.activity-task-timed-out-event-attributes/details] :locations {}))

(clojure.core/defn list-open-workflow-executions "Returns a list of open workflow executions in the specified domain that meet the\nfiltering criteria. The results may be split into multiple pages. To retrieve\nsubsequent pages, make the call again using the nextPageToken returned by the\ninitial call.\n This operation is eventually consistent. The results are best effort and may\nnot exactly reflect recent updates and changes.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * tagFilter.tag: String constraint. The key is swf:tagFilter.tag.\n * typeFilter.name: String constraint. The key is swf:typeFilter.name.\n * typeFilter.version: String constraint. The key is swf:typeFilter.version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([list-open-workflow-executions-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.ListOpenWorkflowExecutions" list-open-workflow-executions-input :portkey.aws.swf.-2012-01-25/list-open-workflow-executions-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/workflow-execution-infos {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef list-open-workflow-executions :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/list-open-workflow-executions-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-infos))

(clojure.core/defn register-domain "Registers a new domain.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * You cannot use an IAM policy to control domain access for this action. The\nname of the domain being registered is available as the resource of this action.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([register-domain-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.RegisterDomain" register-domain-input :portkey.aws.swf.-2012-01-25/register-domain-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"DomainAlreadyExistsFault" :portkey.aws.swf.-2012-01-25/domain-already-exists-fault, "LimitExceededFault" :portkey.aws.swf.-2012-01-25/limit-exceeded-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef register-domain :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/register-domain-input) :ret clojure.core/true?)

(clojure.core/defn count-pending-decision-tasks "Returns the estimated number of decision tasks in the specified task list. The\ncount returned is an approximation and isn't guaranteed to be exact. If you\nspecify a task list that no decision task was ever scheduled in then 0 is\nreturned.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the taskList.name parameter by using a Condition element with the\nswf:taskList.name key to allow the action to access only certain task lists.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([count-pending-decision-tasks-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.CountPendingDecisionTasks" count-pending-decision-tasks-input :portkey.aws.swf.-2012-01-25/count-pending-decision-tasks-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/pending-task-count {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef count-pending-decision-tasks :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/count-pending-decision-tasks-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/pending-task-count))

(clojure.core/defn poll-for-decision-task "Used by deciders to get a DecisionTask from the specified decision taskList. A\ndecision task may be returned for any open workflow execution that is using the\nspecified task list. The task includes a paginated view of the history of the\nworkflow execution. The decider should use the workflow type and the history to\ndetermine how to properly handle the task.\n This action initiates a long poll, where the service holds the HTTP connection\nopen and responds as soon a task becomes available. If no decision task is\navailable in the specified task list before the timeout of 60 seconds expires,\nan empty result is returned. An empty result, in this context, means that a\nDecisionTask is returned, but that the value of taskToken is an empty string.\n Deciders should set their client side socket timeout to at least 70 seconds (10\nseconds higher than the timeout).\n Because the number of workflow history events for a single workflow execution\nmight be very large, the result returned might be split up across a number of\npages. To retrieve subsequent pages, make additional calls to\nPollForDecisionTask using the nextPageToken returned by the initial call. Note\nthat you do not call GetWorkflowExecutionHistory with this nextPageToken.\nInstead, call PollForDecisionTask again.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the taskList.name parameter by using a Condition element with the\nswf:taskList.name key to allow the action to access only certain task lists.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([poll-for-decision-task-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.PollForDecisionTask" poll-for-decision-task-input :portkey.aws.swf.-2012-01-25/poll-for-decision-task-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/decision-task {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault, "LimitExceededFault" :portkey.aws.swf.-2012-01-25/limit-exceeded-fault})))
(clojure.spec.alpha/fdef poll-for-decision-task :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/poll-for-decision-task-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/decision-task))

(clojure.core/defn list-closed-workflow-executions "Returns a list of closed workflow executions in the specified domain that meet\nthe filtering criteria. The results may be split into multiple pages. To\nretrieve subsequent pages, make the call again using the nextPageToken returned\nby the initial call.\n This operation is eventually consistent. The results are best effort and may\nnot exactly reflect recent updates and changes.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * tagFilter.tag: String constraint. The key is swf:tagFilter.tag.\n * typeFilter.name: String constraint. The key is swf:typeFilter.name.\n * typeFilter.version: String constraint. The key is swf:typeFilter.version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([list-closed-workflow-executions-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.ListClosedWorkflowExecutions" list-closed-workflow-executions-input :portkey.aws.swf.-2012-01-25/list-closed-workflow-executions-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/workflow-execution-infos {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef list-closed-workflow-executions :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/list-closed-workflow-executions-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-infos))

(clojure.core/defn list-domains "Returns the list of domains registered in the account. The results may be split\ninto multiple pages. To retrieve subsequent pages, make the call again using the\nnextPageToken returned by the initial call.\n This operation is eventually consistent. The results are best effort and may\nnot exactly reflect recent updates and changes.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains. The element must be set to arn:aws:swf::AccountID:domain/*,\nwhere AccountID is the account ID, with no dashes.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([list-domains-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.ListDomains" list-domains-input :portkey.aws.swf.-2012-01-25/list-domains-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/domain-infos {"OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef list-domains :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/list-domains-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-infos))

(clojure.core/defn describe-domain "Returns information about the specified domain, including description and\nstatus.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([describe-domain-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.DescribeDomain" describe-domain-input :portkey.aws.swf.-2012-01-25/describe-domain-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/domain-detail {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef describe-domain :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/describe-domain-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/domain-detail))

(clojure.core/defn respond-activity-task-canceled "Used by workers to tell the service that the ActivityTask identified by the\ntaskToken was successfully canceled. Additional details can be provided using\nthe details argument.\n These details (if provided) appear in the ActivityTaskCanceled event added to\nthe workflow history.\n Only use this operation if the canceled flag of a RecordActivityTaskHeartbeat\nrequest returns true and if the activity can be safely undone or abandoned.\n A task is considered open from the time that it is scheduled until it is\nclosed. Therefore a task is reported as open while a worker is processing it. A\ntask is closed after it has been specified in a call to\nRespondActivityTaskCompleted, RespondActivityTaskCanceled,\nRespondActivityTaskFailed, or the task has timed out\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-basic.html#swf-dev-timeout-types).\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([respond-activity-task-canceled-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.RespondActivityTaskCanceled" respond-activity-task-canceled-input :portkey.aws.swf.-2012-01-25/respond-activity-task-canceled-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef respond-activity-task-canceled :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/respond-activity-task-canceled-input) :ret clojure.core/true?)

(clojure.core/defn request-cancel-workflow-execution "Records a WorkflowExecutionCancelRequested event in the currently running\nworkflow execution identified by the given domain, workflowId, and runId. This\nlogically requests the cancellation of the workflow execution as a whole. It is\nup to the decider to take appropriate actions when it receives an execution\nhistory with this event.\n If the runId isn't specified, the WorkflowExecutionCancelRequested event is\nrecorded in the history of the current open workflow execution with the\nspecified workflowId in the domain.\n Because this action allows the workflow to properly clean up and gracefully\nclose, it should be used instead of TerminateWorkflowExecution when possible.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([request-cancel-workflow-execution-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.RequestCancelWorkflowExecution" request-cancel-workflow-execution-input :portkey.aws.swf.-2012-01-25/request-cancel-workflow-execution-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef request-cancel-workflow-execution :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/request-cancel-workflow-execution-input) :ret clojure.core/true?)

(clojure.core/defn terminate-workflow-execution "Records a WorkflowExecutionTerminated event and forces closure of the workflow\nexecution identified by the given domain, runId, and workflowId. The child\npolicy, registered with the workflow type or specified when starting this\nexecution, is applied to any open child workflow executions of this workflow\nexecution.\n If the identified workflow execution was in progress, it is terminated\nimmediately.\n If a runId isn't specified, then the WorkflowExecutionTerminated event is\nrecorded in the history of the current open workflow with the matching\nworkflowId in the domain.\n You should consider using RequestCancelWorkflowExecution action instead because\nit allows the workflow to gracefully close while TerminateWorkflowExecution\ndoesn't.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([terminate-workflow-execution-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.TerminateWorkflowExecution" terminate-workflow-execution-input :portkey.aws.swf.-2012-01-25/terminate-workflow-execution-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef terminate-workflow-execution :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/terminate-workflow-execution-input) :ret clojure.core/true?)

(clojure.core/defn get-workflow-execution-history "Returns the history of the specified workflow execution. The results may be\nsplit into multiple pages. To retrieve subsequent pages, make the call again\nusing the nextPageToken returned by the initial call.\n This operation is eventually consistent. The results are best effort and may\nnot exactly reflect recent updates and changes.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([get-workflow-execution-history-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.GetWorkflowExecutionHistory" get-workflow-execution-history-input :portkey.aws.swf.-2012-01-25/get-workflow-execution-history-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/history {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef get-workflow-execution-history :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/get-workflow-execution-history-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/history))

(clojure.core/defn start-workflow-execution "Starts an execution of the workflow type in the specified domain using the\nprovided workflowId and input data.\n This action returns the newly started workflow execution.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * tagList.member.0: The key is swf:tagList.member.0.\n * tagList.member.1: The key is swf:tagList.member.1.\n * tagList.member.2: The key is swf:tagList.member.2.\n * tagList.member.3: The key is swf:tagList.member.3.\n * tagList.member.4: The key is swf:tagList.member.4.\n * taskList: String constraint. The key is swf:taskList.name.\n * workflowType.name: String constraint. The key is swf:workflowType.name.\n * workflowType.version: String constraint. The key is swf:workflowType.version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([start-workflow-execution-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.StartWorkflowExecution" start-workflow-execution-input :portkey.aws.swf.-2012-01-25/start-workflow-execution-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/run {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "TypeDeprecatedFault" :portkey.aws.swf.-2012-01-25/type-deprecated-fault, "WorkflowExecutionAlreadyStartedFault" :portkey.aws.swf.-2012-01-25/workflow-execution-already-started-fault, "LimitExceededFault" :portkey.aws.swf.-2012-01-25/limit-exceeded-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault, "DefaultUndefinedFault" :portkey.aws.swf.-2012-01-25/default-undefined-fault})))
(clojure.spec.alpha/fdef start-workflow-execution :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/start-workflow-execution-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/run))

(clojure.core/defn register-activity-type "Registers a new activity type along with its configuration settings in the\nspecified domain.\n A TypeAlreadyExists fault is returned if the type already exists in the domain.\nYou cannot change any configuration settings of the type after its registration,\nand it must be registered as a new version.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * defaultTaskList.name: String constraint. The key is swf:defaultTaskList.name.\n * name: String constraint. The key is swf:name.\n * version: String constraint. The key is swf:version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([register-activity-type-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.RegisterActivityType" register-activity-type-input :portkey.aws.swf.-2012-01-25/register-activity-type-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"TypeAlreadyExistsFault" :portkey.aws.swf.-2012-01-25/type-already-exists-fault, "LimitExceededFault" :portkey.aws.swf.-2012-01-25/limit-exceeded-fault, "UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef register-activity-type :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/register-activity-type-input) :ret clojure.core/true?)

(clojure.core/defn respond-decision-task-completed "Used by deciders to tell the service that the DecisionTask identified by the\ntaskToken has successfully completed. The decisions argument specifies the list\nof decisions made while processing the task.\n A DecisionTaskCompleted event is added to the workflow history. The\nexecutionContext specified is attached to the event in the workflow execution\nhistory.\n Access Control\n If an IAM policy grants permission to use RespondDecisionTaskCompleted, it can\nexpress permissions for the list of decisions in the decisions parameter. Each\nof the decisions has one or more parameters, much like a regular API call. To\nallow for policies to be as readable as possible, you can express permissions on\ndecisions as if they were actual API calls, including applying conditions to\nsome parameters. For more information, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([respond-decision-task-completed-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.RespondDecisionTaskCompleted" respond-decision-task-completed-input :portkey.aws.swf.-2012-01-25/respond-decision-task-completed-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef respond-decision-task-completed :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/respond-decision-task-completed-input) :ret clojure.core/true?)

(clojure.core/defn register-workflow-type "Registers a new workflow type and its configuration settings in the specified\ndomain.\n The retention period for the workflow history is set by the RegisterDomain\naction.\n If the type already exists, then a TypeAlreadyExists fault is returned. You\ncannot change the configuration settings of a workflow type once it is\nregistered and it must be registered as a new version.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * defaultTaskList.name: String constraint. The key is swf:defaultTaskList.name.\n * name: String constraint. The key is swf:name.\n * version: String constraint. The key is swf:version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([register-workflow-type-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.RegisterWorkflowType" register-workflow-type-input :portkey.aws.swf.-2012-01-25/register-workflow-type-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"TypeAlreadyExistsFault" :portkey.aws.swf.-2012-01-25/type-already-exists-fault, "LimitExceededFault" :portkey.aws.swf.-2012-01-25/limit-exceeded-fault, "UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef register-workflow-type :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/register-workflow-type-input) :ret clojure.core/true?)

(clojure.core/defn describe-workflow-type "Returns information about the specified workflow type. This includes\nconfiguration settings specified when the type was registered and other\ninformation such as creation date, current status, etc.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * workflowType.name: String constraint. The key is swf:workflowType.name.\n * workflowType.version: String constraint. The key is swf:workflowType.version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([describe-workflow-type-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.DescribeWorkflowType" describe-workflow-type-input :portkey.aws.swf.-2012-01-25/describe-workflow-type-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/workflow-type-detail {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef describe-workflow-type :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/describe-workflow-type-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type-detail))

(clojure.core/defn respond-activity-task-failed "Used by workers to tell the service that the ActivityTask identified by the\ntaskToken has failed with reason (if specified). The reason and details appear\nin the ActivityTaskFailed event added to the workflow history.\n A task is considered open from the time that it is scheduled until it is\nclosed. Therefore a task is reported as open while a worker is processing it. A\ntask is closed after it has been specified in a call to\nRespondActivityTaskCompleted, RespondActivityTaskCanceled,\nRespondActivityTaskFailed, or the task has timed out\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-basic.html#swf-dev-timeout-types).\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([respond-activity-task-failed-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.RespondActivityTaskFailed" respond-activity-task-failed-input :portkey.aws.swf.-2012-01-25/respond-activity-task-failed-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef respond-activity-task-failed :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/respond-activity-task-failed-input) :ret clojure.core/true?)

(clojure.core/defn poll-for-activity-task "Used by workers to get an ActivityTask from the specified activity taskList.\nThis initiates a long poll, where the service holds the HTTP connection open and\nresponds as soon as a task becomes available. The maximum time the service holds\non to the request before responding is 60 seconds. If no task is available\nwithin 60 seconds, the poll returns an empty result. An empty result, in this\ncontext, means that an ActivityTask is returned, but that the value of taskToken\nis an empty string. If a task is returned, the worker should use its type to\nidentify and process it correctly.\n Workers should set their client side socket timeout to at least 70 seconds (10\nseconds higher than the maximum time service may hold the poll request).\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the taskList.name parameter by using a Condition element with the\nswf:taskList.name key to allow the action to access only certain task lists.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([poll-for-activity-task-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.PollForActivityTask" poll-for-activity-task-input :portkey.aws.swf.-2012-01-25/poll-for-activity-task-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/activity-task {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault, "LimitExceededFault" :portkey.aws.swf.-2012-01-25/limit-exceeded-fault})))
(clojure.spec.alpha/fdef poll-for-activity-task :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/poll-for-activity-task-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-task))

(clojure.core/defn list-workflow-types "Returns information about workflow types in the specified domain. The results\nmay be split into multiple pages that can be retrieved by making the call\nrepeatedly.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([list-workflow-types-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.ListWorkflowTypes" list-workflow-types-input :portkey.aws.swf.-2012-01-25/list-workflow-types-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/workflow-type-infos {"OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault, "UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault})))
(clojure.spec.alpha/fdef list-workflow-types :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/list-workflow-types-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-type-infos))

(clojure.core/defn signal-workflow-execution "Records a WorkflowExecutionSignaled event in the workflow execution history and\ncreates a decision task for the workflow execution identified by the given\ndomain, workflowId and runId. The event is recorded with the specified user\ndefined signalName and input (if provided).\n If a runId isn't specified, then the WorkflowExecutionSignaled event is\nrecorded in the history of the current open workflow with the matching\nworkflowId in the domain.\n If the specified workflow execution isn't open, this method fails with\nUnknownResource.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([signal-workflow-execution-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.SignalWorkflowExecution" signal-workflow-execution-input :portkey.aws.swf.-2012-01-25/signal-workflow-execution-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef signal-workflow-execution :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/signal-workflow-execution-input) :ret clojure.core/true?)

(clojure.core/defn deprecate-domain "Deprecates the specified domain. After a domain has been deprecated it cannot be\nused to create new workflow executions or register new types. However, you can\nstill use visibility actions on this domain. Deprecating a domain also\ndeprecates all activity and workflow types registered in the domain. Executions\nthat were started before the domain was deprecated continues to run.\n This operation is eventually consistent. The results are best effort and may\nnot exactly reflect recent updates and changes.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([deprecate-domain-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.DeprecateDomain" deprecate-domain-input :portkey.aws.swf.-2012-01-25/deprecate-domain-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "DomainDeprecatedFault" :portkey.aws.swf.-2012-01-25/domain-deprecated-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef deprecate-domain :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/deprecate-domain-input) :ret clojure.core/true?)

(clojure.core/defn describe-workflow-execution "Returns information about the specified workflow execution including its type\nand some statistics.\n This operation is eventually consistent. The results are best effort and may\nnot exactly reflect recent updates and changes.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([describe-workflow-execution-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.DescribeWorkflowExecution" describe-workflow-execution-input :portkey.aws.swf.-2012-01-25/describe-workflow-execution-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/workflow-execution-detail {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef describe-workflow-execution :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/describe-workflow-execution-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-detail))

(clojure.core/defn count-open-workflow-executions "Returns the number of open workflow executions within the given domain that meet\nthe specified filtering criteria.\n This operation is eventually consistent. The results are best effort and may\nnot exactly reflect recent updates and changes.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * tagFilter.tag: String constraint. The key is swf:tagFilter.tag.\n * typeFilter.name: String constraint. The key is swf:typeFilter.name.\n * typeFilter.version: String constraint. The key is swf:typeFilter.version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([count-open-workflow-executions-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.CountOpenWorkflowExecutions" count-open-workflow-executions-input :portkey.aws.swf.-2012-01-25/count-open-workflow-executions-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/workflow-execution-count {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef count-open-workflow-executions :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/count-open-workflow-executions-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-count))

(clojure.core/defn list-activity-types "Returns information about all activities registered in the specified domain that\nmatch the specified name and registration status. The result includes\ninformation like creation date, current status of the activity, etc. The results\nmay be split into multiple pages. To retrieve subsequent pages, make the call\nagain using the nextPageToken returned by the initial call.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([list-activity-types-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.ListActivityTypes" list-activity-types-input :portkey.aws.swf.-2012-01-25/list-activity-types-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/activity-type-infos {"OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault, "UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault})))
(clojure.spec.alpha/fdef list-activity-types :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/list-activity-types-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type-infos))

(clojure.core/defn describe-activity-type "Returns information about the specified activity type. This includes\nconfiguration settings provided when the type was registered and other general\ninformation about the type.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * activityType.name: String constraint. The key is swf:activityType.name.\n * activityType.version: String constraint. The key is swf:activityType.version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([describe-activity-type-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.DescribeActivityType" describe-activity-type-input :portkey.aws.swf.-2012-01-25/describe-activity-type-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/activity-type-detail {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef describe-activity-type :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/describe-activity-type-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-type-detail))

(clojure.core/defn respond-activity-task-completed "Used by workers to tell the service that the ActivityTask identified by the\ntaskToken completed successfully with a result (if provided). The result appears\nin the ActivityTaskCompleted event in the workflow history.\n If the requested task doesn't complete successfully, use\nRespondActivityTaskFailed instead. If the worker finds that the task is canceled\nthrough the canceled flag returned by RecordActivityTaskHeartbeat, it should\ncancel the task, clean up and then call RespondActivityTaskCanceled.\n A task is considered open from the time that it is scheduled until it is\nclosed. Therefore a task is reported as open while a worker is processing it. A\ntask is closed after it has been specified in a call to\nRespondActivityTaskCompleted, RespondActivityTaskCanceled,\nRespondActivityTaskFailed, or the task has timed out\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-basic.html#swf-dev-timeout-types).\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([respond-activity-task-completed-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.RespondActivityTaskCompleted" respond-activity-task-completed-input :portkey.aws.swf.-2012-01-25/respond-activity-task-completed-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef respond-activity-task-completed :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/respond-activity-task-completed-input) :ret clojure.core/true?)

(clojure.core/defn record-activity-task-heartbeat "Used by activity workers to report to the service that the ActivityTask\nrepresented by the specified taskToken is still making progress. The worker can\nalso specify details of the progress, for example percent complete, using the\ndetails parameter. This action can also be used by the worker as a mechanism to\ncheck if cancellation is being requested for the activity task. If a\ncancellation is being attempted for the specified task, then the boolean\ncancelRequested flag returned by the service is set to true.\n This action resets the taskHeartbeatTimeout clock. The taskHeartbeatTimeout is\nspecified in RegisterActivityType.\n This action doesn't in itself create an event in the workflow execution\nhistory. However, if the task times out, the workflow execution history contains\na ActivityTaskTimedOut event that contains the information from the last\nheartbeat generated by the activity worker.\n The taskStartToCloseTimeout of an activity type is the maximum duration of an\nactivity task, regardless of the number of RecordActivityTaskHeartbeat requests\nreceived. The taskStartToCloseTimeout is also specified in RegisterActivityType.\n This operation is only useful for long-lived activities to report liveliness of\nthe task and to determine if a cancellation is being attempted.\n If the cancelRequested flag returns true, a cancellation is being attempted. If\nthe worker can cancel the activity, it should respond with\nRespondActivityTaskCanceled. Otherwise, it should ignore the cancellation\nrequest.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * You cannot use an IAM policy to constrain this action's parameters.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([record-activity-task-heartbeat-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.RecordActivityTaskHeartbeat" record-activity-task-heartbeat-input :portkey.aws.swf.-2012-01-25/record-activity-task-heartbeat-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/activity-task-status {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef record-activity-task-heartbeat :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/record-activity-task-heartbeat-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/activity-task-status))

(clojure.core/defn count-closed-workflow-executions "Returns the number of closed workflow executions within the given domain that\nmeet the specified filtering criteria.\n This operation is eventually consistent. The results are best effort and may\nnot exactly reflect recent updates and changes.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * tagFilter.tag: String constraint. The key is swf:tagFilter.tag.\n * typeFilter.name: String constraint. The key is swf:typeFilter.name.\n * typeFilter.version: String constraint. The key is swf:typeFilter.version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([count-closed-workflow-executions-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.CountClosedWorkflowExecutions" count-closed-workflow-executions-input :portkey.aws.swf.-2012-01-25/count-closed-workflow-executions-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/workflow-execution-count {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef count-closed-workflow-executions :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/count-closed-workflow-executions-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/workflow-execution-count))

(clojure.core/defn count-pending-activity-tasks "Returns the estimated number of activity tasks in the specified task list. The\ncount returned is an approximation and isn't guaranteed to be exact. If you\nspecify a task list that no activity task was ever scheduled in then 0 is\nreturned.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the taskList.name parameter by using a Condition element with the\nswf:taskList.name key to allow the action to access only certain task lists.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([count-pending-activity-tasks-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.CountPendingActivityTasks" count-pending-activity-tasks-input :portkey.aws.swf.-2012-01-25/count-pending-activity-tasks-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.swf.-2012-01-25/pending-task-count {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef count-pending-activity-tasks :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/count-pending-activity-tasks-input) :ret (clojure.spec.alpha/and :portkey.aws.swf.-2012-01-25/pending-task-count))

(clojure.core/defn deprecate-workflow-type "Deprecates the specified workflow type. After a workflow type has been\ndeprecated, you cannot create new executions of that type. Executions that were\nstarted before the type was deprecated continues to run. A deprecated workflow\ntype may still be used when calling visibility actions.\n This operation is eventually consistent. The results are best effort and may\nnot exactly reflect recent updates and changes.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * workflowType.name: String constraint. The key is swf:workflowType.name.\n * workflowType.version: String constraint. The key is swf:workflowType.version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([deprecate-workflow-type-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.DeprecateWorkflowType" deprecate-workflow-type-input :portkey.aws.swf.-2012-01-25/deprecate-workflow-type-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "TypeDeprecatedFault" :portkey.aws.swf.-2012-01-25/type-deprecated-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef deprecate-workflow-type :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/deprecate-workflow-type-input) :ret clojure.core/true?)

(clojure.core/defn deprecate-activity-type "Deprecates the specified activity type. After an activity type has been\ndeprecated, you cannot create new tasks of that activity type. Tasks of this\ntype that were scheduled before the type was deprecated continue to run.\n This operation is eventually consistent. The results are best effort and may\nnot exactly reflect recent updates and changes.\n Access Control\n You can use IAM policies to control this action's access to Amazon SWF\nresources as follows:\n * Use a Resource element with the domain name to limit the action to only\nspecified domains.\n * Use an Action element to allow or deny permission to call this action.\n * Constrain the following parameters by using a Condition element with the\nappropriate keys.\n * activityType.name: String constraint. The key is swf:activityType.name.\n * activityType.version: String constraint. The key is swf:activityType.version.\n If the caller doesn't have sufficient permissions to invoke the action, or the\nparameter values fall outside the specified constraints, the action fails. The\nassociated event attribute's cause parameter is set to OPERATION_NOT_PERMITTED.\nFor details and example IAM policies, see Using IAM to Manage Access to Amazon\nSWF Workflows\n(http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html) in\nthe Amazon SWF Developer Guide." ([deprecate-activity-type-input] (portkey.aws/-json-call portkey.aws.swf.-2012-01-25/endpoints "POST" "SimpleWorkflowService.DeprecateActivityType" deprecate-activity-type-input :portkey.aws.swf.-2012-01-25/deprecate-activity-type-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil nil {"UnknownResourceFault" :portkey.aws.swf.-2012-01-25/unknown-resource-fault, "TypeDeprecatedFault" :portkey.aws.swf.-2012-01-25/type-deprecated-fault, "OperationNotPermittedFault" :portkey.aws.swf.-2012-01-25/operation-not-permitted-fault})))
(clojure.spec.alpha/fdef deprecate-activity-type :args (clojure.spec.alpha/tuple :portkey.aws.swf.-2012-01-25/deprecate-activity-type-input) :ret clojure.core/true?)
